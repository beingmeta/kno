;; -*- Mode: fdscript -*-

(define (make-phrase head tag elements preposition)
  (vector head tag elements preposition
	  '() '() #f #f))
(define (phrase-head x) (vector-ref x 0))
(define (phrase-tag x) (vector-ref x 1))
(define (phrase-elements x) (vector-ref x 2))
(define (phrase-preposition x) (vector-ref x 3))
(define (set-phrase-preposition! x prep) (vector-set! x 3 prep))
(define (phrase-prefix x) (vector-ref x 4))
(define (push-prefix! prefix x)
  (vector-set! x 4 (cons prefix (vector-ref x 4))))
(define (phrase-suffix x) (vector-ref x 5))
(define (push-suffix! suffix x)
  (vector-set! x 5 (cons suffix (vector-ref x 5))))
(define (phrase-last-action x) (vector-ref x 6))
(define (set-phrase-last-action! x act) (vector-set! x 6 act))
(define (phrase-frame x) (vector-ref x 7))

;;; Tagging and phrasing

(define (construct-phrase input at)
  (let* ((head (elt input at))
	 (phrase (list head))
	 (tail phrase)
	 (prep #f))
    (do ((i (- at 1) (- i 1)))
	((or (< i 0) (not (contains? (cadr (elt input i)) *prefixes*)))
	 (do ((i (+ at 1) (+ i 1)))
	     ((or (>= i (length input))
		  (not (contains? (cadr (elt input i)) *suffixes*)))
	      (let* ((tag (cadr head))
		     (root-form
		      (if (member tag *things*)
			  (noun-root (car head)) (verb-root (car head)))))
		(make-phrase (try root-form (car head))
			     (cadr head) phrase prep)))
	   (set-cdr! tail (cons (elt input i) (cdr tail)))
	   (set! tail (cdr tail))))
      (when (contains? (cadr (elt input i)) *preps*)
	(set! prep (string->symbol (string-upcase (car (elt input i))))))
      (set! phrase (cons (elt input i) phrase)))))

(define (extract-phrases input)
  (let ((phrases (make-vector (length input))) (phrase 0)
        (dangling-prep #f) (last-action #f))
    (dotimes (i (length input))
      (cond ((contains? (cadr (elt input i)) *heads*)
             (let ((phrase-obj (construct-phrase input i)))
	       (vector-set! phrases phrase phrase-obj)
               (when (contains? (phrase-tag phrase-obj) *predicates*)
                 (set-phrase-last-action! phrase-obj last-action)
		 (set! last-action phrase-obj))
               (when dangling-prep
                 (unless (phrase-preposition phrase-obj)
                   (set-phrase-preposition! phrase-obj dangling-prep)
		   (set! dangling-prep #f)))
               (set! phrase (+ phrase 1))))
            ((and (eq? (cadr (elt input i)) 'conjunction) (> phrase 0))
             (set! dangling-prep
		   (phrase-preposition (elt phrases (- phrase 1)))))
            ((and last-action (contains? (cadr (elt input i)) *danglers*))
             (push-suffix! (elt input i) last-action))))
    (subseq phrases 0 phrase)))

(define (phraseit . input)
  (extract-phrases (apply tagit input)))

(define (hookup-phrases phrases)
  (dotimes (i (length phrases))
    (let ((point (elt phrases i)))
      (when (and (contains? (phrase-tag point) *predicates*) (> i 0))
	(call/cc
	 (lambda (found-subject)
	   (do ((j (- i 1) (- j 1))) ((< j 0))
	     (let ((preceding (elt phrases j)))
	       (if (contains? (phrase-tag preceding) *things*)
		   (if (not (phrase-preposition preceding))
		       (push-prefix! (cons 'subject preceding) point))
		 (if (not (eq (phrase-tag preceding) 'ing-verb))
		     (found-subject #F))))))))
      (when (and (contains? (phrase-tag point) *things*) (> i 0))
	(call/cc
	 (lambda (found-verb)
	   (dotimes (j (- i 1))
	     (let ((preceding (elt phrases j)))
	       (push-suffix!
		(cons (or (phrase-preposition point) 
			  (if (contains? (phrase-tag preceding) *predicates*) 
			      'object 'appositive))
		      point)
		point)
	       (if (and (contains? (phrase-tag preceding) *predicates*)
			(not (eq (phrase-tag preceding) 'ing-verb)))
		   (found-verb #f))))))))))

(define (write-hookup-table file)
  (when (file-exists? file) (system "rm " file))
  (dtype->file+ (choice->list *heads*) file)
  (dtype->file+ (choice->list *things*) file)
  (dtype->file+ (choice->list *predicates*) file)
  (dtype->file+ (choice->list *prefixes*) file)
  (dtype->file+ (choice->list *suffixes*) file)
  (dtype->file+ (choice->list *preps*) file)
  (dtype->file+ (choice->list *names*) file)
  (dtype->file+ (choice->list *danglers*) file))
