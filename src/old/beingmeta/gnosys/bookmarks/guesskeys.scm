(in-module 'gnosys/bookmarks/guesskeys)

(use-module 'gnosys)
(use-module 'gnosys/bookmarks)
(use-module 'gnosys/metakeys)
(use-module 'gnosys/metakeys/disambiguate)
(use-module 'texttools)
(use-module 'chopper/en)
(use-module 'morph/en)

(module-export! 'gethints)
(module-export! 'geturlwords)
(module-export! 'guess-keylist)
(module-export! 'url->keylist)
(module-export! 'url->keyentries)

;;; Guessing initial keywords

(define (in-keylist? word keylist)
  (if (null? keylist) #f
      (let ((entry (car keylist)))
	(or (equal? word (keyentry-base entry))
	    (equal? word (keyentry-term entry))
	    (in-keylist? word (cdr keylist))))))

(define (guess-keylist url title user (language @?english))
  (let* ((urlwords (geturlelts url))
	 (wordlists (deglom urlwords))
	 (titlewords (getwords title))
	 (goodwords (reject (choice (pick urlwords dictionary)
				    (getcompounds wordlists #t)
				    (getcompounds titlewords #t))
			    stop-words))
	 (keylist (if (and (string? title)
			   (> (length title) 0)
			   (> (length (getwords title)) 2))
		      (sentence->keylist title language)
		      (vector title language '())))
	 (entries (keylist-entries keylist)))
    (prefetch-keys! (choice (cons @?english goodwords)
			    (cons 'names (downcase goodwords))))
    (do-choices (word goodwords)
      (unless (in-keylist? word entries)
	(let* ((base-term (if (and (capitalized? word)
				   (exists? (pick (lookup-term (downcase word) language)
					      'type '{noun verb})))
			      (downcase word)
			      word))
	       (meanings (lookup-term base-term language)))
	  (when (and (exists? meanings)
		     (< (choice-size meanings) 5))
	    (set! entries
		  (cons (if (singleton? meanings)
			    (vector word base-term meanings meanings)
			    (vector word base-term (qc meanings) (qc)))
			entries))))))
    (vector (keylist-text keylist) (keylist-language keylist)
	    (reverse entries))))

;;; This gets the "words" out of a URL

(define (geturlwords url)
  (getcompounds (deglom (geturlelts url)) #t))

(define (geturlelts-raw url)
  (choice (elts (get url 'path))
	  (elts (difference (subseq (segment (get url 'hostname) ".") 0 -1)
			    {"co" "ac" "gov" "com" "edu" "org" "gv"}))
	  (if (position #\. (get url 'name))
	      (subseq (get url 'name) 0 (position #\. (get url 'name)))
	      (get url 'name))))
(define (geturlelts url)
  (filter-choices (string (geturlelts-raw url))
    (and (> (length string) 1)
	 (not (char-numeric? (elt string 0))))))

(define (deglommer string start i)
  (if (>= start (length string)) '()
      (if (> i (length string)) (fail)
	  (let* ((substring (subseq string start i))
		 (alternate (if (capitalized? substring)
				(downcase substring)
				(capitalize substring))))
	    (choice (tryif (exists? (get dictionary substring))
			   (cons substring (deglommer string i (+ i 2))))
		    (tryif (exists? (get dictionary alternate))
			   (cons alternate
				 (deglommer string i (+ i 2))))
		    (deglommer string start (+ i 1)))))))

(define (nounp x (language @?english)) (?? language x 'type 'noun))
(define (verbp x (language @?english)) (?? language x 'type 'verb))

(define (wordp string)
  (and (or (exists? (get dictionary string))
	   (exists? (get dictionary (capitalize string)))
	   (exists? (get dictionary (downcase string)))
	   (exists? (noun-root (downcase string) nounp))
	   (exists? (verb-root (downcase string) verbp)))
       (not (closed-class-word? string))
       (not (closed-class-word? (downcase string)))))

(define (deglommer string)
  (do ((i 2 (1+ i))
       (lim (- (length string) 2)))
      ((or (> i lim)
	   (and (wordp (subseq string 0 i))
		(wordp (subseq string i))))
       (if (> i lim) (fail)
	   (list (stdspace (subseq string 0 i))
		 (stdspace (subseq string i)))))))

(define (deglom string)
  (cond ((equal? string "") (fail))
	((wordp string) (list string))
	((position #\Space string) (segment string " "))
	((position #\_ string) (segment string "_"))
	((position #\- string) (segment string "-"))
	((position #\. string) (segment string "."))
	(else (deglommer string)))) ;; (deglommer string 0 2)

;;; Taking a wordlist and extracting compounds from it.

(define (find-compound start wordlist fragments)
  (if (null? wordlist) (fail)
      (tryif (test fragments start)
	     (try
	      (let ((probe (append start " " (car wordlist))))
		(choice (if (exists? (get dictionary probe)) probe (fail))
			(if (get fragments probe)
			    (find-compound probe (cdr wordlist) fragments)
			    (fail))))
	      (let ((probe (append start " " (capitalize (car wordlist)))))
		(choice (if (exists? (get dictionary probe)) probe (fail))
			(if (get fragments probe)
			    (find-compound probe (cdr wordlist) fragments)
			    (fail))))))))

(define (probe-compound head wordlist singleok)
  (if (null? wordlist)
      (tryif (and singleok (> (length head) 2)
		  (not (closed-class-word? head))
		  (or (exists? (get dictionary head))
		      (wordp head)
		      (exists? (noun-root head nounp)))
		  (not (hashset-get stop-words head)))
	     head)
      (choice (tryif (get fragments head)
		     (find-compound head wordlist fragments))
	      (tryif (and (capitalized? head)
			  (exists?
			   (?? 'names
			       (stdstring (append head " " (car wordlist))))))
		     (append head " " (car wordlist)))
	      (tryif (and singleok (> (length head) 2)
			  (not (closed-class-word? head))
			  (or (exists? (get dictionary head))
			      (wordp head)
			      (exists? (noun-root head nounp)))
			  (not (hashset-get stop-words head)))
		     head))))

(define (getcompounds wordlist (singleok #f))
  (if  (null? wordlist) (fail)
       (choice (try (probe-compound (car wordlist) (cdr wordlist) singleok)
		    (if (capitalized? (car wordlist))
			(probe-compound (downcase (car wordlist))
					(cdr wordlist) singleok)
			(probe-compound (capitalize (car wordlist))
					(cdr wordlist) singleok)))
	       (getcompounds (cdr wordlist) singleok)
	       (let ((combo (stringout (doseq (word wordlist i)
					 (printout (if (> i 0) " ") word)))))
		 (tryif (or (wordp combo)
			    (noun-root combo nounp)
			    (verb-root combo verbp))
			combo)))))

(define (url->keylist url language)
  (let ((urlwords (geturlwords url)))
    (strings->keylist (qc (reject urlwords length 2)
			  (upcase (pick urlwords length 2))
			  (capitalize (reject  urlwords length 2)))
		      language)))
(define (url->keyentries url language)
  (let ((urlwords (geturlwords url)))
    (term->keyentry (choice (reject urlwords length 2)
			    (upcase (pick urlwords length 2))
			    (capitalize (reject  urlwords length 2))) language)))

(define (gethints doc)
  (let* ((concepts (get doc @?gn/concepts))
	 (language (try (get doc @?gn/language) @?english))
	 (names (get doc @?gn/proper-names))
	 (stdnames (stdstring names))
	 (words (get doc @?gn/words)))
    (choice concepts
	    (filter-choices (name (get doc @?gn/proper-names))
	      (not (or (test concepts 'names name)
		       (test concepts language name)
		       (has-word-suffix? stdnames (stdstring name) #f)
		       (has-word-prefix? stdnames (stdstring name) #f))))
	    (filter-choices (word (get doc @?gn/words))
	      (not (or (test concepts language word)
		       (has-word-suffix? stdnames (stdstring word) #f)
		       (has-word-prefix? stdnames (stdstring word) #f)))))))

