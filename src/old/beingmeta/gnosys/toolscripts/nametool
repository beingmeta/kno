#!/usr/bin/env fdexec
;;; -*- Mode: fdscript; -*-

(define (main op in out)
  (cond ((< nargs 3) (describe-usage))
	((equal? op "getnames") (copy-name-keys in out))
	((equal? op "getphrases") (copy-noun-phrase-keys in out))
	((equal? op "getkeys") (copy-candidate-keys in out))
	((equal? op "makenames")
	 (set-name-db! out)
	 (make-names (read-freq-table in) (get-language-config) (get-threshold-config)))
	((equal? op "makeconcepts")
	 (use-pool out) (use-index out)
	 (do-choices (index %background)
	   (when (file-index? index) (preload-file-index! index)))
	 (make-concepts (read-freq-table in)
			(get-language-config) (get-threshold-config)
			(use-pool out) (use-index out)))
	(else (describe-usage))))

(define (describe-usage)
  (lineout "nametool getnames <index file> <name file>")
  (lineout "nametool getphrases <index file> <phrase file>")
  (lineout "nametool makenames <name file> <name pool/index> [language]")
  (lineout "nametool makeconcepts <name file> <name pool/index> [language]")
  (exit 1))

;;;; Configuration

(use-module 'brico)
(use-module 'index-plus)
(use-module 'gnosys)
(use-module 'gnosys/indexer)

(set-notify! #t)
(auto-cache-file-pools)
(auto-cache-file-indices)
(define memgap 100000000)
(define memlimit (+ (memusage) memgap))

;;; Utilities

(define (memcheck)
  (when (> (memusage) memlimit)
    (framerd-stats)
    (commit-all) (swap-out-all)
    (framerd-stats)
    (set! memlimit (+ (memusage) memgap))
    (notify "New mem limit " (memusage) "/" memlimit)))

(define (get-language-config)
  (if (bound? language)
      (if (oid? language) language
	  (try (?? 'langid language) (?? 'language 'english)))
      (?? 'language 'english)))
(define (get-threshold-config)
  (if (bound? threshold)
      (if (string? threshold) (read-from-string threshold)
	  threshold)
      2))

(define (flo x) (inexact->string x 2))
(define (get% n d) (stringout (inexact->string (/ (* 100.0 n) d) 2) "%"))

;;;; Extracting keys

(define (copy-name-keys in out)
  (let ((index (open-index in))
	(file (fopen out "a+b"))
	(i 0) (copy-count 0))
    (preload-file-index! index)
    (let ((keys (index-keys index)))
      (do-choices (key keys)
	(set! i (1+ i))
	(when (and (or (eq? (car key) gn/proper-names)
		       (eq? (car key) gn/compound-names))
		   (< (length (cdr key)) 64)
		   (< (count #\Space (cdr key)) 8)
		   (char-upper-case? (elt (cdr key) 0))
		   (or (find #\Space (cdr key))
		       (uppercase? (cdr key))))
	  (set! copy-count (1+ copy-count))
	  (write-dtype (cons key (index-get-size index key))
		       file)
	  (when (zero? (remainder copy-count 500))
	    (notify "Processed " copy-count
		    " (" (get% i (choice-size keys)) ")"
		    " keys: " (cdr key))))))))

(define (copy-noun-phrase-keys in out)
  (let ((index (open-index in))
	(file (fopen out "a+b"))
	(i 0) (copy-count 0))
    (preload-file-index! index)
    (let ((keys (index-keys index)))
      (do-choices (key keys)
	(set! i (1+ i))
	(when (eq? (car key) gn/noun-phrases)
	  (set! copy-count (1+ copy-count))
	  (write-dtype (cons key (index-get-size index key))
		       file)
	  (when (zero? (remainder copy-count 500))
	    (notify "Processed " copy-count
		    " (" (get% i (choice-size keys)) ")"
		    " keys: " (cdr key))))))))

(define (copy-name-keys in out)
  (let ((index (open-index in))
	(file (fopen out "a+b"))
	(i 0) (copy-count 0))
    (preload-file-index! index)
    (let ((keys (index-keys index)))
      (do-choices (key keys)
	(set! i (1+ i))
	(when (and (or (eq? (car key) gn/proper-names)
		       (eq? (car key) gn/compound-names))
		   (< (length (cdr key)) 64)
		   (< (count #\Space (cdr key)) 8)
		   (char-upper-case? (elt (cdr key) 0))
		   (or (find #\Space (cdr key))
		       (uppercase? (cdr key))))
	  (set! copy-count (1+ copy-count))
	  (write-dtype (cons key (index-get-size index key))
		       file)
	  (when (zero? (remainder copy-count 500))
	    (notify "Processed " copy-count
		    " (" (get% i (choice-size keys)) ")"
		    " keys: " (cdr key))))))))

(define (copy-candidate-keys in out)
  (let ((index (open-index in))
	(file (fopen out "a+b"))
	(i 0) (copy-count 0))
    (preload-file-index! index)
    (let ((keys (index-keys index)))
      (do-choices (key keys)
	(set! i (1+ i))
	(when (or (eq? (car key) gn/noun-phrases)
		  (and (or (eq? (car key) gn/proper-names)
			   (eq? (car key) gn/compound-names))
		       (< (length (cdr key)) 64)
		       (< (count #\Space (cdr key)) 8)
		       (char-upper-case? (elt (cdr key) 0))
		       (or (find #\Space (cdr key))
			   (uppercase? (cdr key)))))
	  (set! copy-count (1+ copy-count))
	  (write-dtype (cons key (index-get-size index key))
		       file)
	  (when (zero? (remainder copy-count 500))
	    (notify "Processed " copy-count
		    " (" (get% i (choice-size keys)) ")"
		    " keys: " (cdr key))))))))

;;; Making names

(define (make-names keyfreqs language threshold)
  (let* ((names (select-good-names keyfreqs language threshold))
	 (n-names 0))
    (notify "There are " (choice-size names) " good candidates for names")
    (doseq (name (reverse (sortby length names)) i)
      (let ((f (make-name name language)))
	(when (exists? f) (set! n-names (1+ n-names)))
	(when (zero? (remainder (1+ i) 500))
	  (notify "Processed " i "/" (choice-size names) " entries"
		  " (" (get% i (choice-size names)) ") to make "
		  n-names " names")
	  (if (empty? f) (notify "Failed to make name from " (readably name))
	      (notify "Created name frame " f))
	  (framerd-stats)))
      (memcheck))))

;;;; Making concepts

(define (get-word-meanings wordlist language)
  (if (null? wordlist) '()
      (let* ((word (car wordlist))
	     (meanings (pick (?? language word) 'part-of-speech '{noun name})))
	(if (empty? meanings)
	    (get-word-meanings (cdr wordlist) language)
	    (cons (qc meanings) (get-word-meanings (cdr wordlist) language))))))


(define (new-concept concept-pool concept-index phrase language category g m)
  (let ((existing (?? genls g 'modifiers m)))
    (if (fail? existing)
	(let ((f (frame-create concept-pool
		   'obj-name `(,(try category 'CONCEPT) ,@(choice->list phrase))
		   language phrase
		   'sense-category category
		   genls g 'modifiers m)))
	  (index-frame concept-index f
		       (choice language genls 'sense-category 'modifiers))
	  (let ((breakup (elts (segment phrase))))
	    (index-frame concept-index f all-words (choice breakup (stdstring breakup))))
	  f)
	(for-choices (concept existing)
	  (cond ((writable? concept)
		 (assert! concept language phrase)
		 (when (in-pool? concept concept-pool)
		   (let ((old-name (get concept 'obj-name)))
		     (%set! concept 'obj-name
			    (cons (car old-name)
				  (choice->list (choice phrase (elts (cdr old-name))))))))
		 (index-frame (try (get-index concept) concept-index)
			      concept language phrase)
		 (let ((breakup (elts (segment phrase))))
		   (index-frame concept-index concept all-words
				(choice breakup (stdstring breakup))))
		 concept)
		(else (let ((f (frame-create concept-pool
				 'obj-name `(,(try category 'CONCEPT) ,@(choice->list phrase))
				 language phrase '= concept
				 'sense-category category
				 genls (choice g concept) 'modifiers m)))
			(let ((breakup (elts (segment phrase))))
			  (index-frame concept-index f all-words
				       (choice breakup (stdstring breakup))))
			(index-frame concept-index f
				     (choice language genls 'sense-category 'modifiers '=))
			f)))))))

(define (modified-concept concept-pool concept-index phrase language concept m)
  (cond ((writable? concept)
	 (assert! concept language phrase)
	 (when (in-pool? concept concept-pool)
	   (let ((old-name (get concept 'obj-name)))
	     (%set! concept 'obj-name
		    (list* (car old-name)
			   (choice->list (choice phrase (elts (cdr old-name))))))))
	 (let ((breakup (elts (segment phrase))))
	   (index-frame concept-index concept all-words
			(choice breakup (stdstring breakup))))
	 (index-frame (try (get-index concept) concept-index)
		      concept language phrase)
	 concept)
	(else (let ((f (frame-create concept-pool
			 'obj-name (cons (try (get concept 'sense-category) 'CONCEPT)
					 (choice->list phrase))
			 language phrase '= concept
			 'sense-category (get concept 'sense-category)
			 genls (choice concept (get concept genls))
			 'modifiers m)))
		(index-frame concept-index f
			     (choice language genls 'sense-category 'modifiers '=))
		(let ((breakup (elts (segment phrase))))
		  (index-frame concept-index f all-words
			       (choice breakup (stdstring breakup))))
		f))))

(define (probe-concept-1 phrase language concept-pool concept-index)
  (try (?? language phrase)
       (let* ((wordlist (segment phrase))
	      (head-terminal #t)	; Should get from language somehow
	      (head (if head-terminal (elt wordlist (1- (length wordlist)))
		      (car wordlist)))
	      (head-meanings (pick (?? language head) language head))
	      (modifiers (difference (elts wordlist) head))
	      (modifier-meanings (pick (?? language modifiers)
				     language modifiers
				     'part-of-speech '{noun name}))
	      (categories (intersection (get head-meanings 'sense-category)
					(get modifier-meanings 'sense-category))))
	 (for-choices (category categories)
	   (new-concept concept-pool concept-index
			phrase language category
			(qc (pick head-meanings 'sense-category category))
			(qc (pick modifier-meanings 'sense-category category)))))))

(define (phrase-variant wordlist variant head-at-end)
  (let* ((len (length wordlist))
	 (head-pos (if head-at-end (1- len) 0))
	 (stream (open-string-stream)))
    (doseq (word wordlist i)
      (if (> i 0) (display " " stream))
      (if (= i head-pos) (display variant stream)
	(display word stream)))
    (string-stream-contents stream)))

(define (probe-concept-2 phrase language other-phrases concept-pool concept-index)
  (try (?? language phrase)
       (let* ((wordlist (segment phrase))
	      (head-at-end (try (get (get-language-bundle language) 'head-at-end) #t))
	      (head (if head-at-end (elt wordlist (1- (length wordlist)))
		      (car wordlist)))
	      (head-meanings (pick (?? language head)
				 language head
				 'part-of-speech '{noun name}))
	      (recurring-head-meanings
	       (filter-choices (meaning head-meanings)
		 (let ((variants (phrase-variant
				  wordlist (difference (get meaning language) phrase)
				  head-at-end)))
		   (or (exists? (?? language variants))
		       (satisfied? (hashset-get other-phrases variants))))))
	      (modifiers (difference (elts wordlist) head))
	      (modifier-meanings (pick (?? language modifiers) language modifiers)))
	 (for-choices (meaning recurring-head-meanings)
	   (let* ((variants (phrase-variant wordlist (difference (get meaning language) phrase)
					    head-at-end))
		  (existing-variants (hashset-accept other-phrases variants))
		  (existing-concepts (?? language variants)))
	     (if (exists? existing-concepts)
		 (modified-concept concept-pool concept-index
				   (qc phrase existing-variants) language
				   existing-concepts (qc modifier-meanings))
	       (new-concept concept-pool concept-index
			    (qc phrase existing-variants) language
			    (get meaning 'sense-category) meaning
			    (qc modifier-meanings))))))))
(define (probe-concept-2 phrase language other-phrases concept-pool concept-index)
  (try (?? language phrase)
       (let* ((wordlist (segment phrase))
	      (head-at-end (try (get (get-language-bundle language) 'head-at-end) #t))
	      (head (if head-at-end (elt wordlist (1- (length wordlist)))
		      (car wordlist)))
	      (head-meanings (pick (?? language head)
				 language head
				 'part-of-speech '{noun name}))
	      (recurring-head-meanings
	       (filter-choices (meaning head-meanings)
		 (let ((variants (phrase-variant
				  wordlist (difference (get meaning language) phrase)
				  head-at-end)))
		   (or (exists? (?? language variants))
		       (satisfied? (hashset-get other-phrases variants))))))
	      (modifiers (difference (elts wordlist) head))
	      (modifier-meanings (pick (?? language modifiers) language modifiers)))
	 (for-choices (meaning recurring-head-meanings)
	   (let* ((variants (phrase-variant wordlist (difference (get meaning language) phrase)
					    head-at-end))
		  (existing-variants (hashset-accept other-phrases variants))
		  (existing-concepts (?? language variants)))
	     (if (exists? existing-concepts)
		 (modified-concept concept-pool concept-index
				   (qc phrase existing-variants) language
				   existing-concepts (qc modifier-meanings))
	       (new-concept concept-pool concept-index
			    (qc phrase existing-variants) language
			    (get meaning 'sense-category) meaning
			    (qc modifier-meanings))))))))

(define (force-concept phrase language concept-pool concept-index)
  (try (?? language phrase)
       (let* ((wordlist (segment phrase))
	      (head-at-end (try (get (get-language-bundle language) 'head-at-end) #t))
	      (head (if head-at-end (elt wordlist (1- (length wordlist)))
			(car wordlist)))
	      (head-meanings (pick (?? language head)
			       language head
			       'part-of-speech '{noun name}))
	      (modifiers (difference (elts wordlist) head))
	      (modifier-meanings (pick (?? language modifiers) language modifiers)))
	 (new-concept concept-pool concept-index
		      phrase language 'concept head-meanings (qc modifier-meanings)))))

(define (make-concepts keyfreqs language threshold concept-pool concept-index)
  (let* ((i 0) (n-hits 0) (n-concepts 0)
	 (phrases (cdr (hashtable-skim keyfreqs threshold)))
	 (table (choices->hashset (cdr (hashtable-skim keyfreqs (quotient threshold 2))))))
    (do-choices (phrase phrases)
      (let ((concepts (try (probe-concept-1 phrase language concept-pool concept-index)
			   (probe-concept-2 phrase language table concept-pool concept-index)
			   (if (> (get keyfreqs (cons gn/noun-phrases phrase)) 10)
			       (force-concept phrase language concept-pool concept-index)
			       (fail)))))
	(set! n-concepts (+ n-concepts (choice-size concepts)))
	(set! i (1+ i))
	(when (exists? concepts)
	  (set! n-hits (1+ n-hits))
	  (when (zero? (remainder n-hits 500))
	    (notify "Processed " i "/" (choice-size phrases) " entries"
		    " (" (get% i (choice-size phrases)) ") to make "
		    n-concepts " concepts from " n-hits " phrases")
	    (if (empty? concepts) (notify "Failed to make concept from " (readably phrase))
	      (notify "Created concept frames " concepts))
	    (framerd-stats))))
      (memcheck))))

