#!/usr/bin/fdscript
;;; -*- Mode: fdscript; -*-

;; Usage: extend-background freqdata background [concept-index] indices...
;; Copyright (C) beingmeta, inc 2002

;; This extends a background knowledge based on noun phrases and
;; proper names in an analyzed corpus and then indexes the corpus
;; with respect to those concepts.

;; $Id: extend-background,v 1.8 2002/06/18 04:42:33 haase Exp $

;;;; Configuration

(use-module 'brico)
(use-module 'index-plus)
(use-module 'vpools)
(use-module 'load-utils)
(use-module 'gnosys)
(use-module 'gnosys/indexer)

(gset! %debug #t)
(set-notify! #t)
(control-frame-printing 1)
(auto-cache-file-pools)
(auto-cache-file-indices)

(define memgap 100000000)
(define memlimit (+ (memusage) memgap))

(define (show% n d)
  (stringout n "/" d "=" (inexact->string (/ (* 100.0 n) d) 2) "%"))

(define-if-needed source {})
(if (string? source) (set! source (read-from-string source)))

;; Make sure the background is all direct index pointers
(set! %background (use-index %background))
;; Preload BRICO and XBRICO
(when (file-index? (use-index 'brico))
  (preload-file-index! (use-index 'brico)))
(when (file-index? (use-index 'xbrico))
  (preload-file-index! (use-index 'xbrico)))

;;; The main event

(define (extend-background freqs background (concept-index #f) . indices)

  ;; Load the spider's configuration file if it exists
  (when (file-exists? (newpath (dirname background) "spider.cfg"))
    (load-config (newpath (dirname background) "spider.cfg")))

  ;; Set the language map if it exists
  (when (bound? langmap)
    (set! language-index (open-index langmap)))
  (when language-index (notify "Language index is " language-index))

  ;; Start it up.
  (multiple-value-bind (name-freqs phrase-freqs) (get-freq-data freqs)
    (let* ((name-threshold (get-name-threshold))
	   (phrase-threshold (get-phrase-threshold))
	   (phraseset (make-good-phraseset phrase-freqs phrase-threshold))
	   (name-concepts {}) (phrase-concepts {})
	   (bg-pool (use-pool++ background))
	   (bg-index (get-index bg-pool)))
      
      ;; Create new name concepts
      (set-name-db! background)
      (set! name-concepts (make-new-names name-freqs name-threshold))
      (notify "Name analysis generated " (choice-size name-concepts)
	      " new name concepts")
      (add! name-concepts 'source source)
      
      ;; Create new phrase concepts
      (set! phrase-concepts
	    (make-concepts (qc (hashset-elts phraseset)) phrase-freqs phraseset
			   bg-pool (* phrase-threshold 2)))
      (notify "Phrase analysis generated " (choice-size phrase-concepts)
	      " new concepts from " (hashset-size phraseset) " phrases")
      (add! phrase-concepts 'source source)
      
      ;; Index using these concepts
      (when concept-index
	(let ((indices (elts indices))
	      (concept-index (open-index concept-index))
	      (total (+ (choice-size name-concepts)
			(choice-size phrase-concepts)))
	      (count 0))
	  (do-choices (concept name-concepts)
	    (let ((content-frames
		   (find-frames indices
		     (choice gn/proper-names  gn/compound-names)
		     (get concept all-words))))
	      (index-frame concept-index content-frames gn/refpoints concept)
	      (set! count (1+ count))
	      (when (zero? (remainder count 100))
		(notify "Indexed " (show% count total)  total " concepts")
		(notify "E.G. Associated the concept " concept
			" with " (choice-size content-frames) " frames"))))
	  (do-choices (concept phrase-concepts)
	    (let ((content-frames
		   (find-frames indices
		     gn/noun-phrases (get concept all-words))))
	      (index-frame concept-index content-frames gn/concepts concept)
	      (set! count (1+ count))
	      (when (zero? (remainder count 100))
		(notify "Indexed " (show% count total) " concepts")
		(notify "E.G. Associated the concept " concept
			" with " (choice-size content-frames) " frames"))))
	  )))))
(define main extend-background)

;;;; Support functions

(define (get-name-threshold)
  (if (bound? name-threshold) name-threshold
      (if (bound? threshold) threshold 5)
      5))
(define (get-phrase-threshold)
  (if (bound? phrase-threshold) phrase-threshold
      (if (bound? threshold) threshold 5)
      5))

(define (get-language-for name)
  (if language-index
      (try (get language-index name) default-language)
      default-language))

(define (is-head-at-end? language)
  (try (get (get-language-bundle language) 'head-at-end) #t))

(define (memcheck)
  (when (> (memusage) memlimit)
    (framerd-stats)
    (commit-all) (swap-out-all)
    (framerd-stats)
    (set! memlimit (+ (memusage) memgap))
    (notify "New mem limit " (memusage) "/" memlimit)))

(define (get-freq-data arg)
  (cond ((string? arg)
	 (if (= (read-4bytes (fopen arg "rb")) 0x90e0418)
	     (get-freq-data-from-index arg)
	     (let ((table (read-freq-table arg)))
	       (values table table))))
	((hashtable? arg) (values arg arg))
	(else (raise-exception 'cant-get-freq-in-data
			       "for background extension" arg))))

;;; Generating frequency tables

(define (get-freq-data-from-index filename)
  (notify "Reading frequency data from index " filename)
  (let ((index (if (string? filename) (open-index filename) filename))
	(name-table (make-hashtable)) (phrase-table (make-hashtable)))
    (preload-file-index! index)
    (let ((keys (index-keys index)) (i 0) (copy-count 0))
      (do-choices (key keys)
	(set! i (1+ i))
	(when (or (eq? (car key) gn/noun-phrases) (good-proper-name-key? key))
	  (set! copy-count (1+ copy-count))
	  (hashtable-set! (if (eq? (car key) gn/noun-phrases) phrase-table name-table)
			  key (index-get-size index key))
	  (when (zero? (remainder copy-count 500))
	    (notify "Processed " copy-count
		    " (" (show% i (choice-size keys)) ")"
		    " keys: " (cdr key))))))
    (notify "Extracted " (hashtable-size name-table) " possible names and "
	    (hashtable-size phrase-table) " possible phrases")
    (unpreload-file-index! index)
    (close-index index)
    (values name-table phrase-table)))

(define proper-name-slots (choice gn/proper-names gn/compound-names))

(define (good-proper-name? string)
  (and (< (length string) 64)
       (< (count #\Space string) 8)
       (char-upper-case? (elt string 0))
       (or (find #\Space string) (uppercase? string))))

(define (good-proper-name-key? key)
  (and (contains? (car key) proper-name-slots)
       (good-proper-name? (cdr key))))
 
;;;; Selecting good names

(define name-slotids (choice gn/proper-names gn/compound-names))

(define (make-new-names keyfreqs threshold)
  (let ((keys (hashtable-keys keyfreqs))
	(compound-threshold (+ threshold (quotient threshold 2)))
	(results {})
	(i 0) (n 0))
    (do-choices (key (hashtable-keys keyfreqs))
      (memcheck)
      (let ((slotid (car key)) (name (cdr key)) (result {}))
	;; We start with all of the tests for *not* generating a concept
	;; from a name
	(unless (or (not (contains? slotid name-slotids))
		    (not (capitalized? name))
		    (> (length name) 64)
		    (and (not (uppercase? name)) (not (find #\Space name)))
		    (and (find #\Space name)
			 (or (if (find #\, name)
				 (>= (/ (count #\Space name) (count #\, name)) 3)
				 (>= (count #\Space name) 5))
			     (<= (position #\Space name) 2)))
		    (if (eq? slotid gn/compound-names)
			(< (get keyfreqs key) compound-threshold)
			(< (get keyfreqs key) threshold)))
	  (let ((language (get-language-for name)))
	    (cond ((has-stop-word-prefix? name keyfreqs language))
		  ((eq? slotid gn/proper-names) (set! n (1+ n))
		   (set! result (make-name name language (> (get keyfreqs key) threshold))))
		  ((eq? slotid gn/compound-names) (set! n (1+ n))
		   (set! result
			 (make-name name language
			   (> (get keyfreqs key) (* 2 threshold))))))))
	(set+! results result)
	(set! i (+ i 1))
	(cond ((exists? result)
	       (notify "Processed " (show% i (choice-size keys))
		       " to create " n " new names, including "
		       result))
	      ((zero? (remainder i 100))
	       (notify "Processed " (show% i (choice-size keys))
		       " to create " n " new names, but not "
		       (readably name))))))
    results))

(define (has-stop-word-prefix? name keyfreqs language)
  (let* ((bundle (get-language-bundle language))
	 (stop-words (get bundle 'stop-words))
	 (first-space (position #\Space name)))
    (if (and first-space
	     (hashset-get stop-words
			  (string-downcase (subseq name 0 first-space))))
	(exists? (get keyfreqs (cons (choice gn/proper-names gn/compound-names)
				     (subseq name (1+ first-space)))))
	#f)))

(define (get-last-word string)
  (do ((space (position #\Space string)
	      (position #\Space string (1+ space)))
       (last-space 0 space))
      ((not space) (subseq string (1+ last-space)))))

(define (has-stop-word-suffix? name language)
  (let* ((bundle (get-language-bundle language))
	 (stop-words (get bundle 'stop-words)))
    (hashset-get stop-words (string-downcase (get-last-word name)))))

;;; Making names

(define (make-names names)
  (let ((results {}) (n-names 0))
    (notify "There are " (choice-size names) " good candidates for names")
    (doseq (name (reverse (sortby length names)) i)
      (let ((f (make-name name (get-language-for name))))
	(when (exists? f)
	  (set! n-names (1+ n-names))
	  (set+! results f))
	(when (zero? (remainder (1+ i) 500))
	  (notify "Processed " i "/" (choice-size names) " entries"
		  " (" (show% i (choice-size names)) ") to make "
		  n-names " names")
	  (if (empty? f)
	      (notify "E.G. Failed to make name from " (readably name))
	      (notify "E.G. Created name frame " f))
	  (framerd-stats)))
      (memcheck))
    results))

;;;; Selecting good phrases

(define (plausible-noun-phrase? string)
  (fail? (tx-search '(isdigit) string)))

(define (make-good-phraseset freqs threshold)
  (let ((table (make-hashset (quotient (hashtable-size freqs) 5))))
    (do-choices (key (hashtable-skim freqs threshold))
      (when (and (eq? (car key) gn/noun-phrases)
		 (plausible-noun-phrase? (cdr key)))
	(hashset-add! table (cdr key))))
    table))

;;;; Making concepts from phrases

(define (make-concepts phrases keyfreqs phraseset pool threshold)
  (let* ((i 0) (n-concepts 0) (all-concepts {}))
    (do-choices (phrase phrases)
      (let* ((language (get-language-for phrase))
	     (concept
	      (phrase->concept pool phrase language phraseset
	        (> (get keyfreqs (cons gn/noun-phrases phrase)) threshold))))
	(when (exists? concept)
	  (set+! all-concepts concept)
	  (set! n-concepts (+ n-concepts (choice-size concept))))
	(set! i (1+ i))
	(when (zero? (remainder i 500))
	  (notify "Processed " i "/" (choice-size phrases) " entries"
		  " (" (show% i (choice-size phrases)) ") to make "
		  n-concepts " concepts from " i " phrases")
	  (if (empty? concept)
	      (notify "E.G. Failed to make concept from " (readably phrase))
	      (notify "E.G. Created concept " concept))
	  (notify "DATASIZE=" (ru-data-size))
	  (framerd-stats)))
      (memcheck))
    all-concepts))

;; $Log: extend-background,v $
;; Revision 1.8  2002/06/18 04:42:33  haase
;; Change interpreter name to /usr/bin/fdscript
;;
;; Revision 1.7  2002/05/01 02:25:34  haase
;; Tweaks to name and phrase identification logic
;;
;; Revision 1.6  2002/04/22 05:30:54  haase
;; Many fixes and changes
;;
;; Revision 1.5  2002/04/12 20:04:27  haase
;; Added copyright notice
;;

