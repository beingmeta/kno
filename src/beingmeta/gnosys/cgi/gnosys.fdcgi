(when (file-exists? "gnosys.cfg")
  (load-config "gnosys.cfg"))

(use-module '{brico index-plus
	      gnosys gnosys/indexer gnosys/utils morph
	      fdxml fdxml/pager fdxml/brico})
(gset! %debug #t)

(auto-cache-file-indices)
(auto-cache-file-pools)

(use-brico)
(if (bound? xbrico) (use-pool++ XBRICO))
(if (bound? REFDB) (set-refs-db! REFDB))
(if (bound? POOLS) (use-pool POOLS))
(if (bound? INDICES) (use-pool INDICES))

(unless (bound? content-data)
  (when (file-exists? (get-component "content.pool"))
    (set! content-data (get-component "content"))))
(unless (bound? context-data)
  (when (file-exists? (get-component "context.pool"))
    (set! context-data (get-component "context"))))

(define (this-script) (get (cgi-data) 'script_uri))

(define content-pool (use-pool+ content-data))
(define context-pool (use-pool+ context-data))

(define concept-index (open-index concept-index))

(define context-index (get-index context-pool))
(define content-index (choice (get-index content-pool) concept-index))

(register-adjunct! gn/concepts (open-index
				"/build/timeinc/data/time_concepts.index")
		   (use-pool "/build/timeinc/data/time_content.pool"))
(register-adjunct! gn/concepts (open-index
				"/build/timeinc/data/people_concepts.index")
		   (use-pool "/build/timeinc/data/people_content.pool"))
(register-adjunct! gn/concepts (open-index
				"/build/timeinc/data/ew_concepts.index")
		   (use-pool "/build/timeinc/data/ew_content.pool"))
(register-adjunct! gn/concepts (open-index
				"/build/timeinc/data/fortune_concepts.index")
		   (use-pool "/build/timeinc/data/fortune_content.pool"))

(define (expand-key key)
  (if (oid? (cdr key))
      (cons (car key)
	    (if (test (cdr key) 'sense-category 'noun.location)
		(get (cdr key) parts*)
	      (get (cdr key) specls*)))
    (if (string? (cdr key))
	(cons (car key) (choice (cdr key) (stdstring (cdr key))))
      key)))
(define (stdkey key)
  (if (string? (cdr key))
      (cons (car key) (choice (cdr key) (stdstring (cdr key))))
    key))

(define (compute-scores indices keys)
  (let ((scores (make-hashtable)))
    (do-choices (index indices)
      (do-choices (key keys)
	(hashtable-increment! scores (get index (stdkey key)))))
    scores))
(define (score-results context-indices content-indices preferred required excluded)
  (let ((context-score (make-hashtable))
	(content-score (make-hashtable)))
    (dolist (keyset required)
      (let ((expkeys (expand-key keyset)))
	(do-choices (index context-indices)
	  (hashtable-increment! context-score (get index expkeys))
	  (hashtable-increment! content-score (get index expkeys) 1))
	(do-choices (index content-indices)
	  (hashtable-increment! context-score (get index expkeys) 1)
	  (hashtable-increment! content-score (get index expkeys)))))
    (cond ((null? required)
	   (dolist (keyset preferred)
	     (let ((expkeys (expand-key keyset)))
	       (do-choices (index context-indices)
		 (hashtable-increment! context-score (get index expkeys)))
	       (do-choices (index content-indices)
		 (hashtable-increment! content-score (get index expkeys))))))
	  (else 	
	   (dolist (keyset preferred)
	     (let ((expkeys (expand-key keyset)))
	       (do-choices (index context-indices)
		 (hashtable-increment-existing! context-score (get index expkeys)))
	       (do-choices (index content-indices)
		 (hashtable-increment-existing! content-score (get index expkeys)))))))
    (dolist (keyset excluded)
      (let ((expkeys (expand-key keyset)))
	(do-choices (index (choice content-indices context-indices))
	  (hashtable-increment-existing! context-score (get index expkeys) -65536)
	  (hashtable-increment-existing! content-score (get index expkeys) -65536))))
    (let* ((combined-score (make-hashtable))
	   (possible-content (hashtable-skim content-score 0)))
      (prefetch! possible-content)
      (do-choices (possible possible-content)
	(let ((cscore (get content-score possible))
	      (xscore (get context-score (get possible gn/indoc))))
	  (if (and (exists? xscore) (> xscore 0))
	      (hashtable-set! combined-score possible (* cscore (1+ xscore)))
	    (hashtable-set! combined-score possible cscore))))
      (values combined-score context-score content-score))))

;;;; XHTML generation utilities

(define (start-gnosys-page)
  (stylesheet! "/css/fdxml.css")
  (stylesheet! "gnosys.css")
  (gnosys-page-headers))

(define (anchor-diamond fragment)
  (anchor+ fragment
	   (class "content_tag")
	   (img src "/graphics/bm_diamond" border 0)))

(define (gnosys-page-headers)
  (div (class "top_right")
    (anchor "http://www.beingmeta.com/"
	    (img src "/graphics/bm_block_black_web" class
		 "top_right"))))

(define (paragraph-diamond fragment)
  (anchor+ fragment
	   (class "content_tag")
	   "\u2761" (get fragment 'pnum)
	   (img src "/graphics/bm_diamond" border 0)))

;;;; Working with document keys

(define standard-slotids
  {@?gn/proper-names @?gn/compound-names @?gn/noun-phrases
		     @?gn/textkeys @?gn/xkeys
		     @?gn/concepts @?gn/refpoints})

(define (query->keys string language)
  (if (find #\; string)
      (let ( (preferred '()) (required '()) (excluded '()))
	(dolist (item (segment string ";"))
	  (multiple-value-bind (p r e)
	      (text->keys (string-trim (stdspace item)) language)
	    (when (exists? p) (set! preferred (cons (qc p) preferred)))
	    (when (exists? r) (set! required (cons (qc r) required)))
	    (when (exists? e) (set! excluded (cons (qc e) excluded)))))
	(values preferred required excluded))
    (values (list (qc (text->keys string language))) '() '())))

(define (concept-extractor term language)
  (try (string->concepts term language)
       (filter-choices
	   (meaning (choice (pick (?? language (get-root term 'noun language))
			      'type 'noun)
			    (pick (?? language (get-root term 'verb language))
			      'type 'verb)))
	 (exists? (index-get concept-index gn/concepts (get meaning specls*))))
       (filter-choices (meaning (?? language term))
	 (exists? (index-get concept-index gn/concepts
			     (get meaning specls*))))))

(define (generate-xkeys stringlist)
  (if (or (null? stringlist) (null? (cdr stringlist))) (fail)
    (choice (cons (car stringlist) (elts (cdr stringlist)))
	    (generate-xkeys (cdr stringlist)))))

(define (text->keys string language)
  (cond ((= (length string) 0) (fail))
	((eqv? (elt string 0) #\+)
	 (values (qc) (text->keys (subseq string 1) language)
		 (qc)))
	((eqv? (elt string 0) #\-)
	 (values (qc) (qc)
		 (text->keys (subseq string 1) language)))
	(else (values (qc (cons (choice gn/concepts gn/refpoints)
				(concept-extractor string language))
			  (cons gn/proper-names (stdspace string))
			  (cons gn/noun-phrases (stdspace string))
			  (cons gn/textkeys (elts (segment string " ")))
			  (cons gn/xkeys (generate-xkeys (segment string " "))))
		      (qc) (qc)))))

(define (generate-keys string language)
  (let ((analysis (get-text-analysis string language)))
    (choice (cons gn/textkeys (get analysis 'textkeys))
	    (cons gn/proper-names
		  (choice (get analysis 'simple-names)
			  (get analysis 'compound-names)))
	    (cons gn/xkeys (get analysis 'xkeys))
	    (cons gn/noun-phrases (get analysis 'noun-phrases))
	    (cons gn/noun-phrases (get analysis 'noun-phrases))
	    (cons gn/concepts
		  (concept-extractor (choice (get analysis 'noun-phrases)
					     (get analysis 'textkeys))
				     language))
	    (cons gn/refpoints
		  (get-refpoints (choice (get analysis 'simple-names)
					 (get analysis 'compound-names))
				 language)))))

(define (get-keys fragment slotid)
  (cons slotid (for-choices (val (get fragment slotid))
		 (if (string? val) (choice (stdstring val) val)
		   val))))
(define (display-key key (script #f))
  (when (and script (oid? (cdr key)))
    (anchor (cdr key) (img src "/graphics/bm_diamond" border 0)))
  (if script
      (anchor+ (scripturl script 'key key)
	       (title (get-title key))
	       (display-key key #f))
    (case (car key)
      (@?gn/proper-names (span (class "proper_name") (cdr key)))
      (@?gn/compound-names (span (class "proper_name") (cdr key)))
      (@?gn/textkeys (span (class "textkey") (string-downcase (cdr key))))
      (@?gn/noun-phrases (span (class "noun_phrase") (string-subst (cdr key) " " "_")))
      (@?gn/xkeys (span (class "xkey") (cadr key) "+" (cddr key)))
      (@?gn/concepts (span (class "concept_key") "«" (showwords (cdr key)) "»"))
      (@?gn/refpoints (span (class "refpoint_key") "«" (showwords (cdr key)) "»"))
      (else (span (class "strange_key") key)))))

(define (get-title key)
  (let ((n-frags (stringout " (" (choice-size (index-get content-index key)) " items)")))
    (case (car key)
      (@?gn/proper-names (stringout "search on proper-name: " (cdr key) n-frags))
      (@?gn/compound-names (stringout "search on proper-name: " (cdr key) n-frags))
      (@?gn/textkeys (stringout "search on keyword: " (cdr key) n-frags))
      (@?gn/noun-phrases (stringout "search on noun phrase: " (cdr key) n-frags))
      (@?gn/xkeys (stringout "search on extended key: " (cadr key) "+" (caddr key) n-frags))
      (@?gn/concepts (stringout "search on concept: " (concept-string (cdr key)) n-frags))
      (@?gn/refpoints (stringout "search on refpoint: " (concept-string (cdr key)) n-frags))
      (else (stringout "search on " (car key) ":" (cdr key)
		       n-frags)))))

;;;; Manipulating HTML/XML strings

(define (markup-exciser input output stack removers empty-tags rewriter)
  (if (null? input) (exciser-output output '() stack)
    (if (has-prefix "<" (car input))
	(if (tx-match removers (car input))
	    (markup-exciser (cdr input) output stack 
			    (qc removers) (qc empty-tags) rewriters)
	  (let ((item (try (if rewriter (rewriter (car input)) (fail))
			   (car input))))
	    (cond ((not (string? item))
		   (markup-exciser (cdr input) output stack
				   (qc removers) (qc empty-tags) rewriter))
		  ((has-suffix "/>" item)
		   (markup-exciser (cdr input) (cons item output) stack
				   (qc removers) (qc empty-tags) rewriter))
		  ((has-prefix "</" item)
		   (let ((popped-stack (exciser-stack-pop item
							  stack)))
		     (if popped-stack
			 (markup-exciser (cdr input) (cons item output)
					 popped-stack
					 (qc removers) (qc empty-tags)
					 rewriter)
		       (markup-exciser (cdr input) output stack
				       (qc removers) (qc empty-tags) rewriter))))
		  ((tx-match empty-tags item)
		   (markup-exciser (cdr input) (cons item output) stack
				   (qc removers) (qc empty-tags) rewriter))
		  (else (markup-exciser (cdr input) (cons item output)
					(cons item stack)
					(qc removers) (qc empty-tags) rewriter)))))
      (markup-exciser (cdr input) (cons (car input) output) stack
		      (qc removers) (qc empty-tags) rewriter))))

(define (exciser-output input output stack)
  (if (null? input) output
    (if (member? (car input) stack)
	(exciser-output (cdr input) output stack)
      (exciser-output (cdr input) (cons (car input) output) stack))))

(define (exciser-stack-pop close-item stack)
  (textlet #("</" (label eltname (xmlname)) (spaces*) ">") close-item
    (let ((start-pattern (vector "<" eltname (qc '(isspace) ">"))))
      (do ((substack stack (cdr substack)))
	  ((or (not (pair? substack))
	       (tx-matcher start-pattern (car substack)))
	   (if (pair? substack) (cdr substack) #f))))))

(define (excise-markup string remove-tags empty-tags rewrite-fn)
  (apply string-append
	 (markup-exciser (tx-fragment string #("<" (char-not ">") ">"))
			 '() '()
			 (qc remove-tags) (qc empty-tags) rewrite-fn)))
(module-export! 'excise-markup)

;;;; Special excisers

(define structural-markup-tags
  {"P" "LI" "DT" "DD" "TH" "TD" "TR" "TABLE" "UL" "OL"
   "H1" "H2" "H3" "H4" "H5" "H6" "H7" "H8" "H9"
   "BLOCKQUOTE" "CENTER" "PRE" "BR"})
(define (markup-pattern . args)
  `(IC ,(choice (vector "<" (qc (car args)) '{"" (char-not ">")} ">")
		(vector "<" (qc (car args)) '{"" (char-not ">")} "/>")
		(vector "</" (qc (car args)) '{"" (char-not ">")} ">"))))
(define structural-markup-pattern (markup-pattern structural-markup-tags))

(define (strip-structural-markup string (url #f))
  (excise-markup string structural-markup-pattern
		 (qc (markup-pattern {"IMG" "HR"}))
		 (and url (lambda (x) (rewrite-refs x url)))))
(define (strip-disruptive-markup string)
  (excise-markup string
		 (markup-pattern (choice "IMG" "HR" "A" structural-markup-tags))
		 (qc (markup-pattern {}))
		 #f))

;;;; Rewriting references

(define anchor/img-start-tag
  '(IC {#("<A" (spaces) (char-not ">") ">")
	#("<IMG" (spaces) (char-not ">") ">")}))
(define img-start-tag
  '(IC #("<IMG" (spaces) (char-not ">") ">")))

(define href-pattern
  '(IC {#("href=\'" (label href (char-not "'")) "'")
	#("href=\"" (label href (char-not "\"")) "\"")}))

(define src-pattern
  '(IC {#("src" (spaces*) "=" (spaces*) "\'" (label src (char-not "'")) "'")
	#("src" (spaces*) "=" (spaces*) "\"" (label src (char-not "\"")) "\"")}))

(define (rewrite-anchor-ref string url)
  (let* ((href-pos (tx-search href-pattern string))
	 (href-end (tx-matcher href-pattern string href-pos)))
    (let* ((hrefmap (match->frame #f href-pattern (subseq string href-pos href-end)))
	   (href (get hrefmap 'href)))
      (if (fail? href) (stringout string)
	(if (or (has-prefix "/" href)  (has-prefix "http" href)
		(has-prefix "ftp" href))
	    string
	  (if (has-prefix "#" href)
	      (stringout (subseq string 0 href-pos)
			 "href='" url href "'"
			 (subseq string href-end))
	    (stringout (subseq string 0 href-pos)
		       "href='" (dirname url) "/" href "'"
		       (subseq string href-end))))))))

(define (rewrite-img-ref string url)
  (let* ((src-pos (tx-search src-pattern string))
	 (src-end (tx-matcher src-pattern string src-pos)))
    (let* ((srcmap (match->frame #f src-pattern (subseq string src-pos src-end)))
	   (src (get srcmap 'src)))
      (if (or (has-prefix src "/")  (has-prefix src "http")  (has-prefix src "ftp"))
	  string
	(stringout (subseq string 0 src-pos)
		   "src='" (dirname url) "/" src "'"
		   (if (has-suffix "/>" string)
		       (subseq string src-end)
		     (stringout (subseq string src-end (1- (length string)))
				"/>")))))))

(define (rewrite-img-refs string url)
  (if (tx-match '(ic #("<img" (isspace))) string)
      (rewrite-img-ref string url)
    string))
(define (rewrite-anchor-refs string url)
  (if (tx-match '(ic #("<A" (isspace))) string)
      (rewrite-anchor-ref string url)
    string))
(define (rewrite-refs string url)
  (cond ((tx-match '(ic #("<A" (isspace))) string)
	 (rewrite-anchor-ref string url))
	((tx-match '(ic #("<img" (isspace))) string)
	 (rewrite-img-ref string url))
	(else (fail))))

;;;; Other utility functions

(define (shorten-text string n)
  (let ((plain (string-trim (text->plaintext string))))
    (if (> n (length plain)) plain
      (stringout (subseq plain 0 n) "..."))))

(define head-pattern
  '(ic #("<head" (spaces*) {"" (char-not ">")} ">")))

(define initial-markup #((spaces*) "<" (char-not ">") ">"))

(define (has-real-content? text)
  (> (alphanumeric% (strip-markup+ text)) 0))


;;;; Search pages

(define (text-search-body question)
  (title "GNOSYS Text Search: " question)
  (start-gnosys-page)
  (multiple-value-bind (preferred required excluded)
      (query->keys question english)
    (let* ((action (get (cgi-data) 'action))
	   (scores (score-results (qc context-index) (qc content-index)
				  preferred required excluded)))
      (query-field question (qc (elts preferred))) (hr)
      (%set! (cgi-data) 'result-context '{})
      ;; (P preferred)
      (htmlpager (lambda (x i) (display-search-result
				x scores
				(qc (elts preferred) (elts required))))
		 (if (equal? action "Best")
		     (qc (try (hashtable-skim scores 2)
			      (hashtable-keys scores)))
		   (qc (hashtable-keys scores)))
		 "RESULTS"
		 `(question ,question action ,action)
		 (vector scores gn/indoc 'pnum) '> 10 10))))

(define (key-search-body keys)
  (title "GNOSYS Key Search:" (do-choices (key keys) (xmlout " " key)))
  (start-gnosys-page)
  (let* ((scores (compute-scores (qc content-index) (qc keys))))
    (H1 "GNOSYS search on "
	(do-choices (key keys i)
	  (if (> i 0) (xmlout " | "))
	  (span (class "keytitle") (get-title key))))
    (htmlpager (lambda (x i)
		 (display-search-result x scores (qc keys)))
	       (qc (hashtable-keys scores))
	       "RESULTS" `(keys ,keys)
	       scores '> 5 20)))

(define (display-url-result result)
  (P* (class "context")
      (anchor-diamond result) " Reference to " (get result 'url))
  (P* (class "anchors")
      (do-choices (ref (find-frames content-index www/links-to result))
	(when (test ref 'type 'fragment)
	  (do-choices (url.text (get ref www/anchors))
	    (when  (eq? (car url.text) result)
	      (let* ((ref-doc (get ref gn/indoc)))
		(if (exists? ref-doc)
		    (span (class "anchor_text") (anchor-diamond ref)
			  "\"" (cdr url.text) "\"" " from "
			  (anchor ref-doc
				  (try (get ref-doc 'title)
				       (get ref-doc 'obj-name)
				       (get ref-doc 'url))))
		  (span (class "anchor_text") (anchor-diamond ref)
			(cdr url.text) " ")))))))))

(define (display-fragment-result doc result)
  (let ((url (pick-one (try (get doc 'url) (get (get doc doc/source) 'url)))))
    (when (exists? doc)
      (unless (test (cgi-data) 'result-context doc)
	(%set! (cgi-data) 'result-context doc)
	(P* (class "context") ; (anchor-diamond doc)
	    "From "
	    (anchor+ (scripturl (this-script) 'augment doc)
		     (class "ref" title (stringout "AUGMENT " url))
		     (try (get doc doc/title)
			  (get doc 'title)
			  url
			  (get doc 'obj-name)))
	    (when (exists? (get doc gn/date))
	      (let ((date (get doc gn/date)))
		(xmlout
		 " " (get-date date) " " (get-month date) " "
		 (get-year date))))
	    (when (exists? url)
	      (xmlout " ")
	      (anchor+ url (class "command" title url target "_new") "url")
	      (xmlout " "))
	    (anchor+ (if (exists? (get (cgi-data) 'keys))
			 (scripturl (this-script) 'distill doc 'keys
				    (get (cgi-data) 'keys))
		       (scripturl (this-script) 'distill doc
				  'question (get (cgi-data) 'question)))
		     (class "command"
			    title "get distilled version of document"
			    target "_new")
		     "distill"))))
    (P* (class "content")
	;; (anchor-diamond result)
	(anchor result
		(rewrite-img-refs
		 (strip-disruptive-markup (get result 'text))
		 (try url #f))))))

(define (display-search-result result scores keys)
  (when (test result 'type 'url)
    (display-url-result result)
    (%set! (cgi-data) 'result-context {}))
  (when (exists? (get result 'text))
    (let ((doc (get result gn/indoc)))
      (display-fragment-result doc result)))
  (P* (class "explanation")
      (if scores (xmlout "score=" (get scores result) ":&nbsp;"))
      (do-choices (key (intersection keys (get-keys result standard-slotids)) i)
	(when (> i 0) (xmlout " . ")) (display-key key (this-script)))))

(define (new-search-body question)
  (start-gnosys-page)
  (form (action (this-script)) (query-field question #f)))

(define (query-field question (keys #f))
  (form (action (this-script))
    (P* (class "query_field")
	(span (class "directions")
	  (strong "Syntax: ")
	  "; separates, + requires, - excludes, : constrains" (br))
	"Query GNOBASE: "
	(xmltag 'input 'type 'text 'name 'question
		'value (if (string? question) question "") 'size 60)
	(submit 'action "Best") (submit 'action "All") (submit 'action "New"))
    (if keys
	(P* (class "explanation")
	    (let ((first #t))
	      (do-choices (key keys)
		(unless (fail? (index-get content-index (expand-key key)))
		  (if first (set! first #f) (xmlout " . "))
		  (display-key key (this-script)))))
;;	    (begin
;;	     (span (class "inline") "keys: ")
;;	     (let ((first #t) (null-keys {}))
;;	       (do-choices (key keys)
;;		 (if (zero? (choice-size (index-get content-index key)))
;;		     (set+! null-keys key)
;;		   (begin (if first (set! first #f) (xmlout " . "))
;;			  (display-key key (this-script)))))
;;	       (when (exists? null-keys)
;;		 (span (class "inline") "  " (choice-size null-keys) " null keys: ")
;;		 (do-choices (key null-keys i)
;;		   (if (> i 0) (xmlout " . ")) (xmlout key)
;;		   (display-key key)))))
	    )
      (xmlout))))

;;;; The main loop

(define (main)
  (when (bound? use-browse-script!)
    (use-browse-script! (this-script) 'frame))
  (cgi-init question) (cgi-var frame augment distill)
  (cond ((and (exists? distill) (test distill 'type 'document))
	 (distilled-document-page distill))
	((and (exists? augment) (test augment 'type 'document))
	 (augmented-document-page augment))
	((exists? frame)			
	 (cond ((test frame 'type 'fragment)
		(browse-fragment-page frame))
	       ((test frame 'type 'document)
		(httpdoc
		  (start-gnosys-page)
		  (H3* (class "analysis")
		       "Meta Analysis of " 
		       (span (class "title") (try (get frame 'title) "")) (br)
		       (tt (get (get frame doc/source) 'url)))
		  (table* (class "frame_details")
		    (generate-index-row "Concept Index" frame gn/concepts)
		    (generate-index-row "Refpoint Index" frame gn/refpoints)
		    (generate-index-row "Name Index" frame gn/proper-names)
		    (generate-index-row "Phrase Index" frame gn/noun-phrases)
		    (slots->html frame))))
	       (else (httpdoc (start-gnosys-page) (oid->html frame)))))
	(else
	 (httpdoc
	   (if (test (cgi-data) 'action "New")
	       (new-search-body question)
	     (if (string? question) (text-search-body question)
	       (if (exists? (get (cgi-data) 'key))
		   (let () (cgi-var key) (key-search-body (qc key)))
		 (new-search-body question))))))))

;;;; Augmented document page

(define (body-started? text)
  (or (tx-search '(ic #("<body" (spaces*))) text)
      (tx-search `(ic ,(vector (qc structural-markup-tags) '(spaces*))) text)))

(define (augmented-document-page frame)
  (if (test frame 'type "html")
      (httpdoc
	(let ((url (pick-one (try (get frame 'url)
				  (get (get frame doc/source) 'url))))
	      (parsed (get frame doc/parsed))
	      (before-body #t))
      (let ((first-elt (if (oid? (car parsed)) (get (car parsed) 'text)
			 (car parsed))))
	(when (and (body-started? first-elt)
		   (fail? (tx-search head-pattern first-elt)))
	  (xmlout "\n<base href='" url "'/>")
	  (set! before-body #f)))
      (dolist (f parsed)
	(if before-body
	    (let* ((text (if (oid? f) (get f 'text) f))
		   (start-pos (tx-search head-pattern text))
		   (end-pos (tx-matcher head-pattern text start-pos)))
	      (if end-pos
		  (xmlout (subseq text 0 end-pos) "\n<base href='" url "'/>"
			  (subseq text end-pos))
		(xmlout text))
	      (when (body-started? text)
		(xmlout "\n<base href='" url "'/>")
		(html-start-body "")
		(set! before-body #f)))
	  (let* ((text (if (oid? f) (get f 'text) f))
		 (markup-start (tx-search initial-markup text))
		 (markup-end (tx-matcher initial-markup text markup-start)))
	    (xmlout (subseq text 0 markup-end))
	    (when (and (frame? f) (has-real-content? text))
	      (anchor+ (scripturl (get (cgi-data) 'script_uri) 'frame f)
		       (style "text-decoration: none;")
		       (image "http://road.beingmeta.com/graphics/bm_diamond"
			      alt "+" border 0))
	      (xmltag 'A 'name
		      (stringout "S" (number->string (oid-addr-high f) 16)
				 "/" (number->string (oid-addr-low f) 16))))
	    (xmlout (subseq text markup-end)))))))
    
      (httpdoc
	(let ((parsed (get frame doc/parsed)))
	  (dolist (f parsed)
	    (let ((text (if (oid? f) (get f 'text) f)))
	      (cond ((and (frame? f) (has-real-content? text))
		     (p (anchor+ (scripturl (get (cgi-data) 'script_uri) 'frame f)
			      (style "text-decoration: none;")
			      (image "http://road.beingmeta.com/graphics/bm_diamond"
				     alt "+" border 0))
		     (xmltag 'A 'name
			     (stringout "S" (number->string (oid-addr-high f) 16)
					"/" (number->string
					     (oid-addr-low f) 16)))
		     text))
		    (else (P text)))))))))

;;; Fragment browser

(define (browse-fragment-page frame)
  (httpdoc
    (title "Fragment: " frame)
    (start-gnosys-page)
    (h3 "From " (anchor (scripturl (this-script) 'augment (get frame gn/indoc))
			(try (get (get frame gn/indoc) 'title)
			     (get (get frame gn/indoc) 'heading)
			     (get (get frame gn/indoc) 'obj-name)))
	" " (anchor+ (augment-ref frame)
		     (class "command")
		     "in context")
	(if (exists? (get (get frame gn/indoc) gn/date))
	    (let ((date (get (get frame gn/indoc) gn/date)))
	      (br)
	      (span (class "date")
		"  " (get-year date) " " (get-month date) " " (get-date date)
		" (" (get-hour date) ":" (if (< (get-minute date) 10) "0")
		(get-minute date) ")"))
	  (xmlout))
	;; " &nbsp;" (anchor+ (get frame gn/indoc) (class "command") "analyze")
	(let ((url (try (get frame 'url) (get (get frame doc/source) 'url)
			(get (get (get frame gn/indoc) doc/source) 'url))))
	  (if (exists? url)
	      (xmlout " @"
		      (span (class "smallref") (anchor url url))))))
    (BR CLEAR 'BOTH) (HR)
    (let ((prev (get frame 'previous)) (next (get frame 'next))
	  (url (try (get frame 'url) (get (get frame gn/indoc) 'url)
		    (get (get (get frame gn/indoc) doc/source) 'url))))
      (when (exists? prev)
	(P* (class "previous_fragment")
	    (anchor prev (strip-disruptive-markup (get prev 'text)))))
      (P* (class "focus_fragment")
	  (strip-structural-markup (get frame 'text) (try url #f)))
      (when (exists? next)
	(P* (class "next_fragment")
	    (anchor next (strip-disruptive-markup (get next 'text)))))
      (hr)
      (table* (class "frame_details")
	(fragment-slotrow frame gn/concepts "concepts")
	(fragment-slotrow frame gn/refpoints "refpoints")
	(fragment-slotrow frame gn/proper-names "proper_name")
	(fragment-slotrow frame gn/noun-phrases "noun_phrase")
	(fragment-slotrow frame gn/textkeys "textkey")
	(fragment-slotrow frame gn/xkeys "xkey")
	(slots->html frame (difference (frame-slots frame) fragment-slotids))))))

(define (fragment-slotrow frame slotid classid)
  (let ((values (get frame slotid)))
    (unless (empty? values)
      (tr (th* (class "slotid") slotid)
	  (td* (class "value")
	    (do-choices (value values i)
	      (when (> i 0) (xmlout " . "))
	      (if (frame? value)
		  (span (class classid) (anchor value (showwords value)))
		(span (class classid) value))))))))

(define fragment-slotids
  {@?gn/textkeys @?gn/xkeys @?gn/proper-names @?gn/noun-phrases})

;;;; Metadata pages

(define (document-index-page frame)
  (table (generate-index-row "Names" frame gn/proper-names)))

(define (augment-ref fragment)
  (stringout (scripturl (this-script) 'augment (get fragment gn/indoc)) "#"
	     "S" (number->string (oid-addr-high fragment) 16)
	     "/" (number->string (oid-addr-low fragment) 16)))

(define (generate-index-row label doc slotid)
  (let ((val2fragment (make-hashtable))
	(val-frequencies (make-hashtable)))
    (do-choices (frag (get doc doc/contents))
      (hashtable-add! val2fragment (get frag slotid) frag))
    (do-choices (val (hashtable-keys val2fragment))
      (hashtable-set! val-frequencies val
		      (choice-size (get val2fragment val))))
    (tr (td* (class "fragindex" colspan 2)
	  (span (class "label") label "&nbsp;") "&nbsp;&nbsp;"
	  (doseq (val (reverse (sorted (hashtable-keys val2fragment)
				       val-frequencies)) i)
	    (if (> i 0) (strong " \u00b7 "))
	    (display-key (cons slotid val)) (xmlout " \u2761&nbsp;")
	    (doseq (fragment (sorted (get val2fragment val) 'pnum))
	      (anchor+ (stringout (scripturl (this-script) 'augment doc) "#"
				  "S" (number->string (oid-addr-high fragment) 16)
				  "/" (number->string (oid-addr-low fragment) 16))
		       (class "pnum" target
			      (stringout "D" (number->string (oid-addr-high fragment) 16)
					 "/" (number->string (oid-addr-low fragment) 16)))
		       (get fragment 'pnum))
	      (xmlout " ")))))))

;;; Slice pages

(define (distill-query-field doc map question (keys #f))
  (form (action (this-script))
    (cgipass 'distill doc)
    (when (string? question)
      (P* (class "query_field")
	  "Distill For Query: "
	  (xmltag 'input 'type 'text 'name 'question
		  'value (if (string? question) question "") 'size 60)
	  (submit 'action "Refresh")))
    (if keys
	(P* (class "explanation")
	    (span (class "inline") "keys: ")
	    (let ((first #t) (null-keys {}))
	      (do-choices (key keys)
		(if (empty? (get map key))
		    (set+! null-keys key)
		  (begin (if first (set! first #f) (xmlout " . "))
			 (display-key key (this-script)))))
	      (when (exists? null-keys)
		(span (class "inline")
		  "  " (choice-size null-keys) " null keys: ")
		(do-choices (key null-keys i)
		  (if (> i 0) (xmlout " . ")) (display-key key)))))
      (xmlout))))

(define (analyze-fragments fragments keys)
  (let ((scores (make-hashtable))
	(frags2keys (make-hashtable))
	(keys2frags (make-hashtable)))
    (do-choices (fragment fragments)
      (do-choices (key keys)
	(when (test fragment (car key) (cdr key))
	  (hashtable-increment! scores fragment 1)
	  (hashtable-add! frags2keys fragment key)
	  (hashtable-add! keys2frags key fragment))))
    (values scores frags2keys keys2frags)))

(define (distilled-document-page doc)
  (httpdoc
    (title "GNOSYS Distillation of "
	   (try (get doc 'url) (get (get doc doc/source) 'url)))
    (start-gnosys-page)
    (h3 (anchor (scripturl (this-script) 'augment doc)
		(try (get doc 'title) (get doc 'obj-name)))
	(if (exists? (get doc gn/date))
	    (let ((date (get doc gn/date)))
	      (br)
	      (span (class "date")
		"  " (get-year date) " " (get-month date) " " (get-date date)
		" (" (get-hour date) ":" (if (< (get-minute date) 10) "0")
		(get-minute date) ")"))
	  (xmlout))
	;; " &nbsp;" (anchor+ (get frame gn/indoc) (class "command") "analyze")
	(let ((url (try (get doc 'url) (get (get doc doc/source) 'url))))
	  (if (exists? url)
	      (xmlout " @"
		      (span (class "smallref") (anchor url url))))))
    (cgi-var keys) (cgi-init question)
    (let* ((keys (if (exists? keys) keys (elts (query->keys question english)))))
      (multiple-value-bind (scores frags2keys keys2frags)
	  (analyze-fragments (qc (get doc doc/contents)) (qc keys))
	(distill-query-field doc keys2frags question (qc keys))
	(hr)
	(dolist (s (get doc doc/parsed))
	  (cond ((string? s))
		((or (fail? (get scores s))
		     #f)
		 (reduce-fragment s))
		(else (sliced-fragment
		       s (get scores s) (qc (get frags2keys s))))))))))

(define (reduce-fragment s)
  (P* (class "reduced_fragment")
      (anchor+ (augment-ref s)
	       (class "whole_tag")
	       (get s 'obj-name))))
(define (sliced-fragment s score keys)
  (let* ((doc (get s gn/indoc))
	 (url (pick-one (try (get doc 'url) (get (get doc doc/source) 'url)))))
    (P* (class "sliced_fragment")
	(anchor+ (augment-ref s)
		 (class "content_tag")
		 (img src "/graphics/bm_diamond" border 0))
	(anchor+ (augment-ref s)
		 (class "whole_tag")
		 (strip-structural-markup (get s 'text) (try url #f))))
    (P* (class "slice_explanation")
	(xmlout "score=" score ":&nbsp;")
	(do-choices (key keys i)
	  (when (> i 0) (xmlout " . "))
	  (display-key key (this-script))))))



