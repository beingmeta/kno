;;; -*- Mode: fdscript; fill-column: 90; -*-
;; Preamble stuff

(when (file-exists? (get-component "gnosys.cfg"))
  (load-config (get-component "gnosys.cfg")))

(define brico-pool (use-pool 'brico))
(define brico-index (use-index 'brico))

(define-if-needed memory-headroom 100000000)
(define memlimit (+ (memusage) memory-headroom))

(auto-cache-file-pools)
(auto-cache-file-indices)

(define (display-site-logo)
  (cond ((and (bound? site-logo) (bound? site-string))
	 (IMAGE site-logo ALT site-string))
	((bound? site-logo) (IMAGE site-logo))
	(else (html "&nbsp;"))))

(define (pagehead-session-id) 
  ;; (TR (TH "&nbsp;") (TH* (CLASS "sessionid") (session-id)) (TH "&nbsp;"))
  "")

(define (num->string s p)
  (if (inexact? s) (inexact->string s p) s))

(define (limit-string string len)
  (if (< (length string) len) (html string)
    (let ((space-pos (tx-search '(isspace) string len)))
      (if (or (not space-pos) (> space-pos (+ len 10)))
	  (html (subseq string 0 len) (font (color "red") "..."))
	(html (subseq string 0 space-pos) (font (color "red") "..."))))))

;;(set-notify! #t)
;;(set-notify! (open-output-file "/tmp/gnosys.log"))
(gset! %debug #t)

;;; Load the modules you'll use

(use-module 'brico)
(use-brico)

(use-module 'gnosys)
(use-module 'fd4web)
(use-module 'htmlgen)
(use-module 'xmlgen)
(use-module 'index-plus)
(use-module 'morph)
(use-module 'cgi)

(use-module 'gnosys/cgi/display)
(use-module 'gnosys/cgi/search)

;;; Set up browse scripts, pools, etc.

(gset! %debug #t)

(define content-pool (use-pool CONTENT))
(define content-pools
  (filter-choices (pool (all-pools))
    (equal? (pool-id pool) CONTENT)))
;; This doesn't get added to the background
(define content-index (open-index CONTENT))

(define concept-index {})
(when (bound? CONCEPTS)
  (set! concept-index (open-index CONCEPTS))
  (set+! content-index concept-index))
(define (get-concept-index) (try concept-index content-index))

(define premium-index {})
(when (bound? PREMIUM)
  (set! premium-index (open-index PREMIUM)))

(define (get-keysums spec)
  (if (find #\@ spec)
      (let ((result (dtcall spec keysums)))
	(if (frame? result) result (fail)))
    (frame-create #f)))
(define keysums (get-keysums CONTENT))

(use-pool BACKGROUND)
(define background-pools
  (filter-choices (pool (all-pools))
    (contains? (pool-id pool) BACKGROUND)))
(define background-index (use-index BACKGROUND))

(set-refs-db! REFSERV)

(define-if-needed default-language
  (find-frames brico-index 'language 'english))
(define-if-needed possible-languages
  (find-frames brico-index 'language 'english))

(define-if-needed summaries {})

(when (bound? xbrico)
  (define xbrico-pool (use-pool 'xbrico))
  (define xbrico-index (use-index 'xbrico)))

(when (bound? background)
  (use-pool++ background))

(use-browse-script! "gnosys.fdcgi")

(define stdslots
  (choice gn/concepts gn/refpoints gn/proper-names gn/compound-names
	  gn/noun-phrases gn/textkeys))

;;;; Set up summary retrieval

(define summary-servers
  (if (bound? summaries) (use-server summaries) (fail)))
(define summary-table (make-hashtable))

(define (preload-summaries frames)
  (let ((needed (filter-choices (frame frames)
		  (exists? (hashtable-get summary-table frame)))))
    (let ((results (dtcall summary-servers summary-get needed)))
      (do-choices (result results)
	(hashtable-set! summary-table (car result) (cdr result))))))

(define (get-summary frame)
  (try (hashtable-get summary-table frame)
       (begin (preload-summaries frame)
	      (hashtable-get summary-table frame))))

;;;; The main event

(define (get-action cgi-data)
  (try (get cgi-data 'action)
       (cond ((exists? (get cgi-data 'hsearch.x)) "Hybrid Search")
	     ((exists? (get cgi-data 'fsearch.x)) "Text Search")
	     ((exists? (get cgi-data 'csearch.x)) "Concept Search")
	     ((exists? (get cgi-data 'xsearch.x)) "Extended Search")
	     ((exists? (get cgi-data 'simsearch.x)) "Find Similar")
	     ((exists? (get cgi-data 'random.x)) "Random")
	     (else (fail)))))

(define (main)
  (cgi-init query) (cgi-var searchmode)
  (if (and (> (length query) 0) (eqv? (elt query 0) #\@))
      (frame-browser (read-from-string query))
      (let* ((reqdata (cgi-data))
	     (action (req-get reqdata 'action)))
	(cond ((eq? action 'slotsearch)
	       (slotsearch-responder reqdata))
	      ((eq? action 'augment)
	       (let ((frame (req-get (cgi-data) 'frame)))
		 (if (exists? (get frame doc/contents))
		     (display-augmented-document reqdata frame)
		   (display-page reqdata frame))))
	      ((eq? action 'search) (generic-search-responder reqdata))
	      ((eq? action 'display)
	       (display-page reqdata (req-get (cgi-data) 'frame)))
	      ((eq? action 'analysis)
	       (analysis-page reqdata (req-get (cgi-data) 'frame)))
	      ((eq? action 'sysview)
	       (cgi-var frame)
	       (httpdoc (header 'pragma "no-cache")
			(title "Description of " frame)
			(stylesheet! "sysview.css")
			(center (oid->html frame)))))))
  (http-flush!)
  (when (> (memusage) memlimit)
    (swap-out-all)
    (set! memlimit (+ (memusage) memory-headroom))))

;;; Generating GNOSYS scripturls

(define-if-needed gnosys-web-root "http://gnosys.beingmeta.com/")
(define gnosys-script-root
  (string-append ""))
(define gnosys-image-root
  (string-append "/images/"))

(define (gscript string)
  (string-append gnosys-script-root string))
(define (gimage string)
  (string-append gnosys-image-root string))

(define (gnosys-banner)
  (anchor@ "_new" (string-append gnosys-web-root "/gnosys/")
	   (image (gimage "gnosys_banner_web.gif")
		  valign 'top border 0 alt "GNOSYS")))
(define (bm-banner)
  (anchor@ "_new" (string-append gnosys-web-root "/")
	  (image (gimage "bm_banner_black_web.gif")
		 valign 'top border 0 alt "beingmeta")))

(define (gnosys-beingmeta-logo)
  (image (gimage "gnosys_bm_logo.gif") ALT "GNOSYS from beingmeta"))

(define (small-diamond)
  (img src (gimage "sm_diamond.gif") border 0 ALT "+"))

(define (publogo doc)
  (when (exists? (get doc 'publication))
    (let ((pub (get doc 'publication)))
      (if (exists? (get pub 'puburl))
	  (anchor (get pub 'puburl)
		  (if (exists? (get pub 'publogo))
		      (IMAGE (get pub 'publogo) BORDER 0 ALT (get pub '%refid))
		      (if (exists? (get pub '%refid)) (html (get pub '%refid)))))
	  (if (exists? (get pub 'publogo))
	      (IMAGE (get pub 'publogo) BORDER 0 ALT (get doc '%refid))
	      (if (exists? (get pub '%refid))
		  (html (get pub '%refid))))))))

(define (get-title frame)
  (try (get frame 'title) (get frame 'heading)
       (if (bound? title-slotids)
	   (let try-others ((slotids title-slotids))
		(if (null? slotids) (fail)
		  (try (get frame (car slotids))
		       (try-others (cdr slotids))))))))

(define (substring-search-url string root-map)
  (scripturl "gnosys.fdcgi"
	     'gnfn 'search 'searchmode 'slotstring
	     'slotid (if (capitalized? string)
			(choice gn/proper-names  gn/compound-names)
			gn/noun-phrases)
	     'value (try (get root-map string) string)))


;;; Support for automatic refresh

(define javascript
"
<SCRIPT LANGUAGE='Javascript'>
<!--
function refile_form () {
  document.bmform.submit(); }
-->
</SCRIPT>
"
)


;;;; Stripping structural tags

(define structural-tags (elts (segment "LI TD TR TH DL DT DD P TABLE")))

(define structural-markup-pat
  `(ic ,(choice (vector "<" (qc structural-tags) '{"" (char-not ">")} ">")
		(vector "</" (qc structural-tags) ">"))))

(define (strip-structural-markup string)
  (let ((stream (open-string-stream)))
    (let* ((pos 0)
	   (mpos (smallest (tx-search structural-markup-pat string pos)) ))
      (while (exists? mpos)
	(if (> mpos pos)
	    (display (convert-character-entities (subseq string pos mpos))
		     stream))
	(set! pos (tx-matcher structural-markup-pat string mpos))
	(set! mpos (tx-search structural-markup-pat string pos)))
      (if (> (length string) pos)
	  (display (convert-character-entities (subseq string pos)) stream))
      (string-stream-contents stream))))


;;;; Display primitives

(define (language-radiobutton var language current)
  (htmltag 'input 'type 'radio 'name var
	   'value language 'onclick "refile_form()"
	   (if (eq? current language) " CHECKED" "")))
(define (language-box cgi-data)
  (let ((current (get-language cgi-data)))
    (do-choices (lang (get-languages cgi-data))
      (html (language-radiobutton 'language lang current)
	    "&nbsp;" (try (get lang 'string) (get lang 'language)
			  (get lang 'obj-name)))
	    " ")))

(define (active-radiobutton var val checked)
  (htmltag 'input 'type 'radio 'name var
	   'value val 'onclick "refile_form()"
	   (if checked " CHECKED" "")))

(define (active-checkbox var val checked)
  (htmltag 'input 'type 'checkbox 'name var
	   'value val 'onclick "refile_form()"
	   (if checked " CHECKED" "")))

(define (concept-choice var concept (selected #f) (active #f))
  (if active
      (htmltag 'input 'type 'checkbox
	       'name (if var (STRINGOUT var "-CONCEPTS") 'concepts)
	       'value concept 'onclick "refile_form()"
	       (if selected " CHECKED" ""))
      (htmltag 'input 'type 'checkbox
	       'name (if var (STRINGOUT var "-CONCEPTS") 'concepts)
	       'value concept
	       (if selected " CHECKED" ""))))

(define (refine-choice var concept selected)
  (htmltag 'input 'type 'checkbox
	   'name (if var (stringout var "-CONCEPTS") 'refine)
	   'value concept 'onclick "refile_form()"
	   (if selected " CHECKED" "")))

(define (html-concept concept language)
  (let ((words (get concept language)))
    (if (exists? words)
	(anchor concept
		(doseq (elt (sortby length choices) i)
		  (if (= i 0) (html elt) (html " . " elt))))
	(anchor concept
		(doseq (elt (sortby length (get concept 'words)) i)
		  (if (= i 0) (html elt) (html " . " elt)))))))

(define (concept-row concept language displayed selected
		     (refined #f) (active #f))
  (unless (hashset-get displayed concept)
    (hashset-add! displayed concept)
    (TR (TH* (CLASS "checkbox")
	     (concept-choice concept selected active))
	(TH* (CLASS "concept")
	     (html-concept concept)
	     (if (exists? (get concept 'gloss))
		 (HTML (BR) (EM (get concept 'gloss))))
	     (BR) (get concept 'sense-category) "&nbsp;" 
	     (when (exists? (get concept 'hypernym))
	       (do-choices (hyp (get concept 'hypernym))
		 (html-concept hyp) " &nbsp;.&nbsp; ")))
	(when selected
	  (TH* (CLASS "checkbox")
	       (refine-choice concept refined)
	       "&nbsp;refine")))))

(define (short-value value)
  (if (oid? value)
      (let* ((name (get value 'obj-name))
	     (string (if (string? name) name (write-to-string name))))
	(if (> (length string) 60)
	    (anchor value (nobreak (subseq string 0 60))
		    (font (color "red") "...."))
	    (anchor value (nobreak string))))
      (let ((name (if (string? value) value (write-to-string value))))
	(if (> (length name) 60)
	    (html (nobreak (subseq name 0 60)) (font (color "red") "...."))
	    (html name)))))


;;;; Interwoven references

(define (make-root-map pairs)
  (let ((rootmap (make-hashtable)))
    (do-choices (pair pairs)
      (unless (equal? (car pair) (cdr pair))
	(hashtable-add! rootmap (cdr pair) (car pair))))
    rootmap))

(define (pick-one-refpoint refpoints)
  (pick-one
   (try (pick refpoints 'source @/brico/0)
	refpoints)))

(define (standardize-string string root-map)
  (let ((wordlist (tx-segment string '(spaces)))
	(stream (open-string-stream)))
    (display (car wordlist) stream)
    (dolist (word (cdr wordlist))
      (display " " stream) (display word stream))
    (let ((string (string-stream-contents stream)))
      (try (get root-map string)
	   (if (uppercase? string)
	       (choice string (string-capitalize string))
	       string)))))

(define (insert-search-anchors text breaks root-map)
  (let ((fragmented (tx-fragment text `(word ,breaks))))
    (if (= (length fragmented) 1) (html text)
	(do ((scan fragmented (cddr scan)))
	    ((null? scan))
	  (if (= (length (car scan)) 0) (html (cadr scan))
	      (if #t ; (worth-a-search? (try (get root-map (car scan)) (car scan)))
		  (html (a* (class "textsearch"
			     href (substring-search-url
				   (stdspace (car scan)) root-map)) 
			    (car scan))
			(cadr scan))
		  (html (car scan) (cadr scan))))))))

(define (display-interwoven-text frame)
  (let* ((language (try (get frame gn/language) default-language))
	 (concepts (choice (get frame gn/refpoints) (get frame gn/concepts)))
	 (root-map (make-root-map (qc (get frame 'roots))))
	 (breaks (choice (get frame gn/proper-names)
			 (get frame gn/compound-names)
			 (get frame gn/noun-phrases)
			 (cdr (get frame 'roots))))
	 (concept-breaks
	  (filter-choices (break breaks)
	    (test concepts (choice language 'names 'short-name)
		  (choice break (string-capitalize break)
			  (get root-map break))))))
    ;; We would do this if we were really calling worth-a-search?
    ;; (index-prefetch
    ;;  content-index
    ;;  (choice (cons gn/proper-names (get frame gn/proper-names))
    ;;  (cons gn/compound-names (get frame gn/compound-names))
    ;;  (cons gn/noun-phrases (get frame gn/noun-phrases))))
    (cond ((or (fail? breaks) (fail? concepts))
	   (html (get frame 'text)))
	  (else
	   (let* ((text (get frame 'text))
		  (fragmented (if (exists? concept-breaks)
				  (tx-fragment text `(word ,concept-breaks))
				  (list "" text))))
	     (if (= (length fragmented) 1) (html text)
		 ;; Now we output an alternating list of text fragments and concept anchors
		 (do ((scan fragmented (cddr scan)))
		     ((null? scan))
		   (if (= (length (car scan)) 0)
		       (insert-search-anchors (cadr scan) (qc breaks) root-map)
		       (let* ((name (standardize-string (car scan) root-map))
			      (concepts
			       (if (find #\Space name)
				   (try (?? (choice 'names language) name)
					(pick concepts 'short-name name))
				   (try (pick concepts 'short-name name)
					(?? (choice 'names language) name)))))
			 (cond ((fail? concepts) (strong name))
			       ((= (choice-size concepts) 1)
				(anchor concepts (small-diamond) (car scan)))
			       (else (anchor (pick-one-refpoint (qc concepts))
					     (small-diamond) (car scan))))
			 (insert-search-anchors (cadr scan) (qc breaks)
						root-map))))))))))

(define name-slots (choice gn/proper-names gn/compound-names))

(define (worth-a-search? string)
  (if (capitalized? string)
      (> (choice-size (find-frames content-index name-slots string)) 1)
      (> (choice-size (find-frames content-index gn/noun-phrases string)) 1)))


;;; Applying keys to text

(define (key->txpat key)
  (let ((slotid (car key)) (slotval (cdr key)))
    (cond ((or (eq? slotid gn/noun-phrases) (eq? slotid gn/proper-names)
	       (eq? slotid gn/compound-names))
	   `(canonical ,slotval))
	  ((eq? slotid gn/textkeys) slotval)
	  ((eq? slotid gn/xkeys)
	   `(canonical ,(vector (car slotval)
				(qc '(spaces)
				    #((spaces) (aword) (spaces))
				    #((spaces) (aword) (spaces) (aword) (spaces))
				    #((spaces) (aword) (spaces) (aword)
				      (spaces) (aword) (spaces))
				    #((spaces) (aword) (spaces) (aword)
				      (spaces) (aword) (spaces) (aword) (spaces)))
				(cadr slotval))))
	  ((or (eq? slotid gn/concepts)  (eq? slotid gn/refpoints))
	   `(is ,(get slotval (choice 'names 'short-name default-language))))
	  (else (fail)))))

(define (get-locations pattern text)
  (let* ((positions {})
	 (start (tx-search pattern text 0))
	 (end (tx-matcher pattern text start)))
    (while (exists? start)
      (set+! positions (cons start end))
      (set! start (tx-search pattern text end))
      (set! end (tx-matcher pattern text start)))
    positions))

(define (span-distance span1 span2)
  (abs (if (> (car span1) (cdr span2))
	   (- (car span1) (cdr span2)) 
	   (- (car span2) (cdr span1)))))

(define (get-compactness text against-keys)
  (let ((locs (get-locations (qc (key->txpat against-keys)) text))
	(minspans '()))
    (do-choices (loc locs)
      (let ((min #f))
	(do-choices (other locs)
	  (unless (= other loc)
	    (let ((distance (span-distance loc other)))
	      (if min
		  (if (< distance min) (set! min distance))
		  (set! min distance)))))
	(if min (set! minspans (cons min minspans)))))
    (if (null? minspans) 1000000
	(/ (apply + 0.0 minspans) (length minspans)))))

;;; Sales scoring

(define (sales-score item keys1 keys2)
  (let ((hits1 0.0) (hits2 0.0))
    (do-choices (key1 keys1)
      (if (contains? item (index-get content-index key1))
	  ;; (test item (car key1) (cdr key1))
	(set! hits1 (1+ hits1))))
    (do-choices (key2 keys2)
      (if (contains? item (index-get content-index key2))
	  ;; (test item (car key2) (cdr key2))
	  (set! hits2 (1+ hits2))))
    (/ hits1 hits2)))

;;; "Objective" Scoring functions

(define (log-inv-score key)
  (- (log (/ 1.0 (index-get-size content-index key)))))	

(define (constant-score key) 1)

(define (oid-biased-score key)
  (if (oid? (cdr key)) 4 1))

(define (value-based-score key)
  (let ((v (cdr key)))
    (cond ((oid? v) 4)
	  ((pair? v) 3)
	  ((not (string? v)) 1)
	  ((or (capitalized? v) (find #\Space v)) 2)
	  (else 1))))
(define (compound-biased-score key)
  (let ((v (cdr key)))
    (if (or (oid? v) (pair? v)
	    (and (string? v) (find #\Space v)))
	2
      1)))

(define (slot-based-score key)
  (let ((slotid (car key)))
    (cond ((or (eq? slotid gn/textkeys)  (eq? slotid gn/stemkeys)) 1)
	  ((or (eq? slotid gn/xkeys)) 2)
	  (else 4))))

(define (score-key key)
  (if (exists? (%get keysums (car key)))
      (if (zero? (index-get-size content-index key)) 0
	  (log (/ (* 1.0 (%get keysums (car key)))
		  (index-get-size content-index key))))
      (value-based-score-on-value (cdr key))))

;;; Search function

(define (dosearch-simple keys scorefn expandfn (excluded #f))
  (notify "Starting dosearch")
  (if (exists? expandfn)
      (index-prefetch content-index (expandfn keys))
      (index-prefetch content-index keys))
  (notify "Key prefetch completed")
  (do-choices (key keys)
    (let ((hits (index-get content-index key)))
      (notify "Key " key " is associated with "
	      (choice-size hits) " entries")))
  (let ((scores (make-hashtable 500000))
	(expkeys {}))
    (do-choices (key keys)
      (let ((score (scorefn key))
	    (expansion (if (exists? expandfn) (expandfn key) key)))
	(let ((hits (proper-choice (index-get content-index expansion))))
	  (set+! expkeys expansion)
	  (if (and (pair? key) (oid? (cdr key)))
	      (hashtable-increment! scores hits score)
	      (unless (> (choice-size hits) 50000)
		(hashtable-increment! scores hits score))))))
    (notify "Scores computed")
    (if excluded
	(do-choices (frame excluded)
	  (if (exists? (get frame scores)) (hashtable-set! scores frame 0))))
    (values scores (qc expkeys))))

(define (dosearch keys focus-keys not-keys scorefn expandfn (excluded #f))
  (if (exists? expandfn)
      (index-prefetch content-index (expandfn (choice keys focus-keys not-keys)))
      (index-prefetch content-index keys))
  (do-choices (key keys)
    (let ((hits (index-get content-index key)))
      (notify "Key " key " is associated with "
	      (choice-size hits) " entries")))
  (let ((scores (make-hashtable 500000))
	(censored (make-hashset))
	(expkeys {}))
    (do-choices (key not-keys)
      (hashset-add! censored (index-get content-index key)))
    (when expandfn
      (do-choices (key (expandfn not-keys))
	(hashset-add! censored (index-get content-index key))))
    (do-choices (key keys)
      (let* ((score (if (contains? key focus-keys)
			(* 3 (scorefn key)) (scorefn key)))
	     (expansion (if (exists? expandfn) (expandfn key) key))
	     (hits (hashset-filter censored
				   (index-get content-index expansion))))
	(set+! expkeys expansion)
	(if (and (pair? key) (oid? (cdr key)))
	    (hashtable-increment! scores hits score)
	    (unless (> (choice-size hits) 50000)
	      (hashtable-increment! scores hits score)))))
    (notify "Scores computed")
    (if excluded
	(do-choices (frame excluded)
	  (if (exists? (get frame scores)) (hashtable-set! scores frame 0))))
    (values scores (qc expkeys))))

;;;; Displaying searches

(define (display-search cgi-data core keys scores maxshow)
  (cgi-var minscore)
  (if (fail? minscore)
      (set! minscore (get scores (pick-one (hashtable-max scores)))))
  (let ((items (qc (hashtable-skim scores (- minscore 0.1)))))
    (if (> (choice-size items) maxshow)
	(H1* (ALIGN 'CENTER)
	     (helplet "results_doc.html#results_list")
	     "Displaying " (try maxshow 20) " out of the "  (choice-size items)
	     " possible items")
	(html))
    (scored-search-displayer
     cgi-data (qc (pick-n (qc items) maxshow)) (qc keys) scores)))

(define (pretty-timestring timestamp)
  (stringout
   (string-capitalize (symbol->string (get-month timestamp)))
   " " (get-date timestamp) ", " (get-year timestamp)))

(define (helplet url)
  (anchor url (image "/images/qmark.gif" border 0)))

(define (new-source! doc (duplicate #f))
  (unless duplicate (TR (TH* (COLSPAN 2) (HR))))
  (TR (TH* (CLASS "from") (if duplicate (anchor duplicate "also in") "from"))
      (TH* (CLASS "source")
	   (helplet "results_doc.html#result_header")
	   (ANCHOR (scripturl "gnosys.fdcgi" 'gnfn 'display 'doc doc)
		   (get-doc-title doc))
	   (when (exists? (get doc 'publication))
	     (html "&nbsp;in&nbsp;"
		   (if (exists? (get (get doc 'publication) 'puburl))
		       (anchor  (get (get doc 'publication) 'puburl)
				(span (class "pubname")
				  (get doc 'publication)))
		       (span (class "pubname")
			 (get doc 'publication)))))
	   " " "[" (anchor doc "breakdown") "]"
	   (when (exists? (get doc gn/date))
	     (html " " (pretty-timestring (get doc gn/date)))))))

(define (score-string item compactness scores)
  (let ((compactscore (vector-ref (get compactness item) 0))
	(score (get scores item)))
    (string-append (inexact->string compactscore 3) "/"
		   (if (inexact? score) (inexact->string score 3)
		       (number->string score)))))

(define (select-matching-keys keys item)
  (filter-choices (key keys)
    (test item (car key) (cdr key))))

(define (search-displayer cgi-data results core keys scores)
  (let ((item-scores (make-hashtable))
	(start (xtimestamp)) (prefetch-time #f)
	(compactness-time 0) (novelty-time 0)
	(pre-sort-time #f) (sort-time #f))
    (prefetch results) (prefetch (get results gn/indoc))
    (prefetch (just-oids (cdr keys)))
    (set! prefetch-time (difftime (xtimestamp) start))
    (let ((stime (xtimestamp)))
      (do-choices (item results)
	(let ((compactness #f)  (novelty-score #f))
	  (set! compactness (get-compactness (get item 'text) (qc keys)))
	  (let ((now (xtimestamp)))
	    (set! compactness-time (+ compactness-time (difftime now stime)))
	    (set! stime now))
	  (set! novelty-score (sales-score item (qc core) (qc keys)))
	  (let ((now (xtimestamp)))
	    (set! novelty-time (+ novelty-time (difftime now stime)))
	    (set! stime now))
	(hashtable-set! item-scores item
			(vector compactness novelty-score)))))
    (set! pre-sort-time (- (difftime (xtimestamp) start) prefetch-time))
    (let* ((ordered (sortby item-scores results))
	   (n-items (length ordered)))
      (set! sort-time (- (difftime (xtimestamp) start) prefetch-time))
      (FORM (ACTION "gnosys.fdcgi")
	    (HR)
	    ;; (P "Prefetch time: " prefetch-time " secs; "
	    ;;    "compactness time: " compactness-time " secs; "
	    ;;    "novelty time: " novelty-time " secs; "
	    ;;    "pre-sort time: " pre-sort-time " secs; "
	    ;;    "sort time: " sort-time " secs")
	    (CGIPASS 'GNFN 'SIMSEARCH)
	    (table* (class "searchresults")
	      (TR (TH* (VALIGN 'BOTTOM ALIGN 'RIGHT)
		       (INPUT TYPE "IMAGE"
			      SRC "/images/more-like-these.png"
			      NAME "SIMSEARCH"))
		  (TD* (COLSPAN 2 VALIGN 'BOTTOM)
		       (display-search-map scores)))
	      (let ((document #f) (last-text #f))
		(dotimes (i n-items)
		  (let* ((item (vector-ref ordered i))
			 (doc (get item gn/indoc))
			 (text (get item 'text))
			 (keys (select-matching-keys (qc keys) item)))
		    (cond ((equal? last-text text)
			   (new-source! doc item) (set! document doc))
			  ((exists? doc)
			   (unless (eq? document doc)
			     (new-source! doc) (set! document doc))
			   (set! last-text text)
			   (display-one-search-result
			    cgi-data item (score-string item item-scores scores)
			    (qc keys)))
			  (else (set! document #f)
				(set! last-text text)
				(display-one-search-result
				 cgi-data item (score-string item item-scores scores)
				 (qc keys))))))))))))


;;;; Displaying one search result

(define (display-one-search-result cgi-data frame (score "+") keys)
  (prefetch (get frame (choice '%elt_type '%elt_attribs)))
  (TR (TH* (CLASS "score" ROWSPAN 2)
	   score (checkbox 'frames frame #f))
      (if (exists? (get frame 'text))
	  (TD* (CLASS "summary")
	       (span (class "text")
		 (anchor frame
			 (display-highlighted-text 
			  (strip-structural-markup (get frame 'text))
			  (qc keys)))))
	  (TD* (CLASS "summary")
	       (span (class "text")
		 (anchor frame
			 (try (get frame 'url)
			      (get (get frame doc/source) 'url)
			      (get-title frame)
			      (get-title (get frame doc/source))
			      (get frame 'obj-name)))))))
  (let ((language (get-language cgi-data)))
    (TR (th* (CLASS "keysummary")
	  (helplet "results_doc.html#matched_features")
	  (display-keys (qc keys) gn/refpoints language "oid")
	  (display-keys (qc keys) gn/concepts language "oid")
	  (display-keys (qc keys) gn/proper-names language "stringval")
	  (display-keys (qc keys) gn/compound-names language "stringval")
	  (display-keys (qc keys) gn/noun-phrases language "stringval")
	  (display-keys (qc keys) gn/textkeys language "stringval")
	  (do-choices (slotid (difference (car keys) stdslots))
	    (display-keys (qc keys) slotid language "slotval")))))
  (http-flush!))

(define (display-highlighted-text string keys)
  (let* ((patterns (key->txpat keys))
	 (fragged (if (empty? patterns) (list string)
		    (tx-fragment string patterns))))
    (if (= (length fragged) 1) (html (car fragged))
	(do ((frags fragged (cddr frags)))
	    ((null? frags))
	  (span (class "highlight") (car frags)) (html (cadr frags))))))


;;;; Displaying search maps

(define (modified-url var val)
  (cgi-init script_name) (cgi-init query_string)
  (let ((var-pos (tx-search `#({(bol) "&"} ,var "=") query_string)))
    (if (exists? var-pos)
	(let ((var-end (position #\& query_string (1+ var-pos))))
	  (if var-end
	      (stringout script_name "?"
			 (subseq query_string 0 var-pos) "&" var "=" val "&"
			 (subseq query_string var-end))
	      (stringout script_name "?"
			 (subseq query_string 0 var-pos) "&" var "=" val "&")))
	(stringout script_name "?" query_string "&" var "=" val "&"))))

(define (make-histogram scores)
  (let ((histogram (make-hashtable)))
    (do-choices (key (hashtable-keys scores))
      (hashtable-increment! histogram (get scores key)))
    histogram))

(define (display-search-map scores)
  (let ((histogram (make-histogram scores)) (n 0))
    (SPAN (STYLE "font-size: 14pt;")
	  ;; (STRONG "SEARCHMAP&nbsp;&nbsp;&nbsp;")
	  (doseq (score (reverse (sorted (hashtable-keys histogram))) i)
	    (set! n (+ n (get histogram score)))
	    (unless  (= i 0) (html " . "))
	    (span (class "nobreak")
	      (ANCHOR (modified-url "MINSCORE" score) "score=" score)
	      " (" n " items)"))
	  (helplet "results_doc.html#search_map"))))

;;;; Textual Query analysis

(define (lookup-parser symbol)
  (case symbol
    (concept-parse concept-parse)
    (stemkey-parse stemkey-parse)
    (xkey-parse xkey-parse)
    (textkey-parse textkey-parse)
    (else (fail))))

(define (parse-querytext cgi-data)
  (cgi-init querytext)
  (if (exists? (lookup-parser (get cgi-data 'parser)))
      ((lookup-parser (get cgi-data 'parser)) cgi-data querytext)
      (standard-text-analysis cgi-data querytext)))

(define (get-clean-textkeys frame)
  (let ((keys (get frame 'textkeys)))
    (for-choices (key keys)
      (if (and (lowercase? key)
	       (contains? (string-capitalize key) keys))
	  (fail)
	key))))

(define (standard-text-analysis cgi-data text)
  (let* ((language (or (get-language cgi-data) default-language))
	 (analysis (get-text-analysis text language))
	 (simple+compound (get analysis '{simple-names compound-names}))
	 (refpoints  (get-refpoints simple+compound language))
	 (concepts (get-concepts (choice (get analysis 'noun-phrases)
					 (elts (segment text))
					 (get-clean-textkeys analysis))
				 language))
	 (concept-words
	  (choice (get concepts language)
		  (get refpoints language)
		  (stdstring (get refpoints language))))
	 (keys (choice
		(cons gn/proper-names
		      (filter-stringkeys
		       (difference (get analysis 'simple-names)
				   (get refpoints 'names))
		       (qc concept-words)))
		(cons gn/compound-names
		      (filter-stringkeys
		       (difference (get analysis 'compound-names)
				   (get refpoints 'names))
		       (qc concept-words)))
		(cons gn/noun-phrases
		      (difference (get analysis 'noun-phrases)
				  (get concepts language)))
		(cons gn/refpoints refpoints)
		(cons gn/textkeys
		      (filter-stringkeys
		       (qc (get analysis 'textkeys))
		       (qc (get analysis 'proper-names)
			   (stdstring (get analysis 'proper-names))
			   concept-words)))
		(cons gn/concepts concepts)
		(cons gn/xkeys
		      (filter-xkeys (qc (get analysis 'xkeys))
				    (qc concept-words))))))
    keys))

(define (textkey-parse cgi-data text)
  (let* ((language (or (get-language cgi-data) default-language))
	 (analysis (get-text-analysis text language)))
    (cons gn/textkeys (get analysis 'textkeys))))

(define (stemkey-parse cgi-data text)
  (cons gn/stemkeys (english-stem (elts (segment text)))))

(define (concept-parse cgi-data text)
  (let* ((language (or (get-language cgi-data) default-language))
	 (analysis (get-text-analysis text language))
	 (simple+compound (get analysis '{simple-names compound-names})))
    (choice (cons gn/refpoints (get-refpoints simple+compound language))
	    (cons gn/concepts
		  (get-concepts (get analysis 'noun-phrases)
				language)))))

(define (xkey-parse cgi-data text)
  (let* ((language (or (get-language cgi-data) default-language))
	 (analysis (get-text-analysis text language))
	 (simple+compound (get analysis '{simple-names compound-names})))
    (cons gn/xkeys (get analysis 'xkeys))))

;;; This filters out xkeys that involve particular words, which is useful to 
;;; avoid double counting xkeys which are already reflected in concepts,
;;; phrases, or names
(define (filter-xkeys xkeys words)
  (let ((lwords (stdstring words)))
    (filter-choices (key xkeys)
      (not (satisfied? (xkey-conflict? key lwords))))))
(define (xkey-conflict? xkey name)
  (and (search (car xkey) name) (search (cadr xkey) name)))

(define (filter-stringkeys textkeys xwords)
  (filter-choices (key textkeys)
    (not (satisfied? (search key xwords)))))

;;; Extended queries

(define marked-word
  `#((subst {"+" "-"} "") (compound-word)))

(define (rewriter pattern string)
  (let ((frags (tx-fragment string pattern)))
    (if (= (length frags) 1) (car frags)
	(do ((stream (open-string-stream))
	     (frags frags (cddr frags)))
	    ((null? frags) (string-stream-contents stream))
	  (display (tx-subst pattern (car frags)) stream)
	  (display (cadr frags) stream)))))
    
(define (get-roots-too string language)
  (choice (get-roots string language) (stdstring string) string))

(define (parse-advanced-querytext cgi-data string)
  (let* ((marked-words (tx-gather marked-word string))
	 (language     (get-language cgi-data))
	 (parser (try (lookup-parser (get cgi-data 'parser)) standard-text-analysis))
	 (stripped-string (rewriter marked-word string))
	 (all-keys (parser cgi-data stripped-string))
	 (plus-words
	  (get-roots-too
	   (for-choices (word marked-words)
	     (if (has-prefix "+" word) (subseq word 1) (fail)))
	   language))
	 (minus-words
	  (get-roots-too
	   (for-choices (word marked-words)
	     (if (has-prefix "-" word) (subseq word 1) (fail)))
	   language))
	 (plus-keys (filter-choices (key all-keys)
		      (key-relevant-to? key (qc plus-words) language)))
	 (minus-keys (filter-choices (key all-keys)
		       (key-relevant-to? key (qc minus-words) language))))
    (values (qc (difference all-keys (choice plus-keys minus-keys)))
	    (qc plus-keys) (qc minus-keys))))

(define (key-relevant-to? key words language)
  (let ((slotid (car key)) (slotval (cdr key)))
    (cond ((eq? slotid gn/textkeys) (contains? slotval words))
	  ((eq? slotid gn/xkeys)
	   (or (contains? (car slotval) words)
	       (contains? (cadr slotval) words)))
	  ((eq? slotid gn/noun-phrases)
	   (satisfied? (search words slotval)))
	  ((or (eq? slotid gn/proper-names)  (eq? slotid gn/compound-names))
	   (satisfied? (search words slotval)))
	  ((eq? slotid gn/concepts)
	   (satisfied? (search words (get slotval language))))
	  ((eq? slotid gn/refpoints)
	   (satisfied? (search words (get slotval language))))
	  (else #f))))

;;;; Getting keys from frames

(define (get-frame-features cgi-data)
  (cgi-var frames)
  (generate-features frames))

(define (generate-features frame)
  (let* ((concepts (get frame gn/concepts))
	 (refpoints (get frame gn/refpoints))
	 (refnames (get refpoints english)))
    (choice (cons gn/concepts concepts)
	    (cons gn/refpoints refpoints)
	    (cons gn/noun-phrases
		  (difference (get frame gn/noun-phrases) (get concepts english)))
	    (cons gn/proper-names (difference (get frame gn/proper-names) refnames))
	    (cons gn/xkeys (get frame gn/xkeys))
	    (cons gn/textkeys (get frame gn/textkeys)))))


;;;; Key Expansion

(define (expand-concept-loop concepts by seen)
  (let ((expansion {}))
    (prefetch concepts)
    (do-choices (concept concepts)
      (unless (hashset-get seen concept)
	(hashset-add! seen concept)
	(let ((v (get concept by)))
	  (if (< (choice-size v) 100) (set+! expansion v)))))
    (unless (empty? expansion)
      (expand-concept-loop (qc expansion) (qc by) seen))))

(define (expand-concept concept by)
  (let ((seen (make-hashset)))
    (expand-concept-loop concept (qc =is= by) seen)
    (hashset-elts seen)))

(define (smart-full-expand concept)
  (let ((seen (make-hashset)))
    (if (test concept 'sense-category 'noun.location)
	(expand-concept-loop concept (qc =is= parts) seen)
	(expand-concept-loop concept (qc =is= specls) seen))
    (hashset-elts seen)))

(define (simple-expand concept by)
  (choice concept (get concept =is=) (get concept by)
	  (get  (get concept =is=) by)
	  (get  (get concept by) =is=)))

(define (smart-expand concept)
  (let ((seen (make-hashset)))
    (if (test concept 'sense-category 'noun.location)
	(simple-expand concept parts)
	(simple-expand concept specls))
    (hashset-elts seen)))

(define (expand-key key)
  (cond ((or (eq? (car key) gn/concepts) (eq? (car key) gn/refpoints))
	 (choice key (cons (car key) (smart-expand (cdr key)))))
	((eq? (car key) gn/xkeys)
	 (cons gn/xkeys
	       (let ((language (try (get-language) default-language)))
		 (let ((xkey (cdr key)))
		   (choice (cons (get (?? language (car xkey)) language) (cdr xkey))
			   (cons (car xkey) (get (?? language (cdr xkey)) language)))))))
	(else key)))

;;; Displaying keys

(define (select-keys keys slotid)
  (filter-choices (key keys) (eq? (car key) slotid)))

(define (display-refpoint frame language)
  (let ((longest-name (largest (get frame (choice 'names language)) length)))
    (if (exists? longest-name)
	(anchor frame longest-name)
	frame)))

(define (display-keys keys slotid language cssclass)
  (let ((keys (select-keys (qc keys) slotid)))
    (when (exists? keys)
      (span (style "white-space: nowrap;")
	(span (class "slotid") slotid) (html " &nbsp; ")
	(do-choices (key keys i)
	  (if (> i 0) (html " . "))
	  (let ((value (cdr key)))
	    (span (class cssclass)
	      (cond ((and (pair? value) (string? (car value))
			  (pair? (cdr value)) (string? (cadr value)))
		     (stringout (car value) "-/-" (cadr value) ))
		    ((oid? value) (display-refpoint value language))
		    (else value))))))
      (html " &nbsp;&nbsp; "))))


;;; Top level search responders

(define default-scorefn slot-based-score)

(define (search-header cgi-data scores keys language elapsed)
  (table* (class "pagehead" CELLPADDING 0)
    (TR (td* (class "lefticon" rowspan 3) (gnosys-beingmeta-logo))
	(th* (class "righticon") (helplet "results_doc.html#results_count"))
	(th* (class "lefthead")
	  "Found " (hashtable-size scores) " possible candidates in "
	  (inexact->string elapsed 2) " seconds from "
	  (cond ((exists? (get cgi-data 'querytext)) "the text query")
		((exists? (get cgi-data 'frames)) "the example-based query")
		(else "the literal query")))
	(th (FORM (action "gnosys.fdcgi")
	      (cgipass 'querytext (get cgi-data 'querytext))
	      (cgipass 'keys keys)
	      (submit 'ACTION "Refine"))))
    (TR (th)
	(cond ((exists? (get cgi-data 'querytext))
	       (th* (class "querytext" colspan 2)
		 "&nbsp;&nbsp;&nbsp;" (get cgi-data 'querytext)))
	      ((exists? (get cgi-data 'frames))
	       (cgi-var frames)
	       (th* (class "framelist" colspan 2) (html "defined by ")
		    (do-choices (frame frames) (html frame " ... "))))
	      (else (TH)))
	(TH* (STYLE "font-size: 20pt; font-family: sans-serif;")
	     (anchor "results_doc.html" "Help")))
    (TR (th* (class "righticon") (helplet "results_doc.html#text_analysis"))
	(th* (class "keysummary")
	  (display-keys (qc keys) gn/concepts language "oid")
	  (display-keys (qc keys) gn/refpoints language "oid")
	  (display-keys (qc keys) gn/proper-names language "stringval")
	  (display-keys (qc keys) gn/compound-names language "stringval")
	  (display-keys (qc keys) gn/noun-phrases language "stringval")
	  (display-keys (qc keys) gn/textkeys language "stringval")
	  (let ((other-slotids (difference (car keys) stdslots)))
	    (display-keys (qc keys) other-slotids language "slotval")
	    (html)))
	(th))))

(define (generic-search-responder reqdata)
  (cgi-var maxshow) 
  (let* ((search-start (xtimestamp))
	 (language (try (get-language reqdata) default-language)))
    (multiple-value-bind (scores core-keys expanded-keys)
	(cond ((exists? (get reqdata 'querytext)) (execute-text-search reqdata))
	      ((exists? (get reqdata 'frames)) (execute-frame-search reqdata))
	      ((exists? (get reqdata 'keys)) (execute-key-search reqdata))
	      (else (fail)))
      (let ((search-end (xtimestamp)))
	(notify "Displaying "
		(cond ((exists? (get reqdata 'querytext)) "text-based ")
		      ((exists? (get reqdata 'frames)) "frame-based "))
		"search based on "
		(choice-size core-keys) " core keys and "
		(choice-size expanded-keys) " expanded keys executed in "
		(difftime search-end search-start) " seconds")
	(httpdoc (header 'pragma "no-cache")
	  (title "Search Results") (stylesheet! "gnosys.css")
	  (search-header reqdata scores (qc core-keys) language
			 (difftime search-end search-start))
	  (unless (zero? (hashtable-size scores)) (HR))
	  (unless (zero? (hashtable-size scores))
	    (let ((items (select-to-fit reqdata scores)))
	      (scored-search-displayer reqdata (qc items) (qc core-keys) scores)))
	  ;; (HR) (refine-box reqdata (qc keys) (qc keys) (qc))
	  )))))


;(define (slotsearch-responder reqdata)
;  (let* ((slotids (req-get reqdata 'slotid))
;	 (slotvals (req-get reqdata 'slotvalue)))
;    (lineout "Inside")
;    (httpdoc (title "Items with " slotids " of " slotvals)
;	     (table* (class "pagehead" CELLPADDING 0)
;	       (TR (td* (class "lefticon" rowspan 3) (gnosys-beingmeta-logo))
;		   ;; (th* (class "righticon") (helplet "results_doc.html#results_count"))
;		   (th* (class "lefthead")
;		     "Items with " (br)
;		     (do-choices (slotid slotids) (html slotid "&nbsp;")) (br)
;		     "slots of" (br)
;		     (do-choices (slotval slotvals) (html slotval " "))
;		   (th))))
;	     (bare-search-displayer reqdata (qc (find-frames %background slotids slotvals))))))

(define (execute-key-search cgi-data)
  (let ((keys (get cgi-data 'keys)))
    (multiple-value-bind (scores expanded-keys)
	(dosearch-simple (qc keys) 
			 (try (eval (get cgi-data 'scorefn)) default-scorefn)
			 (qc (eval (get cgi-data 'expanders))))
      (values scores (qc keys) (qc expanded-keys)))))
(define (execute-frame-search cgi-data)
  (let ((keys (get-frame-features cgi-data)))
    (multiple-value-bind (scores expanded-keys)
	(dosearch-simple (qc keys) 
			 (try (eval (get cgi-data 'scorefn)) default-scorefn)
			 (qc (eval (get cgi-data 'expanders))))
      (values scores (qc keys) (qc expanded-keys)))))
(define (execute-text-search cgi-data)
  (multiple-value-bind (keys focus exclude)
      (parse-advanced-querytext cgi-data (get cgi-data 'querytext))
    (multiple-value-bind (scores expanded-keys)
	(dosearch (qc keys) (qc focus) (qc exclude)
		     (try (eval (get cgi-data 'scorefn)) default-scorefn)
		     (qc (eval (get cgi-data 'expanders))))
      (values scores (qc keys) (qc expanded-keys)))))
(define (execute-simple-text-search cgi-data)
  (let ((keys  (parse-querytext cgi-data)))
    (multiple-value-bind (scores expanded-keys)
	(dosearch-simple (qc keys) 
		  (try (eval (get cgi-data 'scorefn)) default-scorefn)
		  (qc (eval (get cgi-data 'expanders))))
      (values scores (qc keys) (qc expanded-keys)))))

;;; Specific search responders

(define (conceptual-search-responder cgi-data)
  (%set! cgi-data 'parser 'concept-parse)
  ; (%set! cgi-data 'expanders 'expand-key)
  (generic-search-responder cgi-data))

(define (hybrid-search-responder cgi-data)
  (%set! cgi-data 'expanders 'expand-key)
  (generic-search-responder cgi-data))

(define (xkey-search-responder cgi-data)
  (%set! cgi-data 'parser 'xkey-parse)
  ; (%set! cgi-data 'expanders 'expand-key)
  (generic-search-responder cgi-data))

(define (stemkey-search-responder cgi-data)
  (%set! cgi-data 'parser 'stemkey-parse)
  (%set! cgi-data 'scorefn 'log-inv-score)
  ; (%set! cgi-data 'expanders 'expand-key)
  (generic-search-responder cgi-data))

;;; Strict searching

(define (slotsearch-responder cgi-data)
  (cgi-var slotid slotvalue)
  (%set! cgi-data 'keys (cons slotid slotvalue))
  (generic-search-responder cgi-data))

(define (keysearch-responder cgi-data)
  (cgi-var keys)
  (drop! cgi-data 'querytext (get cgi-data 'querytext))
  (%set! cgi-data 'keys keys)
  (%set! cgi-data 'expanders 'expand-key)
  (generic-search-responder cgi-data))

(define (expsearch-responder cgi-data)
  (cgi-var slotid value)
  (%set! cgi-data 'keys (cons slotid value))
  (%set! cgi-data 'expanders 'expand-key)
  (generic-search-responder cgi-data))

(define (stringsearch-responder cgi-data)
  (cgi-var slotid) (cgi-init value)
  (%set! cgi-data 'keys (cons slotid value))
  (generic-search-responder cgi-data))

(define (simsearch-responder cgi-data)
  (%set! cgi-data 'expanders 'expand-key)
  (generic-search-responder cgi-data))


;;;; Refine responder

(define (refine-header cgi-data keys)
  (table* (class "pagehead" CELLPADDING 0 WIDTH "100%")
    (TR (td* (class "lefticon" rowspan 2) (gnosys-beingmeta-logo))
	(th* (class "lefthead")
	  "Refining a search with " (choice-size keys) " keys with the text:")
	(th (submit 'ACTION "Refine") (BR)
	    (submit 'ACTION "Search") (BR)
 	    (A* (HREF "results_doc.html"
		      STYLE "font-size: 24pt; font-family: sans-serif;")
		"Help")))
    (TR (th* (class "querytext")
	  (textfield 'querytext 60 (get cgi-data 'querytext)))
	(th (submit 'ACTION "Search")))))

(define (generic-refine-responder cgi-data)
  (cgi-var keys)
  (let* ((language (get-language cgi-data)))
    (multiple-value-bind (textkeys pkeys mkeys)
	(parse-advanced-querytext cgi-data (get cgi-data 'querytext))
      (httpdoc
	(header 'pragma "no-cache") 
	(title "Refining a GNOSYS Search") (stylesheet! "gnosys.css")
	(FORM (ACTION "gnosys.fdcgi")
	  (cgipass 'searchmode 'keysearch)
	  (refine-header cgi-data (qc keys))
	  (TABLE* (WIDTH "80%" ALIGN "CENTER")
	    (refine-display cgi-data (qc keys) (qc textkeys pkeys))))))))

(define (refine-display cgi-data keys new-keys)
  (let* ((all-keys (choice keys new-keys))
	 (language (get-language cgi-data))
	 (all-slots (car all-keys)))
    (index-prefetch content-index all-keys)
    (refine-block cgi-data language gn/refpoints (qc all-keys) (qc keys) "oid")
    (refine-block cgi-data language gn/concepts (qc all-keys) (qc keys) "oid")
    (refine-block cgi-data language gn/proper-names (qc all-keys) (qc keys) "stringval")
    (refine-block cgi-data language gn/noun-phrases (qc all-keys) (qc keys) "stringval")
    (refine-block cgi-data language gn/textkeys (qc all-keys) (qc keys) "stringval")
    (do-choices (slotid (difference all-slots stdslots))
      (refine-block cgi-data language gn/textkeys (qc all-keys) (qc keys)))))

(define (refine-block cgi-data language slotid all-keys active-keys (cssclass "slotval"))
  (let ((keys (filter-choices (key all-keys) (eq? (car key) slotid))))
    (when (exists? keys)
      (TR (TH* (class "slotid") (span (class "slotid") slotid))
	  (TD* (class "slotvalue")
	   (do-choices (key keys i)
	     (if (> i 0) (html " . "))
	     (htmltag 'input 'type 'checkbox 'name 'keys 'value key
		      (if (contains? key active-keys) " CHECKED" ""))
	     (let ((value (cdr key)))
	       (span (class cssclass)
		 (cond ((and (pair? value) (string? (car value))
			     (pair? (cdr value)) (string? (cadr value)))
			(stringout (car value) "-/-" (cadr value) ))
		       ((oid? value) (display-refpoint value language))
		       (else value))))
	     (let ((immediate (index-get (choice content-index (get-concept-index)) key))
		   (indirect (index-get (choice content-index (get-concept-index))
					(expand-key key))))
	       (if (= (choice-size immediate) (choice-size indirect))
		   (html" (" (choice-size immediate) ")")
		 (html" (" (choice-size immediate) "/" (choice-size indirect) ")")))))))))


;;;; Refine boxes

(define (refine-from-frame cgi-data frame)
  (FORM (ACTION "gnosys.fdcgi")
    (cgipass 'searchmode 'keysearch)
    (TABLE* (WIDTH "80%" ALIGN "CENTER")
      (TR (TD* (STYLE "vertical-align: top; text-align: right; white-space: nowrap;")
	    (submit 'action "Refine") (submit 'action "Search"))
	  (TH* (STYLE "vertical-align: top; text-align: left; font-size: 150%;")
	    "Refine a search based on " frame))
      (refine-display cgi-data (qc (generate-features frame)) (qc)))))


;;;; Display responders

(define (display-responder cgi-data)
  (cgi-var doc)
  (httpdoc (header 'pragma "no-cache")
    (title doc ": " (get-doc-title doc))
    (stylesheet! "gnosys.css")
    (TABLE* (class "pagehead")
      (TR (TD* (class "lefticon") (publogo doc))
	  (TH* (class "centerhead")
	       (span (class "title")
		     (get-doc-title doc) (br))
	       (when (exists? (get doc doc/subtitle))
		 (span (class "subtitle") (get-doc-subtitle doc) (br)))
	       (span (class "byline")
		     (let ((namelist (choices->list (get doc 'byline)))
			   (first-one #t))
		       (dolist (staff namelist)
			 (when (test staff 'domain 'staff)
			   (html (unless first-one (html "&nbsp;.&nbsp; "))
				 (set! first-one #f)
				 (anchor staff (get staff 'string)))))))
	       (br) (span (class "sysview")
			  "[" (anchor (scripturl "gnosys.fdcgi"
						 'gnfn 'sysview 'frame doc)
				      "sysview") "]"))
	  (TD* (class "righticon") (gnosys-beingmeta-logo)))
      (pagehead-session-id))
    (TABLE* (CLASS "textdisplay")
      (doseq (paragraph (sorted (get doc doc/contents) 'pnum))
	(TAGGED paragraph
		(TR (TH* (CLASS "ptag")
			 (anchor@ "_new" paragraph (small-diamond)))
		    (if (find #\Newline (get paragraph 'text))
			(TD* (CLASS "ptext")
			     (display-interwoven-text paragraph))
			(TH* (CLASS "phead")
			     (display-interwoven-text paragraph)))))))))


;;;; Browse responders

(define (frame-browser oid)
  (cond ((test oid 'type 'fragment) (display-fragment-page (cgi-data)  oid))
	((test oid 'type 'document) (display-document-page (cgi-data) oid))
	((or (exists? (get oid 'words))
	     (exists? (get oid 'translations)))
	 (display-concept-page (cgi-data) oid))
	;; If we don't recognize it, just use OID->HTML
	(else (httpdoc  (header 'pragma "no-cache")
		(title "Description of " oid)
		(stylesheet! "sysview.css")
		(oid->html oid)))))

(define (browse-fragment frame)
  (prefetch (get frame
		 (choice gn/indoc 'previous 'next '%elt_type
			 '%elt_attrib gn/concepts gn/refpoints)))
  (httpdoc (header 'pragma "no-cache")
	   (title frame ": " (get frame 'obj-name))
	   (stylesheet! "gnosys.css")
	   (TABLE* (class "pagehead")
	     (TR (TD* (class "lefticon") (publogo (get frame gn/indoc)))
		 (TH* (class "centerhead") (limit-string (get frame 'text) 80) (br)
		      (span (class "sysview")
			"[" (anchor (scripturl "gnosys.fdcgi" 'gnfn 'sysview 'frame frame)
				    "sysview") "]"))
		 (TD* (class "righticon") (gnosys-beingmeta-logo)))
	     (pagehead-session-id))
	   (H2 "From "
	       (ANCHOR (scripturl "gnosys.fdcgi" 'gnfn 'display 'doc (get frame gn/indoc))
		       (get-doc-title (get frame gn/indoc)))
	       (when (exists? (get (get frame gn/indoc) gn/indoc))
		 (html "&nbsp;in&nbsp;"
		       (ANCHOR (get (get frame gn/indoc) gn/indoc)
			       (span (class "pubname")
				 (get-doc-title (get (get frame gn/indoc) gn/indoc))))
		       (span (class "pubname"))))
	       " " "[" (anchor (get frame gn/indoc) "breakdown") "]" " "
	       (pretty-timestring (get frame gn/date)))
	   (when (exists? (get frame 'previous))
	     (blockquote* (class "prevtext")
			  (anchor (get frame 'previous)
				  (get (get frame 'previous) 'text))))
	   (blockquote* (class "maintext")
			(when (test frame 'type 'xml-fragment)
			  (span (class "markup")
			    (get frame '%elt_type)
			    (dolist (attrib (get frame '%elt_attribs))
			      (if (pair? attrib)
				  (html  " " (car attrib) "=" (cdr attrib))
				(html " " attrib)))
			    (br)))
			(display-interwoven-text frame))
	   (when (exists? (get frame 'next))
	     (blockquote* (class "nexttext")
			  (anchor (get frame 'next) (get (get frame 'next) 'text))))
	   ;; (refine-from-frame (cgi-data) frame)
	   ))

(define (browse-document doc)
  (httpdoc (header 'pragma "no-cache")
	   (title doc ": " (get doc 'head))
	   (stylesheet! "gnosys.css")
	   (TABLE* (class "pagehead")
	     (TR (TD* (class "lefticon") (publogo doc))
		 (TH* (class "centerhead")
		   (span (class "title")
		     (anchor (scripturl "gnosys.fdcgi" 'gnfn 'display 'doc doc)
			     (get-doc-title doc)) (br))
		   (when (exists? (get doc doc/subtitle))
		     (span (class "subtitle") (get-doc-subtitle doc) (br)))
		   (when (exists? (get doc gn/indoc))
		     (span (class "pub")
		       (anchor (get doc gn/indoc) (get-doc-title (get doc gn/indoc)))))
		   (br) (span (class "sysview")
			  "["
			  (anchor (scripturl "gnosys.fdcgi" 'gnfn 'sysview 'frame doc)
				  "sysview")
			  "]"))
		 (TD* (class "righticon") (gnosys-beingmeta-logo)))
	     (pagehead-session-id))
	   (TABLE* ()
	     (document-slot-entry doc gn/refpoints)
	     (document-slot-entry doc gn/concepts)
	     (document-slot-entry doc gn/proper-names)
	     (document-slot-entry doc gn/noun-phrases)
	     (document-slot-entry doc gn/compound-names)
	     (let ((ordered-contents (sortby 'pnum (get doc doc/contents))))
	       (doseq (paragraph ordered-contents)
		 (TR (TH* (class "pnum") "Paragraph " (get paragraph 'pnum))
		     (TD* (class "psum") paragraph)))))))


;;; Utility functions

(define (limit-string string len)
  (if (< (length string) len) (html string)
    (let ((space-pos (tx-search '(isspace) string len)))
      (if (or (not space-pos) (> space-pos (+ len 10)))
	  (html (subseq string 0 len) (font (color "red") "..."))
	(html (subseq string 0 space-pos) (font (color "red") "..."))))))


(define (document-slot-entry frame slotid (max-values #f))
  (when (exists? (get (get frame doc/contents) slotid))
    (let ((value2fragment (make-hashtable))
	  (value2prominence (make-hashtable))
	  (n-fragments (choice-size (get frame doc/contents))))
      (do-choices (fragment (get frame doc/contents))
	(hashtable-add! value2fragment
			(get fragment slotid)
			fragment))
      (do-choices (value (hashtable-keys value2fragment))
	(let ((fragments (hashtable-get value2fragment value)))
	  (hashtable-set! value2prominence
			  value
			  (cons (choice-size fragments)
				(- n-fragments (get fragments 'pnum))))))
      (let ((sorted-values
	     (reverse (sortby value2prominence
			      (hashtable-keys value2fragment)))))
	(TR (TH* (CLASS "slotid") (anchor slotid (get slotid 'obj-name)))
	    (TD* (CLASS "slotvalue")
		 (doseq (value sorted-values)
		   (unless (= (choice-size (get value2fragment value)) n-fragments)
		     (html (short-value value) "&nbsp;&nbsp;"
			   (doseq (f (sortby 'pnum (get value2fragment value)))
			     (html (anchor f (get f 'pnum)) "&nbsp;"))
			   (html " | "))))))))))




;;;; Editing reference points

(define (concept-editor cgi-data)
  (let ((frame (parse-arg (get cgi-data 'frame)))
	(language (get-language cgi-data))
	(informant (get-informant cgi-data)))
    (httpdoc
      (if (exists? frame)
	  (title "Editing the frame " frame)
	  (title "Creating a new frame"))
      (stylesheet! "gnosys.css")
      (html javascript-refile)
      (FORM (ACTION "gnosys.fdcgi" NAME "fdedit" METHOD "POST")
	    (cgipass 'gnfn 'cedit)
	    (table* (class "edheader" width "100%") ;  BORDER-COLOR "green" BORDER 5
	      (TR (TH* (class "llogo" CELLPADDING 0)
		       (anchor "search.fdcgi" (image "/images/brico_dbg.png" BORDER 0 ALT "BRICO")))
		  (TH* ()
		       (FONT (size "+1")
			     (span (style "font-family: sans-serif; font-size: 18pt;") "editing") (BR)
			     (span (style "color: white; font-family: sans-serif; font-size: 24pt;")
			       (doseq (word (sorted (try (get frame language)
							 (get frame 'words))
						    length) i)
				 (if (= i 0) (html word) (html " . " word))))
			     (br)
			     (anchor frame (get frame 'obj-name)))
		       (br) (em (show-description frame)))
		  (TH* (class "rlogo" CELLPADDING 0)
		       (anchor "/" (image "/images/bm_logo_dbg.png" border 0 ALT "beingmeta"))))
	      (TR (TD* (CLASS "lbuttons")
		       (cond ((exists? frame)
			      (span (class "nobreak")
				    (submit 'action "Refresh")
				    (submit 'action "Revert") (submit 'action "Commit")))
			     (else (span (class "nobreak")
					 (submit 'action "Refresh") (submit 'action "Create")))))
		  (TD* (CLASS "languages")
		       (do-choices (lang (get-languages cgi-data))
			 (span (class "nobreak")
			       (active-radiobutton 'language lang (eq? lang language))
			       (if (eq? lang language)
				   (font (color "red") "&nbsp;" (get lang 'obj-name) " ")
				   (html "&nbsp;" (get lang 'obj-name) " ")))))
		  (TD* (CLASS "rbuttons") "&nbsp;&nbsp;"
		       (cond ((exists? frame)
			      (span (class "nobreak")
				    (submit 'action "Clone") (submit 'action "Refine")))
			     (else (fail))))))
	    (if (exists? frame) (CGIPASS 'frame) "")
	    (TABLE* (CLASS "sloteditor")
		    (string-slot language cgi-data)
		    (unless (eq? language english) (string-slot english cgi-data))
		    (browsed-slot genls cgi-data)
		    (browsed-slot specls cgi-data)
		    (browsed-slot part-of cgi-data)
		    (browsed-slot parts cgi-data)
		    (browsed-slot =is= cgi-data)
		    (parsed-sv-slot 'obj-name cgi-data)
		    (parsed-sv-slot 'sense-category cgi-data)))
      (let ((action (get cgi-data 'action)))
	(cond ((equal? action "Create")
	       (set! frame (frame-create foreground-pool))
	       (%set! cgi-data 'frame frame))
	      ((fail? frame))
	      ((equal? action "Publish") (commit-oid frame))
	      ((equal? action "Revert") (revert-oid frame))
	      ((equal? action "Clone")
	       (set! frame (frame-create foreground-pool))
	       (%set! cgi-data 'frame frame)))
	(commit-all)
	(html)))))

;;; Browsing BRICO

(define beingmeta-text
  "being<font color=red>m<font color=lightgreen>e<font color=blue>t</font></font></font>a")

(define wordnet-source @/brico/0)
(define roget-source @/brico/1)
(define cyc-source @/brico/2)

(define cyc-comment (find-frames brico-index 'cyc-name 'cyc-comment))

(define (get-display-name frame)
  (if (and (exists? (get frame 'obj-name))
	   (string? (get frame 'obj-name)))
      (get frame 'obj-name)
      (let* ((lang (get-language))
	     (strings (try (get frame lang)
			   (get frame 'names)
			   (get frame 'words))))
	(if (exists? strings) (largest (largest strings length))
	    (try (get frame 'obj-name) frame)))))

(define (display-hierarchy name frames slotid seen)
  (do-choices (f frames)
    (hashset-add! seen f)
    (span (class "slotval")
	  (anchor f (get-display-name f))
	  "&nbsp;&nbsp;&nbsp; "))
  (let* ((new-oids (hashset-filter seen (just-oids (get frames slotid))))
	 (v (begin (prefetch new-oids)
		   (filter-choices (oid new-oids)
		     (exists? (get oid 'words))))))
    (unless (empty? v)
      (html " " name " ")
      (display-hierarchy name (qc v) slotid seen))))

(define (display-slot-hierarchy name frame slotid)
  (let* ((values (get frame slotid))
	 (oid-values (just-oids values)))
    (when (exists? values)
      (TR (TH* (valign 'top align 'right) name)
	  (TD* (valign 'top align 'left)
	       (display-hierarchy name (qc oid-values) slotid (make-hashset))
	       (do-choices (v (difference values oid-values))
		 (span (class "slotval") v "&nbsp;&nbsp;&nbsp; ")))))))

(define (pick-n choices n)
  (let ((choices (proper-choice choices)))
    (if (< (choice-size choices) n) choices
	(let* ((selected (make-hashset)))
	  (dotimes (i n)
	    (let ((choice (pick-one choices)))
	      (while (hashset-get selected choice)
		(set! choice (pick-one choices)))
	      (hashset-add! selected choice)))
	  (hashset-elts selected)))))

(define (display-slot-value name frame slotid)
  (when (exists? (get frame slotid))
    (let ((values (get frame slotid)))
      (TR (TH* (valign 'top align 'right) name)
	  (TD* (valign 'top align 'left)
	       (cond ((> (choice-size values) 100)
		      (font (color "Red") "This slot has "
			    (choice-size values)
			    " values.  Here are 20 of them:") (br)
			    (set! values (pick-n (qc values) 20)))
		     (else (html)))
	       ;; Prefetch wrapped in begin so we don't get an {} in the output
	       (begin (prefetch (just-oids values)) (html))
	       (do-choices (f values)
		 (span (class "slotval")
		       (if (frame? f)
			   (anchor f (get-display-name f))
			   (html f))
		       "&nbsp;&nbsp;&nbsp; ")))))))

(define (describe-brico-frame frame)
  (htmldoc (title "Description of " (get frame 'obj-name))
    (stylesheet! "gnosys.css")
    (table* (width "100%")
      (TR (TH* (VALIGN 'TOP ALIGN 'LEFT)
	       (anchor "/brico/index.html"
		       (image "/images/brico-icon.png" border 0 ALT "BRICO")))
	  (TH  (FONT (size "+1")
		     (font (color "BLUE") (get frame 'obj-name))
		     (when (exists? (get-translations frame))
		       (font (color "GREEN") (br)
			     (do-choices (g (get-translations frame))
			       (font (size "-1") " &nbsp; " g)))))
	       (br) (em (show-description frame)))
	  (TH* (VALIGN 'TOP)
	       (anchor "/"
		       (IMAGE "/images/bm_icon.png" BORDER 0 ALT "beingmeta")))))
    (table* (align 'center)
      (TR
       (TH (ANCHOR "/index.html" "[" beingmeta-text "]"))
       (TH (ANCHOR "/brico/index.html" "[Search BRICO]"))
       (TH (ANCHOR "/brico/random.fdcgi" "[Random Frame]"))
       (TH (ANCHOR (index-url "/brico/similar.fdcgi" frame)
		   "[Similar Frame]"))))
    (HR SIZE 10)
    (table* (width "100%" ALIGN 'LEFT)
      (TR (TH* (valign 'top align 'right) "Words")
	  (TD* (VALIGN 'TOP ALIGN 'left)
	       (do-choices (wd (get frame 'words))
		 (anchor (scripturl "/brico/enter.fdcgi" 'KEYS (generate-coloc wd)) wd)
		 (html " &nbsp;&nbsp;&nbsp; "))
	       (do-choices (wd (get-translations frame))
		 (anchor (scripturl "/brico/enter.fdcgi"
				    'KEYS (generate-coloc wd))
			 (font (color "green") wd))
		 (html " &nbsp;&nbsp;&nbsp; "))))
      (display-slot-value "Genzns" frame genls)
      (display-slot-value "Part Of" frame part-of)
      (display-slot-value "Ingredient Of" frame ingredient-of)
      (display-slot-value "Member Of" frame member-of)
      (TR (TH* (valign 'top align 'right) "Description")
	  (TD* (valign 'top align 'left)
	       (strong (try (get frame (amb 'gloss cyc-comment))
			    "No Description"))))
      (display-slot-value "Parts" frame parts)
      (display-slot-value "Ingredients" frame ingredients)
      (display-slot-value "Members" frame members)
      (TR (TH* (valign 'top align 'right) "Related Concepts")
	  (TD* (valign 'top align 'left)
	       (do-choices (r (amb 'wordnet-synsets 'roget-clusters
				   'cyc-concepts))
		 (font (size "-1")
		   (do-choices (f (get frame r))
		     (html f "&nbsp;&nbsp;&nbsp;&nbsp; "))))))
      (do-choices (slot (amb 'antonym 'also-see 'attribute
			     'derived-from 'derivations
			     'cause 'entailment 'similar-to))
	(when (exists? (get frame slot))
	  (TR (TH* (valign 'top align 'right) slot)
	      (TD* (valign 'top align 'left)
		   (font (size "-1") (get frame slot))))))
      (TR (TD* (COLSPAN 2) (HR)))
      (doslots (f slot values frame)
	(TR (TH* (valign 'top align 'right) slot)
	    (TD* (align 'left)
		 (do-results (value values)
		   (html value " &nbsp;&nbsp;&nbsp;&nbsp; "))))))))

(define (show-description f)
  (let ((source (get f 'source)))
    (cond ((eq? source wordnet-source)
	   (try (get f 'gloss) "No description"))
	  ((eq? source cyc-source)
	   (try (get f cyc-comment) "No description"))
	  ((eq? source roget-source) "No description")
	  (else "No Description"))))

(define (generate-coloc word)
  (if (pair? word)
      (let ((out (open-string-stream)))
	(display (car word) out)
	(dolist (elt (cdr word))
	  (display "_" out) (display elt out))
	(string-stream-contents out))
      word))

(define (get-translations frame)
  (cadr (filter-choices (translation (get frame 'translations))
	  (not (eq? (car translation) 'english)))))



;;; Doing key conversions for referrals

(define (alta-vista-referral concepts language)
  (FORM (ACTION "http://www.altavista.com/sites/search/web")
	(cgipass "aqb" (convert-concepts (qc concepts) language "AND"))
	(BUTTON (NAME "pg" VALUE "aq") (IMAGE "/images/AVsmall.gif"))))
(define (google-referral concepts language)
  (FORM (ACTION "http://www.google.com/search")
	(cgipass "hl" (get language 'iso639/1))
	(cgipass "q" (convert-concepts (qc concepts) language "AND"))
	(BUTTON (NAME 'Action VALUE "Find Similar")
		(IMAGE "/images/google_sm.gif" BORDER 0))))

(define (get-all-words concept language)
  (choice (get concept language)
	  (get-all-words (get concept specls) language)))

(define (generate-concept-query stream concept language)
  (let ((words (get-all-words concept language)))
    (display "(" stream)
    (doseq (word (sorted words) i)
      (if (> i 0) (printout-to stream " OR "))
      (printout-to stream "\"" word "\""))
    (display ")" stream)))

(define (convert-concept concept language)
  (let ((stream (open-string-stream)))
    (generate-concept-query stream concept language)
    (string-stream-contents stream)))

(define (convert-concepts concepts language connective)
  (let ((stream (open-string-stream)))
    (display "(" stream)
    (doseq (concept (sorted concepts) i)
      (if (> i 0) (printout-to stream " " connective " "))
      (generate-concept-query stream concept language))
    (display ")" stream)
    (string-stream-contents stream)))

(define (generate-xkey-query stream xkey)
  (printout-to stream "(" (car xkey) " NEAR " (cdr xkey) ")")
  (display "(" stream)
  (doseq (word (sorted words) i)
      (if (= i 0) (printout-to stream "\"" word "\"")
	  (printout-to stream "\"" word "\" OR ")))
    (display ")" stream)
    (string-stream-contents ))

(define (generate-xxkey-query stream xkey language)
  (let ((concepts (?? language (cdr xkey)))
	(synonyms (get concepts language)))
    (printout-to stream "(")
    (doseq (synonym (sorted synonyms) i)
      (printout-to stream "(" (car xkey) " NEAR " synonym ")")
      (if (> i 0) (printout-to stream " " OR " ")))
    (printout-to stream ")")))


;;; Interlingual Concept browsing

(define (words->concepts keywords language)
  (filter-choices (concept (expand-keywords keywords language))
    (concept-ok? concept)))

(define (concept->words concept language)
  (try (get concept language) (get concept 'words)))

(define (expand-keyword keyword language)
  (if (find #\: keyword)
      (let ((split (position #\: keyword))
	    (left (expand-keyword (subseq keyword 0 split) language))
	    (right (expand-keyword (subseq keyword (1+ split)) language)))
	(filter-choices (cand left)
	  (inherits? cand 'hypernym right)))
    (choice (?? language keyword) (?? '{words names} keyword))))

(define (expand-keywords keywords language)
  (expand-keyword (string-trim (elts (segment keywords ","))) language))

;;; Displaying slot values

(define (slot-entry frame slotid)
  (when (exists? (get frame slotid))
    (display-slot-entry slotid (qc (get frame slotid)))))

(define (display-slot-entry slotid values)
  (TR (TH* (CLASS "slotid") slotid)
      (TD* (CLASS "slotvalue")
	   (value-entry slotid (qc values)))))

(define (value-entry slotid values)
  (let ((ordered (reverse (sortby value-length values))))
    (doseq (v ordered i)
      (if (= i 0) (short-value v) (html " | " (short-value v))))))

(define (value-length v)
  (cond ((string? v) (length v))
	((symbol? v) (length (symbol->string v)))
	((oid? v) (value-length (get v 'obj-name)))
	(else (length (write-to-string v)))))

;;; Displaying search entries

(define (slot-search-entry frame slotid (check-all #f))
  (when (exists? (get frame slotid))
    (display-slot-search-entry
     #t slotid (qc (get frame slotid))
     (if check-all (qc (get frame slotid)) (qc)))))

(define (display-slot-search-entry active slotid values checked)
  (cgipass 'keyspace (cons slotid values))
  (TR (TH* (CLASS "slotid")
	   slotid (BR)
	   "ignore&nbsp;" (checkbox 'ignoreslots slotid (not active)) )
      (TD* (CLASS "slotvalue")
	   (value-search-entry slotid (qc values) (qc checked)))))

(define (value-search-entry slotid values checked)
  (let* ((unchecked (difference values checked)))
    (doseq (v (reverse (sortby value-length checked)))
      (span (class "nobreak")
	    (checkbox 'keys (cons slotid v) #t)
	    "&nbsp;" (short-value v) "  "))
    (doseq (v (reverse (sortby value-length unchecked)))
      (span (class "nobreak")
	    (checkbox 'keys (cons slotid v) #f)
	    (html "&nbsp;" (short-value v) "  ")))))

;;; Key-based search entries

(define (get-key-values keys slotid)
  (for-choices (key keys) (if (eq? (car key) slotid) (cdr key) (fail))))

(define (display-search-keys keys keyspace ignoreslots)
  (let* ((active-slotids (difference (car keys) ignoreslots))
	 (inactive-slotids (difference (car keyspace) active-slotids)))
    (do-choices (slotid active-slotids)
      (let ((values (get-key-values (qc keyspace) slotid))
	    (checked (get-key-values (qc keys) slotid)))
	(display-slot-search-entry #t slotid (qc values) (qc checked))))
    (do-choices (slotid (difference inactive-slotids ignoreslots))
      (let ((values (get-key-values (qc keyspace) slotid))
	    (checked (get-key-values (qc keys) slotid)))
	(display-slot-search-entry #t slotid (qc values) (qc checked))))
    (do-choices (slotid (intersection inactive-slotids ignoreslots))
      (let ((values (get-key-values (qc keyspace) slotid))
	    (checked (get-key-values (qc keys) slotid)))
	(display-slot-search-entry #f slotid (qc values) (qc checked))))))

(define (group-weight group)
  (/ (apply + (map score-key (cdr group)))
     (* 1.0 (length group))))

;;; Getting document properties

(define (get-text x)
  (if (string? x) x
    (if (oid? x) (get x 'text)
      (fail))))

(define (get-doc-title doc)
  (try (get-text (get doc doc/title)) 
       (get doc 'obj-name)
       (list '??? doc)))
(define (get-doc-subtitle doc)
  (get-text (get doc doc/subtitle)))

;;;; Ontology editing

(define (drop-word! concept word (language default-language))
  (drop! concept (choice language 'names) word)
  (index-drop! (get-index concept)
	       (cons (choice language 'names) (choice word (stdstring word)))
	       concept)
  ;; Drop the index
  (index-drop! (choice content-index (get-concept-index))
	       (cons gn/concepts concept)
	       (find-frames content-index (choice gn/textkeys gn/noun-phrases) word)))

(define (add-word! concept word (language default-language) (certainym? #f))
  (add! concept language word)
  (index-frame (get-index concept) concept language word)
  (when (capitalized? word)
    (add concept 'names word)
    (index-frame (get-index concept) concept 'names
		 (choice word (stdstring word))))
  (when certainym?
    (add! concept 'certainym (cons language word))
    (index-frame (get-index concept)
		 concept 'certainym (cons language word)))
  (when (or certainym? (find #\Space word))
    (index-frame (get-concept-index)
		 (find-frames content-index
		   (choice gn/textkeys gn/noun-phrases
			   gn/proper-names gn/compound-names)
		   (if (capitalized? word) (choice word (stdstring word))
		     word))
		 (if (capitalized? word) gn/refpoints gn/concepts)
		 concept)))

(define (drop-=is=! concept other)
  (drop! concept =is= other)
  (drop! other =is= concept)
  (index-drop! (get-index other) (cons =is= concept) other)
  (index-drop! (get-index concept) (cons =is= other) concept))

(define (drop-all-=is=! concept )
  (drop-=is=! concept (get concept =is=))
  (drop-=is=! (?? =is= concept) concept))
						      
(define (add-=is=! concept other)
  (add! concept =is= other)
  (add! other =is= concept)
  (index-add! %background (cons =is= concept) other)
  (index-add! %background (cons =is= other) concept))

(define (drop-genl! concept genzn)
  (drop! concept genls genzn)
  (drop! concept specls genzn)
  (index-drop! (get-index genzn) (cons specls concept) genzn)
  (index-drop! (get-index concept) (cons genls genzn) concept))

(define (add-genl! concept genzn)
  (add! concept genls genzn)
  (index-frame (get-index concept) concept genls genzn))

(define (set-genl! concept genzn)
  (let ((to-drop (difference (get concept genls) genzn)))
    (drop-genl! concept to-drop)
    (add-genl! concept genzn)))

(define (iadd! f s v)
  (add! f s v)
  (index-frame (get-index f) f s v))
(define (idrop! f s v)
  (drop! f s v)
  (index-drop! (get-index f) (cons s v) f))
