;;; -*- Mode: Scheme; Character-encoding: utf-8; -*-
;;; Copyright (C) 2005-2020 beingmeta, inc.  All rights reserved.
;;; Copyright (C) 2020-2021 beingmeta, llc.

(in-module 'knodb/countrefs)

(use-module '{logger varconfig kno/mttools kno/reflect})

(module-export! '{countrefs countrefs/vec countrefs/pool})

(defambda (ref-counter object opts freqs (alloids #f))
  (cond ((ambiguous? object)
	 (do-choices (elt object)
	   (cond ((symbol? elt) (table-increment! freqs elt))
		 ((oid? elt) 
		  (table-increment! freqs (oid-base elt))
		  (when alloids (table-increment! freqs elt)))
		 ((not (cons? elt)))
		 ((or (table? elt) (vector? elt) (compound? elt))
		  (ref-counter elt opts freqs alloids)))))
	((symbol? object) (table-increment! freqs object))
	((oid? object)
	 (if alloids (table-increment! freqs object))
	 (table-increment! freqs (oid-base object)))
	((pair? object)
	 (if (proper-list? object)
	     (dolist (elt object)
	       (cond ((symbol? elt) (table-increment! freqs elt))
		     ((oid? elt) 
		      (table-increment! freqs (oid-base elt))
		      (when alloids (table-increment! freqs elt)))
		     ((not (cons? elt)))
		     ((or (table? elt) (vector? elt) (compound? elt))
		      (ref-counter elt opts freqs alloids))))
	     (let ((scan object) (elt #f))
	       (while (pair? scan)
		 (set! elt (car scan))
		 (set! scan (cdr scan))
		 (cond ((symbol? elt) (table-increment! freqs elt))
		       ((oid? elt) 
			(table-increment! freqs (oid-base elt))
			(when alloids (table-increment! freqs elt)))
		       ((not (cons? elt)))
		       ((or (table? elt) (vector? elt) (compound? elt))
			(ref-counter elt opts freqs alloids)))
		 (set! scan (cdr scan))))))
	((or (vector? object) (and (sequence? object) (compound? object)))
	 (doseq (elt object)
	   (cond ((symbol? elt) (table-increment! freqs elt))
		 ((oid? elt) 
		  (table-increment! freqs (oid-base elt))
		  (when alloids (table-increment! freqs elt)))
		 ((not (cons? elt)))
		 ((or (table? elt) (vector? elt) (compound? elt))
		  (ref-counter elt opts freqs alloids)))))
	((table? object)
	 (let ((elt #f))
	   (do-choices (key (getkeys object))
	     (when (symbol? key) (table-increment! freqs key))
	     (when (oid? key)
	       (table-increment! freqs key)
	       (table-increment! freqs (oid-base key)))
	     (set! elt (get object key))
	     (cond ((symbol? elt) (table-increment! freqs elt))
		   ((oid? elt) 
		    (table-increment! freqs (oid-base elt))
		    (when alloids (table-increment! freqs elt)))
		   ((not (cons? elt)))
		   ((or (table? elt) (vector? elt) (compound? elt))
		    (ref-counter elt opts freqs alloids))))))
	(else)))

;;;; Simple countrefs

(defambda (countrefs objects (opts #f) (freqs (make-hashtable)))
  (ref-counter objects opts freqs (getopt opts 'alloids #f)))

;;; Vector countrefs

(define (countrange freqs vec start n opts alloids (elt))
  (dotimes (i n)
    (set! elt (elt vec (+ start i)))
    (ref-counter elt opts freqs alloids)))

(define (countrefs/vec vec (opts #f) (freqs) (nthreads) (alloids))
  (default! freqs (getopt opts 'freqs (make-hashtable)))
  (default! nthreads (mt/threadcount (getopt opts 'nthreads (config 'nthreads #t))))
  (default! alloids (getopt opts 'alloids #f))
  (let* ((n (length vec))
	 (tables {}) (threads {})
	 (batch-size (quotient n nthreads)))
    (dotimes (i nthreads)
      (let ((table (make-hashtable)))
	(set+! threads (thread/call countrange
			   table vec (* i batch-size)
			   (min (- n (* i batch-size)) batch-size)
			   opts alloids))
	(set+! tables table)))
    (thread/wait! threads)
    (do-choices (table tables)
      (do-choices (key (getkeys table))
	(table-increment! freqs key (get table key)))))
  freqs)

;;;; Pool countrefs

(define (countoids freqs pool base n opts alloids (oid))
  (dotimes (i n)
    (set! oid (oid-plus base i))
    (ref-counter (get pool oid) opts freqs alloids)
    (swapout pool oid)))

(define (countrefs/pool pool (opts #f) (freqs) (nthreads) (alloids))
  (default! freqs (getopt opts 'freqs (make-hashtable)))
  (default! nthreads (mt/threadcount (getopt opts 'nthreads (config 'nthreads #t))))
  (default! alloids (getopt opts 'alloids #f))
  (if nthreads
      (let* ((tables {}) (threads {}) 
	     (load (pool-load pool))
	     (batch-size (quotient load nthreads))
	     (base (pool-base pool)))
	(dotimes (i nthreads)
	  (let ((table (make-hashtable)))
	    (set+! threads (thread/call countoids
			       table pool (oid-plus base (* i batch-size))
			       (min (- load (* i batch-size)) batch-size)
			       opts alloids))
	    (set+! tables table)))
	(thread/wait! threads)
	(do-choices (table tables)
	  (do-choices (key (getkeys table))
	    (table-increment! freqs key (get table key)))))
      (countoids freqs pool (pool-base pool) (pool-load pool) opts alloids))
  freqs)

