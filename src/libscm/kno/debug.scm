;;;; -*- Mode: Scheme; -*-

(in-module 'kno/debug)

(use-module '{kno/reflect texttools varconfig text/stringfmts logger})

(module-export! '{debug.command
		  backtrace.command bt.command
		  frame.command f.command
		  env.command args.command arg.command
		  source.command context.command
		  getframe.command getenv.command
		  val.command})

(define-init debug-width 120)
(varconfig! kno:debug:width debug-width)

(define (set-debug! (arg (req/get '_debug #f)))
  (unless arg
    (set! arg (or (req/get '_err #f)
		  (req/get '_debug (req/get '_err #f)))))
  (cond ((not arg)
	 (logwarn |NoException| "No current or past exception to debug!"))
	((req/test '_debug arg))
	(else
	 (logwarn |Debugging| (exception-summary arg) 
		  "\n" (timestamp+ (exception-timebase arg) (exception-moment arg))
		  " (elapsed=" (exception-moment arg) ")"
		  "\nthread #" (exception-threadno arg) " in session " (exception-sessionid arg))
	 (req/set! '_debug arg)
	 (req/set! '_debug_stack (exception-stack arg))
	 (req/set! '_debug_stack_entry (first (exception-stack arg)))))
  arg)

(define (get-stack-frame n)
  (cond ((not n) (req/get '_debug_stack_entry))
	((not (number? n)) (irritant n |BadStackRef|))
	((set-debug!)
	 (let ((stack (req/get '_debug_stack)))
	   (cond ((and (>= n 0) (< n (length stack)))
		  (elt stack (- (length stack) 1 n)))
		 (else (logwarn |BadStackRef| n " is not in [0," (length stack) "]")
		       #f))))
	(else #f)))

(define (debug.command (arg (req/get '_debug (req/get '_err #f))))
  (if arg (set-debug! arg)
      (logwarn |NoError| "Nothing to debug")))

(define (display-stackframe frame (label #f))
  (let ((fcn (stack-function frame))
	(args (stack-args frame))
	(env (stack-env frame)))
    (lineout (if label (printout label " ")) 
      "#" (stack-depth frame) " "
      (if (and (stack-origin frame)
	       (not (equal? (stack-origin frame) (stack-label frame))))
	  (printout (stack-origin frame) "/" (stack-label frame))
	  (printout (stack-label frame)))
      (if (or (applicable? fcn) (special-form? fcn) (macro? fcn))
	  (printout " " (or (procedure-name fcn) fcn)))
      (if (stack-filename frame) (printout " " (write (stack-filename frame))))
      (if args (printout " " ($count (length args) "arg")))
      (if env (printout " binding"
		(do-choices (sym (onerror (picksyms (getkeys env)) {}) i)
		  (printout (if (> i 0) ",") " " sym)))))))

(define (getframe.command (n #f))
  (when (set-debug!)
    (let* ((frame (get-stack-frame n)))
      frame)))
(define (getenv.command (n #f))
  (when (set-debug!)
    (let* ((frame (get-stack-frame n)))
      (and frame (stack-env frame)))))

(define (frame.command (n #f))
  (let* ((frame (get-stack-frame n))
	 (args (stack-args frame))
	 (env (stack-env frame))
	 (source (stack-source frame))
	 (source-string (and source (pprint source #f debug-width "    ")))
	 (annotated (stack-annotated-source frame))
	 (annotated-string (and annotated (pprint annotated #f debug-width " "))))
    (req/set! '_debug_stack_entry frame)
    (lineout "================================================================================")
    (display-stackframe frame)
    (when annotated-string (lineout " " annotated-string))
    (when env (show-env env (not annotated-string)))
    (lineout "    ============================================================================")
    (when source-string (lineout "    " source-string))
    (unless (= (length args) 0)
      (doseq (arg args i) 
	(lineout "      arg" i "( " (if (void? arg) #qvoid (listdata arg)) " )")))
    (lineout "================================================================================")))
(define f.command (fcn/alias frame.command))

(define (source.command (n #f))
  (let ((frame (get-stack-frame n)))
    (req/set! '_debug_stack_entry frame)
    (display-stackframe frame "Source")
    (if (stack-source frame)
	(lineout (void (pprint (stack-source frame) #t stack-width)))
	(logwarn |NoSource| "For stack frame " n))))
(define (context.command (n #f))
  (let ((frame (get-stack-frame n)))
    (req/set! '_debug_stack_entry frame)
    (display-stackframe frame "Source")
    (if (stack-annotated-source frame)
	(lineout (void (pprint (stack-annotated-source frame) #t debug-width)))
	(logwarn |NoSourceContext| "For stack frame " n))))
(define (args.command (n #f))
  (let* ((frame (get-stack-frame n))
	 (args (stack-args frame)))
    (req/set! '_debug_stack_entry frame)
    (display-stackframe frame "Source")
    (unless (= (length args) 0)
      (doseq (arg args i) (lineout "arg" i "\t" (if (void? arg) #qvoid (listdata arg)))))))
(define (env.command (n #f))
  (let* ((frame (get-stack-frame n))
	 (env (stack-env frame)))
    (req/set! '_debug_stack_entry frame)
    (display-stackframe frame "Source")
    (if env
	(show-env env)
	(lineout " No environment in this frame"))))

(define (val.command (sym #f) (n #f))
  (when (string? sym) (set! sym (string->symbol sym)))
  (let* ((frame (get-stack-frame n))
	 (stack (req/get '_debug_stack))
	 (env (stack-env frame))
	 (noresult (deep-copy "noresult"))
	 (result noresult)
	 (depth (length stack))
	 (n (stack-depth frame)))
    (when (and (stack-function frame) (not (stack-env frame)) (> n 0))
      (set! frame (get-stack-frame (-1+ n)))
      (set! n (stack-depth frame)))
    (while (and (>= n 0) (not (stack-function frame)))
      (when (and (stack-env frame) (test (stack-env frame) sym))
	(set! result (get (stack-env frame) sym))
	(break))
      (set! n (-1+ n))
      (set! frame (elt stack (- depth 1 n))))
    (req/set! '_debug_stack_entry frame)
    (display-stackframe frame)
    (if (eq? result noresult)
	(lineout "Variable not found '" sym "'")
	result)))
(define v.command (fcn/alias val.command))

(define (args.command (n #f))
  (let* ((frame (get-stack-frame n))
	 (args (stack-args frame)))
    (req/set! '_debug_stack_entry frame)
    (display-stackframe frame "Source")
    (unless (= (length args) 0)
      (doseq (arg args i) (lineout "arg" i "\t" (if (void? arg) #qvoid (listdata arg)))))))

(define (arg.command (pos #f) (n #f))
  (let* ((frame (get-stack-frame n))
	 (args (stack-args frame)))
    (cond ((not (vector? args)) (lineout "No args in frame"))
	  ((and (number? pos) (> pos 0) (< pos (length args)))
	   (elt args pos))
	  (else (lineout "Invalid position '" pos " given " (length args) " arguments")))))

(define (show-env env (header))
  (let ((vars (getkeys env)))
    (when header (lineout ($count (|| vars) "binding") ":"))
    (do-choices (key vars)
      (if (void? key)
	  (lineout "unitialized binding")
	  (if (symbol? key)
	      (let* ((val (get env key))
		     (string (if (void? val) "#qvoid" (stringout (write val)))))
		(cond ((and (not (multiline-string? string)) (< (length string) 45))
		       (lineout "   " key "=\t" string))
		      ((ambiguous? val)
		       (lineout "   " key "=")
		       (do-choices (v val)
			 (lineout "    "
			   (indent-text (stringout (listdata v)) 4))))
		      (else
		       (lineout "   " key "=")
		       (lineout "  "
			 (indent-text (stringout (listdata val)) 2)))))
	      (lineout " uninitialized binding"))))))

(define (backtrace.command (n #f) (base 0))
  (when (set-debug!)
    (let* ((stack (req/get '_debug_stack))
	   (depth (length stack)))
      (if (>= base depth)
	  (logwarn |StackRangeError|
	    "The specified start frame " base " is beyond the end of the stack")
	  (doseq (frame (reverse (slice stack base (and n (+ base (min n depth))))))
	    (display-stackframe frame))))))
(define bt.command (fcn/alias backtrace.command))
