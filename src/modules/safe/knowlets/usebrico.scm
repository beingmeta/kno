(in-module 'knowlets/usebrico)

(use-module '{texttools knowlets brico brico/lookup brico/dterms})

(module-export! '{brico->kno kno/usebrico})

;;;; Resolving references

(define serial 0)

(define (get-unique-id base knowlet)
  (let ((dterms (knowlet-dterms knowlet)))
    (do ((i 1 (1+ i)))
	((fail? (get dterms (stringout base "(" i ")")))
	 (stringout base "(" i ")")))))

(defambda (brico->kno bf knowlet (create #f))
  (try (find-frames (knowlet-index knowlet) 'oid bf)
       (?? 'oid bf 'knowlet (knowlet-oid knowlet))
       (tryif create
	      (let* ((language (knowlet-language knowlet))
		     (langframe (get language-map language))
		     (dterm (pick-one (get-dterm bf langframe)))
		     (kf (kno/dterm
			  (try (or dterm {})
			       (get-unique-id (get-norm bf language)
					      knowlet))
			  knowlet)))
		(when (ambiguous? bf)
		  (add! kf 'dterms (get-dterm bf language))
		  (add! (knowlet-index knowlet)
			(cons 'dterms (get-dterm bf language))
			kf))
		(unless (eq? language 'en)
		  (add! kf 'dterms (cons 'en (get-dterm bf @?en)))
		  (add! (knowlet-index knowlet)
			(cons 'dterms (cons 'en (get-dterm bf language)))
			kf))
		(when (fail? dterm)
		  (warning "Can't get DTERM for " bf))
		(add! kf 'oid bf)
		(add! (knowlet-index knowlet) (cons 'oid bf) kf)
		(store! kf 'gloss (get-gloss bf (get language-map language)))
		(store! kf 'en (get-norm bf @?en))
		(add! (knowlet-index knowlet)
		      (cons 'en (get-norm bf @?en))
		      kf)
		(store! kf language (get bf (get language-map language)))
		(add! (knowlet-index knowlet)
		      (cons (knowlet-language knowlet)
			    (get-norm bf  (get language-map language)))
		      kf)
		kf))))

(define (brico->kno* bf knowlet (visits (make-hashset)))
  (try (find-frames (knowlet-index knowlet) 'oid bf)
       (?? 'oid bf 'knowlet (knowlet-oid knowlet))
       (let* ((always (get bf @?always)))
	 (hashset-add! visits bf)
	 (brico->kno* (reject always visits) knowlet visits))))

;;; Copying information from brico

(define usebrico-defaults
  '#{})

(define (kno/usebrico (kf #f) (bf #f) (slotids usebrico-defaults))
  (when (or kf bf)
    (when (not kf)
      (set! kf (find-frames (knowlet-index default-knowlet)
		 'oid bf)))
    (when (not bf) (set! bf (get kf 'oid)))
    (when (overlaps? slotid 'languages)
      (set+! slotids langids))
    (let* ((knowlet (get knowlets (get kf 'knowlet)))
	   (knolang (knowlet-language knowlet))
	   (languages (intersection slotids langids)))
      (if (and (test bf 'gloss) (eq? knolang 'en) (not (test kf 'gloss)))
	  (store! kf 'gloss (get bf 'gloss))
	  (store! kf 'gloss (get-single-gloss bf knolang)))
      (do-choices (lang languages)
	(add! kf lang (get bf (get lang-map lang)))
	(if (eq? lang knolang)
	    (add! kf 'norms (get-norm bf lang))
	    (add! kf 'norms (cons (get lang 'key) (get-norm bf lang))))
	(if (eq? lang knolang)
	    (add! kf 'glosses (get bf (get gloss-map lang)))
	    (add! kf 'glosses
		  (cons (get lang 'key) (get bf (get gloss-map lang)))))
	(if (eq? lang nolang)
	    (add! kf 'hooks (get bf (get index-map lang)))
	    (add! kf 'glosses
		  (cons (get lang 'key)
			(get bf (get index-map lang))))))
      (unless (test bf 'sensecat '{noun.tops verb.tops})
	(kno/add! kf 'genls (brico->kno (get bf {@?always @?commonly})))
	(kno/add! kf 'commonly (brico->kno (get bf @?commonly)))
	(kno/add! kf 'sometimes (brico->kno (get bf @?sometimes))))
      (kno/add! kf 'never (brico->kno (get bf @?never)))
      (kno/add! kf 'rarely (brico->kno (get bf @?rarely)))
      (kno/add! kf 'somenot (brico->kno (get bf @?somenot)))
      (when (test bf 'country)
	(kno/add! kf (kno/dterm "country" knowlet)
		  (brico->kno (get bf 'country) #t)))
      (when (test bf 'region)
	(kno/add! kf (kno/dterm "region" knowlet)
		  (brico->kno (get bf 'region) #t)))
      (when (test bf @?ingredients)
	(kno/add! kf (kno/dterm "ingredient" knowlet)
		  (brico->kno (get bf @?ingredients) #t)))
      (when (test bf @?memberof)
	(kno/add! kf (kno/dterm "group" knowlet)
		  (brico->kno (get bf @?memberof) #t)))
      (when (test bf @?partof)
	(kno/add! kf (kno/dterm "assemblage" knowlet)
		  (brico->kno (get bf @?memberof) #t)))
      (do-choices (role (pick (pickoids (getkeys bf)) 'sensecat))
	(do-choices (v (pickoids (%get bf role)))
	  (kno/add! kf (brico->kno role #t) (brico->kno v #t))))
      kf)))



