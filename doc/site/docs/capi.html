<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<meta name="generator" content=
"HTML Tidy for HTML5 for Linux version 4.9.27">
<title>FramerD Kernel APIs</title>
<link rel="stylesheet" type="text/css" href=
"/static/framerd/documentation.css">
</head>
<body>
<h1>FramerD Kernel APIs</h1>
<p>Automatically Generated by etc/build-api-doc.fdx at
2002-06-26T14:58:37.044382-4:00</p>
<h2>Summary</h2>
<table width="100%">
<tr>
<th valign="top" align="left"><a href=
"#hash.c"><tt>src/cons/hash.c</tt></a></th>
<td valign="top" align="left"><a href=
"#_fd_hashset_add_nc"><tt style=
"font-size: small;">_fd_hashset_add_nc</tt></a> | <a href=
"#_fd_hashtable_set_nolock"><tt style=
"font-size: small;">_fd_hashtable_set_nolock</tt></a> | <a href=
"#_fd_set_symbol_value_noref"><tt style=
"font-size: small;">_fd_set_symbol_value_noref</tt></a> | <a href=
"#_fd_symbol_value_noref"><tt style=
"font-size: small;">_fd_symbol_value_noref</tt></a> | <a href=
"#fd_choice_to_hashset"><tt style=
"font-size: small;">fd_choice_to_hashset</tt></a> | <a href=
"#fd_cleanup_locked_hashtable"><tt style=
"font-size: small;">fd_cleanup_locked_hashtable</tt></a> | <a href=
"#fd_final_hashset_elts"><tt style=
"font-size: small;">fd_final_hashset_elts</tt></a> | <a href=
"#fd_for_all_symbols"><tt style=
"font-size: small;">fd_for_all_symbols</tt></a> | <a href=
"#fd_free_hashset"><tt style=
"font-size: small;">fd_free_hashset</tt></a> | <a href=
"#fd_free_hashtable"><tt style=
"font-size: small;">fd_free_hashtable</tt></a> | <a href=
"#fd_grow_hashset"><tt style=
"font-size: small;">fd_grow_hashset</tt></a> | <a href=
"#fd_grow_hashtable"><tt style=
"font-size: small;">fd_grow_hashtable</tt></a> | <a href=
"#fd_hash_lisp"><tt style="font-size: small;">fd_hash_lisp</tt></a>
| <a href="#fd_hashset_add"><tt style=
"font-size: small;">fd_hashset_add</tt></a> | <a href=
"#fd_hashset_drop"><tt style=
"font-size: small;">fd_hashset_drop</tt></a> | <a href=
"#fd_hashset_elts"><tt style=
"font-size: small;">fd_hashset_elts</tt></a> | <a href=
"#fd_hashset_get"><tt style=
"font-size: small;">fd_hashset_get</tt></a> | <a href=
"#fd_hashset_intern"><tt style=
"font-size: small;">fd_hashset_intern</tt></a> | <a href=
"#fd_hashset_probe"><tt style=
"font-size: small;">fd_hashset_probe</tt></a> | <a href=
"#fd_hashset_strget"><tt style=
"font-size: small;">fd_hashset_strget</tt></a> | <a href=
"#fd_hashtable_add"><tt style=
"font-size: small;">fd_hashtable_add</tt></a> | <a href=
"#fd_hashtable_drop"><tt style=
"font-size: small;">fd_hashtable_drop</tt></a> | <a href=
"#fd_hashtable_get"><tt style=
"font-size: small;">fd_hashtable_get</tt></a> | <a href=
"#fd_hashtable_increment"><tt style=
"font-size: small;">fd_hashtable_increment</tt></a> | <a href=
"#fd_hashtable_increment_existing"><tt style=
"font-size: small;">fd_hashtable_increment_existing</tt></a> |
<a href="#fd_hashtable_max"><tt style=
"font-size: small;">fd_hashtable_max</tt></a> | <a href=
"#fd_hashtable_probe"><tt style=
"font-size: small;">fd_hashtable_probe</tt></a> | <a href=
"#fd_hashtable_set"><tt style=
"font-size: small;">fd_hashtable_set</tt></a> | <a href=
"#fd_hashtable_skim"><tt style=
"font-size: small;">fd_hashtable_skim</tt></a> | <a href=
"#fd_hashtable_test"><tt style=
"font-size: small;">fd_hashtable_test</tt></a> | <a href=
"#fd_hashtable_zap"><tt style=
"font-size: small;">fd_hashtable_zap</tt></a> | <a href=
"#fd_init_hashset"><tt style=
"font-size: small;">fd_init_hashset</tt></a> | <a href=
"#fd_init_hashtable"><tt style=
"font-size: small;">fd_init_hashtable</tt></a> | <a href=
"#fd_intern"><tt style="font-size: small;">fd_intern</tt></a> |
<a href="#fd_make_hashset"><tt style=
"font-size: small;">fd_make_hashset</tt></a> | <a href=
"#fd_make_hashtable"><tt style=
"font-size: small;">fd_make_hashtable</tt></a> | <a href=
"#fd_make_qstring"><tt style=
"font-size: small;">fd_make_qstring</tt></a> | <a href=
"#fd_make_symbol"><tt style=
"font-size: small;">fd_make_symbol</tt></a> | <a href=
"#fd_probe_symbol"><tt style=
"font-size: small;">fd_probe_symbol</tt></a> | <a href=
"#fd_reinit_hashset"><tt style=
"font-size: small;">fd_reinit_hashset</tt></a> | <a href=
"#fd_reinit_hashtable"><tt style=
"font-size: small;">fd_reinit_hashtable</tt></a> | <a href=
"#fd_select_table_size"><tt style=
"font-size: small;">fd_select_table_size</tt></a> | <a href=
"#fd_set_symbol_value"><tt style=
"font-size: small;">fd_set_symbol_value</tt></a> | <a href=
"#fd_symbol_value"><tt style=
"font-size: small;">fd_symbol_value</tt></a> |</td>
</tr>
<tr>
<th valign="top" align="left"><a href=
"#file-index.c"><tt>src/index/file-index.c</tt></a></th>
<td valign="top" align="left"><a href=
"#fd_dtype_compare"><tt style="font-size: small;">fd_dtype_compare</tt></a>
| <a href="#fd_file_index_collect_values"><tt style=
"font-size: small;">fd_file_index_collect_values</tt></a> |
<a href="#fd_index_report_stats"><tt style=
"font-size: small;">fd_index_report_stats</tt></a> | <a href=
"#fd_preload_file_index"><tt style=
"font-size: small;">fd_preload_file_index</tt></a> | <a href=
"#fd_register_file_index_opener"><tt style=
"font-size: small;">fd_register_file_index_opener</tt></a> |
<a href="#fd_unpreload_file_index"><tt style=
"font-size: small;">fd_unpreload_file_index</tt></a> | <a href=
"#object"><tt style="font-size: small;">object</tt></a> |</td>
</tr>
<tr>
<th valign="top" align="left"><a href=
"#data.c"><tt>src/cons/data.c</tt></a></th>
<td valign="top" align="left"><a href="#FD_MAKE_LIST"><tt style=
"font-size: small;">FD_MAKE_LIST</tt></a> | <a href=
"#_FD_MAKE_LIST1"><tt style=
"font-size: small;">_FD_MAKE_LIST1</tt></a> | <a href=
"#_FD_MAKE_PAIR"><tt style=
"font-size: small;">_FD_MAKE_PAIR</tt></a> | <a href=
"#_fd_copy_lisp_proc"><tt style=
"font-size: small;">_fd_copy_lisp_proc</tt></a> | <a href=
"#_fd_decref_cons"><tt style=
"font-size: small;">_fd_decref_cons</tt></a> | <a href=
"#_fd_incref_cons"><tt style=
"font-size: small;">_fd_incref_cons</tt></a> | <a href=
"#fd_copy_string"><tt style=
"font-size: small;">fd_copy_string</tt></a> | <a href=
"#fd_for_elts"><tt style="font-size: small;">fd_for_elts</tt></a> |
<a href="#fd_free_proc"><tt style=
"font-size: small;">fd_free_proc</tt></a> | <a href=
"#fd_get_big_buffer"><tt style=
"font-size: small;">fd_get_big_buffer</tt></a> | <a href=
"#fd_init_string"><tt style=
"font-size: small;">fd_init_string</tt></a> | <a href=
"#fd_init_vector"><tt style=
"font-size: small;">fd_init_vector</tt></a> | <a href=
"#fd_lisp_equal"><tt style=
"font-size: small;">fd_lisp_equal</tt></a> | <a href=
"#fd_list_length"><tt style=
"font-size: small;">fd_list_length</tt></a> | <a href=
"#fd_lookup_compound"><tt style=
"font-size: small;">fd_lookup_compound</tt></a> | <a href=
"#fd_lookup_package_code"><tt style=
"font-size: small;">fd_lookup_package_code</tt></a> | <a href=
"#fd_lookup_record"><tt style=
"font-size: small;">fd_lookup_record</tt></a> | <a href=
"#fd_lower_string"><tt style=
"font-size: small;">fd_lower_string</tt></a> | <a href=
"#fd_make_character"><tt style=
"font-size: small;">fd_make_character</tt></a> | <a href=
"#fd_make_cptr"><tt style="font-size: small;">fd_make_cptr</tt></a>
| <a href="#fd_make_lrecord"><tt style=
"font-size: small;">fd_make_lrecord</tt></a> | <a href=
"#fd_make_pair"><tt style="font-size: small;">fd_make_pair</tt></a>
| <a href="#fd_make_record"><tt style=
"font-size: small;">fd_make_record</tt></a> | <a href=
"#fd_make_string"><tt style=
"font-size: small;">fd_make_string</tt></a> | <a href=
"#fd_make_substring"><tt style=
"font-size: small;">fd_make_substring</tt></a> | <a href=
"#fd_make_vector"><tt style=
"font-size: small;">fd_make_vector</tt></a> | <a href=
"#fd_memberp"><tt style="font-size: small;">fd_memberp</tt></a> |
<a href="#fd_register_record"><tt style=
"font-size: small;">fd_register_record</tt></a> | <a href=
"#fd_register_source_file"><tt style=
"font-size: small;">fd_register_source_file</tt></a> | <a href=
"#fd_register_typecode"><tt style=
"font-size: small;">fd_register_typecode</tt></a> | <a href=
"#fd_stream_string"><tt style=
"font-size: small;">fd_stream_string</tt></a> | <a href=
"#fd_utf8_string_ref"><tt style=
"font-size: small;">fd_utf8_string_ref</tt></a> | <a href=
"#fd_utf8_strlen"><tt style=
"font-size: small;">fd_utf8_strlen</tt></a> | <a href=
"#fd_utf8_substring"><tt style=
"font-size: small;">fd_utf8_substring</tt></a> |</td>
</tr>
<tr>
<th valign="top" align="left"><a href=
"#index.c"><tt>src/index/index.c</tt></a></th>
<td valign="top" align="left"><a href="#fd_close_index"><tt style=
"font-size: small;">fd_close_index</tt></a> | <a href=
"#fd_commit_index"><tt style=
"font-size: small;">fd_commit_index</tt></a> | <a href=
"#fd_find_index"><tt style=
"font-size: small;">fd_find_index</tt></a> | <a href=
"#fd_for_indices"><tt style=
"font-size: small;">fd_for_indices</tt></a> | <a href=
"#fd_index_add"><tt style="font-size: small;">fd_index_add</tt></a>
| <a href="#fd_index_drop"><tt style=
"font-size: small;">fd_index_drop</tt></a> | <a href=
"#fd_index_get"><tt style="font-size: small;">fd_index_get</tt></a>
| <a href="#fd_index_get_size"><tt style=
"font-size: small;">fd_index_get_size</tt></a> | <a href=
"#fd_index_keys"><tt style=
"font-size: small;">fd_index_keys</tt></a> | <a href=
"#fd_index_prefetch"><tt style=
"font-size: small;">fd_index_prefetch</tt></a> | <a href=
"#fd_index_set"><tt style="font-size: small;">fd_index_set</tt></a>
| <a href="#fd_index_set_sizes"><tt style=
"font-size: small;">fd_index_set_sizes</tt></a> | <a href=
"#fd_intern_index_values"><tt style=
"font-size: small;">fd_intern_index_values</tt></a> | <a href=
"#fd_interpret_index"><tt style=
"font-size: small;">fd_interpret_index</tt></a> | <a href=
"#fd_revert_index"><tt style=
"font-size: small;">fd_revert_index</tt></a> | <a href=
"#fd_set_index_zipf_threshold"><tt style=
"font-size: small;">fd_set_index_zipf_threshold</tt></a> | <a href=
"#fd_swap_out_index"><tt style=
"font-size: small;">fd_swap_out_index</tt></a> | <a href=
"#fd_use_index"><tt style="font-size: small;">fd_use_index</tt></a>
|</td>
</tr>
<tr>
<th valign="top" align="left"><a href=
"#fdprintf.c"><tt>src/os/fdprintf.c</tt></a></th>
<td valign="top" align="left"><a href=
"#_fd_grow_string_stream"><tt style=
"font-size: small;">_fd_grow_string_stream</tt></a> | <a href=
"#_fd_sputc"><tt style="font-size: small;">_fd_sputc</tt></a> |
<a href="#_fd_sputn"><tt style=
"font-size: small;">_fd_sputn</tt></a> | <a href=
"#_fd_sputs"><tt style="font-size: small;">_fd_sputs</tt></a> |
<a href="#fd_default_notifier"><tt style=
"font-size: small;">fd_default_notifier</tt></a> | <a href=
"#fd_fprintf"><tt style="font-size: small;">fd_fprintf</tt></a> |
<a href="#fd_notify"><tt style=
"font-size: small;">fd_notify</tt></a> | <a href=
"#fd_printf"><tt style="font-size: small;">fd_printf</tt></a> |
<a href="#fd_set_notify_handler"><tt style=
"font-size: small;">fd_set_notify_handler</tt></a> | <a href=
"#fd_set_warn_handler"><tt style=
"font-size: small;">fd_set_warn_handler</tt></a> | <a href=
"#fd_warn"><tt style="font-size: small;">fd_warn</tt></a> |
<a href="#fd_xprintf"><tt style=
"font-size: small;">fd_xprintf</tt></a> |</td>
</tr>
<tr>
<th valign="top" align="left"><a href=
"#network-index.c"><tt>src/index/network-index.c</tt></a></th>
<td valign="top" align="left"><a href=
"#fd_use_network_index"><tt style=
"font-size: small;">fd_use_network_index</tt></a> |</td>
</tr>
<tr>
<th valign="top" align="left"><a href=
"#sandbox.c"><tt>src/eval/sandbox.c</tt></a></th>
<td valign="top" align="left"><a href=
"#fd_add_restricted_cproc"><tt style=
"font-size: small;">fd_add_restricted_cproc</tt></a> | <a href=
"#fd_add_restricted_lexpr"><tt style=
"font-size: small;">fd_add_restricted_lexpr</tt></a> | <a href=
"#fd_add_restricted_special_form"><tt style=
"font-size: small;">fd_add_restricted_special_form</tt></a> |</td>
</tr>
<tr>
<th valign="top" align="left"><a href=
"#mime.c"><tt>src/text/mime.c</tt></a></th>
<td valign="top" align="left"><a href="#fd_parse_mime"><tt style=
"font-size: small;">fd_parse_mime</tt></a> |</td>
</tr>
<tr>
<th valign="top" align="left"><a href=
"#text.c"><tt>src/text/text.c</tt></a></th>
<td valign="top" align="left"><a href="#fd_text_subst"><tt style=
"font-size: small;">fd_text_subst</tt></a> |</td>
</tr>
<tr>
<th valign="top" align="left"><a href=
"#htmlgen.c"><tt>src/text/htmlgen.c</tt></a></th>
<td valign="top" align="left"><a href="#fd_http_puts"><tt style=
"font-size: small;">fd_http_puts</tt></a> | <a href=
"#fd_http_write_bytes"><tt style=
"font-size: small;">fd_http_write_bytes</tt></a> | <a href=
"#fd_set_http_output_methods"><tt style=
"font-size: small;">fd_set_http_output_methods</tt></a> | <a href=
"#fd_start_http"><tt style=
"font-size: small;">fd_start_http</tt></a> | <a href=
"#fd_start_http_output"><tt style=
"font-size: small;">fd_start_http_output</tt></a> | <a href=
"#fd_unparse_xml"><tt style=
"font-size: small;">fd_unparse_xml</tt></a> |</td>
</tr>
<tr>
<th valign="top" align="left"><a href=
"#network-pool.c"><tt>src/odb/network-pool.c</tt></a></th>
<td valign="top" align="left"><a href=
"#fd_use_network_pool"><tt style=
"font-size: small;">fd_use_network_pool</tt></a> |</td>
</tr>
<tr>
<th valign="top" align="left"><a href=
"#pools.c"><tt>src/odb/pools.c</tt></a></th>
<td valign="top" align="left"><a href="#fd_commit_pool"><tt style=
"font-size: small;">fd_commit_pool</tt></a> | <a href=
"#fd_find_pool_named"><tt style=
"font-size: small;">fd_find_pool_named</tt></a> | <a href=
"#fd_for_pools"><tt style="font-size: small;">fd_for_pools</tt></a>
| <a href="#fd_get_pool"><tt style=
"font-size: small;">fd_get_pool</tt></a> | <a href=
"#fd_interpret_pool"><tt style=
"font-size: small;">fd_interpret_pool</tt></a> | <a href=
"#fd_locate_pool"><tt style=
"font-size: small;">fd_locate_pool</tt></a> | <a href=
"#fd_pool_load"><tt style="font-size: small;">fd_pool_load</tt></a>
| <a href="#fd_random_oid"><tt style=
"font-size: small;">fd_random_oid</tt></a> | <a href=
"#fd_register_pool"><tt style=
"font-size: small;">fd_register_pool</tt></a> | <a href=
"#fd_set_oid_locator"><tt style=
"font-size: small;">fd_set_oid_locator</tt></a> | <a href=
"#fd_use_pool"><tt style="font-size: small;">fd_use_pool</tt></a>
|</td>
</tr>
<tr>
<th valign="top" align="left"><a href=
"#stem.c"><tt>src/text/stem.c</tt></a></th>
<td valign="top" align="left"><a href=
"#fd_stem_english_word"><tt style=
"font-size: small;">fd_stem_english_word</tt></a> |</td>
</tr>
<tr>
<th valign="top" align="left"><a href=
"#xdata.c"><tt>src/cons/xdata.c</tt></a></th>
<td valign="top" align="left"><a href=
"#fd_alist_to_hashtable"><tt style=
"font-size: small;">fd_alist_to_hashtable</tt></a> | <a href=
"#fd_compare_cptrs"><tt style=
"font-size: small;">fd_compare_cptrs</tt></a> | <a href=
"#fd_cons"><tt style="font-size: small;">fd_cons</tt></a> |
<a href="#fd_copy_cptr"><tt style=
"font-size: small;">fd_copy_cptr</tt></a> | <a href=
"#fd_hashtable_to_alist"><tt style=
"font-size: small;">fd_hashtable_to_alist</tt></a> | <a href=
"#fd_lisp_hashset_elts"><tt style=
"font-size: small;">fd_lisp_hashset_elts</tt></a> | <a href=
"#fd_make_complex"><tt style=
"font-size: small;">fd_make_complex</tt></a> | <a href=
"#fd_make_double_vector"><tt style=
"font-size: small;">fd_make_double_vector</tt></a> | <a href=
"#fd_make_error"><tt style=
"font-size: small;">fd_make_error</tt></a> | <a href=
"#fd_make_exception"><tt style=
"font-size: small;">fd_make_exception</tt></a> | <a href=
"#fd_make_float_vector"><tt style=
"font-size: small;">fd_make_float_vector</tt></a> | <a href=
"#fd_make_flonum"><tt style=
"font-size: small;">fd_make_flonum</tt></a> | <a href=
"#fd_make_hashset_for_lisp"><tt style=
"font-size: small;">fd_make_hashset_for_lisp</tt></a> | <a href=
"#fd_make_hashtable_for_lisp"><tt style=
"font-size: small;">fd_make_hashtable_for_lisp</tt></a> | <a href=
"#fd_make_int_vector"><tt style=
"font-size: small;">fd_make_int_vector</tt></a> | <a href=
"#fd_make_packet"><tt style=
"font-size: small;">fd_make_packet</tt></a> | <a href=
"#fd_make_rational"><tt style=
"font-size: small;">fd_make_rational</tt></a> | <a href=
"#fd_make_short_vector"><tt style=
"font-size: small;">fd_make_short_vector</tt></a> | <a href=
"#fd_make_timestamp"><tt style=
"font-size: small;">fd_make_timestamp</tt></a> | <a href=
"#fd_make_xtimestamp"><tt style=
"font-size: small;">fd_make_xtimestamp</tt></a> | <a href=
"#fd_parse_packet"><tt style=
"font-size: small;">fd_parse_packet</tt></a> | <a href=
"#fd_quote_lisp"><tt style=
"font-size: small;">fd_quote_lisp</tt></a> |</td>
</tr>
<tr>
<th valign="top" align="left"><a href=
"#timefns.c"><tt>src/os/timefns.c</tt></a></th>
<td valign="top" align="left"><a href="#fd_breakup_time"><tt style=
"font-size: small;">fd_breakup_time</tt></a> | <a href=
"#fd_get_now"><tt style="font-size: small;">fd_get_now</tt></a> |
<a href="#fd_init_xtime"><tt style=
"font-size: small;">fd_init_xtime</tt></a> | <a href=
"#fd_iso8601_to_xtime"><tt style=
"font-size: small;">fd_iso8601_to_xtime</tt></a> | <a href=
"#fd_localtime"><tt style="font-size: small;">fd_localtime</tt></a>
| <a href="#fd_mktime"><tt style=
"font-size: small;">fd_mktime</tt></a> | <a href=
"#fd_parse_iso8601"><tt style=
"font-size: small;">fd_parse_iso8601</tt></a> | <a href=
"#fd_parse_tzspec"><tt style=
"font-size: small;">fd_parse_tzspec</tt></a> | <a href=
"#fd_sleep"><tt style="font-size: small;">fd_sleep</tt></a> |
<a href="#fd_timestamp_time"><tt style=
"font-size: small;">fd_timestamp_time</tt></a> | <a href=
"#fd_timestamp_to_xtime"><tt style=
"font-size: small;">fd_timestamp_to_xtime</tt></a> | <a href=
"#fd_xtime_to_iso8601"><tt style=
"font-size: small;">fd_xtime_to_iso8601</tt></a> | <a href=
"#fd_xtime_to_timestamp"><tt style=
"font-size: small;">fd_xtime_to_timestamp</tt></a> |</td>
</tr>
<tr>
<th valign="top" align="left"><a href=
"#consed-oids.c"><tt>src/cons/consed-oids.c</tt></a></th>
<td valign="top" align="left"><a href="#_fd_not_an_oid"><tt style=
"font-size: small;">_fd_not_an_oid</tt></a> | <a href=
"#fd_grow_oid_table"><tt style=
"font-size: small;">fd_grow_oid_table</tt></a> | <a href=
"#fd_make_oid"><tt style="font-size: small;">fd_make_oid</tt></a> |
<a href="#fd_probe_oid"><tt style=
"font-size: small;">fd_probe_oid</tt></a> |</td>
</tr>
<tr>
<th valign="top" align="left"><a href=
"#load.c"><tt>src/eval/load.c</tt></a></th>
<td valign="top" align="left"><a href="#fd_get_module"><tt style=
"font-size: small;">fd_get_module</tt></a> | <a href=
"#fd_load_file"><tt style="font-size: small;">fd_load_file</tt></a>
| <a href="#fd_load_library"><tt style=
"font-size: small;">fd_load_library</tt></a> |</td>
</tr>
<tr>
<th valign="top" align="left"><a href=
"#envfns.c"><tt>src/os/envfns.c</tt></a></th>
<td valign="top" align="left"><a href="#fd_exit"><tt style=
"font-size: small;">fd_exit</tt></a> | <a href=
"#fd_get_gid"><tt style="font-size: small;">fd_get_gid</tt></a> |
<a href="#fd_get_gname"><tt style=
"font-size: small;">fd_get_gname</tt></a> | <a href=
"#fd_get_uid"><tt style="font-size: small;">fd_get_uid</tt></a> |
<a href="#fd_get_uname"><tt style=
"font-size: small;">fd_get_uname</tt></a> | <a href=
"#fd_get_user_data"><tt style=
"font-size: small;">fd_get_user_data</tt></a> | <a href=
"#fd_getenv"><tt style="font-size: small;">fd_getenv</tt></a> |
<a href="#fd_getrusage"><tt style=
"font-size: small;">fd_getrusage</tt></a> | <a href=
"#fd_inhibit_anti_warranty"><tt style=
"font-size: small;">fd_inhibit_anti_warranty</tt></a> | <a href=
"#fd_inhibit_herald"><tt style=
"font-size: small;">fd_inhibit_herald</tt></a> | <a href=
"#fd_int_getenv"><tt style=
"font-size: small;">fd_int_getenv</tt></a> | <a href=
"#fd_load_config"><tt style=
"font-size: small;">fd_load_config</tt></a> | <a href=
"#fd_set_build_date"><tt style=
"font-size: small;">fd_set_build_date</tt></a> | <a href=
"#fd_set_gid"><tt style="font-size: small;">fd_set_gid</tt></a> |
<a href="#fd_set_random"><tt style=
"font-size: small;">fd_set_random</tt></a> | <a href=
"#fd_set_session_mnemonic"><tt style=
"font-size: small;">fd_set_session_mnemonic</tt></a> | <a href=
"#fd_set_uid"><tt style="font-size: small;">fd_set_uid</tt></a> |
<a href="#fd_string_getenv"><tt style=
"font-size: small;">fd_string_getenv</tt></a> |</td>
</tr>
<tr>
<th valign="top" align="left"><a href=
"#filefns.c"><tt>src/os/filefns.c</tt></a></th>
<td valign="top" align="left"><a href="#fd_directoryp"><tt style=
"font-size: small;">fd_directoryp</tt></a> | <a href=
"#fd_fclose"><tt style="font-size: small;">fd_fclose</tt></a> |
<a href="#fd_file_existsp"><tt style=
"font-size: small;">fd_file_existsp</tt></a> | <a href=
"#fd_file_size"><tt style="font-size: small;">fd_file_size</tt></a>
| <a href="#fd_file_writablep"><tt style=
"font-size: small;">fd_file_writablep</tt></a> | <a href=
"#fd_find_file"><tt style="font-size: small;">fd_find_file</tt></a>
| <a href="#fd_fopen"><tt style=
"font-size: small;">fd_fopen</tt></a> | <a href=
"#fd_fopen_locked"><tt style=
"font-size: small;">fd_fopen_locked</tt></a> | <a href=
"#fd_get_exec_filename"><tt style=
"font-size: small;">fd_get_exec_filename</tt></a> | <a href=
"#fd_getpath"><tt style="font-size: small;">fd_getpath</tt></a> |
<a href="#fd_regular_filep"><tt style=
"font-size: small;">fd_regular_filep</tt></a> | <a href=
"#fd_symbolic_linkp"><tt style=
"font-size: small;">fd_symbolic_linkp</tt></a> |</td>
</tr>
<tr>
<th valign="top" align="left"><a href=
"#odb.c"><tt>src/odb/odb.c</tt></a></th>
<td valign="top" align="left"><a href="#fd_close_pool"><tt style=
"font-size: small;">fd_close_pool</tt></a> | <a href=
"#fd_commit_oid"><tt style=
"font-size: small;">fd_commit_oid</tt></a> | <a href=
"#fd_control_frame_printing"><tt style=
"font-size: small;">fd_control_frame_printing</tt></a> | <a href=
"#fd_get_modified"><tt style=
"font-size: small;">fd_get_modified</tt></a> | <a href=
"#fd_get_oid_value"><tt style=
"font-size: small;">fd_get_oid_value</tt></a> | <a href=
"#fd_mark_modified"><tt style=
"font-size: small;">fd_mark_modified</tt></a> | <a href=
"#fd_new_oid"><tt style="font-size: small;">fd_new_oid</tt></a> |
<a href="#fd_oid_modifiedp"><tt style=
"font-size: small;">fd_oid_modifiedp</tt></a> | <a href=
"#fd_print_oid"><tt style="font-size: small;">fd_print_oid</tt></a>
| <a href="#fd_revert_oid"><tt style=
"font-size: small;">fd_revert_oid</tt></a> | <a href=
"#fd_revert_pool"><tt style=
"font-size: small;">fd_revert_pool</tt></a> | <a href=
"#fd_set_oid_value"><tt style=
"font-size: small;">fd_set_oid_value</tt></a> | <a href=
"#fd_show_poolids"><tt style=
"font-size: small;">fd_show_poolids</tt></a> | <a href=
"#fd_swap_out"><tt style="font-size: small;">fd_swap_out</tt></a> |
<a href="#fd_swap_out_pool"><tt style=
"font-size: small;">fd_swap_out_pool</tt></a> | <a href=
"#fd_try_oid_value"><tt style=
"font-size: small;">fd_try_oid_value</tt></a> |</td>
</tr>
<tr>
<th valign="top" align="left"><a href=
"#osprims.c"><tt>src/fdscript/osprims.c</tt></a></th>
<td valign="top" align="left"><a href=
"#fd_register_url_protocol"><tt style=
"font-size: small;">fd_register_url_protocol</tt></a> | <a href=
"#fd_urlget"><tt style="font-size: small;">fd_urlget</tt></a>
|</td>
</tr>
<tr>
<th valign="top" align="left"><a href=
"#strings.c"><tt>src/scheme/strings.c</tt></a></th>
<td valign="top" align="left"><a href=
"#fd_string_length"><tt style="font-size: small;">fd_string_length</tt></a>
| <a href="#fd_string_ref"><tt style=
"font-size: small;">fd_string_ref</tt></a> | <a href=
"#fd_string_set"><tt style=
"font-size: small;">fd_string_set</tt></a> |</td>
</tr>
<tr>
<th valign="top" align="left"><a href=
"#super-pool.c"><tt>src/odb/super-pool.c</tt></a></th>
<td valign="top" align="left"><a href=
"#fd_allocate_pool"><tt style="font-size: small;">fd_allocate_pool</tt></a>
| <a href="#fd_recovered_pool"><tt style=
"font-size: small;">fd_recovered_pool</tt></a> | <a href=
"#fd_super_pool_base"><tt style=
"font-size: small;">fd_super_pool_base</tt></a> | <a href=
"#fd_super_pool_loading"><tt style=
"font-size: small;">fd_super_pool_loading</tt></a> | <a href=
"#fd_super_pool_top"><tt style=
"font-size: small;">fd_super_pool_top</tt></a> |</td>
</tr>
<tr>
<th valign="top" align="left"><a href=
"#threads.c"><tt>src/eval/threads.c</tt></a></th>
<td valign="top" align="left"><a href=
"#fd_thread_symbind"><tt style=
"font-size: small;">fd_thread_symbind</tt></a> | <a href=
"#fd_thread_symeval"><tt style=
"font-size: small;">fd_thread_symeval</tt></a> |</td>
</tr>
<tr>
<th valign="top" align="left"><a href=
"#choices.c"><tt>src/cons/choices.c</tt></a></th>
<td valign="top" align="left"><a href=
"#_fd_add_to_choice"><tt style=
"font-size: small;">_fd_add_to_choice</tt></a> | <a href=
"#_fd_binary_choice"><tt style=
"font-size: small;">_fd_binary_choice</tt></a> | <a href=
"#_fd_make_choice_heterogenous"><tt style=
"font-size: small;">_fd_make_choice_heterogenous</tt></a> |
<a href="#_fd_make_choice_homogenous"><tt style=
"font-size: small;">_fd_make_choice_homogenous</tt></a> | <a href=
"#_fd_merge_choices"><tt style=
"font-size: small;">_fd_merge_choices</tt></a> | <a href=
"#_fd_quote_choice"><tt style=
"font-size: small;">_fd_quote_choice</tt></a> | <a href=
"#_fd_unquote_choice"><tt style=
"font-size: small;">_fd_unquote_choice</tt></a> | <a href=
"#fd_choice_containsp"><tt style=
"font-size: small;">fd_choice_containsp</tt></a> | <a href=
"#fd_choice_overlapsp"><tt style=
"font-size: small;">fd_choice_overlapsp</tt></a> | <a href=
"#fd_init_choice"><tt style=
"font-size: small;">fd_init_choice</tt></a> | <a href=
"#fd_init_oid_choice"><tt style=
"font-size: small;">fd_init_oid_choice</tt></a> | <a href=
"#fd_intersect_choices"><tt style=
"font-size: small;">fd_intersect_choices</tt></a> | <a href=
"#fd_list_to_choice"><tt style=
"font-size: small;">fd_list_to_choice</tt></a> | <a href=
"#fd_merge_choices"><tt style=
"font-size: small;">fd_merge_choices</tt></a> | <a href=
"#fd_proper_choicep"><tt style=
"font-size: small;">fd_proper_choicep</tt></a> | <a href=
"#fd_remove_from_choice"><tt style=
"font-size: small;">fd_remove_from_choice</tt></a> | <a href=
"#fd_return_proper_choice"><tt style=
"font-size: small;">fd_return_proper_choice</tt></a> | <a href=
"#fd_sort_choice"><tt style=
"font-size: small;">fd_sort_choice</tt></a> |</td>
</tr>
<tr>
<th valign="top" align="left"><a href=
"#frames.c"><tt>src/odb/frames.c</tt></a></th>
<td valign="top" align="left"><a href=
"#fd_already_doing_p"><tt style=
"font-size: small;">fd_already_doing_p</tt></a> | <a href=
"#fd_clear_slot_cache"><tt style=
"font-size: small;">fd_clear_slot_cache</tt></a> | <a href=
"#fd_copy_frame"><tt style=
"font-size: small;">fd_copy_frame</tt></a> | <a href=
"#fd_describe_slot"><tt style=
"font-size: small;">fd_describe_slot</tt></a> | <a href=
"#fd_disable_slot_cache"><tt style=
"font-size: small;">fd_disable_slot_cache</tt></a> | <a href=
"#fd_enable_slot_cache"><tt style=
"font-size: small;">fd_enable_slot_cache</tt></a> | <a href=
"#fd_for_slots"><tt style="font-size: small;">fd_for_slots</tt></a>
| <a href="#fd_frame_add"><tt style=
"font-size: small;">fd_frame_add</tt></a> | <a href=
"#fd_frame_create"><tt style=
"font-size: small;">fd_frame_create</tt></a> | <a href=
"#fd_frame_get"><tt style="font-size: small;">fd_frame_get</tt></a>
| <a href="#fd_frame_get_star"><tt style=
"font-size: small;">fd_frame_get_star</tt></a> | <a href=
"#fd_frame_remove"><tt style=
"font-size: small;">fd_frame_remove</tt></a> | <a href=
"#fd_frame_set"><tt style="font-size: small;">fd_frame_set</tt></a>
| <a href="#fd_frame_slots"><tt style=
"font-size: small;">fd_frame_slots</tt></a> | <a href=
"#fd_frame_test"><tt style=
"font-size: small;">fd_frame_test</tt></a> | <a href=
"#fd_get_slotmap"><tt style=
"font-size: small;">fd_get_slotmap</tt></a> | <a href=
"#fd_inherit_values"><tt style=
"font-size: small;">fd_inherit_values</tt></a> | <a href=
"#fd_inherits_valuep"><tt style=
"font-size: small;">fd_inherits_valuep</tt></a> | <a href=
"#fd_overlay_create"><tt style=
"font-size: small;">fd_overlay_create</tt></a> | <a href=
"#fd_overlay_get"><tt style=
"font-size: small;">fd_overlay_get</tt></a> | <a href=
"#fd_overlay_test"><tt style=
"font-size: small;">fd_overlay_test</tt></a> | <a href=
"#fd_pathp"><tt style="font-size: small;">fd_pathp</tt></a> |
<a href="#fd_prim_add"><tt style=
"font-size: small;">fd_prim_add</tt></a> | <a href=
"#fd_prim_add_consed"><tt style=
"font-size: small;">fd_prim_add_consed</tt></a> | <a href=
"#fd_prim_drop"><tt style="font-size: small;">fd_prim_drop</tt></a>
| <a href="#fd_prim_get"><tt style=
"font-size: small;">fd_prim_get</tt></a> | <a href=
"#fd_prim_set"><tt style="font-size: small;">fd_prim_set</tt></a> |
<a href="#fd_prim_set_consed"><tt style=
"font-size: small;">fd_prim_set_consed</tt></a> | <a href=
"#fd_prim_test"><tt style="font-size: small;">fd_prim_test</tt></a>
| <a href="#fd_use_autoindex"><tt style=
"font-size: small;">fd_use_autoindex</tt></a> |</td>
</tr>
<tr>
<th valign="top" align="left"><a href=
"#libframerd.c"><tt>src/odb/libframerd.c</tt></a></th>
<td valign="top" align="left"><a href=
"#fd_report_framerd_stats"><tt style=
"font-size: small;">fd_report_framerd_stats</tt></a> |</td>
</tr>
<tr>
<th valign="top" align="left"><a href=
"#xml.c"><tt>src/text/xml.c</tt></a></th>
<td valign="top" align="left"><a href="#fd_make_xmltag"><tt style=
"font-size: small;">fd_make_xmltag</tt></a> | <a href=
"#fd_parse_html"><tt style=
"font-size: small;">fd_parse_html</tt></a> | <a href=
"#fd_parse_xml"><tt style="font-size: small;">fd_parse_xml</tt></a>
| <a href="#fd_xml_attributes"><tt style=
"font-size: small;">fd_xml_attributes</tt></a> | <a href=
"#fd_xml_content"><tt style=
"font-size: small;">fd_xml_content</tt></a> | <a href=
"#fd_xml_tag"><tt style="font-size: small;">fd_xml_tag</tt></a> |
<a href="#fd_xmltag_name"><tt style=
"font-size: small;">fd_xmltag_name</tt></a> | <a href=
"#fd_xmltag_namespace"><tt style=
"font-size: small;">fd_xmltag_namespace</tt></a> |</td>
</tr>
<tr>
<th valign="top" align="left"><a href=
"#slotmaps.c"><tt>src/cons/slotmaps.c</tt></a></th>
<td valign="top" align="left"><a href=
"#_fd_done_with_slotmap_data"><tt style=
"font-size: small;">_fd_done_with_slotmap_data</tt></a> | <a href=
"#_fd_slotmap_data"><tt style=
"font-size: small;">_fd_slotmap_data</tt></a> | <a href=
"#fd_make_slotmap"><tt style=
"font-size: small;">fd_make_slotmap</tt></a> | <a href=
"#fd_slotmap_add"><tt style=
"font-size: small;">fd_slotmap_add</tt></a> | <a href=
"#fd_slotmap_get"><tt style=
"font-size: small;">fd_slotmap_get</tt></a> | <a href=
"#fd_slotmap_remove"><tt style=
"font-size: small;">fd_slotmap_remove</tt></a> | <a href=
"#fd_slotmap_set"><tt style=
"font-size: small;">fd_slotmap_set</tt></a> | <a href=
"#fd_slotmap_test"><tt style=
"font-size: small;">fd_slotmap_test</tt></a> | <a href=
"#fd_slotmap_zap"><tt style=
"font-size: small;">fd_slotmap_zap</tt></a> |</td>
</tr>
<tr>
<th valign="top" align="left"><a href=
"#lambda.c"><tt>src/eval/lambda.c</tt></a></th>
<td valign="top" align="left"><a href="#fd_bind_value"><tt style=
"font-size: small;">fd_bind_value</tt></a> | <a href=
"#fd_free_env"><tt style="font-size: small;">fd_free_env</tt></a> |
<a href="#fd_make_env"><tt style=
"font-size: small;">fd_make_env</tt></a> | <a href=
"#fd_make_gproc"><tt style=
"font-size: small;">fd_make_gproc</tt></a> | <a href=
"#fd_make_sproc"><tt style=
"font-size: small;">fd_make_sproc</tt></a> | <a href=
"#fd_make_ssproc"><tt style=
"font-size: small;">fd_make_ssproc</tt></a> | <a href=
"#fd_mallocd_env"><tt style=
"font-size: small;">fd_mallocd_env</tt></a> | <a href=
"#fd_module_export"><tt style=
"font-size: small;">fd_module_export</tt></a> | <a href=
"#fd_module_uses"><tt style=
"font-size: small;">fd_module_uses</tt></a> | <a href=
"#fd_register_module"><tt style=
"font-size: small;">fd_register_module</tt></a> | <a href=
"#fd_register_restricted_module"><tt style=
"font-size: small;">fd_register_restricted_module</tt></a> |
<a href="#fd_registered_module"><tt style=
"font-size: small;">fd_registered_module</tt></a> | <a href=
"#fd_required_symeval"><tt style=
"font-size: small;">fd_required_symeval</tt></a> | <a href=
"#fd_safe_set_value"><tt style=
"font-size: small;">fd_safe_set_value</tt></a> | <a href=
"#fd_set_value"><tt style="font-size: small;">fd_set_value</tt></a>
| <a href="#fd_symeval"><tt style=
"font-size: small;">fd_symeval</tt></a> |</td>
</tr>
<tr>
<th valign="top" align="left"><a href=
"#eval.c"><tt>src/eval/eval.c</tt></a></th>
<td valign="top" align="left"><a href=
"#_fd_finalize_static_tail_call"><tt style=
"font-size: small;">_fd_finalize_static_tail_call</tt></a> |
<a href="#fd_add_alias"><tt style=
"font-size: small;">fd_add_alias</tt></a> | <a href=
"#fd_add_cproc"><tt style="font-size: small;">fd_add_cproc</tt></a>
| <a href="#fd_add_lexpr"><tt style=
"font-size: small;">fd_add_lexpr</tt></a> | <a href=
"#fd_add_special_form"><tt style=
"font-size: small;">fd_add_special_form</tt></a> | <a href=
"#fd_do_application"><tt style=
"font-size: small;">fd_do_application</tt></a> | <a href=
"#fd_eval"><tt style="font-size: small;">fd_eval</tt></a> |
<a href="#fd_eval_elts"><tt style=
"font-size: small;">fd_eval_elts</tt></a> | <a href=
"#fd_eval_in_env"><tt style=
"font-size: small;">fd_eval_in_env</tt></a> | <a href=
"#fd_evalstring"><tt style=
"font-size: small;">fd_evalstring</tt></a> | <a href=
"#fd_finish_value"><tt style=
"font-size: small;">fd_finish_value</tt></a> | <a href=
"#fd_make_rproc"><tt style=
"font-size: small;">fd_make_rproc</tt></a> | <a href=
"#fd_mv_arity"><tt style="font-size: small;">fd_mv_arity</tt></a> |
<a href="#fd_mv_ref"><tt style=
"font-size: small;">fd_mv_ref</tt></a> | <a href=
"#fd_mv_return"><tt style="font-size: small;">fd_mv_return</tt></a>
| <a href="#fd_record_typep"><tt style=
"font-size: small;">fd_record_typep</tt></a> | <a href=
"#fd_set_supertype"><tt style=
"font-size: small;">fd_set_supertype</tt></a> | <a href=
"#fd_start_eval"><tt style=
"font-size: small;">fd_start_eval</tt></a> | <a href=
"#fd_streval"><tt style="font-size: small;">fd_streval</tt></a>
|</td>
</tr>
<tr>
<th valign="top" align="left"><a href=
"#network.c"><tt>src/os/network.c</tt></a></th>
<td valign="top" align="left"><a href=
"#fd_careful_dtcall"><tt style=
"font-size: small;">fd_careful_dtcall</tt></a> | <a href=
"#fd_careful_dtype_eval"><tt style=
"font-size: small;">fd_careful_dtype_eval</tt></a> | <a href=
"#fd_close_connection"><tt style=
"font-size: small;">fd_close_connection</tt></a> | <a href=
"#fd_connect"><tt style="font-size: small;">fd_connect</tt></a> |
<a href="#fd_dtcall"><tt style=
"font-size: small;">fd_dtcall</tt></a> | <a href=
"#fd_dtype_eval"><tt style=
"font-size: small;">fd_dtype_eval</tt></a> | <a href=
"#fd_get_portno"><tt style=
"font-size: small;">fd_get_portno</tt></a> | <a href=
"#fd_http_get"><tt style="font-size: small;">fd_http_get</tt></a> |
<a href="#fd_http_head"><tt style=
"font-size: small;">fd_http_head</tt></a> | <a href=
"#fd_http_string"><tt style=
"font-size: small;">fd_http_string</tt></a> | <a href=
"#fd_init_connection"><tt style=
"font-size: small;">fd_init_connection</tt></a> | <a href=
"#fd_open_connection"><tt style=
"font-size: small;">fd_open_connection</tt></a> | <a href=
"#fd_open_local_socket"><tt style=
"font-size: small;">fd_open_local_socket</tt></a> | <a href=
"#fd_open_tcp_socket"><tt style=
"font-size: small;">fd_open_tcp_socket</tt></a> | <a href=
"#fd_read_from_socket"><tt style=
"font-size: small;">fd_read_from_socket</tt></a> | <a href=
"#fd_send_smtp_mail"><tt style=
"font-size: small;">fd_send_smtp_mail</tt></a> | <a href=
"#fd_sendall"><tt style="font-size: small;">fd_sendall</tt></a> |
<a href="#fd_timed_recv"><tt style=
"font-size: small;">fd_timed_recv</tt></a> | <a href=
"#fd_trace_dteval"><tt style=
"font-size: small;">fd_trace_dteval</tt></a> | <a href=
"#fd_try_to_connect"><tt style=
"font-size: small;">fd_try_to_connect</tt></a> |</td>
</tr>
<tr>
<th valign="top" align="left"><a href=
"#i18n.c"><tt>src/os/i18n.c</tt></a></th>
<td valign="top" align="left"><a href="#fd_convert_utf8"><tt style=
"font-size: small;">fd_convert_utf8</tt></a> | <a href=
"#fd_define_encoding"><tt style=
"font-size: small;">fd_define_encoding</tt></a> | <a href=
"#fd_downcase_string"><tt style=
"font-size: small;">fd_downcase_string</tt></a> | <a href=
"#fd_fgetc"><tt style="font-size: small;">fd_fgetc</tt></a> |
<a href="#fd_foreign_filestring"><tt style=
"font-size: small;">fd_foreign_filestring</tt></a> | <a href=
"#fd_fputc"><tt style="font-size: small;">fd_fputc</tt></a> |
<a href="#fd_fputs_encoded"><tt style=
"font-size: small;">fd_fputs_encoded</tt></a> | <a href=
"#fd_fputs_raw"><tt style="font-size: small;">fd_fputs_raw</tt></a>
| <a href="#fd_free_xfile"><tt style=
"font-size: small;">fd_free_xfile</tt></a> | <a href=
"#fd_get_encoding"><tt style=
"font-size: small;">fd_get_encoding</tt></a> | <a href=
"#fd_get_file_encoding"><tt style=
"font-size: small;">fd_get_file_encoding</tt></a> | <a href=
"#fd_get_xfile"><tt style="font-size: small;">fd_get_xfile</tt></a>
| <a href="#fd_interpret_unicode_escapes"><tt style=
"font-size: small;">fd_interpret_unicode_escapes</tt></a> |
<a href="#fd_load_encoding"><tt style=
"font-size: small;">fd_load_encoding</tt></a> | <a href=
"#fd_localize_utf8"><tt style=
"font-size: small;">fd_localize_utf8</tt></a> | <a href=
"#fd_make_utf8"><tt style="font-size: small;">fd_make_utf8</tt></a>
| <a href="#fd_set_default_encoding"><tt style=
"font-size: small;">fd_set_default_encoding</tt></a> | <a href=
"#fd_set_file_encoding"><tt style=
"font-size: small;">fd_set_file_encoding</tt></a> | <a href=
"#fd_set_system_encoding"><tt style=
"font-size: small;">fd_set_system_encoding</tt></a> | <a href=
"#fd_ungetc"><tt style="font-size: small;">fd_ungetc</tt></a> |
<a href="#fd_upcase_string"><tt style=
"font-size: small;">fd_upcase_string</tt></a> | <a href=
"#fd_valid_utf8p"><tt style=
"font-size: small;">fd_valid_utf8p</tt></a> | <a href=
"#fd_xgetc"><tt style="font-size: small;">fd_xgetc</tt></a> |
<a href="#fd_xgetc_encoded"><tt style=
"font-size: small;">fd_xgetc_encoded</tt></a> | <a href=
"#fd_xputc"><tt style="font-size: small;">fd_xputc</tt></a> |
<a href="#fd_xputc_encoded"><tt style=
"font-size: small;">fd_xputc_encoded</tt></a> | <a href=
"#fd_xungetc"><tt style="font-size: small;">fd_xungetc</tt></a>
|</td>
</tr>
<tr>
<th valign="top" align="left"><a href=
"#fdmalloc.c"><tt>src/os/fdmalloc.c</tt></a></th>
<td valign="top" align="left"><a href="#_fd_qfree"><tt style=
"font-size: small;">_fd_qfree</tt></a> | <a href=
"#_fd_qmalloc"><tt style="font-size: small;">_fd_qmalloc</tt></a> |
<a href="#_fd_qmalloc_cons"><tt style=
"font-size: small;">_fd_qmalloc_cons</tt></a> | <a href=
"#fd_free"><tt style="font-size: small;">fd_free</tt></a> |
<a href="#fd_free_int_array"><tt style=
"font-size: small;">fd_free_int_array</tt></a> | <a href=
"#fd_malloc"><tt style="font-size: small;">fd_malloc</tt></a> |
<a href="#fd_malloc_adjust"><tt style=
"font-size: small;">fd_malloc_adjust</tt></a> | <a href=
"#fd_malloc_init"><tt style=
"font-size: small;">fd_malloc_init</tt></a> | <a href=
"#fd_mallocize"><tt style="font-size: small;">fd_mallocize</tt></a>
| <a href="#fd_memdup"><tt style=
"font-size: small;">fd_memdup</tt></a> | <a href=
"#fd_realloc"><tt style="font-size: small;">fd_realloc</tt></a> |
<a href="#fd_strdup"><tt style=
"font-size: small;">fd_strdup</tt></a> | <a href=
"#fd_xfree"><tt style="font-size: small;">fd_xfree</tt></a> |
<a href="#fd_xmalloc"><tt style=
"font-size: small;">fd_xmalloc</tt></a> | <a href=
"#fd_xmemdup"><tt style="font-size: small;">fd_xmemdup</tt></a> |
<a href="#fd_xrealloc"><tt style=
"font-size: small;">fd_xrealloc</tt></a> |</td>
</tr>
<tr>
<th valign="top" align="left"><a href=
"#except.c"><tt>src/os/except.c</tt></a></th>
<td valign="top" align="left"><a href="#_fd_push_jbr"><tt style=
"font-size: small;">_fd_push_jbr</tt></a> | <a href=
"#fd_ctype_error"><tt style=
"font-size: small;">fd_ctype_error</tt></a> | <a href=
"#fd_exception_context"><tt style=
"font-size: small;">fd_exception_context</tt></a> | <a href=
"#fd_exception_context_push"><tt style=
"font-size: small;">fd_exception_context_push</tt></a> | <a href=
"#fd_pigs_fly"><tt style="font-size: small;">fd_pigs_fly</tt></a> |
<a href="#fd_raise_detailed_exception"><tt style=
"font-size: small;">fd_raise_detailed_exception</tt></a> | <a href=
"#fd_raise_exception"><tt style=
"font-size: small;">fd_raise_exception</tt></a> | <a href=
"#fd_raise_lisp_exception"><tt style=
"font-size: small;">fd_raise_lisp_exception</tt></a> | <a href=
"#fd_record_type_error"><tt style=
"font-size: small;">fd_record_type_error</tt></a> | <a href=
"#fd_set_exception"><tt style=
"font-size: small;">fd_set_exception</tt></a> | <a href=
"#fd_throw"><tt style="font-size: small;">fd_throw</tt></a> |
<a href="#fd_type_error"><tt style=
"font-size: small;">fd_type_error</tt></a> |</td>
</tr>
<tr>
<th valign="top" align="left"><a href=
"#io.c"><tt>src/cons/io.c</tt></a></th>
<td valign="top" align="left"><a href="#_fd_sgetc"><tt style=
"font-size: small;">_fd_sgetc</tt></a> | <a href=
"#fd_add_dtype_to_file"><tt style=
"font-size: small;">fd_add_dtype_to_file</tt></a> | <a href=
"#fd_configure_oid_io"><tt style=
"font-size: small;">fd_configure_oid_io</tt></a> | <a href=
"#fd_default_parse_oid"><tt style=
"font-size: small;">fd_default_parse_oid</tt></a> | <a href=
"#fd_default_print_oid"><tt style=
"font-size: small;">fd_default_print_oid</tt></a> | <a href=
"#fd_dtype_size"><tt style=
"font-size: small;">fd_dtype_size</tt></a> | <a href=
"#fd_object_to_string"><tt style=
"font-size: small;">fd_object_to_string</tt></a> | <a href=
"#fd_parse_arg"><tt style="font-size: small;">fd_parse_arg</tt></a>
| <a href="#fd_parse_lisp_from_stream"><tt style=
"font-size: small;">fd_parse_lisp_from_stream</tt></a> | <a href=
"#fd_parse_number"><tt style=
"font-size: small;">fd_parse_number</tt></a> | <a href=
"#fd_parse_string"><tt style=
"font-size: small;">fd_parse_string</tt></a> | <a href=
"#fd_print_lisp"><tt style=
"font-size: small;">fd_print_lisp</tt></a> | <a href=
"#fd_print_lisp_to_stdout"><tt style=
"font-size: small;">fd_print_lisp_to_stdout</tt></a> | <a href=
"#fd_print_lisp_to_string"><tt style=
"font-size: small;">fd_print_lisp_to_string</tt></a> | <a href=
"#fd_read_dtype_from_file"><tt style=
"font-size: small;">fd_read_dtype_from_file</tt></a> | <a href=
"#fd_read_dtypes_from_file"><tt style=
"font-size: small;">fd_read_dtypes_from_file</tt></a> | <a href=
"#fd_set_bignum_parser"><tt style=
"font-size: small;">fd_set_bignum_parser</tt></a> | <a href=
"#fd_set_super_pool_aliasing"><tt style=
"font-size: small;">fd_set_super_pool_aliasing</tt></a> | <a href=
"#fd_validate_dtype"><tt style=
"font-size: small;">fd_validate_dtype</tt></a> | <a href=
"#fd_write_dtype_to_file"><tt style=
"font-size: small;">fd_write_dtype_to_file</tt></a> |</td>
</tr>
<tr>
<th valign="top" align="left"><a href=
"#file-pool.c"><tt>src/odb/file-pool.c</tt></a></th>
<td valign="top" align="left"><a href=
"#fd_cache_file_pool"><tt style=
"font-size: small;">fd_cache_file_pool</tt></a> | <a href=
"#fd_file_pool_capacity"><tt style=
"font-size: small;">fd_file_pool_capacity</tt></a> | <a href=
"#fd_file_pool_freespace"><tt style=
"font-size: small;">fd_file_pool_freespace</tt></a> | <a href=
"#fd_file_pool_load"><tt style=
"font-size: small;">fd_file_pool_load</tt></a> | <a href=
"#fd_label_file_pool"><tt style=
"font-size: small;">fd_label_file_pool</tt></a> | <a href=
"#fd_lock_file_pool"><tt style=
"font-size: small;">fd_lock_file_pool</tt></a> | <a href=
"#fd_make_file_pool"><tt style=
"font-size: small;">fd_make_file_pool</tt></a> | <a href=
"#fd_make_new_super_pool"><tt style=
"font-size: small;">fd_make_new_super_pool</tt></a> | <a href=
"#fd_make_pool_snapshot"><tt style=
"font-size: small;">fd_make_pool_snapshot</tt></a> | <a href=
"#fd_make_super_pool"><tt style=
"font-size: small;">fd_make_super_pool</tt></a> | <a href=
"#fd_new_file_pool"><tt style=
"font-size: small;">fd_new_file_pool</tt></a> | <a href=
"#fd_read_file_pool_metadata"><tt style=
"font-size: small;">fd_read_file_pool_metadata</tt></a> | <a href=
"#fd_register_file_pool_opener"><tt style=
"font-size: small;">fd_register_file_pool_opener</tt></a> |
<a href="#fd_use_file_pool"><tt style=
"font-size: small;">fd_use_file_pool</tt></a> |</td>
</tr>
<tr>
<th valign="top" align="left"><a href=
"#search.c"><tt>src/index/search.c</tt></a></th>
<td valign="top" align="left"><a href="#fd_find_frames"><tt style=
"font-size: small;">fd_find_frames</tt></a> | <a href=
"#fd_find_similar"><tt style=
"font-size: small;">fd_find_similar</tt></a> | <a href=
"#fd_get_frame_features"><tt style=
"font-size: small;">fd_get_frame_features</tt></a> | <a href=
"#fd_get_slot_features"><tt style=
"font-size: small;">fd_get_slot_features</tt></a> | <a href=
"#fd_index_frame"><tt style=
"font-size: small;">fd_index_frame</tt></a> | <a href=
"#fd_index_notice_slot_values"><tt style=
"font-size: small;">fd_index_notice_slot_values</tt></a> | <a href=
"#fd_index_slot_values"><tt style=
"font-size: small;">fd_index_slot_values</tt></a> | <a href=
"#fd_index_slots"><tt style=
"font-size: small;">fd_index_slots</tt></a> | <a href=
"#fd_score_from_samples"><tt style=
"font-size: small;">fd_score_from_samples</tt></a> | <a href=
"#fd_score_from_spec"><tt style=
"font-size: small;">fd_score_from_spec</tt></a> | <a href=
"#fd_strict_search"><tt style=
"font-size: small;">fd_strict_search</tt></a> |</td>
</tr>
</table>
<h2><a name="envfns.c" id="envfns.c">Functions defined in
<tt>src/os/envfns.c</tt></a></h2>
<p><a href="#fd_exit"><tt>fd_exit</tt></a> | <a href=
"#fd_get_gid"><tt>fd_get_gid</tt></a> | <a href=
"#fd_get_gname"><tt>fd_get_gname</tt></a> | <a href=
"#fd_get_uid"><tt>fd_get_uid</tt></a> | <a href=
"#fd_get_uname"><tt>fd_get_uname</tt></a> | <a href=
"#fd_get_user_data"><tt>fd_get_user_data</tt></a> | <a href=
"#fd_getenv"><tt>fd_getenv</tt></a> | <a href=
"#fd_getrusage"><tt>fd_getrusage</tt></a> | <a href=
"#fd_inhibit_anti_warranty"><tt>fd_inhibit_anti_warranty</tt></a> |
<a href="#fd_inhibit_herald"><tt>fd_inhibit_herald</tt></a> |
<a href="#fd_int_getenv"><tt>fd_int_getenv</tt></a> | <a href=
"#fd_load_config"><tt>fd_load_config</tt></a> | <a href=
"#fd_set_build_date"><tt>fd_set_build_date</tt></a> | <a href=
"#fd_set_gid"><tt>fd_set_gid</tt></a> | <a href=
"#fd_set_random"><tt>fd_set_random</tt></a> | <a href=
"#fd_set_session_mnemonic"><tt>fd_set_session_mnemonic</tt></a> |
<a href="#fd_set_uid"><tt>fd_set_uid</tt></a> | <a href=
"#fd_string_getenv"><tt>fd_string_getenv</tt></a> |</p>
<table cellpadding="5">
<tr>
<th align="left">Function</th>
<th align="left">Arguments</th>
<th align="left">Returns</th>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name="fd_get_uname"
id="fd_get_uname">fd_get_uname</a></td>
<td class="ccode">uid_t id</td>
<td class="ccode">char *</td>
</tr>
<tr>
<th></th>
<td>a uid</td>
<td>a string</td>
</tr>
<tr>
<th></th>
<td><em>Gets the user name for a particular id</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name="fd_set_gid"
id="fd_set_gid">fd_set_gid</a></td>
<td class="ccode">char *gname</td>
<td class="ccode">int</td>
</tr>
<tr>
<th></th>
<td>a gid</td>
<td>changes the current group to be name, return 1 if
successful</td>
</tr>
<tr>
<th></th>
<td></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name=
"fd_inhibit_herald" id=
"fd_inhibit_herald">fd_inhibit_herald</a></td>
<td class="ccode">int inhibit</td>
<td class="ccode">void</td>
</tr>
<tr>
<th></th>
<td>none</td>
<td>void</td>
</tr>
<tr>
<th></th>
<td><em>Keeps the startup and shutdown heralds from being
shown</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name="fd_get_uid"
id="fd_get_uid">fd_get_uid</a></td>
<td class="ccode">char *uname</td>
<td class="ccode">uid_t</td>
</tr>
<tr>
<th></th>
<td>a string</td>
<td>gets the user ID for a named user</td>
</tr>
<tr>
<th></th>
<td></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name=
"fd_set_build_date" id=
"fd_set_build_date">fd_set_build_date</a></td>
<td class="ccode">char *date</td>
<td class="ccode">void</td>
</tr>
<tr>
<th></th>
<td>a string</td>
<td>nothing</td>
</tr>
<tr>
<th></th>
<td><em>Sets the build date to be returned by
fd_get_build_date</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name="fd_int_getenv"
id="fd_int_getenv">fd_int_getenv</a></td>
<td class="ccode">char *var,int dflt</td>
<td class="ccode">int</td>
</tr>
<tr>
<th></th>
<td>a string naming a variable and an int default</td>
<td>an int</td>
</tr>
<tr>
<th></th>
<td><em>Gets a variable from the environment. It first tries the
top level LISP environment, then the Windows registry (under
WIN32), and finally the "POSIX" environment. Unlike fd_getenv, this
doesn't parse the string.</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name="fd_get_gid"
id="fd_get_gid">fd_get_gid</a></td>
<td class="ccode">char *uname</td>
<td class="ccode">gid_t</td>
</tr>
<tr>
<th></th>
<td>a string</td>
<td>gets the group ID for a named group</td>
</tr>
<tr>
<th></th>
<td></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name="fd_get_gname"
id="fd_get_gname">fd_get_gname</a></td>
<td class="ccode">gid_t id</td>
<td class="ccode">char *</td>
</tr>
<tr>
<th></th>
<td>a gid</td>
<td>a string</td>
</tr>
<tr>
<th></th>
<td><em>Gets the group name for a particular gid</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name="fd_exit" id=
"fd_exit">fd_exit</a></td>
<td class="ccode">int status</td>
<td class="ccode">void</td>
</tr>
<tr>
<th></th>
<td>a status code (an int)</td>
<td>no.</td>
</tr>
<tr>
<th></th>
<td><em>This sets the variable fd_normal_exit to 1 if the status
code is zero, which can be read by atexit handlers.</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name=
"fd_load_config" id="fd_load_config">fd_load_config</a></td>
<td class="ccode">char *config_file</td>
<td class="ccode">int</td>
</tr>
<tr>
<th></th>
<td>a filename (a string)</td>
<td>nothing</td>
</tr>
<tr>
<th></th>
<td><em>Loads the variable bindings defined in the specified
configuration file, setting the corresponding symbol
values</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name=
"fd_inhibit_anti_warranty" id=
"fd_inhibit_anti_warranty">fd_inhibit_anti_warranty</a></td>
<td class="ccode">int inhibit</td>
<td class="ccode">void</td>
</tr>
<tr>
<th></th>
<td>none</td>
<td>void</td>
</tr>
<tr>
<th></th>
<td><em>Keeps the startup and shutdown heralds from being
shown</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name="fd_getenv" id=
"fd_getenv">fd_getenv</a></td>
<td class="ccode">char *var</td>
<td class="ccode">lisp</td>
</tr>
<tr>
<th></th>
<td>a string naming a variable</td>
<td>a lisp object</td>
</tr>
<tr>
<th></th>
<td><em>Gets a variable from the environment. It first tries the
top level LISP environment, then the Windows registry (under
WIN32), and finally the "POSIX" environment used by getenv. When
the value comes from anywhere besides the lisp environment, it is
parsed as a LISP argument, so that numbers turn into
numbers.</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name="fd_getrusage"
id="fd_getrusage">fd_getrusage</a></td>
<td class="ccode">struct rusage *r</td>
<td class="ccode">void</td>
</tr>
<tr>
<th></th>
<td>a pointer to an rusage structure</td>
<td>void</td>
</tr>
<tr>
<th></th>
<td><em>Gets rusage information, covering for holes in various
implementations (currently just Linux)</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name=
"fd_string_getenv" id="fd_string_getenv">fd_string_getenv</a></td>
<td class="ccode">char *var</td>
<td class="ccode">fd_u8char *</td>
</tr>
<tr>
<th></th>
<td>a string naming a variable</td>
<td>a lisp string</td>
</tr>
<tr>
<th></th>
<td><em>Gets a variable from the environment. It first tries the
top level LISP environment, then the Windows registry (under
WIN32), and finally the "POSIX" environment. Unlike fd_getenv, this
doesn't parse the string.</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name="fd_set_random"
id="fd_set_random">fd_set_random</a></td>
<td class="ccode">unsigned int seed</td>
<td class="ccode">void</td>
</tr>
<tr>
<th></th>
<td>an unsigned int</td>
<td>void</td>
</tr>
<tr>
<th></th>
<td><em>This sets the random seed.</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name="fd_set_uid"
id="fd_set_uid">fd_set_uid</a></td>
<td class="ccode">char *uname</td>
<td class="ccode">int</td>
</tr>
<tr>
<th></th>
<td>a uid</td>
<td>changes the current user to be name, return 1 if
successful</td>
</tr>
<tr>
<th></th>
<td></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name=
"fd_set_session_mnemonic" id=
"fd_set_session_mnemonic">fd_set_session_mnemonic</a></td>
<td class="ccode">char *mnemonic</td>
<td class="ccode">void</td>
</tr>
<tr>
<th></th>
<td>a string</td>
<td>nothing</td>
</tr>
<tr>
<th></th>
<td><em>Sets the string used to identify this kind of session (e.g.
'fdscript' or more usefully, 'mailreader')</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name=
"fd_get_user_data" id="fd_get_user_data">fd_get_user_data</a></td>
<td class="ccode">uid_t id</td>
<td class="ccode">lisp</td>
</tr>
<tr>
<th></th>
<td>a uid</td>
<td>a lisp structure</td>
</tr>
<tr>
<th></th>
<td><em>Gets the user password data for a particular id</em></td>
<td></td>
</tr>
</table>
<h2><a name="fdprintf.c" id="fdprintf.c">Functions defined in
<tt>src/os/fdprintf.c</tt></a></h2>
<p><a href=
"#_fd_grow_string_stream"><tt>_fd_grow_string_stream</tt></a> |
<a href="#_fd_sputc"><tt>_fd_sputc</tt></a> | <a href=
"#_fd_sputn"><tt>_fd_sputn</tt></a> | <a href=
"#_fd_sputs"><tt>_fd_sputs</tt></a> | <a href=
"#fd_default_notifier"><tt>fd_default_notifier</tt></a> | <a href=
"#fd_fprintf"><tt>fd_fprintf</tt></a> | <a href=
"#fd_notify"><tt>fd_notify</tt></a> | <a href=
"#fd_printf"><tt>fd_printf</tt></a> | <a href=
"#fd_set_notify_handler"><tt>fd_set_notify_handler</tt></a> |
<a href="#fd_set_warn_handler"><tt>fd_set_warn_handler</tt></a> |
<a href="#fd_warn"><tt>fd_warn</tt></a> | <a href=
"#fd_xprintf"><tt>fd_xprintf</tt></a> |</p>
<table cellpadding="5">
<tr>
<th align="left">Function</th>
<th align="left">Arguments</th>
<th align="left">Returns</th>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name=
"fd_default_notifier" id=
"fd_default_notifier">fd_default_notifier</a></td>
<td class="ccode">fd_u8char *message</td>
<td class="ccode">void</td>
</tr>
<tr>
<th></th>
<td>a string</td>
<td>void</td>
</tr>
<tr>
<th></th>
<td><em>This is the default notification function, which outputs a
bracketed time and report.</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name="_fd_sputc" id=
"_fd_sputc">_fd_sputc</a></td>
<td class="ccode">fd_string_stream ss,int ch</td>
<td class="ccode">void</td>
</tr>
<tr>
<th></th>
<td>a pointer to a string stream and a unicode character</td>
<td>void</td>
</tr>
<tr>
<th></th>
<td><em>Writes the utf8 representation of the character to the
string stream.</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name="fd_xprintf"
id="fd_xprintf">fd_xprintf</a></td>
<td class="ccode">char *format_string,...</td>
<td class="ccode">void</td>
</tr>
<tr>
<th></th>
<td>a format string, and other args</td>
<td>void</td>
</tr>
<tr>
<th></th>
<td><em>Outputs a string as exceptional I/O generated from the
format string and using the provided arguments. Much like printf
(surprise).</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name="fd_fprintf"
id="fd_fprintf">fd_fprintf</a></td>
<td class="ccode">FILE *f,char *fstring,...</td>
<td class="ccode">void</td>
</tr>
<tr>
<th></th>
<td>a FILE * stream, a format string, and other args</td>
<td>void</td>
</tr>
<tr>
<th></th>
<td><em>Outputs a string to a file stream generated from the format
string and using the provided arguments. Much like printf
(surprise).</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name="_fd_sputn" id=
"_fd_sputn">_fd_sputn</a></td>
<td class="ccode">fd_string_stream ss,fd_u8char *string,int n</td>
<td class="ccode">void</td>
</tr>
<tr>
<th></th>
<td>a pointer to a string stream, a utf8 string, and an int</td>
<td>void</td>
</tr>
<tr>
<th></th>
<td><em>Internal string stream string putn function, used in macro
ssputn</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name="fd_notify" id=
"fd_notify">fd_notify</a></td>
<td class="ccode">char *format_string,...</td>
<td class="ccode">void</td>
</tr>
<tr>
<th></th>
<td>a FILE * stream, a format string, and other args</td>
<td>void</td>
</tr>
<tr>
<th></th>
<td><em>Outputs a string as a notification, which is generated from
the format string and using the provided arguments. Much like
printf (surprise).</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name="_fd_sputs" id=
"_fd_sputs">_fd_sputs</a></td>
<td class="ccode">fd_string_stream ss,fd_u8char *string</td>
<td class="ccode">void</td>
</tr>
<tr>
<th></th>
<td>a pointer to a string stream and a utf8 string</td>
<td>void</td>
</tr>
<tr>
<th></th>
<td><em>Internal string stream string put function, used in macro
ssputs</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name="fd_printf" id=
"fd_printf">fd_printf</a></td>
<td class="ccode">fd_string_stream s,char *format_string,...</td>
<td class="ccode">void</td>
</tr>
<tr>
<th></th>
<td>a string stream, a format string, and other args</td>
<td>void</td>
</tr>
<tr>
<th></th>
<td><em>Outputs a string to string stream generated from the format
string and using the provided arguments. Much like printf
(surprise).</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name=
"fd_set_notify_handler" id=
"fd_set_notify_handler">fd_set_notify_handler</a></td>
<td class="ccode">void (*nf</td>
<td class="ccode">void</td>
</tr>
<tr>
<th></th>
<td>a function taking a string arg</td>
<td>void</td>
</tr>
<tr>
<th></th>
<td><em>Sets the function which is called on notification
messages</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name="fd_warn" id=
"fd_warn">fd_warn</a></td>
<td class="ccode">char *format_string,...</td>
<td class="ccode">void</td>
</tr>
<tr>
<th></th>
<td>a FILE * stream, a format string, and other args</td>
<td>void</td>
</tr>
<tr>
<th></th>
<td><em>Outputs a string as a warning, which is generated from the
format string and using the provided arguments. Much like printf
(surprise). Note that notifications can be turned off but warnings
cannot.</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name=
"_fd_grow_string_stream" id=
"_fd_grow_string_stream">_fd_grow_string_stream</a></td>
<td class="ccode">fd_string_stream ss,int delta</td>
<td class="ccode">void</td>
</tr>
<tr>
<th></th>
<td>a pointer to a string stream and a number of bytes</td>
<td>void</td>
</tr>
<tr>
<th></th>
<td><em>Grows the data structures for the string stream to include
delta more bytes</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name=
"fd_set_warn_handler" id=
"fd_set_warn_handler">fd_set_warn_handler</a></td>
<td class="ccode">void (*wf</td>
<td class="ccode">void</td>
</tr>
<tr>
<th></th>
<td>a function taking a string arg</td>
<td>void</td>
</tr>
<tr>
<th></th>
<td><em>Sets the function which is called on warning
messages</em></td>
<td></td>
</tr>
</table>
<h2><a name="timefns.c" id="timefns.c">Functions defined in
<tt>src/os/timefns.c</tt></a></h2>
<p><a href="#fd_breakup_time"><tt>fd_breakup_time</tt></a> |
<a href="#fd_get_now"><tt>fd_get_now</tt></a> | <a href=
"#fd_init_xtime"><tt>fd_init_xtime</tt></a> | <a href=
"#fd_iso8601_to_xtime"><tt>fd_iso8601_to_xtime</tt></a> | <a href=
"#fd_localtime"><tt>fd_localtime</tt></a> | <a href=
"#fd_mktime"><tt>fd_mktime</tt></a> | <a href=
"#fd_parse_iso8601"><tt>fd_parse_iso8601</tt></a> | <a href=
"#fd_parse_tzspec"><tt>fd_parse_tzspec</tt></a> | <a href=
"#fd_sleep"><tt>fd_sleep</tt></a> | <a href=
"#fd_timestamp_time"><tt>fd_timestamp_time</tt></a> | <a href=
"#fd_timestamp_to_xtime"><tt>fd_timestamp_to_xtime</tt></a> |
<a href="#fd_xtime_to_iso8601"><tt>fd_xtime_to_iso8601</tt></a> |
<a href="#fd_xtime_to_timestamp"><tt>fd_xtime_to_timestamp</tt></a>
|</p>
<table cellpadding="5">
<tr>
<th align="left">Function</th>
<th align="left">Arguments</th>
<th align="left">Returns</th>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name="fd_init_xtime"
id="fd_init_xtime">fd_init_xtime</a></td>
<td class="ccode">struct FD_XTIME *xtp</td>
<td class="ccode">void</td>
</tr>
<tr>
<th></th>
<td>a pointer to an extended timestamp structure</td>
<td>void</td>
</tr>
<tr>
<th></th>
<td><em>This takes a timestamp object and fills out an extended
time pointer structure which includes timezone and precision
information.</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name=
"fd_parse_tzspec" id="fd_parse_tzspec">fd_parse_tzspec</a></td>
<td class="ccode">char *s,int dflt</td>
<td class="ccode">int</td>
</tr>
<tr>
<th></th>
<td>a string and a default offset</td>
<td>an offset from UTC</td>
</tr>
<tr>
<th></th>
<td><em>This uses a built in table but should really use operating
system facilities if they were even remotely
standardized.</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name="fd_sleep" id=
"fd_sleep">fd_sleep</a></td>
<td class="ccode">double secs</td>
<td class="ccode">void</td>
</tr>
<tr>
<th></th>
<td>an interval in seconds (a double)</td>
<td>nothing</td>
</tr>
<tr>
<th></th>
<td><em>This is a platform abstraction for sleeping that *may*
allow sub-second sleeps.</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name="fd_mktime" id=
"fd_mktime">fd_mktime</a></td>
<td class="ccode">struct tm *tptr,int tzoff</td>
<td class="ccode">time_t</td>
</tr>
<tr>
<th></th>
<td>a pointer to a tm struct and a time offset (from UTC) in
seconds</td>
<td>a time_t pointer</td>
</tr>
<tr>
<th></th>
<td><em>Returns the UTC time given a filled out tm structure and
the offset of the zone it was filled out in from UTC.</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name=
"fd_breakup_time" id="fd_breakup_time">fd_breakup_time</a></td>
<td class="ccode">struct tm *tptr,time_t tick,int tzoff</td>
<td class="ccode">int</td>
</tr>
<tr>
<th></th>
<td>a pointer to a tm struct, a time_t value, and an offset</td>
<td>an integral timezone offset</td>
</tr>
<tr>
<th></th>
<td><em>Fills the tm struct with the broken down UTC time based on
the time_t value. This is threadsafe, locking the possible shared
tptr.</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name=
"fd_timestamp_time" id=
"fd_timestamp_time">fd_timestamp_time</a></td>
<td class="ccode">lisp timestamp</td>
<td class="ccode">time_t</td>
</tr>
<tr>
<th></th>
<td>a lisp pointer to a timestamp</td>
<td>a time_t value</td>
</tr>
<tr>
<th></th>
<td></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name=
"fd_xtime_to_timestamp" id=
"fd_xtime_to_timestamp">fd_xtime_to_timestamp</a></td>
<td class="ccode">struct FD_XTIME *xtp</td>
<td class="ccode">fd_lisp</td>
</tr>
<tr>
<th></th>
<td>a string and a pointer to a timestamp structure</td>
<td>-1 on error, the time as a time_t otherwise</td>
</tr>
<tr>
<th></th>
<td><em>This takes an iso8601 string and fills out an extended time
pointer which includes possible timezone and precision
information.</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name=
"fd_iso8601_to_xtime" id=
"fd_iso8601_to_xtime">fd_iso8601_to_xtime</a></td>
<td class="ccode">char *s,struct FD_XTIME *xtp</td>
<td class="ccode">time_t</td>
</tr>
<tr>
<th></th>
<td>a string and a pointer to a timestamp structure</td>
<td>-1 on error, the time as a time_t otherwise</td>
</tr>
<tr>
<th></th>
<td><em>This takes an iso8601 string and fills out an extended time
pointer which includes possible timezone and precision
information.</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name=
"fd_parse_iso8601" id="fd_parse_iso8601">fd_parse_iso8601</a></td>
<td class="ccode">char *string</td>
<td class="ccode">time_t</td>
</tr>
<tr>
<th></th>
<td>a string</td>
<td>a time_t</td>
</tr>
<tr>
<th></th>
<td><em>Parses an iso8601 format date/time string into a time_t
value.</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name=
"fd_timestamp_to_xtime" id=
"fd_timestamp_to_xtime">fd_timestamp_to_xtime</a></td>
<td class="ccode">fd_lisp timestamp,struct FD_XTIME *xtp</td>
<td class="ccode">time_t</td>
</tr>
<tr>
<th></th>
<td>a lisp pointer to a timestamp and a pointer to a timestamp
structure</td>
<td>-1 on error, the time as a time_t otherwise</td>
</tr>
<tr>
<th></th>
<td><em>This takes a timestamp object and fills out an extended
time pointer structure which includes timezone and precision
information.</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name=
"fd_xtime_to_iso8601" id=
"fd_xtime_to_iso8601">fd_xtime_to_iso8601</a></td>
<td class="ccode">struct FD_XTIME *xtp,fd_string_stream ss</td>
<td class="ccode">int</td>
</tr>
<tr>
<th></th>
<td>a timestamp and a pointer to a string stream</td>
<td>-1 on error, the time as a time_t otherwise</td>
</tr>
<tr>
<th></th>
<td><em>This takes an iso8601 string and fills out an extended time
pointer which includes possible timezone and precision
information.</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name="fd_get_now"
id="fd_get_now">fd_get_now</a></td>
<td class="ccode">struct FD_XTIME *xtp</td>
<td class="ccode">time_t</td>
</tr>
<tr>
<th></th>
<td>a pointer to an extended time pointer</td>
<td>a time_t or -1 if it fails for some reason</td>
</tr>
<tr>
<th></th>
<td><em>This will try and get the finest precision time it
can.</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name="fd_localtime"
id="fd_localtime">fd_localtime</a></td>
<td class="ccode">struct tm *tptr,time_t tick</td>
<td class="ccode">int</td>
</tr>
<tr>
<th></th>
<td>a pointer to a tm struct and a time_t value</td>
<td>the time_t value or -1 if it failed</td>
</tr>
<tr>
<th></th>
<td><em>Fills the tm struct with the local time based on the time_t
value. This is threadsafe, since localtime is not.</em></td>
<td></td>
</tr>
</table>
<h2><a name="except.c" id="except.c">Functions defined in
<tt>src/os/except.c</tt></a></h2>
<p><a href="#_fd_push_jbr"><tt>_fd_push_jbr</tt></a> | <a href=
"#fd_ctype_error"><tt>fd_ctype_error</tt></a> | <a href=
"#fd_exception_context"><tt>fd_exception_context</tt></a> |
<a href="#fd_exception_context_push"><tt>fd_exception_context_push</tt></a>
| <a href="#fd_pigs_fly"><tt>fd_pigs_fly</tt></a> | <a href=
"#fd_raise_detailed_exception"><tt>fd_raise_detailed_exception</tt></a>
| <a href="#fd_raise_exception"><tt>fd_raise_exception</tt></a> |
<a href=
"#fd_raise_lisp_exception"><tt>fd_raise_lisp_exception</tt></a> |
<a href="#fd_record_type_error"><tt>fd_record_type_error</tt></a> |
<a href="#fd_set_exception"><tt>fd_set_exception</tt></a> |
<a href="#fd_throw"><tt>fd_throw</tt></a> | <a href=
"#fd_type_error"><tt>fd_type_error</tt></a> |</p>
<table cellpadding="5">
<tr>
<th align="left">Function</th>
<th align="left">Arguments</th>
<th align="left">Returns</th>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name=
"fd_raise_detailed_exception" id=
"fd_raise_detailed_exception">fd_raise_detailed_exception</a></td>
<td class="ccode">fd_exception ex,char *details</td>
<td class="ccode">void</td>
</tr>
<tr>
<th></th>
<td>an exception (a string) and details (another string)</td>
<td>no.</td>
</tr>
<tr>
<th></th>
<td><em>Raises an exception of a particular kind with particular
details used in generating exception reports Unhandled crises cause
an exit by calling unhandled_exception.</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name=
"fd_raise_lisp_exception" id=
"fd_raise_lisp_exception">fd_raise_lisp_exception</a></td>
<td class="ccode">fd_exception ex,char *details,lisp obj</td>
<td class="ccode">void</td>
</tr>
<tr>
<th></th>
<td>an exception (a string), details (another string), and a lisp
object</td>
<td>no.</td>
</tr>
<tr>
<th></th>
<td><em>Raises an exception of a particular kind with particular
details used in generating exception reports and an associated lisp
object (the irritant) Unhandled crises cause an exit by calling
unhandled_exception.</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name=
"fd_raise_exception" id=
"fd_raise_exception">fd_raise_exception</a></td>
<td class="ccode">fd_exception ex</td>
<td class="ccode">void</td>
</tr>
<tr>
<th></th>
<td>an exception (a string)</td>
<td>no.</td>
</tr>
<tr>
<th></th>
<td><em>Raises an exception of a particular kind without providing
any other information. Unhandled crises cause an exit by calling
unhandled_exception.</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name=
"fd_set_exception" id="fd_set_exception">fd_set_exception</a></td>
<td class="ccode">fd_exception ex,fd_u8char *details,lisp
object</td>
<td class="ccode">void</td>
</tr>
<tr>
<th></th>
<td>an exception (a string), a details string, and a lisp
object</td>
<td>nothing</td>
</tr>
<tr>
<th></th>
<td><em>Set's the current threads exception information.</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name=
"fd_exception_context" id=
"fd_exception_context">fd_exception_context</a></td>
<td class="ccode">int force</td>
<td class="ccode">struct FD_EXCEPTION_CONTEXT *</td>
</tr>
<tr>
<th></th>
<td>none</td>
<td>a pointer to a FD_EXCEPTION_CONTEXT struct</td>
</tr>
<tr>
<th></th>
<td></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name=
"fd_ctype_error" id="fd_ctype_error">fd_ctype_error</a></td>
<td class="ccode">char *c_context,fd_u8char *details,lisp obj</td>
<td class="ccode">void</td>
</tr>
<tr>
<th></th>
<td>details text (a string), and a lisp object</td>
<td>no.</td>
</tr>
<tr>
<th></th>
<td><em>Raises a type error with particular details and an
object.</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name=
"fd_record_type_error" id=
"fd_record_type_error">fd_record_type_error</a></td>
<td class="ccode">lisp obj,lisp tag</td>
<td class="ccode">void</td>
</tr>
<tr>
<th></th>
<td>details text (a string), and a lisp object</td>
<td>no.</td>
</tr>
<tr>
<th></th>
<td><em>Raises a type error with particular details and an
object.</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name="fd_pigs_fly"
id="fd_pigs_fly">fd_pigs_fly</a></td>
<td class="ccode">fd_u8char *details</td>
<td class="ccode">void</td>
</tr>
<tr>
<th></th>
<td>details text (a string)</td>
<td>no.</td>
</tr>
<tr>
<th></th>
<td><em>This is used to signal errors which should never
happen.</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name="_fd_push_jbr"
id="_fd_push_jbr">_fd_push_jbr</a></td>
<td class="ccode">fd_setjmp_rec *jbr</td>
<td class="ccode">void</td>
</tr>
<tr>
<th></th>
<td>a setjmp record</td>
<td>void</td>
</tr>
<tr>
<th></th>
<td><em>Adds an entry to the exception handling stack for a
particular setmp location</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name="fd_type_error"
id="fd_type_error">fd_type_error</a></td>
<td class="ccode">fd_u8char *details,lisp obj</td>
<td class="ccode">void</td>
</tr>
<tr>
<th></th>
<td>details text (a string), and a lisp object</td>
<td>no.</td>
</tr>
<tr>
<th></th>
<td><em>Raises a type error with particular details and an
object.</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name=
"fd_exception_context_push" id=
"fd_exception_context_push">fd_exception_context_push</a></td>
<td class="ccode">lisp sym</td>
<td class="ccode">void</td>
</tr>
<tr>
<th></th>
<td>a lisp pointer</td>
<td>void</td>
</tr>
<tr>
<th></th>
<td><em>Adds a value to the current exception context</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name="fd_throw" id=
"fd_throw">fd_throw</a></td>
<td class="ccode">fd_exception ex,char *details,lisp obj</td>
<td class="ccode">void</td>
</tr>
<tr>
<th></th>
<td>an exception (a string), details (another string), and a lisp
object</td>
<td>no.</td>
</tr>
<tr>
<th></th>
<td><em>Throws an exception, with particular details and irritant.
This is used when the exception is expected to be caught, as in the
use of exceptions to implement continuation. This is identical to
fd_raise_lisp_exception but that debuggers may often break on
fd_raise_lisp_exception and not on fd_throw.</em></td>
<td></td>
</tr>
</table>
<h2><a name="network.c" id="network.c">Functions defined in
<tt>src/os/network.c</tt></a></h2>
<p><a href="#fd_careful_dtcall"><tt>fd_careful_dtcall</tt></a> |
<a href="#fd_careful_dtype_eval"><tt>fd_careful_dtype_eval</tt></a>
| <a href="#fd_close_connection"><tt>fd_close_connection</tt></a> |
<a href="#fd_connect"><tt>fd_connect</tt></a> | <a href=
"#fd_dtcall"><tt>fd_dtcall</tt></a> | <a href=
"#fd_dtype_eval"><tt>fd_dtype_eval</tt></a> | <a href=
"#fd_get_portno"><tt>fd_get_portno</tt></a> | <a href=
"#fd_http_get"><tt>fd_http_get</tt></a> | <a href=
"#fd_http_head"><tt>fd_http_head</tt></a> | <a href=
"#fd_http_string"><tt>fd_http_string</tt></a> | <a href=
"#fd_init_connection"><tt>fd_init_connection</tt></a> | <a href=
"#fd_open_connection"><tt>fd_open_connection</tt></a> | <a href=
"#fd_open_local_socket"><tt>fd_open_local_socket</tt></a> |
<a href="#fd_open_tcp_socket"><tt>fd_open_tcp_socket</tt></a> |
<a href="#fd_read_from_socket"><tt>fd_read_from_socket</tt></a> |
<a href="#fd_send_smtp_mail"><tt>fd_send_smtp_mail</tt></a> |
<a href="#fd_sendall"><tt>fd_sendall</tt></a> | <a href=
"#fd_timed_recv"><tt>fd_timed_recv</tt></a> | <a href=
"#fd_trace_dteval"><tt>fd_trace_dteval</tt></a> | <a href=
"#fd_try_to_connect"><tt>fd_try_to_connect</tt></a> |</p>
<table cellpadding="5">
<tr>
<th align="left">Function</th>
<th align="left">Arguments</th>
<th align="left">Returns</th>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name="fd_dtype_eval"
id="fd_dtype_eval">fd_dtype_eval</a></td>
<td class="ccode">lisp expr,fd_server s</td>
<td class="ccode">lisp</td>
</tr>
<tr>
<th></th>
<td>a lisp object and a server</td>
<td>a lisp object</td>
</tr>
<tr>
<th></th>
<td><em>Asks the server to evaluate the lisp object, returning the
result and trying to restart the connection once if
neccessary.</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name="fd_sendall"
id="fd_sendall">fd_sendall</a></td>
<td class="ccode">int socket,char *buf,int size,int flags</td>
<td class="ccode">int</td>
</tr>
<tr>
<th></th>
<td>a socket, a pointer to a block of data, the length of the block
of data, and flags to pass to send()</td>
<td>either zero or -1 (indictating an error)</td>
</tr>
<tr>
<th></th>
<td><em>This sends all of the bytes in a block of data, repeatedly
calling send(). This will return -1, indicating a failure, if the
attempt to write times out.</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name=
"fd_init_connection" id=
"fd_init_connection">fd_init_connection</a></td>
<td class="ccode">fd_server server,char *dest,int port,char
*id</td>
<td class="ccode">void</td>
</tr>
<tr>
<th></th>
<td>a pointer to an FD_SERVER struct, a host (a string), a port (an
int), and an id (a string or NULL)</td>
<td>nothing</td>
</tr>
<tr>
<th></th>
<td><em>Initializations a TCP/IP connection structure.</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name="fd_dtcall" id=
"fd_dtcall">fd_dtcall</a></td>
<td class="ccode">fd_server s,char *fcn,...</td>
<td class="ccode">lisp</td>
</tr>
<tr>
<th></th>
<td>a server, a function name (a string), and a number of args
ending with FD_VOID</td>
<td>a lisp object</td>
</tr>
<tr>
<th></th>
<td><em>Asks the server to apply the named function to the args,
returning the result. It calls fd_dtype_eval. The arguments are
quoted before being passed.</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name=
"fd_try_to_connect" id=
"fd_try_to_connect">fd_try_to_connect</a></td>
<td class="ccode">char *spec</td>
<td class="ccode">fd_server</td>
</tr>
<tr>
<th></th>
<td>a string identifying a server</td>
<td>a server</td>
</tr>
<tr>
<th></th>
<td><em>Tries to make a connection to a particular server,
returning NULL if it fails. The server identification has the form
port@host, where port is either a registered service or is
'touch-tone' encoded to a port number</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name=
"fd_send_smtp_mail" id=
"fd_send_smtp_mail">fd_send_smtp_mail</a></td>
<td class="ccode">char *dest,char *text,lisp fields</td>
<td class="ccode">void</td>
</tr>
<tr>
<th></th>
<td>a destination (a string), a contents (a string), and a set of
fields (a lisp object)</td>
<td>nothing</td>
</tr>
<tr>
<th></th>
<td><em>Uses a local SMTP connection to send mail to a particular
individual with a particular set of fields and a particular
contents.</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name=
"fd_open_tcp_socket" id=
"fd_open_tcp_socket">fd_open_tcp_socket</a></td>
<td class="ccode">char *hostname,int port,char *id,int
signal_error,char **fullname</td>
<td class="ccode">int</td>
</tr>
<tr>
<th></th>
<td>a hostname (a string) and a port (an int) and an id (a string)
and an error flag (an int)</td>
<td>an open socket</td>
</tr>
<tr>
<th></th>
<td><em>This utility function gets an open TCP socket for a host
and port.</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name=
"fd_close_connection" id=
"fd_close_connection">fd_close_connection</a></td>
<td class="ccode">fd_server s</td>
<td class="ccode">void</td>
</tr>
<tr>
<th></th>
<td>a server</td>
<td>nothing</td>
</tr>
<tr>
<th></th>
<td><em>Closes the connection to server. This just does a close on
the socket and nothing clever to ensure that pending transactions
are completed (though they should throw out and restart).</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name=
"fd_careful_dtcall" id=
"fd_careful_dtcall">fd_careful_dtcall</a></td>
<td class="ccode">fd_server s,char *fcn,...</td>
<td class="ccode">lisp</td>
</tr>
<tr>
<th></th>
<td>a server, a function name (a string), and a number of args
ending with FD_VOID</td>
<td>a lisp object</td>
</tr>
<tr>
<th></th>
<td><em>Like fd_dtcall, but signals an error when the remote server
returns an error object.</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name="fd_timed_recv"
id="fd_timed_recv">fd_timed_recv</a></td>
<td class="ccode">int secs,int socket_id,char *data,int len,int
flags</td>
<td class="ccode">int</td>
</tr>
<tr>
<th></th>
<td>an interval in seconds (an int), an open socket, a pointer to a
block of data, a number of bytes, and some flags (an int) for
recv()</td>
<td>the number of bytes read or -1 on error</td>
</tr>
<tr>
<th></th>
<td><em>Tries to read bytes from a connection, returning -1 if the
connection times out.</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name="fd_connect"
id="fd_connect">fd_connect</a></td>
<td class="ccode">char *spec</td>
<td class="ccode">fd_server</td>
</tr>
<tr>
<th></th>
<td>a string identifying a server</td>
<td>a server</td>
</tr>
<tr>
<th></th>
<td><em>Makes a connection to a particular server, signalling an
error if a connection cannot be made. The server identification has
the form port@host, where port is either a registered service or is
'touch-tone' encoded to a port number</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name="fd_http_get"
id="fd_http_get">fd_http_get</a></td>
<td class="ccode">char *url,int *sizep</td>
<td class="ccode">char *</td>
</tr>
<tr>
<th></th>
<td>a string and a pointer to an int</td>
<td>a string (actually a pointer to a byte array)</td>
</tr>
<tr>
<th></th>
<td><em>Gets the contents of a remote URL as a character string,
storing the size in the second argument (if non-NULL)</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name=
"fd_open_local_socket" id=
"fd_open_local_socket">fd_open_local_socket</a></td>
<td class="ccode">char *filename,char *id,int signal_error</td>
<td class="ccode">int</td>
</tr>
<tr>
<th></th>
<td>a filename (a string) and a server id (a string) and an error
flag (an int)</td>
<td>an open socket</td>
</tr>
<tr>
<th></th>
<td><em>This utility function gets an open socket for a local
filenname.</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name="fd_http_head"
id="fd_http_head">fd_http_head</a></td>
<td class="ccode">char *url,int *sizep</td>
<td class="ccode">char *</td>
</tr>
<tr>
<th></th>
<td>a string and a pointer to an int</td>
<td>a string (actually a pointer to a byte array)</td>
</tr>
<tr>
<th></th>
<td><em>Gets the head of a remote URL as a character
string</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name=
"fd_open_connection" id=
"fd_open_connection">fd_open_connection</a></td>
<td class="ccode">char *name,int port,char *id</td>
<td class="ccode">fd_server</td>
</tr>
<tr>
<th></th>
<td>a name (a string), a port (an int) and an id (a string)</td>
<td>a server (a pointer to a FD_SERVER struct)</td>
</tr>
<tr>
<th></th>
<td><em>Looks for a current connection to port@hostname and creates
one if it doesn't exist.</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name=
"fd_read_from_socket" id=
"fd_read_from_socket">fd_read_from_socket</a></td>
<td class="ccode">struct FD_DBUF *buf,int socket</td>
<td class="ccode">void</td>
</tr>
<tr>
<th></th>
<td>a pointer to an FD_DBUF struct and a socket</td>
<td>nothing (void)</td>
</tr>
<tr>
<th></th>
<td><em>This fills the expandable FD_DBUF struct with bytes read
from socket, stopping when recv() return 0 or the call to recv
times out.</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name=
"fd_careful_dtype_eval" id=
"fd_careful_dtype_eval">fd_careful_dtype_eval</a></td>
<td class="ccode">lisp expr,fd_server s</td>
<td class="ccode">lisp</td>
</tr>
<tr>
<th></th>
<td>a lisp object and a server</td>
<td>a lisp object</td>
</tr>
<tr>
<th></th>
<td><em>Like fd_dtype_eval but signals an error if the remote
server returns an error or exception object.</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name="fd_get_portno"
id="fd_get_portno">fd_get_portno</a></td>
<td class="ccode">char *string</td>
<td class="ccode">int</td>
</tr>
<tr>
<th></th>
<td>a string</td>
<td>an integer</td>
</tr>
<tr>
<th></th>
<td><em>Returns the port number identified by a particular string,
starting with the service database and doing touch-tone encoding if
that fails.</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name=
"fd_trace_dteval" id="fd_trace_dteval">fd_trace_dteval</a></td>
<td class="ccode">int flag</td>
<td class="ccode">int</td>
</tr>
<tr>
<th></th>
<td>1 or 0</td>
<td>1 or 0</td>
</tr>
<tr>
<th></th>
<td><em>Turns on tracing of all remote DTYPE evaluation
activity.</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name=
"fd_http_string" id="fd_http_string">fd_http_string</a></td>
<td class="ccode">char *url</td>
<td class="ccode">char *</td>
</tr>
<tr>
<th></th>
<td>a string</td>
<td>a string (actually a pointer to a byte array)</td>
</tr>
<tr>
<th></th>
<td><em>Gets the contents of a remote URL as a character string,
storing the size in the second argument</em></td>
<td></td>
</tr>
</table>
<h2><a name="filefns.c" id="filefns.c">Functions defined in
<tt>src/os/filefns.c</tt></a></h2>
<p><a href="#fd_directoryp"><tt>fd_directoryp</tt></a> | <a href=
"#fd_fclose"><tt>fd_fclose</tt></a> | <a href=
"#fd_file_existsp"><tt>fd_file_existsp</tt></a> | <a href=
"#fd_file_size"><tt>fd_file_size</tt></a> | <a href=
"#fd_file_writablep"><tt>fd_file_writablep</tt></a> | <a href=
"#fd_find_file"><tt>fd_find_file</tt></a> | <a href=
"#fd_fopen"><tt>fd_fopen</tt></a> | <a href=
"#fd_fopen_locked"><tt>fd_fopen_locked</tt></a> | <a href=
"#fd_get_exec_filename"><tt>fd_get_exec_filename</tt></a> |
<a href="#fd_getpath"><tt>fd_getpath</tt></a> | <a href=
"#fd_regular_filep"><tt>fd_regular_filep</tt></a> | <a href=
"#fd_symbolic_linkp"><tt>fd_symbolic_linkp</tt></a> |</p>
<table cellpadding="5">
<tr>
<th align="left">Function</th>
<th align="left">Arguments</th>
<th align="left">Returns</th>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name="fd_file_size"
id="fd_file_size">fd_file_size</a></td>
<td class="ccode">fd_u8char *path</td>
<td class="ccode">off_t</td>
</tr>
<tr>
<th></th>
<td>a string</td>
<td>a long</td>
</tr>
<tr>
<th></th>
<td><em>Returns the size of a file</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name="fd_fclose" id=
"fd_fclose">fd_fclose</a></td>
<td class="ccode">FILE *stream</td>
<td class="ccode">void</td>
</tr>
<tr>
<th></th>
<td>a filename</td>
<td>a FILE * pointer</td>
</tr>
<tr>
<th></th>
<td><em>Closes the stream and cleans up XFILEs associated with
it</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name="fd_getpath"
id="fd_getpath">fd_getpath</a></td>
<td class="ccode">fd_u8char *name</td>
<td class="ccode">lisp</td>
</tr>
<tr>
<th></th>
<td>a string naming an extended environment variable</td>
<td>a lisp pointer to a list of directories</td>
</tr>
<tr>
<th></th>
<td><em>Interprets a path variable</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name=
"fd_symbolic_linkp" id=
"fd_symbolic_linkp">fd_symbolic_linkp</a></td>
<td class="ccode">fd_u8char *path</td>
<td class="ccode">int</td>
</tr>
<tr>
<th></th>
<td>a string</td>
<td>1 or 0</td>
</tr>
<tr>
<th></th>
<td><em>Returns 1 if the file is a symbolic link to another file
(currently always zero under WIN32).</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name=
"fd_get_exec_filename" id=
"fd_get_exec_filename">fd_get_exec_filename</a></td>
<td class="ccode">char *argv0</td>
<td class="ccode">char *</td>
</tr>
<tr>
<th></th>
<td>a string, typicallying argv[0]</td>
<td>a malloc'd absolute filename or NULL</td>
</tr>
<tr>
<th></th>
<td><em>Attempts to figure out the absolute pathname of an
executable from the argv[0] parameter. Used to find the FramerD
configuration file.</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name=
"fd_fopen_locked" id="fd_fopen_locked">fd_fopen_locked</a></td>
<td class="ccode">fd_u8char *filename,char *mode,int
allow_readers</td>
<td class="ccode">FILE *</td>
</tr>
<tr>
<th></th>
<td>a filename, a mode specifier, and a flag (1 or 0)</td>
<td>a FILE * pointer</td>
</tr>
<tr>
<th></th>
<td><em>Normalizes the filename for the OS and locks the returned
stream (using fcntl). If the integer flag is 1, the lock is only a
write lock. If it is 0, neither reads nor writes are
permitted.</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name="fd_find_file"
id="fd_find_file">fd_find_file</a></td>
<td class="ccode">fd_u8char *filename,lisp search_path</td>
<td class="ccode">fd_u8char *</td>
</tr>
<tr>
<th></th>
<td>a string and a lisp pointer</td>
<td>another string</td>
</tr>
<tr>
<th></th>
<td><em>The lisp pointer is used as a search path to look for
files. It first checks to see if the string exists as a file as
given. It then searches along the directories in the search path.
The search path can be a string (taken as a directory name) or a
list of strings take as directory names. It allocates a string for
a result (but doesn't count it as fd_mallocd).</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name="fd_directoryp"
id="fd_directoryp">fd_directoryp</a></td>
<td class="ccode">fd_u8char *path</td>
<td class="ccode">int</td>
</tr>
<tr>
<th></th>
<td>a string</td>
<td>1 or 0</td>
</tr>
<tr>
<th></th>
<td><em>Returns 1 if the file is actually a directory.</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name=
"fd_file_writablep" id=
"fd_file_writablep">fd_file_writablep</a></td>
<td class="ccode">fd_u8char *filename</td>
<td class="ccode">int</td>
</tr>
<tr>
<th></th>
<td>a string</td>
<td>1 or 0</td>
</tr>
<tr>
<th></th>
<td><em>Returns 1 if the file can be written (whether it exists or
not), 0 otherwise. Actually opens it to try, rather than doing
something clever with stat.</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name=
"fd_regular_filep" id="fd_regular_filep">fd_regular_filep</a></td>
<td class="ccode">fd_u8char *path</td>
<td class="ccode">int</td>
</tr>
<tr>
<th></th>
<td>a string</td>
<td>1 or 0</td>
</tr>
<tr>
<th></th>
<td><em>Returns 1 if the file is a regular file.</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name=
"fd_file_existsp" id="fd_file_existsp">fd_file_existsp</a></td>
<td class="ccode">fd_u8char *fname</td>
<td class="ccode">int</td>
</tr>
<tr>
<th></th>
<td>a string</td>
<td>1 or 0</td>
</tr>
<tr>
<th></th>
<td><em>Returns 1 if the file exists, 0 otherwise. Uses
stat.</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name="fd_fopen" id=
"fd_fopen">fd_fopen</a></td>
<td class="ccode">fd_u8char *filename,char *mode</td>
<td class="ccode">FILE *</td>
</tr>
<tr>
<th></th>
<td>a filename and a mode specifier</td>
<td>a FILE * pointer</td>
</tr>
<tr>
<th></th>
<td><em>Normalizes the filename for the OS</em></td>
<td></td>
</tr>
</table>
<h2><a name="i18n.c" id="i18n.c">Functions defined in
<tt>src/os/i18n.c</tt></a></h2>
<p><a href="#fd_convert_utf8"><tt>fd_convert_utf8</tt></a> |
<a href="#fd_define_encoding"><tt>fd_define_encoding</tt></a> |
<a href="#fd_downcase_string"><tt>fd_downcase_string</tt></a> |
<a href="#fd_fgetc"><tt>fd_fgetc</tt></a> | <a href=
"#fd_foreign_filestring"><tt>fd_foreign_filestring</tt></a> |
<a href="#fd_fputc"><tt>fd_fputc</tt></a> | <a href=
"#fd_fputs_encoded"><tt>fd_fputs_encoded</tt></a> | <a href=
"#fd_fputs_raw"><tt>fd_fputs_raw</tt></a> | <a href=
"#fd_free_xfile"><tt>fd_free_xfile</tt></a> | <a href=
"#fd_get_encoding"><tt>fd_get_encoding</tt></a> | <a href=
"#fd_get_file_encoding"><tt>fd_get_file_encoding</tt></a> |
<a href="#fd_get_xfile"><tt>fd_get_xfile</tt></a> | <a href=
"#fd_interpret_unicode_escapes"><tt>fd_interpret_unicode_escapes</tt></a>
| <a href="#fd_load_encoding"><tt>fd_load_encoding</tt></a> |
<a href="#fd_localize_utf8"><tt>fd_localize_utf8</tt></a> |
<a href="#fd_make_utf8"><tt>fd_make_utf8</tt></a> | <a href=
"#fd_set_default_encoding"><tt>fd_set_default_encoding</tt></a> |
<a href="#fd_set_file_encoding"><tt>fd_set_file_encoding</tt></a> |
<a href=
"#fd_set_system_encoding"><tt>fd_set_system_encoding</tt></a> |
<a href="#fd_ungetc"><tt>fd_ungetc</tt></a> | <a href=
"#fd_upcase_string"><tt>fd_upcase_string</tt></a> | <a href=
"#fd_valid_utf8p"><tt>fd_valid_utf8p</tt></a> | <a href=
"#fd_xgetc"><tt>fd_xgetc</tt></a> | <a href=
"#fd_xgetc_encoded"><tt>fd_xgetc_encoded</tt></a> | <a href=
"#fd_xputc"><tt>fd_xputc</tt></a> | <a href=
"#fd_xputc_encoded"><tt>fd_xputc_encoded</tt></a> | <a href=
"#fd_xungetc"><tt>fd_xungetc</tt></a> |</p>
<table cellpadding="5">
<tr>
<th align="left">Function</th>
<th align="left">Arguments</th>
<th align="left">Returns</th>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name=
"fd_foreign_filestring" id=
"fd_foreign_filestring">fd_foreign_filestring</a></td>
<td class="ccode">char *filename,struct FD_TEXT_ENCODING *e</td>
<td class="ccode">lisp</td>
</tr>
<tr>
<th></th>
<td>a filename (a localized string) and a text encoding</td>
<td>a utf-8 string</td>
</tr>
<tr>
<th></th>
<td><em>Interprets the contents of the file according to the
encoding and returns a UTF-8 encoded unicode string.</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name=
"fd_upcase_string" id="fd_upcase_string">fd_upcase_string</a></td>
<td class="ccode">fd_u8char *string,int len</td>
<td class="ccode">fd_u8char *</td>
</tr>
<tr>
<th></th>
<td>a utf8 string</td>
<td>a copy of the argument converted to upper case</td>
</tr>
<tr>
<th></th>
<td></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name=
"fd_get_file_encoding" id=
"fd_get_file_encoding">fd_get_file_encoding</a></td>
<td class="ccode">FILE *f</td>
<td class="ccode">struct FD_TEXT_ENCODING *</td>
</tr>
<tr>
<th></th>
<td>a FILE pointer</td>
<td>a pointer to an encoding struct or NULL</td>
</tr>
<tr>
<th></th>
<td><em>Returns the encoding associated with a particular file
stream.</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name=
"fd_valid_utf8p" id="fd_valid_utf8p">fd_valid_utf8p</a></td>
<td class="ccode">fd_u8char *s</td>
<td class="ccode">int</td>
</tr>
<tr>
<th></th>
<td>a possible utf8 string</td>
<td>1 if the string is valid, 0 otherwise.</td>
</tr>
<tr>
<th></th>
<td></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name=
"fd_fputs_encoded" id="fd_fputs_encoded">fd_fputs_encoded</a></td>
<td class="ccode">fd_u8char *s,int len,FILE *f</td>
<td class="ccode">void</td>
</tr>
<tr>
<th></th>
<td>a utf8 string and a FILE pointer</td>
<td>nothing</td>
</tr>
<tr>
<th></th>
<td><em>Writes the contents of the string to the XFILE, writing
unhandled characters with unicode (\u and \U escapes).</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name="fd_fputc" id=
"fd_fputc">fd_fputc</a></td>
<td class="ccode">xchar c,FILE *f</td>
<td class="ccode">void</td>
</tr>
<tr>
<th></th>
<td>a wide char and a FILE pointer</td>
<td>void</td>
</tr>
<tr>
<th></th>
<td><em>Writes the character to the FILE stream</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name=
"fd_set_system_encoding" id=
"fd_set_system_encoding">fd_set_system_encoding</a></td>
<td class="ccode">char *name</td>
<td class="ccode">void</td>
</tr>
<tr>
<th></th>
<td>an encoding name</td>
<td>void</td>
</tr>
<tr>
<th></th>
<td><em>Sets the encoding used by the operating system (e.g. for
system calls, filenames, etc)</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name="fd_ungetc" id=
"fd_ungetc">fd_ungetc</a></td>
<td class="ccode">int c,FILE *f</td>
<td class="ccode">void</td>
</tr>
<tr>
<th></th>
<td>a wide character and a FILE pointer</td>
<td>nothing</td>
</tr>
<tr>
<th></th>
<td><em>Ungets the character on the stream, using its XFILE
structure if possible.</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name=
"fd_set_default_encoding" id=
"fd_set_default_encoding">fd_set_default_encoding</a></td>
<td class="ccode">char *name</td>
<td class="ccode">void</td>
</tr>
<tr>
<th></th>
<td>an encoding name</td>
<td>void</td>
</tr>
<tr>
<th></th>
<td><em>Sets the default encoding used for XFILES</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name=
"fd_set_file_encoding" id=
"fd_set_file_encoding">fd_set_file_encoding</a></td>
<td class="ccode">FILE *f,char *name</td>
<td class="ccode">void</td>
</tr>
<tr>
<th></th>
<td>a FILE pointer and an ASCII string naming an encoding</td>
<td>void</td>
</tr>
<tr>
<th></th>
<td><em>Sets the encoding for a particular FILE pointer to the
encoding with the specified name.</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name="fd_fgetc" id=
"fd_fgetc">fd_fgetc</a></td>
<td class="ccode">FILE *f</td>
<td class="ccode">int</td>
</tr>
<tr>
<th></th>
<td>a FILE pointer</td>
<td>a wide character</td>
</tr>
<tr>
<th></th>
<td><em>Returns a wide character from a stream according to its
encoding.</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name="fd_get_xfile"
id="fd_get_xfile">fd_get_xfile</a></td>
<td class="ccode">FILE *f</td>
<td class="ccode">struct FD_XFILE *</td>
</tr>
<tr>
<th></th>
<td>a FILE pointer</td>
<td>an XFILE pointer (or NULL)</td>
</tr>
<tr>
<th></th>
<td><em>Gets the XFILE struct associated with a particular file
pointer.</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name="fd_fputs_raw"
id="fd_fputs_raw">fd_fputs_raw</a></td>
<td class="ccode">fd_u8char *s,int len,FILE *f</td>
<td class="ccode">void</td>
</tr>
<tr>
<th></th>
<td>a utf8 string and an XFILE pointer</td>
<td>nothing</td>
</tr>
<tr>
<th></th>
<td><em>Writes the contents of the string to the XFILE, signalling
an error if the stream does not accept any of the characters in the
XFILE.</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name=
"fd_localize_utf8" id="fd_localize_utf8">fd_localize_utf8</a></td>
<td class="ccode">fd_u8char *string,struct FD_TEXT_ENCODING *e</td>
<td class="ccode">unsigned char *</td>
</tr>
<tr>
<th></th>
<td>a utf8 encoded string and a text encoding</td>
<td>a regular string</td>
</tr>
<tr>
<th></th>
<td><em>Returns an 8BIT string encoded using the text
encoding.</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name=
"fd_xgetc_encoded" id="fd_xgetc_encoded">fd_xgetc_encoded</a></td>
<td class="ccode">struct FD_XFILE *f</td>
<td class="ccode">int</td>
</tr>
<tr>
<th></th>
<td>an XFILE pointer</td>
<td>a wide character</td>
</tr>
<tr>
<th></th>
<td><em>Returns a wide character from a stream according to its
encoding. This will interpret \u and \U escapes in the
file.</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name=
"fd_convert_utf8" id="fd_convert_utf8">fd_convert_utf8</a></td>
<td class="ccode">fd_u8char *string,int slen,struct
FD_TEXT_ENCODING *e,int *size_loc</td>
<td class="ccode">unsigned char *</td>
</tr>
<tr>
<th></th>
<td>a utf8 encoded string and a text encoding</td>
<td>a regular string</td>
</tr>
<tr>
<th></th>
<td><em>Returns an 8BIT string encoded using the text
encoding.</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name=
"fd_interpret_unicode_escapes" id=
"fd_interpret_unicode_escapes">fd_interpret_unicode_escapes</a></td>
<td class="ccode">fd_u8char *string</td>
<td class="ccode">fd_u8char *</td>
</tr>
<tr>
<th></th>
<td>a utf8 string with (potentially) embedded unicode escapes</td>
<td>a utf8 string where those escapes have been expanded</td>
</tr>
<tr>
<th></th>
<td></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name="fd_free_xfile"
id="fd_free_xfile">fd_free_xfile</a></td>
<td class="ccode">FILE *f</td>
<td class="ccode">void</td>
</tr>
<tr>
<th></th>
<td>an FILE pointer</td>
<td>nothing</td>
</tr>
<tr>
<th></th>
<td><em>Frees the XFILE entry from the linked list of FILE
association pointers.</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name=
"fd_load_encoding" id="fd_load_encoding">fd_load_encoding</a></td>
<td class="ccode">char *name,char *file</td>
<td class="ccode">void</td>
</tr>
<tr>
<th></th>
<td>a name and a filename</td>
<td>void</td>
</tr>
<tr>
<th></th>
<td><em>Defines a text encoding based on a text file of byte
sequence to unicode mappings. This interprets the standard mappings
files provided by the Unicode consortium at
ftp://ftp.unicode.org/Public/MAPPINGS/.</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name=
"fd_get_encoding" id="fd_get_encoding">fd_get_encoding</a></td>
<td class="ccode">char *name</td>
<td class="ccode">struct FD_TEXT_ENCODING *</td>
</tr>
<tr>
<th></th>
<td>an ASCII string</td>
<td>a pointer to an FD_TEXT_ENCODING struct</td>
</tr>
<tr>
<th></th>
<td><em>This gets the structure describing a particular encoding
given its ASCII name.</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name="fd_xputc" id=
"fd_xputc">fd_xputc</a></td>
<td class="ccode">xchar c,struct FD_XFILE *f</td>
<td class="ccode">void</td>
</tr>
<tr>
<th></th>
<td>a wide char and an XFILE pointer</td>
<td>void</td>
</tr>
<tr>
<th></th>
<td><em>Writes the character to XFILE stream, signalling an error
if the stream cannot handle the character.</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name="fd_make_utf8"
id="fd_make_utf8">fd_make_utf8</a></td>
<td class="ccode">uchar *start,uchar *end,struct FD_TEXT_ENCODING
*e</td>
<td class="ccode">fd_u8char *</td>
</tr>
<tr>
<th></th>
<td>a 8BIT string representation and a text encoding</td>
<td>a utf8 encoded string</td>
</tr>
<tr>
<th></th>
<td></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name=
"fd_xputc_encoded" id="fd_xputc_encoded">fd_xputc_encoded</a></td>
<td class="ccode">xchar c,struct FD_XFILE *f</td>
<td class="ccode">void</td>
</tr>
<tr>
<th></th>
<td>a wide char and an XFILE pointer</td>
<td>void</td>
</tr>
<tr>
<th></th>
<td><em>Writes the character to XFILE stream, using unicode escapes
if the stream cannot handle the character.</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name=
"fd_downcase_string" id=
"fd_downcase_string">fd_downcase_string</a></td>
<td class="ccode">fd_u8char *string,int len</td>
<td class="ccode">fd_u8char *</td>
</tr>
<tr>
<th></th>
<td>a utf8 string</td>
<td>a copy of the argument converted to lower case</td>
</tr>
<tr>
<th></th>
<td></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name="fd_xungetc"
id="fd_xungetc">fd_xungetc</a></td>
<td class="ccode">int c,struct FD_XFILE *e</td>
<td class="ccode">void</td>
</tr>
<tr>
<th></th>
<td>a wide character and an XFILE pointer</td>
<td>nothing</td>
</tr>
<tr>
<th></th>
<td><em>Ungets the character on an XFILE stream.</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name=
"fd_define_encoding" id=
"fd_define_encoding">fd_define_encoding</a></td>
<td class="ccode">char *name,struct FD_MB_MAP *charset,int size,
wc2mb_fn wc2mb,mb2wc_fn mb2wc,int flags</td>
<td class="ccode">int</td>
</tr>
<tr>
<th></th>
<td>a name, a pointer to a charset, a wide-char to multi-byte
conversion function, a multi-byte to wide-char conversion function,
and a set of flags.</td>
<td>1 if the map was used, zero if it wasn't (mapping was already
defined)</td>
</tr>
<tr>
<th></th>
<td><em>Defines an encoding with a name and the associated
properties. If an encoding with the give properties already exists,
the name is added to that encoding structure.</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name="fd_xgetc" id=
"fd_xgetc">fd_xgetc</a></td>
<td class="ccode">struct FD_XFILE *f</td>
<td class="ccode">int</td>
</tr>
<tr>
<th></th>
<td>an XFILE pointer</td>
<td>a wide character</td>
</tr>
<tr>
<th></th>
<td><em>Returns a wide character from a stream according to its
encoding. This will *not* interpret \u and \U escapes in the
file.</em></td>
<td></td>
</tr>
</table>
<h2><a name="fdmalloc.c" id="fdmalloc.c">Functions defined in
<tt>src/os/fdmalloc.c</tt></a></h2>
<p><a href="#_fd_qfree"><tt>_fd_qfree</tt></a> | <a href=
"#_fd_qmalloc"><tt>_fd_qmalloc</tt></a> | <a href=
"#_fd_qmalloc_cons"><tt>_fd_qmalloc_cons</tt></a> | <a href=
"#fd_free"><tt>fd_free</tt></a> | <a href=
"#fd_free_int_array"><tt>fd_free_int_array</tt></a> | <a href=
"#fd_malloc"><tt>fd_malloc</tt></a> | <a href=
"#fd_malloc_adjust"><tt>fd_malloc_adjust</tt></a> | <a href=
"#fd_malloc_init"><tt>fd_malloc_init</tt></a> | <a href=
"#fd_mallocize"><tt>fd_mallocize</tt></a> | <a href=
"#fd_memdup"><tt>fd_memdup</tt></a> | <a href=
"#fd_realloc"><tt>fd_realloc</tt></a> | <a href=
"#fd_strdup"><tt>fd_strdup</tt></a> | <a href=
"#fd_xfree"><tt>fd_xfree</tt></a> | <a href=
"#fd_xmalloc"><tt>fd_xmalloc</tt></a> | <a href=
"#fd_xmemdup"><tt>fd_xmemdup</tt></a> | <a href=
"#fd_xrealloc"><tt>fd_xrealloc</tt></a> |</p>
<table cellpadding="5">
<tr>
<th align="left">Function</th>
<th align="left">Arguments</th>
<th align="left">Returns</th>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name=
"_fd_qmalloc_cons" id="_fd_qmalloc_cons">_fd_qmalloc_cons</a></td>
<td class="ccode">size_t bytes</td>
<td class="ccode">void *</td>
</tr>
<tr>
<th></th>
<td>number of bytes</td>
<td>allocated memory</td>
</tr>
<tr>
<th></th>
<td><em>This also initializes the reference count, assuming that
the result will be a struct whose first int field is the reference
count.</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name="fd_xrealloc"
id="fd_xrealloc">fd_xrealloc</a></td>
<td class="ccode">void *oldptr,size_t bytes</td>
<td class="ccode">void *</td>
</tr>
<tr>
<th></th>
<td>a pointer and a size</td>
<td>returns a pointer to a memory chunk with at least size
bytes</td>
</tr>
<tr>
<th></th>
<td><em>which includes the data of the argument passed in This
signals an exception if malloc fails. It doesn't count the malloc'd
bytes</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name="_fd_qmalloc"
id="_fd_qmalloc">_fd_qmalloc</a></td>
<td class="ccode">size_t bytes</td>
<td class="ccode">void *</td>
</tr>
<tr>
<th></th>
<td>number of bytes</td>
<td>allocated memory</td>
</tr>
<tr>
<th></th>
<td><em>This maintains a free list for certain memory sizes and
allocates them blocks at a time.</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name="fd_malloc" id=
"fd_malloc">fd_malloc</a></td>
<td class="ccode">size_t bytes</td>
<td class="ccode">void *</td>
</tr>
<tr>
<th></th>
<td>number of bytes</td>
<td>allocated memory to at least that many bytes</td>
</tr>
<tr>
<th></th>
<td><em>This signals an exception if malloc fails.</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name="fd_memdup" id=
"fd_memdup">fd_memdup</a></td>
<td class="ccode">const char *data,size_t sz</td>
<td class="ccode">char *</td>
</tr>
<tr>
<th></th>
<td>a pointer to a chunk of memory and a size</td>
<td>a string</td>
</tr>
<tr>
<th></th>
<td><em>Allocates a new string which is a copy of its argument and
has the corresponding size. This will work with strings that
contain NULLs. This will count towards global memory counts and use
huge_malloc if neccessary.</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name=
"fd_malloc_init" id="fd_malloc_init">fd_malloc_init</a></td>
<td class="ccode">size_t sz,int chunk_size</td>
<td class="ccode">void</td>
</tr>
<tr>
<th></th>
<td>two size_t pointers, struct_size and block_size</td>
<td>void</td>
</tr>
<tr>
<th></th>
<td><em>Arranges for malloc tables to keep a free list of structs
with *struct_size* bytes and to allocate these structs in blocks of
*block_size* to reduce malloc overhead. This will signal an error
if any thread has already copied the malloc data table. This isn't
neccessary, but just easy to code right now.</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name="fd_xmalloc"
id="fd_xmalloc">fd_xmalloc</a></td>
<td class="ccode">size_t bytes</td>
<td class="ccode">void *</td>
</tr>
<tr>
<th></th>
<td>number of bytes</td>
<td>allocated memory to at least that many bytes</td>
</tr>
<tr>
<th></th>
<td><em>This signals an exception if malloc fails. It doesn't count
the malloc'd bytes, though...</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name="fd_xfree" id=
"fd_xfree">fd_xfree</a></td>
<td class="ccode">void *ptr</td>
<td class="ccode">void</td>
</tr>
<tr>
<th></th>
<td>a pointer</td>
<td>void</td>
</tr>
<tr>
<th></th>
<td><em>Doesn't signal an error of pointer is NULL</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name=
"fd_free_int_array" id=
"fd_free_int_array">fd_free_int_array</a></td>
<td class="ccode">unsigned int *ptr,size_t size</td>
<td class="ccode">void</td>
</tr>
<tr>
<th></th>
<td>a pointer and number of bytes</td>
<td>void</td>
</tr>
<tr>
<th></th>
<td><em>This frees the pointer and bumps the malloc pointer down by
a number rounded up to the size to FD_STRING_CHUNK.</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name="fd_mallocize"
id="fd_mallocize">fd_mallocize</a></td>
<td class="ccode">char *data,size_t sz</td>
<td class="ccode">char *</td>
</tr>
<tr>
<th></th>
<td>a pointer to a chunk of memory and a size</td>
<td>a pointer</td>
</tr>
<tr>
<th></th>
<td><em>Returns a pointer which can be used with the
fd_malloc/realloc/free functions. This does two things: if the size
is large enough to for calling huge_malloc, it is called, the
strings contents is copied, and the original chunk is freed; in
addition, in either the case of a copy or a pass-through
fd_malloc_adjust is called to record the memory take up by the
chunk of memory.</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name="fd_xmemdup"
id="fd_xmemdup">fd_xmemdup</a></td>
<td class="ccode">const char *data,size_t sz</td>
<td class="ccode">char *</td>
</tr>
<tr>
<th></th>
<td>a pointer to a chunk of data and a size</td>
<td>a string</td>
</tr>
<tr>
<th></th>
<td><em>Allocates a new string which is a copy of its argument and
has the corresponding size. This will work with strings that
contain NULLs. This does not count towards the global memory
counts.</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name="fd_realloc"
id="fd_realloc">fd_realloc</a></td>
<td class="ccode">void *ptr,size_t new_size,size_t old_size</td>
<td class="ccode">void *</td>
</tr>
<tr>
<th></th>
<td>a pointer and a number of bytes</td>
<td>void</td>
</tr>
<tr>
<th></th>
<td><em>Frees the pointer and updates the memory usage
count</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name="fd_strdup" id=
"fd_strdup">fd_strdup</a></td>
<td class="ccode">const char *string</td>
<td class="ccode">char *</td>
</tr>
<tr>
<th></th>
<td>a null terminated string</td>
<td>a null terminated string</td>
</tr>
<tr>
<th></th>
<td><em>Allocates a new string which is a copy of its argument.
This does not count towards the global memory counts.</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name=
"fd_malloc_adjust" id="fd_malloc_adjust">fd_malloc_adjust</a></td>
<td class="ccode">int delta</td>
<td class="ccode">void</td>
</tr>
<tr>
<th></th>
<td>an int</td>
<td>void</td>
</tr>
<tr>
<th></th>
<td><em>Bumps up the malloc count but doesn't really malloc
anything</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name="_fd_qfree" id=
"_fd_qfree">_fd_qfree</a></td>
<td class="ccode">void *p,size_t bytes</td>
<td class="ccode">void</td>
</tr>
<tr>
<th></th>
<td>a pointer and a number of bytes</td>
<td>void</td>
</tr>
<tr>
<th></th>
<td><em>This frees a cons allocated by fd_qmalloc which tries to do
free list maintainance.</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name="fd_free" id=
"fd_free">fd_free</a></td>
<td class="ccode">void *ptr,size_t bytes</td>
<td class="ccode">void</td>
</tr>
<tr>
<th></th>
<td>a pointer and a number of bytes</td>
<td>void</td>
</tr>
<tr>
<th></th>
<td><em>Frees the pointer and updates the memory usage
count</em></td>
<td></td>
</tr>
</table>
{}
<h2><a name="oids.c" id="oids.c">Functions defined in
<tt>src/cons/oids.c</tt></a></h2>
<table cellpadding="5">
<tr>
<th align="left">Function</th>
<th align="left">Arguments</th>
<th align="left">Returns</th>
</tr>
</table>
<h2><a name="slotmaps.c" id="slotmaps.c">Functions defined in
<tt>src/cons/slotmaps.c</tt></a></h2>
<p><a href=
"#_fd_done_with_slotmap_data"><tt>_fd_done_with_slotmap_data</tt></a>
| <a href="#_fd_slotmap_data"><tt>_fd_slotmap_data</tt></a> |
<a href="#fd_make_slotmap"><tt>fd_make_slotmap</tt></a> | <a href=
"#fd_slotmap_add"><tt>fd_slotmap_add</tt></a> | <a href=
"#fd_slotmap_get"><tt>fd_slotmap_get</tt></a> | <a href=
"#fd_slotmap_remove"><tt>fd_slotmap_remove</tt></a> | <a href=
"#fd_slotmap_set"><tt>fd_slotmap_set</tt></a> | <a href=
"#fd_slotmap_test"><tt>fd_slotmap_test</tt></a> | <a href=
"#fd_slotmap_zap"><tt>fd_slotmap_zap</tt></a> |</p>
<table cellpadding="5">
<tr>
<th align="left">Function</th>
<th align="left">Arguments</th>
<th align="left">Returns</th>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name=
"fd_slotmap_add" id="fd_slotmap_add">fd_slotmap_add</a></td>
<td class="ccode">fd_slotmap sm,lisp key,lisp value</td>
<td class="ccode">void</td>
</tr>
<tr>
<th></th>
<td>a slotmap, a lisp key, and a lisp value</td>
<td>makes the value be associated with the key</td>
</tr>
<tr>
<th></th>
<td><em>in the slotmap, making the value non deterministic if
neccessary. Refcounts (if it's not a set) or copies (if it is) the
value given it.</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name=
"_fd_slotmap_data" id="_fd_slotmap_data">_fd_slotmap_data</a></td>
<td class="ccode">lisp x,void **velts</td>
<td class="ccode">int</td>
</tr>
<tr>
<th></th>
<td>a lisp pointer (to a slotmap) and a pointer to a pointer to a
vector of lisp pointers</td>
<td>an int (the number of lisp pointers in the vector assigned</td>
</tr>
<tr>
<th></th>
<td><em>Returns the data of the slotmap to use in producing a
packaged DTYPE from it.</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name=
"fd_slotmap_test" id="fd_slotmap_test">fd_slotmap_test</a></td>
<td class="ccode">fd_slotmap sm,lisp key,lisp value</td>
<td class="ccode">int</td>
</tr>
<tr>
<th></th>
<td>a slotmap, a lisp key, and a lisp value</td>
<td>1 or 0</td>
</tr>
<tr>
<th></th>
<td><em>Returns 1 if the value can be found on the *key* slot of
the slotmap.</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name=
"fd_slotmap_get" id="fd_slotmap_get">fd_slotmap_get</a></td>
<td class="ccode">fd_slotmap sm,lisp key,lisp dflt</td>
<td class="ccode">lisp</td>
</tr>
<tr>
<th></th>
<td>a slotmap, a lisp key, and a default value</td>
<td>the value associated with the key in the slotmap</td>
</tr>
<tr>
<th></th>
<td><em>or the default value otherwise.</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name=
"fd_make_slotmap" id="fd_make_slotmap">fd_make_slotmap</a></td>
<td class="ccode">int size</td>
<td class="ccode">lisp</td>
</tr>
<tr>
<th></th>
<td>a size (int)</td>
<td>a slotmap with capacity for <var>size</var> slots</td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name=
"_fd_done_with_slotmap_data" id=
"_fd_done_with_slotmap_data">_fd_done_with_slotmap_data</a></td>
<td class="ccode">fd_lisp *elts,int size</td>
<td class="ccode">void</td>
</tr>
<tr>
<th></th>
<td>a pointer to a vector of LISP pointers and a size</td>
<td>nothing</td>
</tr>
<tr>
<th></th>
<td><em>Frees a slotmap data vector.</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name=
"fd_slotmap_set" id="fd_slotmap_set">fd_slotmap_set</a></td>
<td class="ccode">fd_slotmap sm,lisp key,lisp value</td>
<td class="ccode">void</td>
</tr>
<tr>
<th></th>
<td>a slotmap, a lisp key, and a lisp value</td>
<td>makes the value be associated with the key</td>
</tr>
<tr>
<th></th>
<td><em>in the slotmap Refcounts (if it's not a set) or copies (if
it is) the value given it.</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name=
"fd_slotmap_remove" id=
"fd_slotmap_remove">fd_slotmap_remove</a></td>
<td class="ccode">fd_slotmap sm,lisp key,lisp value</td>
<td class="ccode">void</td>
</tr>
<tr>
<th></th>
<td>a slotmap, a lisp key, and a lisp value</td>
<td>removes the value from the values associated with</td>
</tr>
<tr>
<th></th>
<td><em>a particular key in the slotmap The value on the slotmap is
freed.</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name=
"fd_slotmap_zap" id="fd_slotmap_zap">fd_slotmap_zap</a></td>
<td class="ccode">fd_slotmap sm,lisp key</td>
<td class="ccode">void</td>
</tr>
<tr>
<th></th>
<td>a pointer to a slotmap and a key</td>
<td>nothing</td>
</tr>
<tr>
<th></th>
<td><em>Removes all values associated with the key in the
slotmap.</em></td>
<td></td>
</tr>
</table>
<h2><a name="io.c" id="io.c">Functions defined in
<tt>src/cons/io.c</tt></a></h2>
<p><a href="#_fd_sgetc"><tt>_fd_sgetc</tt></a> | <a href=
"#fd_add_dtype_to_file"><tt>fd_add_dtype_to_file</tt></a> |
<a href="#fd_configure_oid_io"><tt>fd_configure_oid_io</tt></a> |
<a href="#fd_default_parse_oid"><tt>fd_default_parse_oid</tt></a> |
<a href="#fd_default_print_oid"><tt>fd_default_print_oid</tt></a> |
<a href="#fd_dtype_size"><tt>fd_dtype_size</tt></a> | <a href=
"#fd_object_to_string"><tt>fd_object_to_string</tt></a> | <a href=
"#fd_parse_arg"><tt>fd_parse_arg</tt></a> | <a href=
"#fd_parse_lisp_from_stream"><tt>fd_parse_lisp_from_stream</tt></a>
| <a href="#fd_parse_number"><tt>fd_parse_number</tt></a> |
<a href="#fd_parse_string"><tt>fd_parse_string</tt></a> | <a href=
"#fd_print_lisp"><tt>fd_print_lisp</tt></a> | <a href=
"#fd_print_lisp_to_stdout"><tt>fd_print_lisp_to_stdout</tt></a> |
<a href=
"#fd_print_lisp_to_string"><tt>fd_print_lisp_to_string</tt></a> |
<a href=
"#fd_read_dtype_from_file"><tt>fd_read_dtype_from_file</tt></a> |
<a href=
"#fd_read_dtypes_from_file"><tt>fd_read_dtypes_from_file</tt></a> |
<a href="#fd_set_bignum_parser"><tt>fd_set_bignum_parser</tt></a> |
<a href=
"#fd_set_super_pool_aliasing"><tt>fd_set_super_pool_aliasing</tt></a>
| <a href="#fd_validate_dtype"><tt>fd_validate_dtype</tt></a> |
<a href=
"#fd_write_dtype_to_file"><tt>fd_write_dtype_to_file</tt></a> |</p>
<table cellpadding="5">
<tr>
<th align="left">Function</th>
<th align="left">Arguments</th>
<th align="left">Returns</th>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name="fd_parse_arg"
id="fd_parse_arg">fd_parse_arg</a></td>
<td class="ccode">char *xstring</td>
<td class="ccode">lisp</td>
</tr>
<tr>
<th></th>
<td>a localized string</td>
<td>a lisp object</td>
</tr>
<tr>
<th></th>
<td><em>Returns the lisp object described by the printed
representation in its argument.</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name="fd_print_lisp"
id="fd_print_lisp">fd_print_lisp</a></td>
<td class="ccode">lisp x, FILE * stream</td>
<td class="ccode">void</td>
</tr>
<tr>
<th></th>
<td>a lisp object and a standard output stream</td>
<td>nothing</td>
</tr>
<tr>
<th></th>
<td><em>Outputs an ascii representation of the object to the output
stream</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name=
"fd_configure_oid_io" id=
"fd_configure_oid_io">fd_configure_oid_io</a></td>
<td class="ccode">void ((*print_fcn</td>
<td class="ccode">void</td>
</tr>
<tr>
<th></th>
<td>a pointer to two C functions; the first outputs OIDs to string
streams and the second parses utf8 strings into OIDs</td>
<td>nothing</td>
</tr>
<tr>
<th></th>
<td><em>Changes the default printer and parser for OIDs.</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name=
"fd_write_dtype_to_file" id=
"fd_write_dtype_to_file">fd_write_dtype_to_file</a></td>
<td class="ccode">lisp v,char *filename</td>
<td class="ccode">void</td>
</tr>
<tr>
<th></th>
<td>a lisp object, a filename (a string)</td>
<td>nothing</td>
</tr>
<tr>
<th></th>
<td><em>Outputs a dtype representation of the object to the
specified file.</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name=
"fd_default_parse_oid" id=
"fd_default_parse_oid">fd_default_parse_oid</a></td>
<td class="ccode">fd_u8char *string</td>
<td class="ccode">lisp</td>
</tr>
<tr>
<th></th>
<td>a pointer to a UTF-8 string</td>
<td>a lisp pointer to an FD_OID</td>
</tr>
<tr>
<th></th>
<td><em>Outputs the most primitive ASCII representation of the
object to the string stream.</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name="_fd_sgetc" id=
"_fd_sgetc">_fd_sgetc</a></td>
<td class="ccode">fd_u8char **ss</td>
<td class="ccode">int</td>
</tr>
<tr>
<th></th>
<td>a pointer to a pointer to a UTF-8 string</td>
<td>an int (representing a unicode character)</td>
</tr>
<tr>
<th></th>
<td><em>Reads a single unicode character from a utf-8 string,
advancing the string past the character.</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name=
"fd_read_dtype_from_file" id=
"fd_read_dtype_from_file">fd_read_dtype_from_file</a></td>
<td class="ccode">char *filename</td>
<td class="ccode">lisp</td>
</tr>
<tr>
<th></th>
<td>a localized string (a filename)</td>
<td>a lisp object</td>
</tr>
<tr>
<th></th>
<td><em>Returns the lisp object described by the first DTYPE in
filename.</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name=
"fd_parse_number" id="fd_parse_number">fd_parse_number</a></td>
<td class="ccode">fd_u8char *string,int base</td>
<td class="ccode">lisp</td>
</tr>
<tr>
<th></th>
<td>a utf8 string and an integral base</td>
<td>a lisp object</td>
</tr>
<tr>
<th></th>
<td><em>Parses the number assuming the specified base.</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name=
"fd_default_print_oid" id=
"fd_default_print_oid">fd_default_print_oid</a></td>
<td class="ccode">lisp obj,fd_string_stream ss</td>
<td class="ccode">void</td>
</tr>
<tr>
<th></th>
<td>a pointer to a LISP OID pointer and a pointer to a "string
stream"</td>
<td>nothing</td>
</tr>
<tr>
<th></th>
<td><em>Outputs the most primitive ASCII representation of the
object to the string stream.</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name=
"fd_read_dtypes_from_file" id=
"fd_read_dtypes_from_file">fd_read_dtypes_from_file</a></td>
<td class="ccode">char *filename</td>
<td class="ccode">lisp</td>
</tr>
<tr>
<th></th>
<td>a localized string (a filename)</td>
<td>a lisp object</td>
</tr>
<tr>
<th></th>
<td><em>Returns the lisp objects described by the DTYPES in
filename.</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name=
"fd_validate_dtype" id=
"fd_validate_dtype">fd_validate_dtype</a></td>
<td class="ccode">unsigned char *buf,unsigned char *end</td>
<td class="ccode">int</td>
</tr>
<tr>
<th></th>
<td>two pointers into an array of bytes</td>
<td>1 if the range contains a valid dtype representation</td>
</tr>
<tr>
<th></th>
<td></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name=
"fd_set_bignum_parser" id=
"fd_set_bignum_parser">fd_set_bignum_parser</a></td>
<td class="ccode">lisp (*fcn</td>
<td class="ccode">void</td>
</tr>
<tr>
<th></th>
<td>a function for parsing bignums from strings and returning lisp
objects</td>
<td>void</td>
</tr>
<tr>
<th></th>
<td><em>Defines the function used for parsing large integers into
lisp objects. The function takes a string and an integral radix and
returns a lisp object representing the number described by the
string.</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name="fd_dtype_size"
id="fd_dtype_size">fd_dtype_size</a></td>
<td class="ccode">lisp x</td>
<td class="ccode">unsigned int</td>
</tr>
<tr>
<th></th>
<td>a lis pointer</td>
<td>an integer</td>
</tr>
<tr>
<th></th>
<td><em>Returns the number of bytes which will be used by the DType
representation of its argument.</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name=
"fd_parse_lisp_from_stream" id=
"fd_parse_lisp_from_stream">fd_parse_lisp_from_stream</a></td>
<td class="ccode">FILE *f</td>
<td class="ccode">lisp</td>
</tr>
<tr>
<th></th>
<td>a FILE pointer</td>
<td>a lisp object</td>
</tr>
<tr>
<th></th>
<td><em>Parses the printed representation of an object from a stdio
file stream</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name=
"fd_object_to_string" id=
"fd_object_to_string">fd_object_to_string</a></td>
<td class="ccode">lisp object</td>
<td class="ccode">fd_u8char *</td>
</tr>
<tr>
<th></th>
<td>a lisp object</td>
<td>a string</td>
</tr>
<tr>
<th></th>
<td><em>Returns a string containing a UTF-8 representation of the
object.</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name=
"fd_parse_string" id="fd_parse_string">fd_parse_string</a></td>
<td class="ccode">fd_u8char *string</td>
<td class="ccode">lisp</td>
</tr>
<tr>
<th></th>
<td>a utf8 string</td>
<td>a lisp object</td>
</tr>
<tr>
<th></th>
<td><em>Returns the lisp object described by the printed
representation in its argument.</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name=
"fd_set_super_pool_aliasing" id=
"fd_set_super_pool_aliasing">fd_set_super_pool_aliasing</a></td>
<td class="ccode">FD_OID from,FD_OID to</td>
<td class="ccode">void</td>
</tr>
<tr>
<th></th>
<td>two OIDs</td>
<td>nothing</td>
</tr>
<tr>
<th></th>
<td><em>Sets up the DType reader to translate OIDs in the super
pool of *from* into OIDs in the super pool for *to*.</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name=
"fd_add_dtype_to_file" id=
"fd_add_dtype_to_file">fd_add_dtype_to_file</a></td>
<td class="ccode">lisp v,char *filename</td>
<td class="ccode">void</td>
</tr>
<tr>
<th></th>
<td>a lisp object, a filename (a string)</td>
<td>nothing</td>
</tr>
<tr>
<th></th>
<td><em>Outputs a dtype representation of the object to the end of
the specified file (creating it if neccessary).</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name=
"fd_print_lisp_to_stdout" id=
"fd_print_lisp_to_stdout">fd_print_lisp_to_stdout</a></td>
<td class="ccode">lisp dtype</td>
<td class="ccode">void</td>
</tr>
<tr>
<th></th>
<td>a lisp object</td>
<td>nothing</td>
</tr>
<tr>
<th></th>
<td><em>Outputs an ascii representation of the object to the
standard output</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name=
"fd_print_lisp_to_string" id=
"fd_print_lisp_to_string">fd_print_lisp_to_string</a></td>
<td class="ccode">lisp x,fd_string_stream s</td>
<td class="ccode">void</td>
</tr>
<tr>
<th></th>
<td>a lisp object and a pointer to a "string stream"</td>
<td>nothing</td>
</tr>
<tr>
<th></th>
<td><em>Outputs an ASCII representation of the object to the string
stream.</em></td>
<td></td>
</tr>
</table>
<h2><a name="choices.c" id="choices.c">Functions defined in
<tt>src/cons/choices.c</tt></a></h2>
<p><a href="#_fd_add_to_choice"><tt>_fd_add_to_choice</tt></a> |
<a href="#_fd_binary_choice"><tt>_fd_binary_choice</tt></a> |
<a href=
"#_fd_make_choice_heterogenous"><tt>_fd_make_choice_heterogenous</tt></a>
| <a href=
"#_fd_make_choice_homogenous"><tt>_fd_make_choice_homogenous</tt></a>
| <a href="#_fd_merge_choices"><tt>_fd_merge_choices</tt></a> |
<a href="#_fd_quote_choice"><tt>_fd_quote_choice</tt></a> |
<a href="#_fd_unquote_choice"><tt>_fd_unquote_choice</tt></a> |
<a href="#fd_choice_containsp"><tt>fd_choice_containsp</tt></a> |
<a href="#fd_choice_overlapsp"><tt>fd_choice_overlapsp</tt></a> |
<a href="#fd_init_choice"><tt>fd_init_choice</tt></a> | <a href=
"#fd_init_oid_choice"><tt>fd_init_oid_choice</tt></a> | <a href=
"#fd_intersect_choices"><tt>fd_intersect_choices</tt></a> |
<a href="#fd_list_to_choice"><tt>fd_list_to_choice</tt></a> |
<a href="#fd_merge_choices"><tt>fd_merge_choices</tt></a> |
<a href="#fd_proper_choicep"><tt>fd_proper_choicep</tt></a> |
<a href="#fd_remove_from_choice"><tt>fd_remove_from_choice</tt></a>
| <a href=
"#fd_return_proper_choice"><tt>fd_return_proper_choice</tt></a> |
<a href="#fd_sort_choice"><tt>fd_sort_choice</tt></a> |</p>
<table cellpadding="5">
<tr>
<th align="left">Function</th>
<th align="left">Arguments</th>
<th align="left">Returns</th>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name=
"fd_init_oid_choice" id=
"fd_init_oid_choice">fd_init_oid_choice</a></td>
<td class="ccode">int n</td>
<td class="ccode">lisp</td>
</tr>
<tr>
<th></th>
<td>a size</td>
<td>An empty non-deterministic set with a homogenous type of
OID</td>
</tr>
<tr>
<th></th>
<td><em>This returns an empty set with reserved space for a certain
number of elements. The set is initialized as a homogenous choice
of OIDS.</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name=
"_fd_make_choice_heterogenous" id=
"_fd_make_choice_heterogenous">_fd_make_choice_heterogenous</a></td>
<td class="ccode">fd_choice ch</td>
<td class="ccode">void</td>
</tr>
<tr>
<th></th>
<td>a pointer to a choice</td>
<td>nothing</td>
</tr>
<tr>
<th></th>
<td><em>Makes a homogenous choice into a heterogenous one</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name=
"_fd_binary_choice" id=
"_fd_binary_choice">_fd_binary_choice</a></td>
<td class="ccode">lisp x,lisp y</td>
<td class="ccode">lisp</td>
</tr>
<tr>
<th></th>
<td>two lisp objects</td>
<td>a non-deterministic set containing copies of them</td>
</tr>
<tr>
<th></th>
<td><em>This is useful because the transition from simple value to
nd-value usually starts with a set of two elements.</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name=
"fd_sort_choice" id="fd_sort_choice">fd_sort_choice</a></td>
<td class="ccode">fd_lisp arg</td>
<td class="ccode">int</td>
</tr>
<tr>
<th></th>
<td>a pointer to a choice</td>
<td>1/0</td>
</tr>
<tr>
<th></th>
<td><em>Sorts the elements of a heterogenous choice, returns 1 if
the choice was successfully sorted, 0 otherwise</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name=
"fd_list_to_choice" id=
"fd_list_to_choice">fd_list_to_choice</a></td>
<td class="ccode">lisp lst</td>
<td class="ccode">lisp</td>
</tr>
<tr>
<th></th>
<td>a lisp list</td>
<td>an non-deterministic set whose elements are the elements
of</td>
</tr>
<tr>
<th></th>
<td><em>the list it is given This copies (rather than just crefs)
the elements it is given</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name=
"fd_init_choice" id="fd_init_choice">fd_init_choice</a></td>
<td class="ccode">int n</td>
<td class="ccode">lisp</td>
</tr>
<tr>
<th></th>
<td>a size</td>
<td>An empty non-deterministic set</td>
</tr>
<tr>
<th></th>
<td><em>This returns an empty set with reserved space for a certain
number of elements.</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name=
"fd_remove_from_choice" id=
"fd_remove_from_choice">fd_remove_from_choice</a></td>
<td class="ccode">lisp x,lisp choice</td>
<td class="ccode">lisp</td>
</tr>
<tr>
<th></th>
<td>a lisp object and a lisp non-deterministic set</td>
<td>a non-deterministic set without any occurences of the
object</td>
</tr>
<tr>
<th></th>
<td></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name=
"_fd_make_choice_homogenous" id=
"_fd_make_choice_homogenous">_fd_make_choice_homogenous</a></td>
<td class="ccode">fd_choice ch</td>
<td class="ccode">void</td>
</tr>
<tr>
<th></th>
<td>a pointer to a choice</td>
<td>nothing</td>
</tr>
<tr>
<th></th>
<td><em>Makes a heterogenous choice into a homogenous one</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name=
"fd_choice_containsp" id=
"fd_choice_containsp">fd_choice_containsp</a></td>
<td class="ccode">lisp sub,lisp super</td>
<td class="ccode">int</td>
</tr>
<tr>
<th></th>
<td>two lisp objects</td>
<td>1 or 0</td>
</tr>
<tr>
<th></th>
<td><em>Returns 1 if the first argument is a subset of the second.
of the choice which is the second argument.</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name=
"_fd_unquote_choice" id=
"_fd_unquote_choice">_fd_unquote_choice</a></td>
<td class="ccode">fd_lisp x</td>
<td class="ccode">fd_lisp</td>
</tr>
<tr>
<th></th>
<td>a lisp object (possibly a choice)</td>
<td>a lisp object</td>
</tr>
<tr>
<th></th>
<td><em>Returns a lisp object will be a quoted choice if
appropriate</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name=
"_fd_merge_choices" id=
"_fd_merge_choices">_fd_merge_choices</a></td>
<td class="ccode">lisp x,lisp y</td>
<td class="ccode">lisp</td>
</tr>
<tr>
<th></th>
<td>two objects</td>
<td>a non-deterministic set which contains the elements of
both</td>
</tr>
<tr>
<th></th>
<td><em>This implicitly frees y (its second argument), while adding
its elements to x.</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name=
"fd_merge_choices" id="fd_merge_choices">fd_merge_choices</a></td>
<td class="ccode">lisp x,lisp y</td>
<td class="ccode">lisp</td>
</tr>
<tr>
<th></th>
<td>two objects</td>
<td>a non-deterministic set which contains the elements of
both</td>
</tr>
<tr>
<th></th>
<td><em>Merges two choices, being smart about sorted choices. This
may side effect the first argument.</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name=
"fd_proper_choicep" id=
"fd_proper_choicep">fd_proper_choicep</a></td>
<td class="ccode">lisp value</td>
<td class="ccode">int</td>
</tr>
<tr>
<th></th>
<td>a lisp pointer</td>
<td>1 if the argument is a proper choice, 0 otherwise</td>
</tr>
<tr>
<th></th>
<td><em>A proper choice has no duplicated elements. Note that a
non-choice lisp pointer is always "proper" since it has only one
element.</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name=
"fd_return_proper_choice" id=
"fd_return_proper_choice">fd_return_proper_choice</a></td>
<td class="ccode">lisp values</td>
<td class="ccode">lisp</td>
</tr>
<tr>
<th></th>
<td>a lisp pointer</td>
<td>another lisp pointer</td>
</tr>
<tr>
<th></th>
<td><em>If the argument is a non-deterministic set, this returns a
"proper set" which contains no duplicate elements.</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name=
"fd_choice_overlapsp" id=
"fd_choice_overlapsp">fd_choice_overlapsp</a></td>
<td class="ccode">lisp ch1,lisp ch2</td>
<td class="ccode">int</td>
</tr>
<tr>
<th></th>
<td>two lisp objects</td>
<td>1 or 0</td>
</tr>
<tr>
<th></th>
<td><em>Returns 1 if any elements of the first argument overlap
elements of the second.</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name=
"fd_intersect_choices" id=
"fd_intersect_choices">fd_intersect_choices</a></td>
<td class="ccode">lisp *choices,int size</td>
<td class="ccode">lisp</td>
</tr>
<tr>
<th></th>
<td>a C array of LISP pointers and a size</td>
<td>a lisp object</td>
</tr>
<tr>
<th></th>
<td><em>Returns the intersection of all the choices in the array.
This is optimized to take advantage of sorted choices.</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name=
"_fd_add_to_choice" id=
"_fd_add_to_choice">_fd_add_to_choice</a></td>
<td class="ccode">lisp x,lisp set</td>
<td class="ccode">void</td>
</tr>
<tr>
<th></th>
<td>a lisp object and a lisp non-deterministic set</td>
<td>nothing</td>
</tr>
<tr>
<th></th>
<td><em>Adds the object (not a copy!) to the non-deterministic
set.</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name=
"_fd_quote_choice" id="_fd_quote_choice">_fd_quote_choice</a></td>
<td class="ccode">fd_lisp x</td>
<td class="ccode">fd_lisp</td>
</tr>
<tr>
<th></th>
<td>a lisp object (possibly a choice)</td>
<td>a lisp object</td>
</tr>
<tr>
<th></th>
<td><em>Returns a lisp object will be a quoted choice if
appropriate</em></td>
<td></td>
</tr>
</table>
<h2><a name="xdata.c" id="xdata.c">Functions defined in
<tt>src/cons/xdata.c</tt></a></h2>
<p><a href=
"#fd_alist_to_hashtable"><tt>fd_alist_to_hashtable</tt></a> |
<a href="#fd_compare_cptrs"><tt>fd_compare_cptrs</tt></a> |
<a href="#fd_cons"><tt>fd_cons</tt></a> | <a href=
"#fd_copy_cptr"><tt>fd_copy_cptr</tt></a> | <a href=
"#fd_hashtable_to_alist"><tt>fd_hashtable_to_alist</tt></a> |
<a href="#fd_lisp_hashset_elts"><tt>fd_lisp_hashset_elts</tt></a> |
<a href="#fd_make_complex"><tt>fd_make_complex</tt></a> | <a href=
"#fd_make_double_vector"><tt>fd_make_double_vector</tt></a> |
<a href="#fd_make_error"><tt>fd_make_error</tt></a> | <a href=
"#fd_make_exception"><tt>fd_make_exception</tt></a> | <a href=
"#fd_make_float_vector"><tt>fd_make_float_vector</tt></a> |
<a href="#fd_make_flonum"><tt>fd_make_flonum</tt></a> | <a href=
"#fd_make_hashset_for_lisp"><tt>fd_make_hashset_for_lisp</tt></a> |
<a href=
"#fd_make_hashtable_for_lisp"><tt>fd_make_hashtable_for_lisp</tt></a>
| <a href="#fd_make_int_vector"><tt>fd_make_int_vector</tt></a> |
<a href="#fd_make_packet"><tt>fd_make_packet</tt></a> | <a href=
"#fd_make_rational"><tt>fd_make_rational</tt></a> | <a href=
"#fd_make_short_vector"><tt>fd_make_short_vector</tt></a> |
<a href="#fd_make_timestamp"><tt>fd_make_timestamp</tt></a> |
<a href="#fd_make_xtimestamp"><tt>fd_make_xtimestamp</tt></a> |
<a href="#fd_parse_packet"><tt>fd_parse_packet</tt></a> | <a href=
"#fd_quote_lisp"><tt>fd_quote_lisp</tt></a> |</p>
<table cellpadding="5">
<tr>
<th align="left">Function</th>
<th align="left">Arguments</th>
<th align="left">Returns</th>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name=
"fd_make_rational" id="fd_make_rational">fd_make_rational</a></td>
<td class="ccode">lisp num,lisp denom</td>
<td class="ccode">lisp</td>
</tr>
<tr>
<th></th>
<td>two lisp numbers</td>
<td>a lisp rational</td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name=
"fd_lisp_hashset_elts" id=
"fd_lisp_hashset_elts">fd_lisp_hashset_elts</a></td>
<td class="ccode">lisp table</td>
<td class="ccode">lisp</td>
</tr>
<tr>
<th></th>
<td>a lisp pointer to a hashset</td>
<td>a lisp pointer</td>
</tr>
<tr>
<th></th>
<td><em>Returns all the elements of a hashset as a
choice.</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name="fd_quote_lisp"
id="fd_quote_lisp">fd_quote_lisp</a></td>
<td class="ccode">lisp x</td>
<td class="ccode">lisp</td>
</tr>
<tr>
<th></th>
<td>a lisp object</td>
<td>another object, which when evaluated, returns the first</td>
</tr>
<tr>
<th></th>
<td><em>This also copies any structure copied to it.</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name=
"fd_make_complex" id="fd_make_complex">fd_make_complex</a></td>
<td class="ccode">lisp real,lisp imag</td>
<td class="ccode">lisp</td>
</tr>
<tr>
<th></th>
<td>two numbers</td>
<td>a lisp complex</td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name="fd_cons" id=
"fd_cons">fd_cons</a></td>
<td class="ccode">char *format,...</td>
<td class="ccode">fd_lisp</td>
</tr>
<tr>
<th></th>
<td>a format string and a number of args</td>
<td>a lisp object</td>
</tr>
<tr>
<th></th>
<td><em>Geneates a lisp object based on the format string. Codes in
the format string are interpreted as follows: i integer f long q
lisp pointer (will be incref'd) Q lisp pointer (won't be incref'd)
s locally encoded string S locally encoded symbol u utf8 encoded
string U utf8 encoded symbol (xxx) list with elements {xxx} choice
with elements #(xxx) vector with elements</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name=
"fd_make_short_vector" id=
"fd_make_short_vector">fd_make_short_vector</a></td>
<td class="ccode">int len,short *data</td>
<td class="ccode">lisp</td>
</tr>
<tr>
<th></th>
<td>a float</td>
<td>a LISP floating point number</td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name=
"fd_make_hashtable_for_lisp" id=
"fd_make_hashtable_for_lisp">fd_make_hashtable_for_lisp</a></td>
<td class="ccode">int size</td>
<td class="ccode">lisp</td>
</tr>
<tr>
<th></th>
<td>an integer</td>
<td>a lisp pointer to a hashtable</td>
</tr>
<tr>
<th></th>
<td></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name=
"fd_make_double_vector" id=
"fd_make_double_vector">fd_make_double_vector</a></td>
<td class="ccode">int len,double *data</td>
<td class="ccode">lisp</td>
</tr>
<tr>
<th></th>
<td>a int length and a pointer to an array of doubles</td>
<td>a homongenous double floating point vector</td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name=
"fd_make_hashset_for_lisp" id=
"fd_make_hashset_for_lisp">fd_make_hashset_for_lisp</a></td>
<td class="ccode">int size</td>
<td class="ccode">lisp</td>
</tr>
<tr>
<th></th>
<td>an integer</td>
<td>a lisp pointer to a hashtable</td>
</tr>
<tr>
<th></th>
<td></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name=
"fd_make_float_vector" id=
"fd_make_float_vector">fd_make_float_vector</a></td>
<td class="ccode">int len,float *data</td>
<td class="ccode">lisp</td>
</tr>
<tr>
<th></th>
<td>a int length and a pointer to an array of floats</td>
<td>a homongenous floating point vector</td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name=
"fd_make_flonum" id="fd_make_flonum">fd_make_flonum</a></td>
<td class="ccode">double f</td>
<td class="ccode">lisp</td>
</tr>
<tr>
<th></th>
<td>a float</td>
<td>a LISP floating point number</td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name=
"fd_make_int_vector" id=
"fd_make_int_vector">fd_make_int_vector</a></td>
<td class="ccode">int len,int *data</td>
<td class="ccode">lisp</td>
</tr>
<tr>
<th></th>
<td>an int length and a pointer to an array of ints</td>
<td>a homongenous lisp vector of ints</td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name=
"fd_compare_cptrs" id="fd_compare_cptrs">fd_compare_cptrs</a></td>
<td class="ccode">lisp x,lisp y</td>
<td class="ccode">unsigned int</td>
</tr>
<tr>
<th></th>
<td>two cptr objects</td>
<td>an unsigned int</td>
</tr>
<tr>
<th></th>
<td><em>Compares the pointers underlying two cptrs. Returns 1 if
they are the same.</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name=
"fd_hashtable_to_alist" id=
"fd_hashtable_to_alist">fd_hashtable_to_alist</a></td>
<td class="ccode">lisp table</td>
<td class="ccode">lisp</td>
</tr>
<tr>
<th></th>
<td>a lisp pointer to a hashtable</td>
<td>a lisp association list</td>
</tr>
<tr>
<th></th>
<td><em>Converts a hashtable to an association list</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name=
"fd_make_timestamp" id=
"fd_make_timestamp">fd_make_timestamp</a></td>
<td class="ccode">time_t moment</td>
<td class="ccode">lisp</td>
</tr>
<tr>
<th></th>
<td>a time_t value</td>
<td>a lisp record whose tag is the symbol timestamp</td>
</tr>
<tr>
<th></th>
<td></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name=
"fd_alist_to_hashtable" id=
"fd_alist_to_hashtable">fd_alist_to_hashtable</a></td>
<td class="ccode">lisp alist</td>
<td class="ccode">lisp</td>
</tr>
<tr>
<th></th>
<td>a lisp association list</td>
<td>a lisp pointer to a hashtable</td>
</tr>
<tr>
<th></th>
<td><em>Converts an association list to a hashtable</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name=
"fd_make_xtimestamp" id=
"fd_make_xtimestamp">fd_make_xtimestamp</a></td>
<td class="ccode">time_t moment,int nsecs,fd_tmprec prec,int
tzoff</td>
<td class="ccode">lisp</td>
</tr>
<tr>
<th></th>
<td>a time_t value, a nanoseconds value, a precision, and a
timezone string</td>
<td>a lisp record whose tag is the symbol timestamp</td>
</tr>
<tr>
<th></th>
<td></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name="fd_copy_cptr"
id="fd_copy_cptr">fd_copy_cptr</a></td>
<td class="ccode">lisp x</td>
<td class="ccode">lisp</td>
</tr>
<tr>
<th></th>
<td>a cptr object</td>
<td>another cptr object</td>
</tr>
<tr>
<th></th>
<td><em>Makes a new reference counting CONS for a wrapped
cptr.</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name=
"fd_parse_packet" id="fd_parse_packet">fd_parse_packet</a></td>
<td class="ccode">fd_u8char *string</td>
<td class="ccode">lisp</td>
</tr>
<tr>
<th></th>
<td>a utf8 string</td>
<td>a lisp pointer to a packet structure</td>
</tr>
<tr>
<th></th>
<td><em>Takes a long hex string and turns it into a
packet</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name="fd_make_error"
id="fd_make_error">fd_make_error</a></td>
<td class="ccode">lisp data</td>
<td class="ccode">lisp</td>
</tr>
<tr>
<th></th>
<td>another lisp object describing some error</td>
<td>an error object whose *details* are the given arguments</td>
</tr>
<tr>
<th></th>
<td><em>Note: the details are not copied</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name=
"fd_make_packet" id="fd_make_packet">fd_make_packet</a></td>
<td class="ccode">int len,unsigned char *data</td>
<td class="ccode">lisp</td>
</tr>
<tr>
<th></th>
<td>an integer and a pointer to an array of bytes</td>
<td>a "packet object" containing the array of bytes</td>
</tr>
<tr>
<th></th>
<td><em>Note: the details are not copied</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name=
"fd_make_exception" id=
"fd_make_exception">fd_make_exception</a></td>
<td class="ccode">lisp data</td>
<td class="ccode">lisp</td>
</tr>
<tr>
<th></th>
<td>another lisp object describing some exception</td>
<td>an exception object whose *details* are the given
arguments</td>
</tr>
<tr>
<th></th>
<td><em>Note: the details are not copied</em></td>
<td></td>
</tr>
</table>
<h2><a name="consed-oids.c" id="consed-oids.c">Functions defined in
<tt>src/cons/consed-oids.c</tt></a></h2>
<p><a href="#_fd_not_an_oid"><tt>_fd_not_an_oid</tt></a> | <a href=
"#fd_grow_oid_table"><tt>fd_grow_oid_table</tt></a> | <a href=
"#fd_make_oid"><tt>fd_make_oid</tt></a> | <a href=
"#fd_probe_oid"><tt>fd_probe_oid</tt></a> |</p>
<table cellpadding="5">
<tr>
<th align="left">Function</th>
<th align="left">Arguments</th>
<th align="left">Returns</th>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name="fd_probe_oid"
id="fd_probe_oid">fd_probe_oid</a></td>
<td class="ccode">FD_OID id</td>
<td class="ccode">lisp</td>
</tr>
<tr>
<th></th>
<td>an OID</td>
<td>a lisp pointer to the OID object or the empty set</td>
</tr>
<tr>
<th></th>
<td><em>This is like fd_make_oid but doesn't make the oid, only
returns it if it exists.</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name=
"_fd_not_an_oid" id="_fd_not_an_oid">_fd_not_an_oid</a></td>
<td class="ccode">lisp x</td>
<td class="ccode">struct FD_CONSOID *</td>
</tr>
<tr>
<th></th>
<td>a lisp pointer</td>
<td>never, but pretends to return an FD_OID pointer</td>
</tr>
<tr>
<th></th>
<td></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name=
"fd_grow_oid_table" id=
"fd_grow_oid_table">fd_grow_oid_table</a></td>
<td class="ccode">unsigned int size</td>
<td class="ccode">void</td>
</tr>
<tr>
<th></th>
<td>an unsigned int size</td>
<td>nothing</td>
</tr>
<tr>
<th></th>
<td><em>Grows the oid table to at least a specified size. This is
provided because if you know there will be a lot of object
references, you can grow the oid table at first and avoid having to
take the time to grow it along the way.</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name="fd_make_oid"
id="fd_make_oid">fd_make_oid</a></td>
<td class="ccode">FD_OID id</td>
<td class="ccode">lisp</td>
</tr>
<tr>
<th></th>
<td>an OID address structure</td>
<td>a lisp pointer to a OID object with the corresponding
address</td>
</tr>
<tr>
<th></th>
<td><em>This is basically the same loop as above with a
substitution of FD_COMPARE_OIDS for ==.</em></td>
<td></td>
</tr>
</table>
<h2><a name="lightweight-oids.c" id="lightweight-oids.c">Functions
defined in <tt>src/cons/lightweight-oids.c</tt></a></h2>
<table cellpadding="5">
<tr>
<th align="left">Function</th>
<th align="left">Arguments</th>
<th align="left">Returns</th>
</tr>
</table>
<h2><a name="libdtypes.c" id="libdtypes.c">Functions defined in
<tt>src/cons/libdtypes.c</tt></a></h2>
<table cellpadding="5">
<tr>
<th align="left">Function</th>
<th align="left">Arguments</th>
<th align="left">Returns</th>
</tr>
</table>
<h2><a name="data.c" id="data.c">Functions defined in
<tt>src/cons/data.c</tt></a></h2>
<p><a href="#FD_MAKE_LIST"><tt>FD_MAKE_LIST</tt></a> | <a href=
"#_FD_MAKE_LIST1"><tt>_FD_MAKE_LIST1</tt></a> | <a href=
"#_FD_MAKE_PAIR"><tt>_FD_MAKE_PAIR</tt></a> | <a href=
"#_fd_copy_lisp_proc"><tt>_fd_copy_lisp_proc</tt></a> | <a href=
"#_fd_decref_cons"><tt>_fd_decref_cons</tt></a> | <a href=
"#_fd_incref_cons"><tt>_fd_incref_cons</tt></a> | <a href=
"#fd_copy_string"><tt>fd_copy_string</tt></a> | <a href=
"#fd_for_elts"><tt>fd_for_elts</tt></a> | <a href=
"#fd_free_proc"><tt>fd_free_proc</tt></a> | <a href=
"#fd_get_big_buffer"><tt>fd_get_big_buffer</tt></a> | <a href=
"#fd_init_string"><tt>fd_init_string</tt></a> | <a href=
"#fd_init_vector"><tt>fd_init_vector</tt></a> | <a href=
"#fd_lisp_equal"><tt>fd_lisp_equal</tt></a> | <a href=
"#fd_list_length"><tt>fd_list_length</tt></a> | <a href=
"#fd_lookup_compound"><tt>fd_lookup_compound</tt></a> | <a href=
"#fd_lookup_package_code"><tt>fd_lookup_package_code</tt></a> |
<a href="#fd_lookup_record"><tt>fd_lookup_record</tt></a> |
<a href="#fd_lower_string"><tt>fd_lower_string</tt></a> | <a href=
"#fd_make_character"><tt>fd_make_character</tt></a> | <a href=
"#fd_make_cptr"><tt>fd_make_cptr</tt></a> | <a href=
"#fd_make_lrecord"><tt>fd_make_lrecord</tt></a> | <a href=
"#fd_make_pair"><tt>fd_make_pair</tt></a> | <a href=
"#fd_make_record"><tt>fd_make_record</tt></a> | <a href=
"#fd_make_string"><tt>fd_make_string</tt></a> | <a href=
"#fd_make_substring"><tt>fd_make_substring</tt></a> | <a href=
"#fd_make_vector"><tt>fd_make_vector</tt></a> | <a href=
"#fd_memberp"><tt>fd_memberp</tt></a> | <a href=
"#fd_register_record"><tt>fd_register_record</tt></a> | <a href=
"#fd_register_source_file"><tt>fd_register_source_file</tt></a> |
<a href="#fd_register_typecode"><tt>fd_register_typecode</tt></a> |
<a href="#fd_stream_string"><tt>fd_stream_string</tt></a> |
<a href="#fd_utf8_string_ref"><tt>fd_utf8_string_ref</tt></a> |
<a href="#fd_utf8_strlen"><tt>fd_utf8_strlen</tt></a> | <a href=
"#fd_utf8_substring"><tt>fd_utf8_substring</tt></a> |</p>
<table cellpadding="5">
<tr>
<th align="left">Function</th>
<th align="left">Arguments</th>
<th align="left">Returns</th>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name=
"_fd_decref_cons" id="_fd_decref_cons">_fd_decref_cons</a></td>
<td class="ccode">lisp x</td>
<td class="ccode">void</td>
</tr>
<tr>
<th></th>
<td>a lisp object</td>
<td>void</td>
</tr>
<tr>
<th></th>
<td><em>Increments the GC count for x and reclaims it if
appropriate.</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name=
"_fd_copy_lisp_proc" id=
"_fd_copy_lisp_proc">_fd_copy_lisp_proc</a></td>
<td class="ccode">lisp x</td>
<td class="ccode">lisp</td>
</tr>
<tr>
<th></th>
<td>a lisp object</td>
<td>a copy of the object</td>
</tr>
<tr>
<th></th>
<td><em>This doesn't bother copying fixnums, symbols, objects, or
immediates. The macro fd_incref is the identify for such objects
and calls _fd_copy_lisp_proc for everything else.</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name="fd_lisp_equal"
id="fd_lisp_equal">fd_lisp_equal</a></td>
<td class="ccode">lisp key0, lisp key1</td>
<td class="ccode">int</td>
</tr>
<tr>
<th></th>
<td>two lisp objects</td>
<td>the integer 1 if they're EQUAL, 0 if they're not.</td>
</tr>
<tr>
<th></th>
<td></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name=
"_fd_incref_cons" id="_fd_incref_cons">_fd_incref_cons</a></td>
<td class="ccode">lisp x</td>
<td class="ccode">lisp</td>
</tr>
<tr>
<th></th>
<td>a lisp pointer</td>
<td>its argument</td>
</tr>
<tr>
<th></th>
<td><em>Increments the reference count associated with a
cons</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name=
"fd_make_vector" id="fd_make_vector">fd_make_vector</a></td>
<td class="ccode">int size</td>
<td class="ccode">lisp</td>
</tr>
<tr>
<th></th>
<td>a C integer</td>
<td>a vector of a fixed size, initialized to FD_EMPTY_CHOICE</td>
</tr>
<tr>
<th></th>
<td><em>Makes a vector of the given size. A vector is implemented
as a record with the tag VECTOR_TAG and a pointer to an array of
size and elements.</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name="fd_make_cptr"
id="fd_make_cptr">fd_make_cptr</a></td>
<td class="ccode">fd_lisp_type tp,void *data</td>
<td class="ccode">fd_lisp</td>
</tr>
<tr>
<th></th>
<td>a lisp type and a data pointer</td>
<td>a lisp pointer with the type and an allocated refcounter
for</td>
</tr>
<tr>
<th></th>
<td><em>the cpointer</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name=
"fd_copy_string" id="fd_copy_string">fd_copy_string</a></td>
<td class="ccode">fd_u8char *string</td>
<td class="ccode">lisp</td>
</tr>
<tr>
<th></th>
<td>a null-terminated utf8 string</td>
<td>a lisp object describing the string</td>
</tr>
<tr>
<th></th>
<td><em>This copies the string argument and also determines if it
is UTF-8 or not.</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name=
"fd_make_substring" id=
"fd_make_substring">fd_make_substring</a></td>
<td class="ccode">fd_u8char *start,fd_u8char *end</td>
<td class="ccode">lisp</td>
</tr>
<tr>
<th></th>
<td>two pointers into the same utf-8 string</td>
<td>a lisp object describing the substring between them</td>
</tr>
<tr>
<th></th>
<td></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name="fd_make_pair"
id="fd_make_pair">fd_make_pair</a></td>
<td class="ccode">lisp x, lisp y</td>
<td class="ccode">lisp</td>
</tr>
<tr>
<th></th>
<td>two lisp objects</td>
<td>a cons pair whose CAR and CDR are the arguments</td>
</tr>
<tr>
<th></th>
<td><em>the arguments *are* incref'd</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name=
"fd_lower_string" id="fd_lower_string">fd_lower_string</a></td>
<td class="ccode">fd_u8char *string</td>
<td class="ccode">lisp</td>
</tr>
<tr>
<th></th>
<td>a null-terminated utf-8 C string</td>
<td>a lisp object describing the lower-cased version of the
string</td>
</tr>
<tr>
<th></th>
<td><em>This is useful for canonicalizing strings to look things up
in hashtables, etc.</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name=
"fd_init_string" id="fd_init_string">fd_init_string</a></td>
<td class="ccode">fd_u8char *string,int size</td>
<td class="ccode">lisp</td>
</tr>
<tr>
<th></th>
<td>a null-terminated utf8 string</td>
<td>a lisp object describing the string</td>
</tr>
<tr>
<th></th>
<td><em>This uses the actual string argument (so it shouldn't be
stack consed or subsequently freed by the caller).</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name=
"fd_make_character" id=
"fd_make_character">fd_make_character</a></td>
<td class="ccode">unsigned int c</td>
<td class="ccode">lisp</td>
</tr>
<tr>
<th></th>
<td>a character</td>
<td>the LISP version of the character</td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name=
"fd_utf8_string_ref" id=
"fd_utf8_string_ref">fd_utf8_string_ref</a></td>
<td class="ccode">fd_u8char *str</td>
<td class="ccode">int</td>
</tr>
<tr>
<th></th>
<td>a pointer to a UTF-encoded string</td>
<td>returns the first unicode character in the string</td>
</tr>
<tr>
<th></th>
<td></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name="fd_memberp"
id="fd_memberp">fd_memberp</a></td>
<td class="ccode">lisp x,lisp list</td>
<td class="ccode">int</td>
</tr>
<tr>
<th></th>
<td>a lisp object and a list of such objects</td>
<td>1 if the object is in the list and 0 otherwise</td>
</tr>
<tr>
<th></th>
<td></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name=
"fd_make_string" id="fd_make_string">fd_make_string</a></td>
<td class="ccode">char *string</td>
<td class="ccode">lisp</td>
</tr>
<tr>
<th></th>
<td>a null-terminated localized C string</td>
<td>a lisp object describing the string</td>
</tr>
<tr>
<th></th>
<td><em>This does UTF-8 conversion and doesn't use the direct
pointer to string.</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name="FD_MAKE_LIST"
id="FD_MAKE_LIST">FD_MAKE_LIST</a></td>
<td class="ccode">int length,...</td>
<td class="ccode">lisp</td>
</tr>
<tr>
<th></th>
<td>an integer followed by several elements</td>
<td>a list of <var>length</var> elements in order</td>
</tr>
<tr>
<th></th>
<td></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name=
"fd_utf8_strlen" id="fd_utf8_strlen">fd_utf8_strlen</a></td>
<td class="ccode">fd_u8char *str,int slen</td>
<td class="ccode">int</td>
</tr>
<tr>
<th></th>
<td>a pointer to a UTF-encoded string and a length</td>
<td>an integer indicating the number of unicode characters</td>
</tr>
<tr>
<th></th>
<td><em>in the string it represents</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name=
"fd_list_length" id="fd_list_length">fd_list_length</a></td>
<td class="ccode">lisp x</td>
<td class="ccode">unsigned int</td>
</tr>
<tr>
<th></th>
<td>a lisp object</td>
<td>the number of elements in the object, if it is a list,</td>
</tr>
<tr>
<th></th>
<td><em>or 1 otherwise.</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name=
"fd_lookup_compound" id=
"fd_lookup_compound">fd_lookup_compound</a></td>
<td class="ccode">lisp tag</td>
<td class="ccode">struct FD_TYPE_REGISTRY *</td>
</tr>
<tr>
<th></th>
<td>a lisp tag</td>
<td>a pointer to a record entry or NULL</td>
</tr>
<tr>
<th></th>
<td><em>Returns the record entry for types with the specified
compound tag</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name=
"fd_make_record" id="fd_make_record">fd_make_record</a></td>
<td class="ccode">lisp type_name, void *data</td>
<td class="ccode">lisp</td>
</tr>
<tr>
<th></th>
<td>a type specifier (a lisp object), and a pointer to some
data</td>
<td>a lisp record</td>
</tr>
<tr>
<th></th>
<td></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name="fd_free_proc"
id="fd_free_proc">fd_free_proc</a></td>
<td class="ccode">lisp x</td>
<td class="ccode">void</td>
</tr>
<tr>
<th></th>
<td>a lisp object</td>
<td>nothing</td>
</tr>
<tr>
<th></th>
<td><em>If x is reclaimable (e.g. not a symbol, object, integer,
etc), reclaim the storage used by x for future objects. This is
used by the inline fd_decref which doesn't bother invoking it on
non-reclaimable objects.</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name="_FD_MAKE_PAIR"
id="_FD_MAKE_PAIR">_FD_MAKE_PAIR</a></td>
<td class="ccode">lisp x, lisp y</td>
<td class="ccode">lisp</td>
</tr>
<tr>
<th></th>
<td>two lisp objects</td>
<td>a cons pair whose CAR and CDR are the arguments</td>
</tr>
<tr>
<th></th>
<td><em>the arguments are not incref'd</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name=
"fd_lookup_package_code" id=
"fd_lookup_package_code">fd_lookup_package_code</a></td>
<td class="ccode">unsigned char package_code,unsigned char
subcode</td>
<td class="ccode">struct FD_TYPE_REGISTRY *</td>
</tr>
<tr>
<th></th>
<td>a package code and subcode</td>
<td>a pointer to a record entry or NULL</td>
</tr>
<tr>
<th></th>
<td><em>Returns the record entry for types with the specified
package code and subcode. Note that this looks up the subcode for
the "short" version of the packaged data.</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name=
"fd_register_typecode" id=
"fd_register_typecode">fd_register_typecode</a></td>
<td class="ccode">fd_lisp_type tp</td>
<td class="ccode">struct FD_TYPE_REGISTRY *</td>
</tr>
<tr>
<th></th>
<td>a lisp typecode</td>
<td>a pointer to a record entry</td>
</tr>
<tr>
<th></th>
<td><em>Returns a record entry for types with a particular
typecode. This creates an entry if one does not already exist.
Also, if the tag is FD_VOID, it always creates a new entry. (This
is useful for types which don't have tags but need special methods
like non-deterministic sets.</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name=
"_FD_MAKE_LIST1" id="_FD_MAKE_LIST1">_FD_MAKE_LIST1</a></td>
<td class="ccode">lisp x</td>
<td class="ccode">lisp</td>
</tr>
<tr>
<th></th>
<td>a lisp object</td>
<td>a list whose first and only element is the argument</td>
</tr>
<tr>
<th></th>
<td></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name="fd_for_elts"
id="fd_for_elts">fd_for_elts</a></td>
<td class="ccode">void (*fcn</td>
<td class="ccode">void</td>
</tr>
<tr>
<th></th>
<td>a function which returns void from a lisp object and a list of
lisp objects</td>
<td>nothing</td>
</tr>
<tr>
<th></th>
<td><em>This applies the function to all the elements of the
list.</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name=
"fd_stream_string" id="fd_stream_string">fd_stream_string</a></td>
<td class="ccode">struct FD_STRING_STREAM *s</td>
<td class="ccode">lisp</td>
</tr>
<tr>
<th></th>
<td>a pointer to a string stream</td>
<td>a lisp string containing the contents of the stream</td>
</tr>
<tr>
<th></th>
<td><em>This sets the string stream's pointer to NULL and size to
zero, so that subsequent modifications signal errors.</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name=
"fd_register_source_file" id=
"fd_register_source_file">fd_register_source_file</a></td>
<td class="ccode">char *name,char *date,char *details</td>
<td class="ccode">void</td>
</tr>
<tr>
<th></th>
<td>three strings -- name, date, and details</td>
<td>void</td>
</tr>
<tr>
<th></th>
<td><em>Registers a module. Name is the filename (basename), date
is the compilation date for the file, and details is typically the
RCSID tag.</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name=
"fd_init_vector" id="fd_init_vector">fd_init_vector</a></td>
<td class="ccode">int size,lisp *elts</td>
<td class="ccode">lisp</td>
</tr>
<tr>
<th></th>
<td>a C integer and a pointer to a vector of LISP objects</td>
<td>a vector of a fixed size with the given elements</td>
</tr>
<tr>
<th></th>
<td><em>Makes a vector of the given size with particular elements.
Called by dtio.c to make vectors when reading dtypes.</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name=
"fd_make_lrecord" id="fd_make_lrecord">fd_make_lrecord</a></td>
<td class="ccode">lisp type_name, lisp data</td>
<td class="ccode">lisp</td>
</tr>
<tr>
<th></th>
<td>a type specifier (a lisp object), and another lisp object</td>
<td>a lisp record</td>
</tr>
<tr>
<th></th>
<td></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name=
"fd_lookup_record" id="fd_lookup_record">fd_lookup_record</a></td>
<td class="ccode">lisp tag</td>
<td class="ccode">struct FD_TYPE_REGISTRY *</td>
</tr>
<tr>
<th></th>
<td>a lisp pointer</td>
<td>a pointer to a record entry or NULL</td>
</tr>
<tr>
<th></th>
<td><em>Returns the record entry for types whose record tags are
the argument given to the function.</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name=
"fd_utf8_substring" id=
"fd_utf8_substring">fd_utf8_substring</a></td>
<td class="ccode">fd_u8char *str,int index</td>
<td class="ccode">char *</td>
</tr>
<tr>
<th></th>
<td>a pointer to a UTF-encoded string and an integer</td>
<td>the substring starting at the interger-th character</td>
</tr>
<tr>
<th></th>
<td></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name=
"fd_register_record" id=
"fd_register_record">fd_register_record</a></td>
<td class="ccode">lisp tag</td>
<td class="ccode">struct FD_TYPE_REGISTRY *</td>
</tr>
<tr>
<th></th>
<td>a lisp pointer</td>
<td>a pointer to a record entry</td>
</tr>
<tr>
<th></th>
<td><em>Returns a record entry for types with a particular record
tag. This creates an entry if one does not already exist. Also, if
the tag is FD_VOID, it always creates a new entry. (This is useful
for types which don't have tags but need special methods like
non-deterministic sets.</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name=
"fd_get_big_buffer" id=
"fd_get_big_buffer">fd_get_big_buffer</a></td>
<td class="ccode">unsigned int *bufsize</td>
<td class="ccode">char *</td>
</tr>
<tr>
<th></th>
<td>a pointer to an int</td>
<td>a pointer to a large char array</td>
</tr>
<tr>
<th></th>
<td><em>Allocates a big buffer, with the size determined by the
environment variable FD_BUFFER_SIZE or the runtime define
FD_BIGBUFF_DEFAULT. This value is stored in the int pointed to by
the argument.</em></td>
<td></td>
</tr>
</table>
<h2><a name="hash.c" id="hash.c">Functions defined in
<tt>src/cons/hash.c</tt></a></h2>
<p><a href="#_fd_hashset_add_nc"><tt>_fd_hashset_add_nc</tt></a> |
<a href=
"#_fd_hashtable_set_nolock"><tt>_fd_hashtable_set_nolock</tt></a> |
<a href=
"#_fd_set_symbol_value_noref"><tt>_fd_set_symbol_value_noref</tt></a>
| <a href=
"#_fd_symbol_value_noref"><tt>_fd_symbol_value_noref</tt></a> |
<a href="#fd_choice_to_hashset"><tt>fd_choice_to_hashset</tt></a> |
<a href=
"#fd_cleanup_locked_hashtable"><tt>fd_cleanup_locked_hashtable</tt></a>
| <a href=
"#fd_final_hashset_elts"><tt>fd_final_hashset_elts</tt></a> |
<a href="#fd_for_all_symbols"><tt>fd_for_all_symbols</tt></a> |
<a href="#fd_free_hashset"><tt>fd_free_hashset</tt></a> | <a href=
"#fd_free_hashtable"><tt>fd_free_hashtable</tt></a> | <a href=
"#fd_grow_hashset"><tt>fd_grow_hashset</tt></a> | <a href=
"#fd_grow_hashtable"><tt>fd_grow_hashtable</tt></a> | <a href=
"#fd_hash_lisp"><tt>fd_hash_lisp</tt></a> | <a href=
"#fd_hashset_add"><tt>fd_hashset_add</tt></a> | <a href=
"#fd_hashset_drop"><tt>fd_hashset_drop</tt></a> | <a href=
"#fd_hashset_elts"><tt>fd_hashset_elts</tt></a> | <a href=
"#fd_hashset_get"><tt>fd_hashset_get</tt></a> | <a href=
"#fd_hashset_intern"><tt>fd_hashset_intern</tt></a> | <a href=
"#fd_hashset_probe"><tt>fd_hashset_probe</tt></a> | <a href=
"#fd_hashset_strget"><tt>fd_hashset_strget</tt></a> | <a href=
"#fd_hashtable_add"><tt>fd_hashtable_add</tt></a> | <a href=
"#fd_hashtable_drop"><tt>fd_hashtable_drop</tt></a> | <a href=
"#fd_hashtable_get"><tt>fd_hashtable_get</tt></a> | <a href=
"#fd_hashtable_increment"><tt>fd_hashtable_increment</tt></a> |
<a href=
"#fd_hashtable_increment_existing"><tt>fd_hashtable_increment_existing</tt></a>
| <a href="#fd_hashtable_max"><tt>fd_hashtable_max</tt></a> |
<a href="#fd_hashtable_probe"><tt>fd_hashtable_probe</tt></a> |
<a href="#fd_hashtable_set"><tt>fd_hashtable_set</tt></a> |
<a href="#fd_hashtable_skim"><tt>fd_hashtable_skim</tt></a> |
<a href="#fd_hashtable_test"><tt>fd_hashtable_test</tt></a> |
<a href="#fd_hashtable_zap"><tt>fd_hashtable_zap</tt></a> |
<a href="#fd_init_hashset"><tt>fd_init_hashset</tt></a> | <a href=
"#fd_init_hashtable"><tt>fd_init_hashtable</tt></a> | <a href=
"#fd_intern"><tt>fd_intern</tt></a> | <a href=
"#fd_make_hashset"><tt>fd_make_hashset</tt></a> | <a href=
"#fd_make_hashtable"><tt>fd_make_hashtable</tt></a> | <a href=
"#fd_make_qstring"><tt>fd_make_qstring</tt></a> | <a href=
"#fd_make_symbol"><tt>fd_make_symbol</tt></a> | <a href=
"#fd_probe_symbol"><tt>fd_probe_symbol</tt></a> | <a href=
"#fd_reinit_hashset"><tt>fd_reinit_hashset</tt></a> | <a href=
"#fd_reinit_hashtable"><tt>fd_reinit_hashtable</tt></a> | <a href=
"#fd_select_table_size"><tt>fd_select_table_size</tt></a> |
<a href="#fd_set_symbol_value"><tt>fd_set_symbol_value</tt></a> |
<a href="#fd_symbol_value"><tt>fd_symbol_value</tt></a> |</p>
<table cellpadding="5">
<tr>
<th align="left">Function</th>
<th align="left">Arguments</th>
<th align="left">Returns</th>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name=
"fd_reinit_hashtable" id=
"fd_reinit_hashtable">fd_reinit_hashtable</a></td>
<td class="ccode">fd_hashtable h,int minsize,int locked</td>
<td class="ccode">void</td>
</tr>
<tr>
<th></th>
<td>a pointer to a hashtable and an int minsize</td>
<td>nothing</td>
</tr>
<tr>
<th></th>
<td><em>Reinitializes the table for use with at least minsize
slots. This leaves the tables mutex untouched, since someone may be
waiting on it.</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name=
"fd_final_hashset_elts" id=
"fd_final_hashset_elts">fd_final_hashset_elts</a></td>
<td class="ccode">fd_hashset h</td>
<td class="ccode">lisp</td>
</tr>
<tr>
<th></th>
<td>a pointer to a hashset</td>
<td>a lisp object (possibly a non-deterministic set)</td>
</tr>
<tr>
<th></th>
<td><em>This returns all the values in the hashset and frees the
hashset.</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name=
"fd_init_hashtable" id=
"fd_init_hashtable">fd_init_hashtable</a></td>
<td class="ccode">fd_hashtable h,int minsize</td>
<td class="ccode">void</td>
</tr>
<tr>
<th></th>
<td>a pointer to a hashtable and an int minsize</td>
<td>nothing</td>
</tr>
<tr>
<th></th>
<td><em>Initializes the table for use with at least minsize slots.
This can be used for either a malloc'd hashtable or a hashtable on
the stack.</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name=
"fd_make_symbol" id="fd_make_symbol">fd_make_symbol</a></td>
<td class="ccode">const fd_u8char *pname</td>
<td class="ccode">lisp</td>
</tr>
<tr>
<th></th>
<td>a string</td>
<td>a lisp pointer to a symbol with that name</td>
</tr>
<tr>
<th></th>
<td><em>This is basically the same loop as above with a
substitution of a strcmp for the == test.</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name=
"fd_hashtable_get" id="fd_hashtable_get">fd_hashtable_get</a></td>
<td class="ccode">fd_hashtable h,lisp key,lisp dflt</td>
<td class="ccode">lisp</td>
</tr>
<tr>
<th></th>
<td>a pointer to a hashtable, a lisp key, and a default</td>
<td>a lisp object</td>
</tr>
<tr>
<th></th>
<td><em>Returns the value associated with the key in the hashtable
or the given default value if there is no such assocation. Note
that this does *not* copy the value returned from the
table.</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name=
"fd_hashtable_skim" id=
"fd_hashtable_skim">fd_hashtable_skim</a></td>
<td class="ccode">fd_hashtable h,int threshold</td>
<td class="ccode">lisp</td>
</tr>
<tr>
<th></th>
<td>a hashtable and an integral threshold</td>
<td>a lisp pointer</td>
</tr>
<tr>
<th></th>
<td><em>Returns (as a choice) all the keys in the hashtable whose
values are greater than the numeric threshold.</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name=
"fd_free_hashset" id="fd_free_hashset">fd_free_hashset</a></td>
<td class="ccode">struct FD_HASHSET *h</td>
<td class="ccode">void</td>
</tr>
<tr>
<th></th>
<td>a pointer to a hashset</td>
<td>nothing</td>
</tr>
<tr>
<th></th>
<td><em>Frees the memory taken by a hashset and its elements. Note
that this does not free the hashtable itself, since it might be on
the stack.</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name="fd_hash_lisp"
id="fd_hash_lisp">fd_hash_lisp</a></td>
<td class="ccode">lisp x</td>
<td class="ccode">unsigned int</td>
</tr>
<tr>
<th></th>
<td>a lisp pointer</td>
<td>an unsigned int</td>
</tr>
<tr>
<th></th>
<td><em>Returns the hash for a lisp object. This hash is *not*
portable across sessions.</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name=
"fd_make_hashset" id="fd_make_hashset">fd_make_hashset</a></td>
<td class="ccode">int minsize</td>
<td class="ccode">struct FD_HASHSET *</td>
</tr>
<tr>
<th></th>
<td>an int minsize</td>
<td>a pointer to a hashtable</td>
</tr>
<tr>
<th></th>
<td><em>This mallocs a new hashset and initializes it to have at
least minsize elements.</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name=
"fd_cleanup_locked_hashtable" id=
"fd_cleanup_locked_hashtable">fd_cleanup_locked_hashtable</a></td>
<td class="ccode">fd_hashtable h</td>
<td class="ccode">void</td>
</tr>
<tr>
<th></th>
<td>a pointer to a hashtable</td>
<td>nothing</td>
</tr>
<tr>
<th></th>
<td><em>Removes empty elements from the hashtable.</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name=
"fd_hashtable_increment_existing" id=
"fd_hashtable_increment_existing">fd_hashtable_increment_existing</a></td>
<td class="ccode">fd_hashtable h,lisp key,int increment</td>
<td class="ccode">void</td>
</tr>
<tr>
<th></th>
<td>a pointer to a hashtable, a lisp key, and an int</td>
<td>nothing</td>
</tr>
<tr>
<th></th>
<td><em>Increments the value associated with the key by a number,
doing nothing if the key does not exist.</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name=
"fd_grow_hashset" id="fd_grow_hashset">fd_grow_hashset</a></td>
<td class="ccode">fd_hashset h,int minsize</td>
<td class="ccode">void</td>
</tr>
<tr>
<th></th>
<td>a pointer to a hashset and an int minsize</td>
<td>nothing</td>
</tr>
<tr>
<th></th>
<td><em>Grows the hashset to have at least minsize slots</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name=
"fd_grow_hashtable" id=
"fd_grow_hashtable">fd_grow_hashtable</a></td>
<td class="ccode">struct FD_HASHTABLE *h,int minsize</td>
<td class="ccode">void</td>
</tr>
<tr>
<th></th>
<td>a pointer to a hashtable and an int minsize</td>
<td>nothing</td>
</tr>
<tr>
<th></th>
<td><em>Grows hashtable to have at least minsize slots</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name=
"fd_reinit_hashset" id=
"fd_reinit_hashset">fd_reinit_hashset</a></td>
<td class="ccode">fd_hashset h,int minsize,int locked</td>
<td class="ccode">void</td>
</tr>
<tr>
<th></th>
<td>a pointer to a hashtable and an int minsize</td>
<td>nothing</td>
</tr>
<tr>
<th></th>
<td><em>Reinitializes the table for use with at least minsize
slots. This leaves the tables mutex untouched, since someone may be
waiting on it.</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name=
"_fd_set_symbol_value_noref" id=
"_fd_set_symbol_value_noref">_fd_set_symbol_value_noref</a></td>
<td class="ccode">lisp x,lisp v</td>
<td class="ccode">void</td>
</tr>
<tr>
<th></th>
<td>a LISP symbol, another LISP pointer</td>
<td>nothing</td>
</tr>
<tr>
<th></th>
<td><em>Threadsafe modifier for the value slot of a symbol which
does not do any refcounting or uncounting.</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name=
"fd_probe_symbol" id="fd_probe_symbol">fd_probe_symbol</a></td>
<td class="ccode">const fd_u8char *pname</td>
<td class="ccode">lisp</td>
</tr>
<tr>
<th></th>
<td>a string</td>
<td>a lisp pointer to a symbol with that name</td>
</tr>
<tr>
<th></th>
<td><em>This is like fd_make_symbol but doesn't make the symbol,
only returning it if it exists.</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name=
"fd_make_qstring" id="fd_make_qstring">fd_make_qstring</a></td>
<td class="ccode">fd_u8char *string_data,int len</td>
<td class="ccode">lisp</td>
</tr>
<tr>
<th></th>
<td>a string and a length</td>
<td>a lisp pointer to a qstring that is EQUAL to the string</td>
</tr>
<tr>
<th></th>
<td><em>If the length is negative, it is computed.</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name=
"_fd_symbol_value_noref" id=
"_fd_symbol_value_noref">_fd_symbol_value_noref</a></td>
<td class="ccode">lisp x</td>
<td class="ccode">lisp</td>
</tr>
<tr>
<th></th>
<td>a LISP symbol</td>
<td>the symbol's value</td>
</tr>
<tr>
<th></th>
<td><em>Threadsafe accessor for the value slot which doesn't incref
the value it returns</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name=
"fd_init_hashset" id="fd_init_hashset">fd_init_hashset</a></td>
<td class="ccode">fd_hashset h,int minsize</td>
<td class="ccode">void</td>
</tr>
<tr>
<th></th>
<td>a pointer to a hashset and an int minsize</td>
<td>nothing</td>
</tr>
<tr>
<th></th>
<td><em>Initializes the table for use with at least minsize slots.
This can be used for either a malloc'd hashtable or a hashtable on
the stack.</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name=
"fd_hashtable_zap" id="fd_hashtable_zap">fd_hashtable_zap</a></td>
<td class="ccode">fd_hashtable h,lisp key</td>
<td class="ccode">void</td>
</tr>
<tr>
<th></th>
<td>a pointer to a hashtable and a lisp key</td>
<td>nothing</td>
</tr>
<tr>
<th></th>
<td><em>Removes all values associated key in the
hashtable.</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name=
"fd_set_symbol_value" id=
"fd_set_symbol_value">fd_set_symbol_value</a></td>
<td class="ccode">lisp x,lisp v</td>
<td class="ccode">void</td>
</tr>
<tr>
<th></th>
<td>a LISP symbol, another LISP pointer</td>
<td>nothing</td>
</tr>
<tr>
<th></th>
<td><em>Threadsafe modifier for the value slot of a
symbol.</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name=
"fd_hashtable_increment" id=
"fd_hashtable_increment">fd_hashtable_increment</a></td>
<td class="ccode">fd_hashtable h,lisp key,int increment</td>
<td class="ccode">void</td>
</tr>
<tr>
<th></th>
<td>a pointer to a hashtable, a lisp key, and an int</td>
<td>nothing</td>
</tr>
<tr>
<th></th>
<td><em>Increments the value associated with the key by a number,
simply storing the number if no value is currently
associated.</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name=
"fd_hashtable_test" id=
"fd_hashtable_test">fd_hashtable_test</a></td>
<td class="ccode">fd_hashtable h,lisp key,lisp value</td>
<td class="ccode">int</td>
</tr>
<tr>
<th></th>
<td>a pointer to a hashtable, a lisp key, and a lisp value</td>
<td>1 or 0</td>
</tr>
<tr>
<th></th>
<td><em>Returns 1 if the value is one of the values associated with
the key</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name=
"fd_hashset_get" id="fd_hashset_get">fd_hashset_get</a></td>
<td class="ccode">fd_hashset h,lisp key</td>
<td class="ccode">int</td>
</tr>
<tr>
<th></th>
<td>a pointer to a hashtable and a lisp key</td>
<td>1 or 0</td>
</tr>
<tr>
<th></th>
<td><em>Returns 1 if the given key is in the hashset.</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name=
"fd_free_hashtable" id=
"fd_free_hashtable">fd_free_hashtable</a></td>
<td class="ccode">struct FD_HASHTABLE *h</td>
<td class="ccode">void</td>
</tr>
<tr>
<th></th>
<td>a pointer to a hashtable</td>
<td>nothing</td>
</tr>
<tr>
<th></th>
<td><em>Frees the memory taken by a hashtable and its elements.
Note that this does not free the hashtable itself, since it might
be on the stack.</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name=
"fd_symbol_value" id="fd_symbol_value">fd_symbol_value</a></td>
<td class="ccode">lisp x</td>
<td class="ccode">lisp</td>
</tr>
<tr>
<th></th>
<td>a LISP symbol</td>
<td>the symbol's value</td>
</tr>
<tr>
<th></th>
<td><em>Threadsafe accessor for the value slot which increfs the
value it returns</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name=
"fd_hashtable_drop" id=
"fd_hashtable_drop">fd_hashtable_drop</a></td>
<td class="ccode">fd_hashtable h,lisp key,lisp value</td>
<td class="ccode">void</td>
</tr>
<tr>
<th></th>
<td>a pointer to a hashtable, a lisp key, and a value</td>
<td>nothing</td>
</tr>
<tr>
<th></th>
<td><em>Removes a value from the values associated with key in the
hashtable.</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name=
"fd_hashtable_add" id="fd_hashtable_add">fd_hashtable_add</a></td>
<td class="ccode">fd_hashtable h,lisp key,lisp value</td>
<td class="ccode">void</td>
</tr>
<tr>
<th></th>
<td>a pointer to a hashtable, a lisp key, and a value</td>
<td>nothing</td>
</tr>
<tr>
<th></th>
<td><em>Adds a value to the values associated with key in the
hashtable. If the key is already associated with multiple values, a
copy of the new value is added to it. If there is one association,
a new non-deterministic set is created. And if there is not
association, this is just the same as fd_hashtable_set.</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name=
"fd_for_all_symbols" id=
"fd_for_all_symbols">fd_for_all_symbols</a></td>
<td class="ccode">void (*fcn</td>
<td class="ccode">void</td>
</tr>
<tr>
<th></th>
<td>a function on lisp pointers which returns void</td>
<td>nothing</td>
</tr>
<tr>
<th></th>
<td><em>Applies the function to every symbol in the symbol
table.</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name=
"fd_hashtable_probe" id=
"fd_hashtable_probe">fd_hashtable_probe</a></td>
<td class="ccode">fd_hashtable h,lisp key</td>
<td class="ccode">int</td>
</tr>
<tr>
<th></th>
<td>a pointer to a hashtable, a lisp key</td>
<td>1 or 0</td>
</tr>
<tr>
<th></th>
<td><em>Returns 1 if the key is associated with some value in the
table.</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name=
"fd_select_table_size" id=
"fd_select_table_size">fd_select_table_size</a></td>
<td class="ccode">unsigned int min</td>
<td class="ccode">unsigned int</td>
</tr>
<tr>
<th></th>
<td>an unsigned int (min)</td>
<td>an unsigned int greater than min</td>
</tr>
<tr>
<th></th>
<td><em>Selects a hashtable/index size greater than min.</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name=
"fd_hashset_probe" id="fd_hashset_probe">fd_hashset_probe</a></td>
<td class="ccode">fd_hashset h,lisp key</td>
<td class="ccode">lisp</td>
</tr>
<tr>
<th></th>
<td>a pointer to a hashset and a lisp key</td>
<td>a value EQUAL to the key in the hashset</td>
</tr>
<tr>
<th></th>
<td><em>Adds a cref of a key to the hashset (if it doesn't already
contain it), otherwise returns the pointer already there</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name=
"fd_hashtable_set" id="fd_hashtable_set">fd_hashtable_set</a></td>
<td class="ccode">fd_hashtable h,lisp key,lisp value</td>
<td class="ccode">void</td>
</tr>
<tr>
<th></th>
<td>a pointer to a hashtable, a lisp key, and a value</td>
<td>nothing</td>
</tr>
<tr>
<th></th>
<td><em>Associates the value with the key in the hashtable. If the
key is new it copies both key and value; if the key already had an
association, that value is freed and a copy of the new value
replaces it.</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name=
"fd_hashset_strget" id=
"fd_hashset_strget">fd_hashset_strget</a></td>
<td class="ccode">fd_hashset h,fd_u8char *keystring,int len</td>
<td class="ccode">int</td>
</tr>
<tr>
<th></th>
<td>a pointer to a hashtable and a string</td>
<td>1 or 0</td>
</tr>
<tr>
<th></th>
<td><em>Returns 1 if the a LISP copy of string is in the
hashset.</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name="fd_intern" id=
"fd_intern">fd_intern</a></td>
<td class="ccode">const fd_u8char *name,int len</td>
<td class="ccode">fd_lisp</td>
</tr>
<tr>
<th></th>
<td>a pointer to a string and a int length</td>
<td>a lisp pointer to a symbol whose name is the string
capitalized</td>
</tr>
<tr>
<th></th>
<td><em>Returns an interned symbol whose name is a capitalized
version of name.</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name=
"_fd_hashset_add_nc" id=
"_fd_hashset_add_nc">_fd_hashset_add_nc</a></td>
<td class="ccode">fd_hashset h,lisp key</td>
<td class="ccode">int</td>
</tr>
<tr>
<th></th>
<td>a pointer to a hashset and a lisp key</td>
<td>1 if the value wasn't already there</td>
</tr>
<tr>
<th></th>
<td><em>Adds a key (not a copy!) to the hashset.</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name=
"fd_hashset_elts" id="fd_hashset_elts">fd_hashset_elts</a></td>
<td class="ccode">fd_hashset h</td>
<td class="ccode">lisp</td>
</tr>
<tr>
<th></th>
<td>a pointer to a hashset</td>
<td>a lisp object (possibly a non-deterministic set)</td>
</tr>
<tr>
<th></th>
<td><em>This returns all the values in the hashset.</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name=
"_fd_hashtable_set_nolock" id=
"_fd_hashtable_set_nolock">_fd_hashtable_set_nolock</a></td>
<td class="ccode">fd_hashtable h,lisp key,lisp value</td>
<td class="ccode">void</td>
</tr>
<tr>
<th></th>
<td>a pointer to a hashtable, a lisp key, and a value</td>
<td>nothing</td>
</tr>
<tr>
<th></th>
<td><em>Associates the value with the key in the hashtable. If the
key is new it copies both key and value; if the key already had an
association, that value is freed and a copy of the new value
replaces it.</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name=
"fd_hashset_add" id="fd_hashset_add">fd_hashset_add</a></td>
<td class="ccode">fd_hashset h,lisp key</td>
<td class="ccode">int</td>
</tr>
<tr>
<th></th>
<td>a pointer to a hashset and a lisp key</td>
<td>1 if the value wasn't already there</td>
</tr>
<tr>
<th></th>
<td><em>Adds a cref of a key to the hashset (if it doesn't already
contain it).</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name=
"fd_hashset_intern" id=
"fd_hashset_intern">fd_hashset_intern</a></td>
<td class="ccode">fd_hashset h,lisp key</td>
<td class="ccode">lisp</td>
</tr>
<tr>
<th></th>
<td>a pointer to a hashset and a lisp key</td>
<td>a value EQUAL to the key in the hashset</td>
</tr>
<tr>
<th></th>
<td><em>Adds a cref of a key to the hashset (if it doesn't already
contain it), otherwise returns the pointer already there</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name=
"fd_make_hashtable" id=
"fd_make_hashtable">fd_make_hashtable</a></td>
<td class="ccode">int minsize</td>
<td class="ccode">struct FD_HASHTABLE *</td>
</tr>
<tr>
<th></th>
<td>an int minsize</td>
<td>a pointer to a hashtable</td>
</tr>
<tr>
<th></th>
<td><em>This mallocs a new hashtable and initializes it to have at
least minsize elements.</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name=
"fd_hashset_drop" id="fd_hashset_drop">fd_hashset_drop</a></td>
<td class="ccode">fd_hashset h,lisp key</td>
<td class="ccode">void</td>
</tr>
<tr>
<th></th>
<td>a pointer to a hashtable and a lisp key</td>
<td>nothing</td>
</tr>
<tr>
<th></th>
<td><em>"Removes" the key from the hashset by replacing it with
FD_VOID. Note that this doesn't save any space, but the search
algorithm will just skip over it rather than returning
it.</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name=
"fd_hashtable_max" id="fd_hashtable_max">fd_hashtable_max</a></td>
<td class="ccode">fd_hashtable h</td>
<td class="ccode">lisp</td>
</tr>
<tr>
<th></th>
<td>a hashtable</td>
<td>a lisp pointer</td>
</tr>
<tr>
<th></th>
<td><em>Returns the keys in the hashtable whose values are
numerically maximum.</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name=
"fd_choice_to_hashset" id=
"fd_choice_to_hashset">fd_choice_to_hashset</a></td>
<td class="ccode">lisp values</td>
<td class="ccode">fd_hashset</td>
</tr>
<tr>
<th></th>
<td>a pointer to a hashset</td>
<td>a lisp object (possibly a non-deterministic set)</td>
</tr>
<tr>
<th></th>
<td><em>This returns all the values in the hashset.</em></td>
<td></td>
</tr>
</table>
{}
<h2><a name="file-pool.c" id="file-pool.c">Functions defined in
<tt>src/odb/file-pool.c</tt></a></h2>
<p><a href="#fd_cache_file_pool"><tt>fd_cache_file_pool</tt></a> |
<a href="#fd_file_pool_capacity"><tt>fd_file_pool_capacity</tt></a>
| <a href=
"#fd_file_pool_freespace"><tt>fd_file_pool_freespace</tt></a> |
<a href="#fd_file_pool_load"><tt>fd_file_pool_load</tt></a> |
<a href="#fd_label_file_pool"><tt>fd_label_file_pool</tt></a> |
<a href="#fd_lock_file_pool"><tt>fd_lock_file_pool</tt></a> |
<a href="#fd_make_file_pool"><tt>fd_make_file_pool</tt></a> |
<a href=
"#fd_make_new_super_pool"><tt>fd_make_new_super_pool</tt></a> |
<a href="#fd_make_pool_snapshot"><tt>fd_make_pool_snapshot</tt></a>
| <a href="#fd_make_super_pool"><tt>fd_make_super_pool</tt></a> |
<a href="#fd_new_file_pool"><tt>fd_new_file_pool</tt></a> |
<a href="#fd_read_file_pool_metadata"><tt>fd_read_file_pool_metadata</tt></a>
| <a href=
"#fd_register_file_pool_opener"><tt>fd_register_file_pool_opener</tt></a>
| <a href="#fd_use_file_pool"><tt>fd_use_file_pool</tt></a> |</p>
<table cellpadding="5">
<tr>
<th align="left">Function</th>
<th align="left">Arguments</th>
<th align="left">Returns</th>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name=
"fd_make_file_pool" id=
"fd_make_file_pool">fd_make_file_pool</a></td>
<td class="ccode">char *filename,FD_OID base, unsigned int
capacity, int major_version,fd_lisp metadata</td>
<td class="ccode">void</td>
</tr>
<tr>
<th></th>
<td>pointer to an object ID (oid) capacity (unsigned int) filename
(string pointer)</td>
<td>void</td>
</tr>
<tr>
<th></th>
<td><em>Creates an empty file pool on disk which can be
subsequently opened or added.</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name=
"fd_make_super_pool" id=
"fd_make_super_pool">fd_make_super_pool</a></td>
<td class="ccode">char *filename,unsigned int base,unsigned int
load</td>
<td class="ccode">unsigned int</td>
</tr>
<tr>
<th></th>
<td>a filename, a base id, and a load</td>
<td>the base id</td>
</tr>
<tr>
<th></th>
<td><em>Creates a new super pool file. The base id is specifies the
high half of the base of the super pool and the load declares how
many OIDs are already "pre allocated" from the super
pool.</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name=
"fd_read_file_pool_metadata" id=
"fd_read_file_pool_metadata">fd_read_file_pool_metadata</a></td>
<td class="ccode">FILE *f,int *revnum,int *size,time_t *make,time_t
*repack,time_t *change</td>
<td class="ccode">fd_lisp</td>
</tr>
<tr>
<th></th>
<td>an open file stream to a file pool and pointers to two
ints</td>
<td>a lisp object (or the empty choice)</td>
</tr>
<tr>
<th></th>
<td><em>Returns metadata and version information for a file pool.
The version information, consisting of a serial repack ID and a
file length, are written into the two integer pointers. Since
modifications always write at the end of the file, the repack
serial number and the length of the file uniquely identify a moment
in time for the file.</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name=
"fd_file_pool_freespace" id=
"fd_file_pool_freespace">fd_file_pool_freespace</a></td>
<td class="ccode">fd_u8char *filename</td>
<td class="ccode">unsigned int</td>
</tr>
<tr>
<th></th>
<td>a pathname (a string)</td>
<td>an unsigned int</td>
</tr>
<tr>
<th></th>
<td><em>Returns the number of unallocated OIDs in the specified
file pool. This operates without actually "using the
pool".</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name=
"fd_make_pool_snapshot" id=
"fd_make_pool_snapshot">fd_make_pool_snapshot</a></td>
<td class="ccode">char *filename,char *snapshot</td>
<td class="ccode">void</td>
</tr>
<tr>
<th></th>
<td>two filenames</td>
<td>the base id</td>
</tr>
<tr>
<th></th>
<td><em>Creates a "snapshot" of a specified file pool. This is
basically a copy of the pools offset table and load information,
which can be used to reconstitute the state of the pool. This takes
advantage of the fact that pools don't write over values until they
are repacked.</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name=
"fd_lock_file_pool" id=
"fd_lock_file_pool">fd_lock_file_pool</a></td>
<td class="ccode">fd_file_pool p</td>
<td class="ccode">int</td>
</tr>
<tr>
<th></th>
<td>a pointer to a file pool</td>
<td>1 on success</td>
</tr>
<tr>
<th></th>
<td><em>Attempts to lock the file storing pool.</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name=
"fd_new_file_pool" id="fd_new_file_pool">fd_new_file_pool</a></td>
<td class="ccode">char *filename,unsigned int capacity,char
*super_pool</td>
<td class="ccode">void</td>
</tr>
<tr>
<th></th>
<td>a filename (localized string), a capacity (unsigned int), and a
super pool id (localized string)</td>
<td>void</td>
</tr>
<tr>
<th></th>
<td><em>Creates a new, empty, file pool with a particular capacity
from a specified super pool.</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name=
"fd_label_file_pool" id=
"fd_label_file_pool">fd_label_file_pool</a></td>
<td class="ccode">char *filename,lisp label</td>
<td class="ccode">void</td>
</tr>
<tr>
<th></th>
<td>a string, and a lisp object</td>
<td>void</td>
</tr>
<tr>
<th></th>
<td><em>Modifies a file pool to have a given label.</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name=
"fd_make_new_super_pool" id=
"fd_make_new_super_pool">fd_make_new_super_pool</a></td>
<td class="ccode">char *filename</td>
<td class="ccode">unsigned int</td>
</tr>
<tr>
<th></th>
<td>a filename</td>
<td>the base id</td>
</tr>
<tr>
<th></th>
<td><em>Creates a new super pool file with a random base id (based
on the time and process id). This will not allocated in the first
thousand super pools.</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name=
"fd_register_file_pool_opener" id=
"fd_register_file_pool_opener">fd_register_file_pool_opener</a></td>
<td class="ccode">int magic_no,fd_pool (*opener</td>
<td class="ccode">void</td>
</tr>
<tr>
<th></th>
<td>a magic number and an opening function</td>
<td>void</td>
</tr>
<tr>
<th></th>
<td><em>This associates an opening function with a number which is
the first word of the file to use this opener.</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name=
"fd_use_file_pool" id="fd_use_file_pool">fd_use_file_pool</a></td>
<td class="ccode">fd_u8char *fname</td>
<td class="ccode">fd_pool</td>
</tr>
<tr>
<th></th>
<td>a string naming a file</td>
<td>a pointer to a file pool structure</td>
</tr>
<tr>
<th></th>
<td><em>Errors: Cannot open pool (signalled by fd_open_file_pool)
Side effects: Creates a file pool structure for the named file Adds
a pointer to the pool structure to _fd_pool_table</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name=
"fd_file_pool_load" id=
"fd_file_pool_load">fd_file_pool_load</a></td>
<td class="ccode">fd_u8char *filename</td>
<td class="ccode">unsigned int</td>
</tr>
<tr>
<th></th>
<td>a pathname (a string)</td>
<td>an unsigned int</td>
</tr>
<tr>
<th></th>
<td><em>Returns the number of allocated OIDs in the specified file
pool. This operates without actually "using the pool".</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name=
"fd_file_pool_capacity" id=
"fd_file_pool_capacity">fd_file_pool_capacity</a></td>
<td class="ccode">fd_u8char *filename</td>
<td class="ccode">unsigned int</td>
</tr>
<tr>
<th></th>
<td>a pathname (a string)</td>
<td>an unsigned int</td>
</tr>
<tr>
<th></th>
<td><em>Returns the total number of possible OIDs in the specified
file pool. This operates without actually "using the
pool".</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name=
"fd_cache_file_pool" id=
"fd_cache_file_pool">fd_cache_file_pool</a></td>
<td class="ccode">fd_pool p</td>
<td class="ccode">void</td>
</tr>
<tr>
<th></th>
<td>pointer to a file pool structure</td>
<td>void</td>
</tr>
<tr>
<th></th>
<td><em>Initializes a cache for the file pool, reducing the need
for disk access and repositioning.</em></td>
<td></td>
</tr>
</table>
<h2><a name="portahash.c" id="portahash.c">Functions defined in
<tt>src/index/portahash.c</tt></a></h2>
<table cellpadding="5">
<tr>
<th align="left">Function</th>
<th align="left">Arguments</th>
<th align="left">Returns</th>
</tr>
</table>
<h2><a name="file-index.c" id="file-index.c">Functions defined in
<tt>src/index/file-index.c</tt></a></h2>
<p><a href="#fd_dtype_compare"><tt>fd_dtype_compare</tt></a> |
<a href=
"#fd_file_index_collect_values"><tt>fd_file_index_collect_values</tt></a>
| <a href=
"#fd_index_report_stats"><tt>fd_index_report_stats</tt></a> |
<a href="#fd_preload_file_index"><tt>fd_preload_file_index</tt></a>
| <a href=
"#fd_register_file_index_opener"><tt>fd_register_file_index_opener</tt></a>
| <a href=
"#fd_unpreload_file_index"><tt>fd_unpreload_file_index</tt></a> |
<a href="#object"><tt>object</tt></a> |</p>
<table cellpadding="5">
<tr>
<th align="left">Function</th>
<th align="left">Arguments</th>
<th align="left">Returns</th>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name=
"fd_file_index_collect_values" id=
"fd_file_index_collect_values">fd_file_index_collect_values</a></td>
<td class="ccode">fd_file_index ix,unsigned int loc,unsigned int
size</td>
<td class="ccode">lisp</td>
</tr>
<tr>
<th></th>
<td>a file stream</td>
<td>a "result set"</td>
</tr>
<tr>
<th></th>
<td><em>This reads a linked list stored in a binary file and
generates a lisp list from its elements. It returns a "result set"
which consists of a size and a list of elements.</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name=
"fd_index_report_stats" id=
"fd_index_report_stats">fd_index_report_stats</a></td>
<td class="ccode">FILE *stream</td>
<td class="ccode">void</td>
</tr>
<tr>
<th></th>
<td>none</td>
<td>void</td>
</tr>
<tr>
<th></th>
<td><em>Prints a report on hash table chaining behavior.</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name=
"fd_register_file_index_opener" id=
"fd_register_file_index_opener">fd_register_file_index_opener</a></td>
<td class="ccode">int magic_no,fd_index (*opener</td>
<td class="ccode">void</td>
</tr>
<tr>
<th></th>
<td>a magic number and an opening function</td>
<td>void</td>
</tr>
<tr>
<th></th>
<td><em>This associates an opening function with a number which is
the first word of the file to use this opener.</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name="object" id=
"object">object</a></td>
<td class="ccode">or the empty choice</td>
<td class="ccode">FRAMERD_EXPORT /* fd_read_file_index_metadata:
Arguments: an open file stream to a file index and pointers to two
ints Returns: a lisp</td>
</tr>
<tr>
<th></th>
<td>an open file stream to a file index, and pointers to two
ints</td>
<td>a lisp object (or the empty choice)</td>
</tr>
<tr>
<th></th>
<td><em>Returns metadata and version information for a file index.
The version information, consisting of a serial repack ID and a
file length, are written into the two int pointers. Since
modifications always write at the end of the file, the repack
serial number and the length of the file uniquely identify a moment
in time for the file.</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name=
"fd_dtype_compare" id="fd_dtype_compare">fd_dtype_compare</a></td>
<td class="ccode">lisp key,FILE *stream</td>
<td class="ccode">int</td>
</tr>
<tr>
<th></th>
<td>a lisp object and a file stream</td>
<td>boolean (int)</td>
</tr>
<tr>
<th></th>
<td><em>This returns true if the dtype representation on the file
stream is equal to the lisp object it is handed. If it returns true
(1), the file is positioned at the end of the dtype
representation.</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name=
"fd_unpreload_file_index" id=
"fd_unpreload_file_index">fd_unpreload_file_index</a></td>
<td class="ccode">fd_index idx_arg</td>
<td class="ccode">void</td>
</tr>
<tr>
<th></th>
<td>a pointer to an index</td>
<td>void</td>
</tr>
<tr>
<th></th>
<td><em>Reinits the size cache and basically undoes the effects of
fd_preload_file_index.</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name=
"fd_preload_file_index" id=
"fd_preload_file_index">fd_preload_file_index</a></td>
<td class="ccode">fd_index idx_arg</td>
<td class="ccode">void</td>
</tr>
<tr>
<th></th>
<td>a pointer to an index</td>
<td>void</td>
</tr>
<tr>
<th></th>
<td><em>This loads up the file indices size cache with all of the
keys in the table. In addition to providing a fast cache of
frequency information, this allows fetching to determine if there
is a value without actually going to disk.</em></td>
<td></td>
</tr>
</table>
<h2><a name="frames.c" id="frames.c">Functions defined in
<tt>src/odb/frames.c</tt></a></h2>
<p><a href="#fd_already_doing_p"><tt>fd_already_doing_p</tt></a> |
<a href="#fd_clear_slot_cache"><tt>fd_clear_slot_cache</tt></a> |
<a href="#fd_copy_frame"><tt>fd_copy_frame</tt></a> | <a href=
"#fd_describe_slot"><tt>fd_describe_slot</tt></a> | <a href=
"#fd_disable_slot_cache"><tt>fd_disable_slot_cache</tt></a> |
<a href="#fd_enable_slot_cache"><tt>fd_enable_slot_cache</tt></a> |
<a href="#fd_for_slots"><tt>fd_for_slots</tt></a> | <a href=
"#fd_frame_add"><tt>fd_frame_add</tt></a> | <a href=
"#fd_frame_create"><tt>fd_frame_create</tt></a> | <a href=
"#fd_frame_get"><tt>fd_frame_get</tt></a> | <a href=
"#fd_frame_get_star"><tt>fd_frame_get_star</tt></a> | <a href=
"#fd_frame_remove"><tt>fd_frame_remove</tt></a> | <a href=
"#fd_frame_set"><tt>fd_frame_set</tt></a> | <a href=
"#fd_frame_slots"><tt>fd_frame_slots</tt></a> | <a href=
"#fd_frame_test"><tt>fd_frame_test</tt></a> | <a href=
"#fd_get_slotmap"><tt>fd_get_slotmap</tt></a> | <a href=
"#fd_inherit_values"><tt>fd_inherit_values</tt></a> | <a href=
"#fd_inherits_valuep"><tt>fd_inherits_valuep</tt></a> | <a href=
"#fd_overlay_create"><tt>fd_overlay_create</tt></a> | <a href=
"#fd_overlay_get"><tt>fd_overlay_get</tt></a> | <a href=
"#fd_overlay_test"><tt>fd_overlay_test</tt></a> | <a href=
"#fd_pathp"><tt>fd_pathp</tt></a> | <a href=
"#fd_prim_add"><tt>fd_prim_add</tt></a> | <a href=
"#fd_prim_add_consed"><tt>fd_prim_add_consed</tt></a> | <a href=
"#fd_prim_drop"><tt>fd_prim_drop</tt></a> | <a href=
"#fd_prim_get"><tt>fd_prim_get</tt></a> | <a href=
"#fd_prim_set"><tt>fd_prim_set</tt></a> | <a href=
"#fd_prim_set_consed"><tt>fd_prim_set_consed</tt></a> | <a href=
"#fd_prim_test"><tt>fd_prim_test</tt></a> | <a href=
"#fd_use_autoindex"><tt>fd_use_autoindex</tt></a> |</p>
<table cellpadding="5">
<tr>
<th align="left">Function</th>
<th align="left">Arguments</th>
<th align="left">Returns</th>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name="fd_for_slots"
id="fd_for_slots">fd_for_slots</a></td>
<td class="ccode">void (*fcn</td>
<td class="ccode">void</td>
</tr>
<tr>
<th></th>
<td>a function on three lisp objects and a lisp object</td>
<td>void</td>
</tr>
<tr>
<th></th>
<td><em>Applies the function to the frame and each of its
attributes and values.</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name=
"fd_get_slotmap" id="fd_get_slotmap">fd_get_slotmap</a></td>
<td class="ccode">lisp arg</td>
<td class="ccode">lisp</td>
</tr>
<tr>
<th></th>
<td>a lisp pointer</td>
<td>a lisp pointer</td>
</tr>
<tr>
<th></th>
<td><em>If arg is a slotmap, it is cref'd and returned; if arg is
an OID whose value is a slotmap, that slotmap is returned if arg is
an OID whose value is a choice, one of which is a slotmap, that
slotmap is returned</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name=
"fd_inherit_values" id=
"fd_inherit_values">fd_inherit_values</a></td>
<td class="ccode">lisp root,lisp slotid,lisp through</td>
<td class="ccode">lisp</td>
</tr>
<tr>
<th></th>
<td>a frame and two slotids</td>
<td>a lisp pointer</td>
</tr>
<tr>
<th></th>
<td><em>Searches for a value for the first slotid through the
lattice defined by the second slotid.</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name="fd_frame_set"
id="fd_frame_set">fd_frame_set</a></td>
<td class="ccode">lisp frame,lisp slotid,lisp value</td>
<td class="ccode">void</td>
</tr>
<tr>
<th></th>
<td>a frame, an attribute name (a lisp pointer), and a value (a
lisp pointer)</td>
<td>void</td>
</tr>
<tr>
<th></th>
<td><em>Modifies the given attribute (slotid) of frame so that it
has values, removing and adding values as neccessary.</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name="fd_prim_drop"
id="fd_prim_drop">fd_prim_drop</a></td>
<td class="ccode">lisp frame,lisp slotid,lisp value</td>
<td class="ccode">void</td>
</tr>
<tr>
<th></th>
<td>a frame, an attribute name (a lisp pointer), and a value (a
lisp pointer)</td>
<td>void</td>
</tr>
<tr>
<th></th>
<td><em>Removes the designated value from the designated attribute
of a frame Note: the attribute name is compared with ==, meaning
that it can be a symbol, fixnum, ascii or unicode character,
boolean, or an object</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name=
"fd_prim_set_consed" id=
"fd_prim_set_consed">fd_prim_set_consed</a></td>
<td class="ccode">lisp frame,lisp slotid,lisp value</td>
<td class="ccode">void</td>
</tr>
<tr>
<th></th>
<td>a frame, an attribute name (a lisp pointer), and a value (a
lisp pointer)</td>
<td>void</td>
</tr>
<tr>
<th></th>
<td><em>Just like fd_prim_set, but frees the value it was passed
(the frame still keeps its pointer. This is a convenience function
for passing consed values as arguments.</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name=
"fd_overlay_get" id="fd_overlay_get">fd_overlay_get</a></td>
<td class="ccode">lisp frame,lisp slotid</td>
<td class="ccode">lisp</td>
</tr>
<tr>
<th></th>
<td>a frame (slotmap or OID evaluating to one) and a slotid</td>
<td>a lisp pointer</td>
</tr>
<tr>
<th></th>
<td><em>Does inheritance through OID values on annotated
frames.</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name=
"fd_frame_remove" id="fd_frame_remove">fd_frame_remove</a></td>
<td class="ccode">lisp frame,lisp slotid,lisp value</td>
<td class="ccode">void</td>
</tr>
<tr>
<th></th>
<td>a frame, an attribute name (a lisp pointer), and a value (a
lisp pointer)</td>
<td>void</td>
</tr>
<tr>
<th></th>
<td><em>If a frame already possesses the named attribute whose
value contains the given value, it is removed. If that would make
the attribute value empty, it is replaced with FD_EMPTY_CHOICE; if
that would make the attribute value a singleton, it is replaced
with just that value. If the slot is itself an oid and the value
removed is actually present, then the remove-effects demons of the
slot are evaluated.</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name="fd_frame_add"
id="fd_frame_add">fd_frame_add</a></td>
<td class="ccode">lisp frame,lisp slotid,lisp value</td>
<td class="ccode">void</td>
</tr>
<tr>
<th></th>
<td>a frame, an attribute name (a lisp pointer), and a value (a
lisp pointer)</td>
<td>void</td>
</tr>
<tr>
<th></th>
<td><em>If a frame already possesses the named attribute, the value
is added to its set of values (if it's value isn't a set, it is
made one). If the slot is itself an oid and the value stored is new
(not currently in the attribute's set of values), then the
add-effects demons of the slot are evaluated. Side effects: May
replace the slot/value vector of a slotmap to add an attribute
Refcounts or copies the value given it (sets are copied) Note: the
attribute name is compared with ==, meaning that it can be a
symbol, fixnum, ascii or unicode character, boolean, or an
oid</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name=
"fd_use_autoindex" id="fd_use_autoindex">fd_use_autoindex</a></td>
<td class="ccode">fd_index ix</td>
<td class="ccode">void</td>
</tr>
<tr>
<th></th>
<td>a pointer to an index</td>
<td>void</td>
</tr>
<tr>
<th></th>
<td><em>Sets up a particular index for automatically recording
changed and new slot values.</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name="fd_copy_frame"
id="fd_copy_frame">fd_copy_frame</a></td>
<td class="ccode">lisp original,fd_pool x</td>
<td class="ccode">lisp</td>
</tr>
<tr>
<th></th>
<td>a frame and a pool</td>
<td>a pointer to a new frame (oid)</td>
</tr>
<tr>
<th></th>
<td><em>This creates a new object in the pool and initializes its
value to be a slotmap copying another object's stotmap, thus making
it a frame.</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name=
"fd_prim_add_consed" id=
"fd_prim_add_consed">fd_prim_add_consed</a></td>
<td class="ccode">lisp frame,lisp slotid,lisp value</td>
<td class="ccode">void</td>
</tr>
<tr>
<th></th>
<td>a frame, an attribute name (a lisp pointer), and a value (a
lisp pointer)</td>
<td>void</td>
</tr>
<tr>
<th></th>
<td><em>Just like fd_prim_add, but frees the value it was passed
(the frame still keeps its pointer. This is for passing consed
values as arguments.</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name=
"fd_describe_slot" id="fd_describe_slot">fd_describe_slot</a></td>
<td class="ccode">FILE *stream,lisp slotid,lisp value</td>
<td class="ccode">void</td>
</tr>
<tr>
<th></th>
<td>an attribute name and a value</td>
<td>void</td>
</tr>
<tr>
<th></th>
<td><em>Describes a slot and its value to a stream.</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name="fd_frame_test"
id="fd_frame_test">fd_frame_test</a></td>
<td class="ccode">lisp frame,lisp slotid,lisp value</td>
<td class="ccode">int</td>
</tr>
<tr>
<th></th>
<td>a frame, a slotid, and a value</td>
<td>1 if the value is on the slot, 0 otherwise</td>
</tr>
<tr>
<th></th>
<td><em>If the slot is an oid, this may use the TEST-METHODS and
GET-METHODS of the slot. Otherwise, it just checks for membership
in the corresponding value. Note: the attribute name is compared
with ==, meaning that it can be a symbol, fixnum, ascii or unicode
character, boolean, or an oid pointer</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name=
"fd_clear_slot_cache" id=
"fd_clear_slot_cache">fd_clear_slot_cache</a></td>
<td class="ccode">lisp slotid,lisp frame</td>
<td class="ccode">void</td>
</tr>
<tr>
<th></th>
<td>slotid, frame</td>
<td>void</td>
</tr>
<tr>
<th></th>
<td><em>Clears cached entries for slotid and frame, clearing all
entries if frame is FD_VOID</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name=
"fd_frame_slots" id="fd_frame_slots">fd_frame_slots</a></td>
<td class="ccode">lisp frames</td>
<td class="ccode">fd_lisp</td>
</tr>
<tr>
<th></th>
<td>a frame</td>
<td>a set of slot ids</td>
</tr>
<tr>
<th></th>
<td><em>Returns the current slot ids with associations on the
frame</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name="fd_prim_get"
id="fd_prim_get">fd_prim_get</a></td>
<td class="ccode">lisp frame,lisp slotid</td>
<td class="ccode">lisp</td>
</tr>
<tr>
<th></th>
<td>a frame and an attribute name (a lisp pointer)</td>
<td>a lisp pointer</td>
</tr>
<tr>
<th></th>
<td><em>Returns either the value associated with the attribute or
FD_EMPTY_CHOICE if no such attribute exists; this value is computed
from the attribute value if the slot is an object identifier. Note:
the attribute name is compared with ==, meaning that it can be a
symbol, fixnum, ascii or unicode character, boolean, or an object
pointer</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name="fd_prim_test"
id="fd_prim_test">fd_prim_test</a></td>
<td class="ccode">lisp frame,lisp slotid,lisp value</td>
<td class="ccode">int</td>
</tr>
<tr>
<th></th>
<td>a frame, an attribute name (a lisp pointer), and a value (a
lisp pointer)</td>
<td>1 or 0</td>
</tr>
<tr>
<th></th>
<td><em>Returns 1 if the named attribute of the frame contains a
value</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name="fd_pathp" id=
"fd_pathp">fd_pathp</a></td>
<td class="ccode">lisp root,lisp slotid,lisp to</td>
<td class="ccode">int</td>
</tr>
<tr>
<th></th>
<td>a frame, a slotid, and a frame</td>
<td>1 or 0</td>
</tr>
<tr>
<th></th>
<td><em>Returns 1 if there is a path through slotid between the two
frames</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name=
"fd_overlay_test" id="fd_overlay_test">fd_overlay_test</a></td>
<td class="ccode">lisp frame,lisp slotid,lisp value</td>
<td class="ccode">int</td>
</tr>
<tr>
<th></th>
<td>a frame (slotmap or OID evaluating to one), a slotid, and a
value</td>
<td>1 or 0</td>
</tr>
<tr>
<th></th>
<td><em>Does inheritance through OID values on annotated frames,
determining if a slotid is associated with a particular
value.</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name=
"fd_enable_slot_cache" id=
"fd_enable_slot_cache">fd_enable_slot_cache</a></td>
<td class="ccode">lisp slotid</td>
<td class="ccode">void</td>
</tr>
<tr>
<th></th>
<td>slotid</td>
<td>void</td>
</tr>
<tr>
<th></th>
<td><em>Enables caching on the slot SLOTID</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name="fd_prim_add"
id="fd_prim_add">fd_prim_add</a></td>
<td class="ccode">lisp frame,lisp slotid,lisp value</td>
<td class="ccode">void</td>
</tr>
<tr>
<th></th>
<td>a frame, an attribute name (a lisp pointer), and a value (a
lisp pointer)</td>
<td>void</td>
</tr>
<tr>
<th></th>
<td><em>If the frame already possess the named attribute, the
specified value is added to the current one; otherwise, the
attribute is added to the frame with the corresponding value. Side
effects: May replace the slot/value vector of a slotmap to add an
attribute Refcounts or copies the value given it (sets are copied)
Note: the attribute name is compared with ==, meaning that it can
be a symbol, fixnum, ascii or unicode character, boolean, or an
object</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name=
"fd_overlay_create" id=
"fd_overlay_create">fd_overlay_create</a></td>
<td class="ccode">fd_pool x,lisp value</td>
<td class="ccode">lisp</td>
</tr>
<tr>
<th></th>
<td>a pool and a frame</td>
<td>a pointer to a frame (oid)</td>
</tr>
<tr>
<th></th>
<td><em>This creates a new oid in the pool and initializes its
value to be both a slotmap and a pointer to a frame</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name=
"fd_frame_create" id="fd_frame_create">fd_frame_create</a></td>
<td class="ccode">fd_pool x</td>
<td class="ccode">lisp</td>
</tr>
<tr>
<th></th>
<td>a pool</td>
<td>a pointer to a frame (oid)</td>
</tr>
<tr>
<th></th>
<td><em>This creates a new oid in the pool and initializes its
value to be a slotmap, thus making it a frame.</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name="fd_frame_get"
id="fd_frame_get">fd_frame_get</a></td>
<td class="ccode">lisp frame,lisp slotid</td>
<td class="ccode">lisp</td>
</tr>
<tr>
<th></th>
<td>a frame and an attribute name (a lisp pointer)</td>
<td>either the value associated with the attribute</td>
</tr>
<tr>
<th></th>
<td><em>or FD_EMPTY_CHOICE if no such attribute exists (The return
value is a copy which may need to be freed). Note: the attribute
name is compared with ==, meaning that it can be a symbol, fixnum,
ascii or unicode character, boolean, or an oid pointer</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name="fd_prim_set"
id="fd_prim_set">fd_prim_set</a></td>
<td class="ccode">lisp frame,lisp slotid,lisp value</td>
<td class="ccode">void</td>
</tr>
<tr>
<th></th>
<td>a frame, a slotid (a lisp pointer), and a value (a lisp
pointer)</td>
<td>void</td>
</tr>
<tr>
<th></th>
<td><em>If the frame already possess the named attribute, its value
is replaced with the new one; otherwise, the attribute is added to
the frame with the corresponding value. Side effects: May replace
the slot/value vector of a slotmap to add an attribute Frees the
previous value of the attribute (if it exists) Refcounts or copies
the value given it (sets are copied) Note: the attribute name is
compared with ==, meaning that it can be a symbol, fixnum, ascii or
unicode character, boolean, or an object</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name=
"fd_disable_slot_cache" id=
"fd_disable_slot_cache">fd_disable_slot_cache</a></td>
<td class="ccode">lisp slotid</td>
<td class="ccode">void</td>
</tr>
<tr>
<th></th>
<td>slotid</td>
<td>void</td>
</tr>
<tr>
<th></th>
<td><em>Disables caching on the slot SLOTID</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name=
"fd_frame_get_star" id=
"fd_frame_get_star">fd_frame_get_star</a></td>
<td class="ccode">fd_lisp frames,fd_lisp slotids</td>
<td class="ccode">fd_lisp</td>
</tr>
<tr>
<th></th>
<td>a choice of frames and a choice of slotids</td>
<td>the kleene star of the slotids on the frames</td>
</tr>
<tr>
<th></th>
<td></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name=
"fd_inherits_valuep" id=
"fd_inherits_valuep">fd_inherits_valuep</a></td>
<td class="ccode">lisp root,lisp slotid,lisp through,lisp
value</td>
<td class="ccode">int</td>
</tr>
<tr>
<th></th>
<td>a frame, two slotids, and a value</td>
<td>1 or 0</td>
</tr>
<tr>
<th></th>
<td><em>Returns 1 if the value can be inherited for the first
slotid going through the lattice defined by the second
slotid.</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name=
"fd_already_doing_p" id=
"fd_already_doing_p">fd_already_doing_p</a></td>
<td class="ccode">slot_op op,lisp frame,lisp slotid,lisp value</td>
<td class="ccode">int</td>
</tr>
<tr>
<th></th>
<td>a slot operation, a frame, slot, and value</td>
<td>1 or 0</td>
</tr>
<tr>
<th></th>
<td><em>Returns 1 if the frame system is already doing a slot
operation. (This causes most slot operations to return the empty
choice).</em></td>
<td></td>
</tr>
</table>
<h2><a name="search.c" id="search.c">Functions defined in
<tt>src/index/search.c</tt></a></h2>
<p><a href="#fd_find_frames"><tt>fd_find_frames</tt></a> | <a href=
"#fd_find_similar"><tt>fd_find_similar</tt></a> | <a href=
"#fd_get_frame_features"><tt>fd_get_frame_features</tt></a> |
<a href="#fd_get_slot_features"><tt>fd_get_slot_features</tt></a> |
<a href="#fd_index_frame"><tt>fd_index_frame</tt></a> | <a href=
"#fd_index_notice_slot_values"><tt>fd_index_notice_slot_values</tt></a>
| <a href="#fd_index_slot_values"><tt>fd_index_slot_values</tt></a>
| <a href="#fd_index_slots"><tt>fd_index_slots</tt></a> | <a href=
"#fd_score_from_samples"><tt>fd_score_from_samples</tt></a> |
<a href="#fd_score_from_spec"><tt>fd_score_from_spec</tt></a> |
<a href="#fd_strict_search"><tt>fd_strict_search</tt></a> |</p>
<table cellpadding="5">
<tr>
<th align="left">Function</th>
<th align="left">Arguments</th>
<th align="left">Returns</th>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name=
"fd_score_from_spec" id=
"fd_score_from_spec">fd_score_from_spec</a></td>
<td class="ccode">lisp indices,lisp frames,lisp spec</td>
<td class="ccode">fd_hashtable</td>
</tr>
<tr>
<th></th>
<td>an index, a set of frames, and a list of feature sets</td>
<td>a hashtable of frames and scores</td>
</tr>
<tr>
<th></th>
<td><em>Computes similarity scores to <var>samples</var> based on
the feature sets If the set of frames argument is void, all
candidates are scored; otherwise, only the specified frames are
scored.</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name=
"fd_find_similar" id="fd_find_similar">fd_find_similar</a></td>
<td class="ccode">lisp indices,lisp frames,lisp slots</td>
<td class="ccode">lisp</td>
</tr>
<tr>
<th></th>
<td>an index, a set of frames, and a set of slots</td>
<td>a set of frames</td>
</tr>
<tr>
<th></th>
<td><em>Finds all frames in <var>index</var> that have some
<var>slots</var> in common with <var>frames</var></em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name=
"fd_get_frame_features" id=
"fd_get_frame_features">fd_get_frame_features</a></td>
<td class="ccode">lisp frames</td>
<td class="ccode">lisp</td>
</tr>
<tr>
<th></th>
<td>a frame (or set of frames)</td>
<td>a set of features based on those on the slots of FRAMES</td>
</tr>
<tr>
<th></th>
<td><em>Gets the features of FRAME based on all of its
slots.</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name=
"fd_score_from_samples" id=
"fd_score_from_samples">fd_score_from_samples</a></td>
<td class="ccode">lisp indices,lisp frames,lisp samples,lisp
slots</td>
<td class="ccode">fd_hashtable</td>
</tr>
<tr>
<th></th>
<td>an index, a set of frames, a set of samples, and a set of
slotids</td>
<td>a hashtable of frames and scores</td>
</tr>
<tr>
<th></th>
<td><em>Computes similarity scores to <var>samples</var> based on
slotids and index. If the set of frames argument is void, all
candidates are scored; otherwise, only the specified frames are
scored.</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name=
"fd_find_frames" id="fd_find_frames">fd_find_frames</a></td>
<td class="ccode">lisp indices,...</td>
<td class="ccode">lisp</td>
</tr>
<tr>
<th></th>
<td>a set of indices and a series of slot and value sets terminated
by a FD_VOID</td>
<td>a set of frames</td>
</tr>
<tr>
<th></th>
<td><em>This is a C version of the FDSCRIPT strict searching
function It returns those frames indexed as having each of the
slots with at least of the subsequent values</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name=
"fd_index_frame" id="fd_index_frame">fd_index_frame</a></td>
<td class="ccode">fd_index idx,lisp frame</td>
<td class="ccode">void</td>
</tr>
<tr>
<th></th>
<td>a frame and an index</td>
<td>nothing</td>
</tr>
<tr>
<th></th>
<td><em>Indexes an object based on its slot values.</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name=
"fd_index_slots" id="fd_index_slots">fd_index_slots</a></td>
<td class="ccode">fd_index idx,lisp frame,lisp slots</td>
<td class="ccode">void</td>
</tr>
<tr>
<th></th>
<td>a frame (or set of frames), an index, and a set of slots</td>
<td>nothing</td>
</tr>
<tr>
<th></th>
<td><em>Indexes the frame (or set of frames) based on the specified
slots</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name=
"fd_index_notice_slot_values" id=
"fd_index_notice_slot_values">fd_index_notice_slot_values</a></td>
<td class="ccode">fd_index idx,lisp frames,lisp slots,lisp
values</td>
<td class="ccode">void</td>
</tr>
<tr>
<th></th>
<td>a frame (or set of frames), an index, a set of slots, and a set
of values</td>
<td>nothing</td>
</tr>
<tr>
<th></th>
<td><em>Indexes the frame (or set of frames) based on the specified
slots This doesn't force slots to be indexed, so stop-features
works.</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name=
"fd_get_slot_features" id=
"fd_get_slot_features">fd_get_slot_features</a></td>
<td class="ccode">lisp frames,lisp slots</td>
<td class="ccode">lisp</td>
</tr>
<tr>
<th></th>
<td>a frame (or set of frames) and a slot (or set of slots)</td>
<td>a set of features based on those slots of those frames</td>
</tr>
<tr>
<th></th>
<td><em>Gets the features of FRAME on SLOTS.</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name=
"fd_index_slot_values" id=
"fd_index_slot_values">fd_index_slot_values</a></td>
<td class="ccode">fd_index idx,lisp frames,lisp slotids,lisp
values</td>
<td class="ccode">void</td>
</tr>
<tr>
<th></th>
<td>a frame (or set of frames), an index, a set of slots, and a set
of values</td>
<td>nothing</td>
</tr>
<tr>
<th></th>
<td><em>Indexes the frame (or set of frames) based on the specified
slots</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name=
"fd_strict_search" id="fd_strict_search">fd_strict_search</a></td>
<td class="ccode">lisp indices,lisp spec</td>
<td class="ccode">lisp</td>
</tr>
<tr>
<th></th>
<td>an index (or set/choice of indices) and a list of sets/choices
of features</td>
<td>a set of objects</td>
</tr>
<tr>
<th></th>
<td><em>Returns all objects recorded in indices which have one of
each set of features in the provided list</em></td>
<td></td>
</tr>
</table>
<h2><a name="index.c" id="index.c">Functions defined in
<tt>src/index/index.c</tt></a></h2>
<p><a href="#fd_close_index"><tt>fd_close_index</tt></a> | <a href=
"#fd_commit_index"><tt>fd_commit_index</tt></a> | <a href=
"#fd_find_index"><tt>fd_find_index</tt></a> | <a href=
"#fd_for_indices"><tt>fd_for_indices</tt></a> | <a href=
"#fd_index_add"><tt>fd_index_add</tt></a> | <a href=
"#fd_index_drop"><tt>fd_index_drop</tt></a> | <a href=
"#fd_index_get"><tt>fd_index_get</tt></a> | <a href=
"#fd_index_get_size"><tt>fd_index_get_size</tt></a> | <a href=
"#fd_index_keys"><tt>fd_index_keys</tt></a> | <a href=
"#fd_index_prefetch"><tt>fd_index_prefetch</tt></a> | <a href=
"#fd_index_set"><tt>fd_index_set</tt></a> | <a href=
"#fd_index_set_sizes"><tt>fd_index_set_sizes</tt></a> | <a href=
"#fd_intern_index_values"><tt>fd_intern_index_values</tt></a> |
<a href="#fd_interpret_index"><tt>fd_interpret_index</tt></a> |
<a href="#fd_revert_index"><tt>fd_revert_index</tt></a> | <a href=
"#fd_set_index_zipf_threshold"><tt>fd_set_index_zipf_threshold</tt></a>
| <a href="#fd_swap_out_index"><tt>fd_swap_out_index</tt></a> |
<a href="#fd_use_index"><tt>fd_use_index</tt></a> |</p>
<table cellpadding="5">
<tr>
<th align="left">Function</th>
<th align="left">Arguments</th>
<th align="left">Returns</th>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name="fd_find_index"
id="fd_find_index">fd_find_index</a></td>
<td class="ccode">fd_u8char *id</td>
<td class="ccode">fd_index</td>
</tr>
<tr>
<th></th>
<td>a string</td>
<td>a pointer to an index or NULL</td>
</tr>
<tr>
<th></th>
<td><em>Returns the index whose id matches the given
string.</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name="fd_index_drop"
id="fd_index_drop">fd_index_drop</a></td>
<td class="ccode">fd_index x,lisp key,lisp value</td>
<td class="ccode">void</td>
</tr>
<tr>
<th></th>
<td>an index pointer, a lisp key, a lisp value</td>
<td>an index</td>
</tr>
<tr>
<th></th>
<td><em>Removes the values from the values associated with the key
in the index.</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name=
"fd_index_get_size" id=
"fd_index_get_size">fd_index_get_size</a></td>
<td class="ccode">fd_index x,lisp key</td>
<td class="ccode">unsigned int</td>
</tr>
<tr>
<th></th>
<td>an index pointer, a lisp key</td>
<td>the number of values associated with the key in the index</td>
</tr>
<tr>
<th></th>
<td><em>Returns the number of values associated with the key in the
index</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name=
"fd_revert_index" id="fd_revert_index">fd_revert_index</a></td>
<td class="ccode">fd_index x</td>
<td class="ccode">void</td>
</tr>
<tr>
<th></th>
<td>a pointer to an index</td>
<td>nothing</td>
</tr>
<tr>
<th></th>
<td><em>Erases all of the changes made to the specified
index.</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name=
"fd_set_index_zipf_threshold" id=
"fd_set_index_zipf_threshold">fd_set_index_zipf_threshold</a></td>
<td class="ccode">fd_index ix,int threshold</td>
<td class="ccode">void</td>
</tr>
<tr>
<th></th>
<td>an index, an integer</td>
<td>nothing</td>
</tr>
<tr>
<th></th>
<td><em>Sets the save threshold for an index, so that keys with
fewer than threshold values will not be written to disk or
server</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name=
"fd_intern_index_values" id=
"fd_intern_index_values">fd_intern_index_values</a></td>
<td class="ccode">fd_index x</td>
<td class="ccode">void</td>
</tr>
<tr>
<th></th>
<td>an index pointer</td>
<td>void</td>
</tr>
<tr>
<th></th>
<td><em>Arranges for an index to intern the values it
stores</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name=
"fd_index_prefetch" id=
"fd_index_prefetch">fd_index_prefetch</a></td>
<td class="ccode">fd_index x,lisp keys</td>
<td class="ccode">void</td>
</tr>
<tr>
<th></th>
<td>an index pointer, and a choice of keys</td>
<td>an index</td>
</tr>
<tr>
<th></th>
<td><em>Prefetches the values for particular keys.</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name=
"fd_commit_index" id="fd_commit_index">fd_commit_index</a></td>
<td class="ccode">fd_index x</td>
<td class="ccode">void</td>
</tr>
<tr>
<th></th>
<td>a pointer to an index</td>
<td>nothing</td>
</tr>
<tr>
<th></th>
<td><em>Saves the changes made to the specified index.</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name=
"fd_interpret_index" id=
"fd_interpret_index">fd_interpret_index</a></td>
<td class="ccode">lisp spec</td>
<td class="ccode">fd_index</td>
</tr>
<tr>
<th></th>
<td>an expression and an environment</td>
<td>a pointer to an index</td>
</tr>
<tr>
<th></th>
<td><em>Evaluates the expression in the environment and tries to
produce an index object from the result.</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name=
"fd_index_set_sizes" id=
"fd_index_set_sizes">fd_index_set_sizes</a></td>
<td class="ccode">fd_index x,int cache_size,int adds_size,int
drops_size,int sizes_size</td>
<td class="ccode">void</td>
</tr>
<tr>
<th></th>
<td>a pointer to an index</td>
<td>nothing</td>
</tr>
<tr>
<th></th>
<td><em>Grows the internal tables for an index to accomodate n keys
and n mods</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name="fd_index_keys"
id="fd_index_keys">fd_index_keys</a></td>
<td class="ccode">fd_index idx</td>
<td class="ccode">lisp</td>
</tr>
<tr>
<th></th>
<td>a pointer to an index</td>
<td>nothing</td>
</tr>
<tr>
<th></th>
<td><em>Non-deterministically returns all the keys in an
index.</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name=
"fd_for_indices" id="fd_for_indices">fd_for_indices</a></td>
<td class="ccode">void (*fcn</td>
<td class="ccode">void</td>
</tr>
<tr>
<th></th>
<td>a function on pointers to indices</td>
<td>nothing</td>
</tr>
<tr>
<th></th>
<td><em>Calls the function on all registered indices.</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name="fd_use_index"
id="fd_use_index">fd_use_index</a></td>
<td class="ccode">fd_u8char *spec</td>
<td class="ccode">fd_index</td>
</tr>
<tr>
<th></th>
<td>a string</td>
<td>an index</td>
</tr>
<tr>
<th></th>
<td><em>Returns an index object based on the string argument. If
the string has the form "port@host" it is taken to be a network
index; otherwise, it is taken to be a file index which is
opened.</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name="fd_index_add"
id="fd_index_add">fd_index_add</a></td>
<td class="ccode">fd_index x,lisp key,lisp value</td>
<td class="ccode">void</td>
</tr>
<tr>
<th></th>
<td>an index pointer, a lisp key, a lisp value</td>
<td>an index</td>
</tr>
<tr>
<th></th>
<td><em>Adds the value to the values associated with the key in the
index.</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name=
"fd_close_index" id="fd_close_index">fd_close_index</a></td>
<td class="ccode">fd_index idx</td>
<td class="ccode">void</td>
</tr>
<tr>
<th></th>
<td>a pointer to an index</td>
<td>nothing</td>
</tr>
<tr>
<th></th>
<td><em>Closes an index</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name="fd_index_get"
id="fd_index_get">fd_index_get</a></td>
<td class="ccode">fd_index x,lisp key,lisp dflt</td>
<td class="ccode">lisp</td>
</tr>
<tr>
<th></th>
<td>an index pointer, a lisp key, and a default value</td>
<td>the values associated with the key in the index</td>
</tr>
<tr>
<th></th>
<td><em>Returns the values associated with the key in the index or
the default value if there are none.</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name=
"fd_swap_out_index" id=
"fd_swap_out_index">fd_swap_out_index</a></td>
<td class="ccode">fd_index x</td>
<td class="ccode">void</td>
</tr>
<tr>
<th></th>
<td>a pointer to an index</td>
<td>nothing</td>
</tr>
<tr>
<th></th>
<td><em>Frees most of the space used by the cached values of an
index.</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name="fd_index_set"
id="fd_index_set">fd_index_set</a></td>
<td class="ccode">fd_index x,lisp key,lisp value</td>
<td class="ccode">void</td>
</tr>
<tr>
<th></th>
<td>an index pointer, a lisp key, a lisp value</td>
<td>an index</td>
</tr>
<tr>
<th></th>
<td><em>Sets the values associated with the key in the
index.</em></td>
<td></td>
</tr>
</table>
<h2><a name="super-pool.c" id="super-pool.c">Functions defined in
<tt>src/odb/super-pool.c</tt></a></h2>
<p><a href="#fd_allocate_pool"><tt>fd_allocate_pool</tt></a> |
<a href="#fd_recovered_pool"><tt>fd_recovered_pool</tt></a> |
<a href="#fd_super_pool_base"><tt>fd_super_pool_base</tt></a> |
<a href="#fd_super_pool_loading"><tt>fd_super_pool_loading</tt></a>
| <a href="#fd_super_pool_top"><tt>fd_super_pool_top</tt></a> |</p>
<table cellpadding="5">
<tr>
<th align="left">Function</th>
<th align="left">Arguments</th>
<th align="left">Returns</th>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name=
"fd_allocate_pool" id="fd_allocate_pool">fd_allocate_pool</a></td>
<td class="ccode">char *super_pool,unsigned int capacity,char
*label</td>
<td class="ccode">FD_OID</td>
</tr>
<tr>
<th></th>
<td>a super pool id, a capacity, and a string label</td>
<td>an FD_OID</td>
</tr>
<tr>
<th></th>
<td><em>Allocates a new pool from a designated super pool with a
particular capacity, returning the base of the new pool.</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name=
"fd_recovered_pool" id=
"fd_recovered_pool">fd_recovered_pool</a></td>
<td class="ccode">char *super_pool,FD_OID base,unsigned int
capacity,lisp sp_label</td>
<td class="ccode">FD_OID</td>
</tr>
<tr>
<th></th>
<td>a super pool id, a base, a capacity, and a lisp pointer
label</td>
<td>an FD_OID</td>
</tr>
<tr>
<th></th>
<td><em>Asserts lost information about a pool in a super
pool.</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name=
"fd_super_pool_top" id=
"fd_super_pool_top">fd_super_pool_top</a></td>
<td class="ccode">char *id</td>
<td class="ccode">FD_OID</td>
</tr>
<tr>
<th></th>
<td>a super pool id</td>
<td>an FD_OID</td>
</tr>
<tr>
<th></th>
<td><em>Returns the highest allocated FD_OID in a super
pool</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name=
"fd_super_pool_loading" id=
"fd_super_pool_loading">fd_super_pool_loading</a></td>
<td class="ccode">char *id</td>
<td class="ccode">float</td>
</tr>
<tr>
<th></th>
<td>a super pool id</td>
<td>a float</td>
</tr>
<tr>
<th></th>
<td><em>Returns the fraction of the super pool which is
allocated</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name=
"fd_super_pool_base" id=
"fd_super_pool_base">fd_super_pool_base</a></td>
<td class="ccode">char *id</td>
<td class="ccode">FD_OID</td>
</tr>
<tr>
<th></th>
<td>a super pool id</td>
<td>an FD_OID</td>
</tr>
<tr>
<th></th>
<td><em>Returns the base of a super pool (e.g. @sp_id/0)</em></td>
<td></td>
</tr>
</table>
<h2><a name="network-pool.c" id="network-pool.c">Functions defined
in <tt>src/odb/network-pool.c</tt></a></h2>
<p><a href="#fd_use_network_pool"><tt>fd_use_network_pool</tt></a>
|</p>
<table cellpadding="5">
<tr>
<th align="left">Function</th>
<th align="left">Arguments</th>
<th align="left">Returns</th>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name=
"fd_use_network_pool" id=
"fd_use_network_pool">fd_use_network_pool</a></td>
<td class="ccode">char *servername,int port,fd_u8char *id</td>
<td class="ccode">fd_network_pool</td>
</tr>
<tr>
<th></th>
<td>a port number, a host name, and an id string</td>
<td>a pointer to a networked pool structure</td>
</tr>
<tr>
<th></th>
<td><em>Errors: Cannot connect to server Side effects: Creates a
networked pool structure for the server Adds a pointer to the pool
structure to fd_all_pools</em></td>
<td></td>
</tr>
</table>
<h2><a name="odb.c" id="odb.c">Functions defined in
<tt>src/odb/odb.c</tt></a></h2>
<p><a href="#fd_close_pool"><tt>fd_close_pool</tt></a> | <a href=
"#fd_commit_oid"><tt>fd_commit_oid</tt></a> | <a href=
"#fd_control_frame_printing"><tt>fd_control_frame_printing</tt></a>
| <a href="#fd_get_modified"><tt>fd_get_modified</tt></a> |
<a href="#fd_get_oid_value"><tt>fd_get_oid_value</tt></a> |
<a href="#fd_mark_modified"><tt>fd_mark_modified</tt></a> |
<a href="#fd_new_oid"><tt>fd_new_oid</tt></a> | <a href=
"#fd_oid_modifiedp"><tt>fd_oid_modifiedp</tt></a> | <a href=
"#fd_print_oid"><tt>fd_print_oid</tt></a> | <a href=
"#fd_revert_oid"><tt>fd_revert_oid</tt></a> | <a href=
"#fd_revert_pool"><tt>fd_revert_pool</tt></a> | <a href=
"#fd_set_oid_value"><tt>fd_set_oid_value</tt></a> | <a href=
"#fd_show_poolids"><tt>fd_show_poolids</tt></a> | <a href=
"#fd_swap_out"><tt>fd_swap_out</tt></a> | <a href=
"#fd_swap_out_pool"><tt>fd_swap_out_pool</tt></a> | <a href=
"#fd_try_oid_value"><tt>fd_try_oid_value</tt></a> |</p>
<table cellpadding="5">
<tr>
<th align="left">Function</th>
<th align="left">Arguments</th>
<th align="left">Returns</th>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name="fd_close_pool"
id="fd_close_pool">fd_close_pool</a></td>
<td class="ccode">fd_pool p</td>
<td class="ccode">void</td>
</tr>
<tr>
<th></th>
<td>a pointer to a pool</td>
<td>void</td>
</tr>
<tr>
<th></th>
<td><em>Closes open file pointers or network connections underlying
the pool.</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name=
"fd_control_frame_printing" id=
"fd_control_frame_printing">fd_control_frame_printing</a></td>
<td class="ccode">int level</td>
<td class="ccode">void</td>
</tr>
<tr>
<th></th>
<td>an integral print level</td>
<td>void</td>
</tr>
<tr>
<th></th>
<td><em>Controls the printing of oids If print level is 0, names
are never printed If print level is 1, names are printed for loaded
oids If print level is 2, names are always printed and oids are
loaded when printed</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name=
"fd_get_oid_value" id="fd_get_oid_value">fd_get_oid_value</a></td>
<td class="ccode">lisp oid</td>
<td class="ccode">lisp</td>
</tr>
<tr>
<th></th>
<td>a lisp pointer to an oid</td>
<td>a lisp pointer</td>
</tr>
<tr>
<th></th>
<td><em>Gets the value of an OID, doing fetching from files or
network as neccessary.</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name=
"fd_set_oid_value" id="fd_set_oid_value">fd_set_oid_value</a></td>
<td class="ccode">lisp oid,lisp value</td>
<td class="ccode">void</td>
</tr>
<tr>
<th></th>
<td>a lisp pointer to an oid and a lisp pointer to a value</td>
<td>none</td>
</tr>
<tr>
<th></th>
<td><em>This sets the value of an oid (its first argument) to a new
value (its second argument). fd_set_oid_value refcounts or copies
the second argument (if it's a choice) Errors: Cannot modify oid
Side effects: Frees the old value of the oid Changes the value
field of the oid Adds the oid to its pools "modified
objects"</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name=
"fd_mark_modified" id="fd_mark_modified">fd_mark_modified</a></td>
<td class="ccode">lisp oid</td>
<td class="ccode">void</td>
</tr>
<tr>
<th></th>
<td>a lisp pointer to an oid</td>
<td>void</td>
</tr>
<tr>
<th></th>
<td><em>Marks the designated OID as modified and signals an error
if it cannot be modified.</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name=
"fd_show_poolids" id="fd_show_poolids">fd_show_poolids</a></td>
<td class="ccode">int use_ids</td>
<td class="ccode">void</td>
</tr>
<tr>
<th></th>
<td>1 or 0</td>
<td>void</td>
</tr>
<tr>
<th></th>
<td><em>Determines if pool ids are used to print OIDs.</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name=
"fd_swap_out_pool" id="fd_swap_out_pool">fd_swap_out_pool</a></td>
<td class="ccode">fd_pool p</td>
<td class="ccode">void</td>
</tr>
<tr>
<th></th>
<td>a pointer to a pool</td>
<td>void</td>
</tr>
<tr>
<th></th>
<td><em>Frees any space being used for the values of unmodified
OIDs in pool. It doesn't do anything about committing
changes.</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name=
"fd_try_oid_value" id="fd_try_oid_value">fd_try_oid_value</a></td>
<td class="ccode">lisp oid</td>
<td class="ccode">lisp</td>
</tr>
<tr>
<th></th>
<td>a lisp pointer to an oid</td>
<td>a lisp pointer</td>
</tr>
<tr>
<th></th>
<td><em>Gets the value of an OID, doing fetching from files or
network as neccessary. If an error occurs, this will return FD_VOID
rather than signalling the error.</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name="fd_commit_oid"
id="fd_commit_oid">fd_commit_oid</a></td>
<td class="ccode">lisp oid</td>
<td class="ccode">int</td>
</tr>
<tr>
<th></th>
<td>a lisp pointer to an oid</td>
<td>1 if successful, 0 otherwise</td>
</tr>
<tr>
<th></th>
<td><em>Commits any changes to an oid using pool specific methods,
as appropriate.</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name="fd_print_oid"
id="fd_print_oid">fd_print_oid</a></td>
<td class="ccode">lisp frame,fd_string_stream ss</td>
<td class="ccode">void</td>
</tr>
<tr>
<th></th>
<td>a lisp pointer (to an `oid') and a string stream</td>
<td>nothing</td>
</tr>
<tr>
<th></th>
<td><em>Outputs an external representation of the oid, consisting
of its ID followed by its OBJ-NAME slot (if it exists).</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name="fd_swap_out"
id="fd_swap_out">fd_swap_out</a></td>
<td class="ccode">lisp oid</td>
<td class="ccode">void</td>
</tr>
<tr>
<th></th>
<td>a lisp pointer to an oid</td>
<td>none</td>
</tr>
<tr>
<th></th>
<td><em>If this oid's value has not been modified, it is freed and
the oid declared "non present", allowing it to be reloaded later if
its value is needed.</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name=
"fd_oid_modifiedp" id="fd_oid_modifiedp">fd_oid_modifiedp</a></td>
<td class="ccode">lisp oid</td>
<td class="ccode">int</td>
</tr>
<tr>
<th></th>
<td>a lisp pointer to an oid</td>
<td>1 or 0</td>
</tr>
<tr>
<th></th>
<td><em>Returns 1 if the oid has usaved modifications.</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name="fd_revert_oid"
id="fd_revert_oid">fd_revert_oid</a></td>
<td class="ccode">lisp oid</td>
<td class="ccode">int</td>
</tr>
<tr>
<th></th>
<td>a lisp pointer to an oid</td>
<td>1 if successful, 0 otherwise</td>
</tr>
<tr>
<th></th>
<td><em>Erases any uncommited changes to the designated
oid.</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name="fd_new_oid"
id="fd_new_oid">fd_new_oid</a></td>
<td class="ccode">fd_pool p</td>
<td class="ccode">lisp</td>
</tr>
<tr>
<th></th>
<td>a pointer to a pool structure</td>
<td>a new oid in the pool</td>
</tr>
<tr>
<th></th>
<td><em>Errors: Pool is used up Side effects: Increments the load
of a file pool or Updates the load on a remote server</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name=
"fd_revert_pool" id="fd_revert_pool">fd_revert_pool</a></td>
<td class="ccode">fd_pool p</td>
<td class="ccode">void</td>
</tr>
<tr>
<th></th>
<td>a pointer to a pool</td>
<td>void</td>
</tr>
<tr>
<th></th>
<td><em>Erases any uncommited changes to the oids in the
pool.</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name=
"fd_get_modified" id="fd_get_modified">fd_get_modified</a></td>
<td class="ccode">fd_pool p,int *n_oids,int reset</td>
<td class="ccode">fd_lisp *</td>
</tr>
<tr>
<th></th>
<td>a pointer to a pool, a result pointer to an int, and a
flag</td>
<td>a pointer to an array of lisp pointers</td>
</tr>
<tr>
<th></th>
<td><em>Returns an array of all the modified OIDs Marks the
designated OID as modified and signals an error if it cannot be
modified.</em></td>
<td></td>
</tr>
</table>
<h2><a name="pools.c" id="pools.c">Functions defined in
<tt>src/odb/pools.c</tt></a></h2>
<p><a href="#fd_commit_pool"><tt>fd_commit_pool</tt></a> | <a href=
"#fd_find_pool_named"><tt>fd_find_pool_named</tt></a> | <a href=
"#fd_for_pools"><tt>fd_for_pools</tt></a> | <a href=
"#fd_get_pool"><tt>fd_get_pool</tt></a> | <a href=
"#fd_interpret_pool"><tt>fd_interpret_pool</tt></a> | <a href=
"#fd_locate_pool"><tt>fd_locate_pool</tt></a> | <a href=
"#fd_pool_load"><tt>fd_pool_load</tt></a> | <a href=
"#fd_random_oid"><tt>fd_random_oid</tt></a> | <a href=
"#fd_register_pool"><tt>fd_register_pool</tt></a> | <a href=
"#fd_set_oid_locator"><tt>fd_set_oid_locator</tt></a> | <a href=
"#fd_use_pool"><tt>fd_use_pool</tt></a> |</p>
<table cellpadding="5">
<tr>
<th align="left">Function</th>
<th align="left">Arguments</th>
<th align="left">Returns</th>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name="fd_get_pool"
id="fd_get_pool">fd_get_pool</a></td>
<td class="ccode">lisp id</td>
<td class="ccode">fd_pool</td>
</tr>
<tr>
<th></th>
<td>a lisp pointer to an OID</td>
<td>a pointer to a pool</td>
</tr>
<tr>
<th></th>
<td><em>Finds the pool containing an oid.</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name="fd_random_oid"
id="fd_random_oid">fd_random_oid</a></td>
<td class="ccode">fd_pool p</td>
<td class="ccode">lisp</td>
</tr>
<tr>
<th></th>
<td>a pointer to a pool</td>
<td>an lisp pointer to an oid (or the empty choice)</td>
</tr>
<tr>
<th></th>
<td><em>Returns a random allocated OID in pool, or the empty choice
if the pool is empty.</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name="fd_for_pools"
id="fd_for_pools">fd_for_pools</a></td>
<td class="ccode">void (*fcn</td>
<td class="ccode">void</td>
</tr>
<tr>
<th></th>
<td>a function on a pool pointer and a void pointer and a void data
pointer</td>
<td>void</td>
</tr>
<tr>
<th></th>
<td><em>Applies the function to each known pool and the data
pointer passed to the call (got that?).</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name=
"fd_interpret_pool" id=
"fd_interpret_pool">fd_interpret_pool</a></td>
<td class="ccode">lisp spec</td>
<td class="ccode">fd_pool</td>
</tr>
<tr>
<th></th>
<td>an expression and an environment</td>
<td>a pointer to a pool</td>
</tr>
<tr>
<th></th>
<td><em>Evaluates the expression in the environment and tries to
produce an index object from the result.</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name=
"fd_commit_pool" id="fd_commit_pool">fd_commit_pool</a></td>
<td class="ccode">fd_pool p</td>
<td class="ccode">void</td>
</tr>
<tr>
<th></th>
<td>a pool</td>
<td>nothing</td>
</tr>
<tr>
<th></th>
<td></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name=
"fd_find_pool_named" id=
"fd_find_pool_named">fd_find_pool_named</a></td>
<td class="ccode">fd_u8char *name</td>
<td class="ccode">fd_pool</td>
</tr>
<tr>
<th></th>
<td>a utf-8 string</td>
<td>a pointer to a pool or NULL</td>
</tr>
<tr>
<th></th>
<td><em>Returns the pool which has been assigned the designated
name.</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name=
"fd_register_pool" id="fd_register_pool">fd_register_pool</a></td>
<td class="ccode">fd_pool p</td>
<td class="ccode">int</td>
</tr>
<tr>
<th></th>
<td>a pointer to a pool</td>
<td>void</td>
</tr>
<tr>
<th></th>
<td><em>Adds an entry for the pool to the pool table, doing nothing
if it is already there and signalling an error if the pool overlaps
with a currently registered pool.</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name=
"fd_set_oid_locator" id=
"fd_set_oid_locator">fd_set_oid_locator</a></td>
<td class="ccode">fd_pool (*ol</td>
<td class="ccode">void</td>
</tr>
<tr>
<th></th>
<td>a function which maps OIDs to pools</td>
<td>nothing</td>
</tr>
<tr>
<th></th>
<td><em>Sets the OID locator function for this session, which takes
an OID and returns its pool. This function is only called if the
pool is not already known, so the purpose of the oid locator is to
find otherwise undeclared pools.</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name="fd_pool_load"
id="fd_pool_load">fd_pool_load</a></td>
<td class="ccode">fd_pool p</td>
<td class="ccode">int</td>
</tr>
<tr>
<th></th>
<td>a pointer to a pool</td>
<td>an int</td>
</tr>
<tr>
<th></th>
<td><em>Returns the number of OIDs allocated in pool.</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name=
"fd_locate_pool" id="fd_locate_pool">fd_locate_pool</a></td>
<td class="ccode">lisp loid</td>
<td class="ccode">fd_pool</td>
</tr>
<tr>
<th></th>
<td>a lisp pointer (to an OID)</td>
<td>a pointer to a pool or NULL</td>
</tr>
<tr>
<th></th>
<td><em>This is just like fd_get_pool, but will try harder, calling
locator functions to try pools which haven't been explicitly
registered.</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name="fd_use_pool"
id="fd_use_pool">fd_use_pool</a></td>
<td class="ccode">fd_u8char *c</td>
<td class="ccode">fd_pool</td>
</tr>
<tr>
<th></th>
<td>a pool specification</td>
<td>a pool</td>
</tr>
<tr>
<th></th>
<td><em>Returns a pool based on a specification. The specification
either has the form port@host indicating a server or a filename
indicating a file pool.</em></td>
<td></td>
</tr>
</table>
<h2><a name="libframerd.c" id="libframerd.c">Functions defined in
<tt>src/odb/libframerd.c</tt></a></h2>
<p><a href=
"#fd_report_framerd_stats"><tt>fd_report_framerd_stats</tt></a>
|</p>
<table cellpadding="5">
<tr>
<th align="left">Function</th>
<th align="left">Arguments</th>
<th align="left">Returns</th>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name=
"fd_report_framerd_stats" id=
"fd_report_framerd_stats">fd_report_framerd_stats</a></td>
<td class="ccode">FILE *to</td>
<td class="ccode">void</td>
</tr>
<tr>
<th></th>
<td>none</td>
<td>void</td>
</tr>
<tr>
<th></th>
<td><em>Reports framerd stats to the standard error.</em></td>
<td></td>
</tr>
</table>
<h2><a name="network-index.c" id="network-index.c">Functions
defined in <tt>src/index/network-index.c</tt></a></h2>
<p><a href=
"#fd_use_network_index"><tt>fd_use_network_index</tt></a> |</p>
<table cellpadding="5">
<tr>
<th align="left">Function</th>
<th align="left">Arguments</th>
<th align="left">Returns</th>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name=
"fd_use_network_index" id=
"fd_use_network_index">fd_use_network_index</a></td>
<td class="ccode">char *servname,int port_no,fd_u8char *id</td>
<td class="ccode">fd_network_index</td>
</tr>
<tr>
<th></th>
<td>servername (a string), port_no (an int), and id (a utf8
string)</td>
<td>a pointer to a network index struct</td>
</tr>
<tr>
<th></th>
<td><em>Finds or creates (if neccessary) a network index served by
the specified servername and port.</em></td>
<td></td>
</tr>
</table>
{}
<h2><a name="load.c" id="load.c">Functions defined in
<tt>src/eval/load.c</tt></a></h2>
<p><a href="#fd_get_module"><tt>fd_get_module</tt></a> | <a href=
"#fd_load_file"><tt>fd_load_file</tt></a> | <a href=
"#fd_load_library"><tt>fd_load_library</tt></a> |</p>
<table cellpadding="5">
<tr>
<th align="left">Function</th>
<th align="left">Arguments</th>
<th align="left">Returns</th>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name="fd_load_file"
id="fd_load_file">fd_load_file</a></td>
<td class="ccode">char *filename,char *enc,fd_lispenv env</td>
<td class="ccode">lisp</td>
</tr>
<tr>
<th></th>
<td>a filename string, an encoding string, an environment</td>
<td>a lisp pointer</td>
</tr>
<tr>
<th></th>
<td><em>Loads a file into a particular environment with a
particular encoding.</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name="fd_get_module"
id="fd_get_module">fd_get_module</a></td>
<td class="ccode">fd_u8char *name,fd_u8char *filename,int all</td>
<td class="ccode">fd_lispenv</td>
</tr>
<tr>
<th></th>
<td>a module name, a filename, and an int flag</td>
<td>a pointer to a lispenv or NULL</td>
</tr>
<tr>
<th></th>
<td><em>Returns the module with the given name, loading it from
filename if needed. If filename is non-NULL, it is used to load the
module's definition. The final flag argument determines whether the
search includes modules which have restricted access.</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name=
"fd_load_library" id="fd_load_library">fd_load_library</a></td>
<td class="ccode">char *filename,char *enc,fd_lispenv env</td>
<td class="ccode">lisp</td>
</tr>
<tr>
<th></th>
<td>a filename string, an encoding string, an environment</td>
<td>a lisp pointer</td>
</tr>
<tr>
<th></th>
<td><em>Loads a file into a particular environment with a
particular encoding. This searches for the file along FDMYPATH and
FDPATH.</em></td>
<td></td>
</tr>
</table>
<h2><a name="libfdeval.c" id="libfdeval.c">Functions defined in
<tt>src/eval/libfdeval.c</tt></a></h2>
<table cellpadding="5">
<tr>
<th align="left">Function</th>
<th align="left">Arguments</th>
<th align="left">Returns</th>
</tr>
</table>
<h2><a name="threads.c" id="threads.c">Functions defined in
<tt>src/eval/threads.c</tt></a></h2>
<p><a href="#fd_thread_symbind"><tt>fd_thread_symbind</tt></a> |
<a href="#fd_thread_symeval"><tt>fd_thread_symeval</tt></a> |</p>
<table cellpadding="5">
<tr>
<th align="left">Function</th>
<th align="left">Arguments</th>
<th align="left">Returns</th>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name=
"fd_thread_symeval" id=
"fd_thread_symeval">fd_thread_symeval</a></td>
<td class="ccode">lisp sym</td>
<td class="ccode">lisp</td>
</tr>
<tr>
<th></th>
<td>a lisp symbol</td>
<td>a lisp value</td>
</tr>
<tr>
<th></th>
<td><em>Returns the thread-local value assigned to a symbol. This
increfs the value it returns.</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name=
"fd_thread_symbind" id=
"fd_thread_symbind">fd_thread_symbind</a></td>
<td class="ccode">lisp sym,lisp value</td>
<td class="ccode">void</td>
</tr>
<tr>
<th></th>
<td>a lisp symbol and a lisp value</td>
<td>void</td>
</tr>
<tr>
<th></th>
<td><em>Assigns a thread-local value to a symbol. The value is
`used up' in the assignment.</em></td>
<td></td>
</tr>
</table>
<h2><a name="sandbox.c" id="sandbox.c">Functions defined in
<tt>src/eval/sandbox.c</tt></a></h2>
<p><a href=
"#fd_add_restricted_cproc"><tt>fd_add_restricted_cproc</tt></a> |
<a href=
"#fd_add_restricted_lexpr"><tt>fd_add_restricted_lexpr</tt></a> |
<a href=
"#fd_add_restricted_special_form"><tt>fd_add_restricted_special_form</tt></a>
|</p>
<table cellpadding="5">
<tr>
<th align="left">Function</th>
<th align="left">Arguments</th>
<th align="left">Returns</th>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name=
"fd_add_restricted_cproc" id=
"fd_add_restricted_cproc">fd_add_restricted_cproc</a></td>
<td class="ccode">char *name,int n_args,lisp (*proc</td>
<td class="ccode">void</td>
</tr>
<tr>
<th></th>
<td>a string, an int, and a function pointer</td>
<td>void</td>
</tr>
<tr>
<th></th>
<td><em>Defines a primitive procedure in the standard restricted
environment.</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name=
"fd_add_restricted_special_form" id=
"fd_add_restricted_special_form">fd_add_restricted_special_form</a></td>
<td class="ccode">char *name,lisp (*proc</td>
<td class="ccode">void</td>
</tr>
<tr>
<th></th>
<td>a string, an int, and a function pointer</td>
<td>void</td>
</tr>
<tr>
<th></th>
<td><em>Defines a primitive special form in the standard restricted
environment.</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name=
"fd_add_restricted_lexpr" id=
"fd_add_restricted_lexpr">fd_add_restricted_lexpr</a></td>
<td class="ccode">char *name,int argcode,lisp (*proc</td>
<td class="ccode">void</td>
</tr>
<tr>
<th></th>
<td>a string, an int, and a function pointer</td>
<td>void</td>
</tr>
<tr>
<th></th>
<td><em>Defines a primitive lexpr in the standard restricted
environment.</em></td>
<td></td>
</tr>
</table>
<h2><a name="lambda.c" id="lambda.c">Functions defined in
<tt>src/eval/lambda.c</tt></a></h2>
<p><a href="#fd_bind_value"><tt>fd_bind_value</tt></a> | <a href=
"#fd_free_env"><tt>fd_free_env</tt></a> | <a href=
"#fd_make_env"><tt>fd_make_env</tt></a> | <a href=
"#fd_make_gproc"><tt>fd_make_gproc</tt></a> | <a href=
"#fd_make_sproc"><tt>fd_make_sproc</tt></a> | <a href=
"#fd_make_ssproc"><tt>fd_make_ssproc</tt></a> | <a href=
"#fd_mallocd_env"><tt>fd_mallocd_env</tt></a> | <a href=
"#fd_module_export"><tt>fd_module_export</tt></a> | <a href=
"#fd_module_uses"><tt>fd_module_uses</tt></a> | <a href=
"#fd_register_module"><tt>fd_register_module</tt></a> | <a href=
"#fd_register_restricted_module"><tt>fd_register_restricted_module</tt></a>
| <a href="#fd_registered_module"><tt>fd_registered_module</tt></a>
| <a href="#fd_required_symeval"><tt>fd_required_symeval</tt></a> |
<a href="#fd_safe_set_value"><tt>fd_safe_set_value</tt></a> |
<a href="#fd_set_value"><tt>fd_set_value</tt></a> | <a href=
"#fd_symeval"><tt>fd_symeval</tt></a> |</p>
<table cellpadding="5">
<tr>
<th align="left">Function</th>
<th align="left">Arguments</th>
<th align="left">Returns</th>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name="fd_set_value"
id="fd_set_value">fd_set_value</a></td>
<td class="ccode">lisp sym,lisp val,lispenv env</td>
<td class="ccode">void</td>
</tr>
<tr>
<th></th>
<td>a symbol, a value, and an environment</td>
<td>void</td>
</tr>
<tr>
<th></th>
<td><em>Sets the binding for symbol in an environment chain,
setting it in the innermost module or the global environment if the
variable is not directly bound.</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name="fd_free_env"
id="fd_free_env">fd_free_env</a></td>
<td class="ccode">fd_lispenv env</td>
<td class="ccode">void</td>
</tr>
<tr>
<th></th>
<td>an environment</td>
<td>void</td>
</tr>
<tr>
<th></th>
<td><em>Frees a dynamically allocated environment</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name=
"fd_mallocd_env" id="fd_mallocd_env">fd_mallocd_env</a></td>
<td class="ccode">fd_lispenv env</td>
<td class="ccode">fd_lispenv</td>
</tr>
<tr>
<th></th>
<td>an environment</td>
<td>a dynamically allocated environment</td>
</tr>
<tr>
<th></th>
<td><em>Returns the existing dynamic copy of an environment or
makes one if one doesn't exist.</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name=
"fd_registered_module" id=
"fd_registered_module">fd_registered_module</a></td>
<td class="ccode">fd_u8char *name,int risky</td>
<td class="ccode">fd_lispenv</td>
</tr>
<tr>
<th></th>
<td>a string</td>
<td>a lisp environment</td>
</tr>
<tr>
<th></th>
<td><em>Returns a module environment, register</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name=
"fd_required_symeval" id=
"fd_required_symeval">fd_required_symeval</a></td>
<td class="ccode">fd_lisp sym,lispenv env</td>
<td class="ccode">fd_lisp</td>
</tr>
<tr>
<th></th>
<td>a lisp symbol and an environment (possibly NULL)</td>
<td>a lisp object (cref'd)</td>
</tr>
<tr>
<th></th>
<td><em>Does an environment lookup (using fd_symeval) but signals
an error if it fails</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name=
"fd_module_uses" id="fd_module_uses">fd_module_uses</a></td>
<td class="ccode">fd_lispenv env,fd_lispenv use</td>
<td class="ccode">void</td>
</tr>
<tr>
<th></th>
<td>two pointers to modules</td>
<td>void</td>
</tr>
<tr>
<th></th>
<td><em>Adds the second argument to the uses for the first
argument, if it is not already included.</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name="fd_make_gproc"
id="fd_make_gproc">fd_make_gproc</a></td>
<td class="ccode">lisp lambda,lispenv env</td>
<td class="ccode">lisp</td>
</tr>
<tr>
<th></th>
<td>a lisp lambda expression and an environment</td>
<td>a procedure object closing the expression in the
environment</td>
</tr>
<tr>
<th></th>
<td></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name="fd_make_sproc"
id="fd_make_sproc">fd_make_sproc</a></td>
<td class="ccode">lisp lambda,lispenv env</td>
<td class="ccode">lisp</td>
</tr>
<tr>
<th></th>
<td>a lisp lambda expression and an environment</td>
<td>a procedure object closing the expression in the
environment</td>
</tr>
<tr>
<th></th>
<td></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name=
"fd_register_module" id=
"fd_register_module">fd_register_module</a></td>
<td class="ccode">fd_u8char *name,fd_lispenv menv</td>
<td class="ccode">void</td>
</tr>
<tr>
<th></th>
<td>a string and an environment</td>
<td>void</td>
</tr>
<tr>
<th></th>
<td><em>Binds the named symbol to the environment in the global
environment. This will signal an error if the global binding is not
VOID.</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name=
"fd_safe_set_value" id=
"fd_safe_set_value">fd_safe_set_value</a></td>
<td class="ccode">lisp sym,lisp val,lispenv env</td>
<td class="ccode">void</td>
</tr>
<tr>
<th></th>
<td>a symbol, a value, and an environment</td>
<td>void</td>
</tr>
<tr>
<th></th>
<td><em>Sets the value for a variable, but never effecting the
global environment.</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name="fd_make_env"
id="fd_make_env">fd_make_env</a></td>
<td class="ccode">fd_lispenv env</td>
<td class="ccode">fd_lispenv</td>
</tr>
<tr>
<th></th>
<td>a parent environment</td>
<td>a new environment</td>
</tr>
<tr>
<th></th>
<td><em>This dynamically allocates a new environment with a
specified parent.</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name="fd_symeval"
id="fd_symeval">fd_symeval</a></td>
<td class="ccode">fd_lisp sym,lispenv env</td>
<td class="ccode">fd_lisp</td>
</tr>
<tr>
<th></th>
<td>a lisp symbol and an environment (possibly NULL)</td>
<td>a lisp object (not cref'd)</td>
</tr>
<tr>
<th></th>
<td><em>This looks up a symbol, handling both lexical references,
module references, and global references.</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name=
"fd_make_ssproc" id="fd_make_ssproc">fd_make_ssproc</a></td>
<td class="ccode">lisp lambda,lispenv env</td>
<td class="ccode">lisp</td>
</tr>
<tr>
<th></th>
<td>a lisp lambda expression and an environment</td>
<td>a procedure object closing the expression in the
environment</td>
</tr>
<tr>
<th></th>
<td><em>with a lock for synchronizing application.</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name="fd_bind_value"
id="fd_bind_value">fd_bind_value</a></td>
<td class="ccode">lisp sym,lisp val,lispenv env</td>
<td class="ccode">void</td>
</tr>
<tr>
<th></th>
<td>a symbol, a value, and an environment</td>
<td>1 on success, 0 on failure</td>
</tr>
<tr>
<th></th>
<td><em>Sets the binding for symbol in the first frame of
environment or creates a new one if one does not exist. Returns 1
if a new binding had to be created.</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name=
"fd_register_restricted_module" id=
"fd_register_restricted_module">fd_register_restricted_module</a></td>
<td class="ccode">fd_u8char *name,fd_lispenv menv</td>
<td class="ccode">void</td>
</tr>
<tr>
<th></th>
<td>a string and an environment</td>
<td>void</td>
</tr>
<tr>
<th></th>
<td><em>Binds the named symbol to the environment in the restricted
environment. This will signal an error if the global binding is not
VOID.</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name=
"fd_module_export" id="fd_module_export">fd_module_export</a></td>
<td class="ccode">fd_lispenv modenv,lisp symbol</td>
<td class="ccode">void</td>
</tr>
<tr>
<th></th>
<td>a pointer to a module and a lisp symbol</td>
<td>void</td>
</tr>
<tr>
<th></th>
<td><em>Arranges for the module to export the specified
symbol.</em></td>
<td></td>
</tr>
</table>
<h2><a name="mini.c" id="mini.c">Functions defined in
<tt>src/eval/mini.c</tt></a></h2>
<table cellpadding="5">
<tr>
<th align="left">Function</th>
<th align="left">Arguments</th>
<th align="left">Returns</th>
</tr>
</table>
<h2><a name="ndeval.c" id="ndeval.c">Functions defined in
<tt>src/eval/ndeval.c</tt></a></h2>
<table cellpadding="5">
<tr>
<th align="left">Function</th>
<th align="left">Arguments</th>
<th align="left">Returns</th>
</tr>
</table>
<h2><a name="eval.c" id="eval.c">Functions defined in
<tt>src/eval/eval.c</tt></a></h2>
<p><a href=
"#_fd_finalize_static_tail_call"><tt>_fd_finalize_static_tail_call</tt></a>
| <a href="#fd_add_alias"><tt>fd_add_alias</tt></a> | <a href=
"#fd_add_cproc"><tt>fd_add_cproc</tt></a> | <a href=
"#fd_add_lexpr"><tt>fd_add_lexpr</tt></a> | <a href=
"#fd_add_special_form"><tt>fd_add_special_form</tt></a> | <a href=
"#fd_do_application"><tt>fd_do_application</tt></a> | <a href=
"#fd_eval"><tt>fd_eval</tt></a> | <a href=
"#fd_eval_elts"><tt>fd_eval_elts</tt></a> | <a href=
"#fd_eval_in_env"><tt>fd_eval_in_env</tt></a> | <a href=
"#fd_evalstring"><tt>fd_evalstring</tt></a> | <a href=
"#fd_finish_value"><tt>fd_finish_value</tt></a> | <a href=
"#fd_make_rproc"><tt>fd_make_rproc</tt></a> | <a href=
"#fd_mv_arity"><tt>fd_mv_arity</tt></a> | <a href=
"#fd_mv_ref"><tt>fd_mv_ref</tt></a> | <a href=
"#fd_mv_return"><tt>fd_mv_return</tt></a> | <a href=
"#fd_record_typep"><tt>fd_record_typep</tt></a> | <a href=
"#fd_set_supertype"><tt>fd_set_supertype</tt></a> | <a href=
"#fd_start_eval"><tt>fd_start_eval</tt></a> | <a href=
"#fd_streval"><tt>fd_streval</tt></a> |</p>
<table cellpadding="5">
<tr>
<th align="left">Function</th>
<th align="left">Arguments</th>
<th align="left">Returns</th>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name="fd_make_rproc"
id="fd_make_rproc">fd_make_rproc</a></td>
<td class="ccode">fd_server s,lisp op</td>
<td class="ccode">lisp</td>
</tr>
<tr>
<th></th>
<td>a server id and a remote op name, both lisp pointers</td>
<td>an rproc to invoke the op name on the named server</td>
</tr>
<tr>
<th></th>
<td></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name=
"fd_do_application" id=
"fd_do_application">fd_do_application</a></td>
<td class="ccode">lisp fcn,lisp argvalues</td>
<td class="ccode">lisp</td>
</tr>
<tr>
<th></th>
<td>two lisp values, a procedure and a list of arguments</td>
<td>a value or a tail call resulting from applying the</td>
</tr>
<tr>
<th></th>
<td><em>procedure to the arguments.</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name="fd_eval_elts"
id="fd_eval_elts">fd_eval_elts</a></td>
<td class="ccode">lisp lst,lispenv env</td>
<td class="ccode">lisp</td>
</tr>
<tr>
<th></th>
<td>a list of expressions</td>
<td>a list of objects</td>
</tr>
<tr>
<th></th>
<td><em>Returns the result of evaluating each element of a list in
an environment. Actual implementation is above.</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name="fd_mv_return"
id="fd_mv_return">fd_mv_return</a></td>
<td class="ccode">lisp *x,int len</td>
<td class="ccode">fd_lisp</td>
</tr>
<tr>
<th></th>
<td>a pointer to an array of lisp pointers and a int length</td>
<td>a multiple value object whose elements are the elements</td>
</tr>
<tr>
<th></th>
<td><em>of the array (copied into a new array)</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name="fd_eval" id=
"fd_eval">fd_eval</a></td>
<td class="ccode">lisp expr</td>
<td class="ccode">lisp</td>
</tr>
<tr>
<th></th>
<td>an expression</td>
<td>a lisp pointer</td>
</tr>
<tr>
<th></th>
<td><em>Evaluates an expression in the top level environment. It's
argument is not gc'd.</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name="fd_add_alias"
id="fd_add_alias">fd_add_alias</a></td>
<td class="ccode">fd_lispenv env,char *alias,char *name</td>
<td class="ccode">void</td>
</tr>
<tr>
<th></th>
<td>a null terminated string, an argument count, and a pointer to a
C function</td>
<td>nothing (void)</td>
</tr>
<tr>
<th></th>
<td><em>Defines a new FDScript primitive which is the same as
another existing primitive. This saves a little consing in that it
simply keeps a pointer to the primitive struct rather than making a
new one. It inherits the safety information of the procedure it is
aliasing.</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name="fd_add_lexpr"
id="fd_add_lexpr">fd_add_lexpr</a></td>
<td class="ccode">fd_lispenv env,char *name,int argcode,lisp
(*proc</td>
<td class="ccode">void</td>
</tr>
<tr>
<th></th>
<td>a null terminated string and a pointer to a C function</td>
<td>nothing (void)</td>
</tr>
<tr>
<th></th>
<td><em>Defines a new FDScript primitive which accepts any number
of arguments. The C function is called on a single lisp object,
pointing to a list of arguments. Note that any non-deterministic
arguments are represented as sets. fd_add_lexpr also declares the
symbol to be "safe" for evaluation.</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name="fd_streval"
id="fd_streval">fd_streval</a></td>
<td class="ccode">char *input</td>
<td class="ccode">char *</td>
</tr>
<tr>
<th></th>
<td>a string</td>
<td>a string</td>
</tr>
<tr>
<th></th>
<td><em>Evaluates an expression in the top level
environment.</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name="fd_evalstring"
id="fd_evalstring">fd_evalstring</a></td>
<td class="ccode">char *input,lispenv env</td>
<td class="ccode">char *</td>
</tr>
<tr>
<th></th>
<td>a string</td>
<td>a string</td>
</tr>
<tr>
<th></th>
<td><em>Evaluates an expression in the top level
environment.</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name="fd_add_cproc"
id="fd_add_cproc">fd_add_cproc</a></td>
<td class="ccode">fd_lispenv env,char *name,int n_args,lisp
(*proc</td>
<td class="ccode">void</td>
</tr>
<tr>
<th></th>
<td>a null terminated string, an argument count, and a pointer to a
C function</td>
<td>nothing (void)</td>
</tr>
<tr>
<th></th>
<td><em>Defines a new FDScript primitive with a name, a number of
arguments and a C implementation. Note that if the number of
arguments is negative, it is taken to be a lexpr or special form,
thought fd_add_special_form is the preferred way to declare such
primitives. A special form's implementation function is called on
the expression being evaluated and its environment, without any
further processing of the expression. fd_add_cproc also declares
the symbol to be "safe" for evaluation.</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name=
"fd_record_typep" id="fd_record_typep">fd_record_typep</a></td>
<td class="ccode">lisp x,lisp tag</td>
<td class="ccode">int</td>
</tr>
<tr>
<th></th>
<td>a lisp record and a tag</td>
<td>1 or 0</td>
</tr>
<tr>
<th></th>
<td><em>Returns 1 if the record's tag is the specified pointer or
one of its `supertypes'. Returns 0 otherwise or if the record is
not really a record</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name="fd_start_eval"
id="fd_start_eval">fd_start_eval</a></td>
<td class="ccode">lisp expr,lispenv env</td>
<td class="ccode">lisp</td>
</tr>
<tr>
<th></th>
<td>a lisp expression and a lisp environment</td>
<td>a lisp value, possibly a tail call</td>
</tr>
<tr>
<th></th>
<td><em>This starts the evaluation process which can be finished
with fd_finish_value</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name=
"_fd_finalize_static_tail_call" id=
"_fd_finalize_static_tail_call">_fd_finalize_static_tail_call</a></td>
<td class="ccode">lisp tc,fd_lispenv env</td>
<td class="ccode">lisp</td>
</tr>
<tr>
<th></th>
<td>a tail call object and an environment</td>
<td>the results of evaluating the tail call until it no</td>
</tr>
<tr>
<th></th>
<td><em>longer depends on the given environment</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name=
"fd_finish_value" id="fd_finish_value">fd_finish_value</a></td>
<td class="ccode">lisp value</td>
<td class="ccode">lisp</td>
</tr>
<tr>
<th></th>
<td>a lisp pointer</td>
<td>a lisp pointer which isn't a tail call</td>
</tr>
<tr>
<th></th>
<td><em>This will force any tail call to evaluate to a real
value.</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name=
"fd_eval_in_env" id="fd_eval_in_env">fd_eval_in_env</a></td>
<td class="ccode">lisp expr,lispenv env</td>
<td class="ccode">lisp</td>
</tr>
<tr>
<th></th>
<td>a lisp expression and a lisp environment</td>
<td>a lisp value, never a tail call</td>
</tr>
<tr>
<th></th>
<td><em>This starts and finishes the evaluation process. It returns
a value which may need to be freed but does not use up the value it
is passed.</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name="fd_mv_ref" id=
"fd_mv_ref">fd_mv_ref</a></td>
<td class="ccode">lisp x,unsigned int i</td>
<td class="ccode">fd_lisp</td>
</tr>
<tr>
<th></th>
<td>a lisp pointer and an int</td>
<td>the ith value represented by the pointer or FD_VOID
otherwise</td>
</tr>
<tr>
<th></th>
<td></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name=
"fd_add_special_form" id=
"fd_add_special_form">fd_add_special_form</a></td>
<td class="ccode">fd_lispenv env,char *name,lisp (*proc</td>
<td class="ccode">void</td>
</tr>
<tr>
<th></th>
<td>a null terminated string and a pointer to a C function</td>
<td>nothing (void)</td>
</tr>
<tr>
<th></th>
<td><em>Defines a new FDScript special form. Whenever a form whose
head is the specified symbol is evaluated, the declared function is
called on the form and the environment of evaluation.
fd_add_special_form also declares the symbol to be "safe" for
evaluation.</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name=
"fd_set_supertype" id="fd_set_supertype">fd_set_supertype</a></td>
<td class="ccode">lisp tag,lisp super_tag</td>
<td class="ccode">void</td>
</tr>
<tr>
<th></th>
<td>two lisp tags</td>
<td>nothing (void)</td>
</tr>
<tr>
<th></th>
<td><em>Records a super type relationship between two
tags</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name="fd_mv_arity"
id="fd_mv_arity">fd_mv_arity</a></td>
<td class="ccode">lisp x</td>
<td class="ccode">int</td>
</tr>
<tr>
<th></th>
<td>a lisp pointer</td>
<td>the number of values represented by the pointer</td>
</tr>
<tr>
<th></th>
<td></td>
<td></td>
</tr>
</table>
{}
<h2><a name="cxr.c" id="cxr.c">Functions defined in
<tt>src/scheme/cxr.c</tt></a></h2>
<table cellpadding="5">
<tr>
<th align="left">Function</th>
<th align="left">Arguments</th>
<th align="left">Returns</th>
</tr>
</table>
<h2><a name="reflect.c" id="reflect.c">Functions defined in
<tt>src/scheme/reflect.c</tt></a></h2>
<table cellpadding="5">
<tr>
<th align="left">Function</th>
<th align="left">Arguments</th>
<th align="left">Returns</th>
</tr>
</table>
<h2><a name="pairs.c" id="pairs.c">Functions defined in
<tt>src/scheme/pairs.c</tt></a></h2>
<table cellpadding="5">
<tr>
<th align="left">Function</th>
<th align="left">Arguments</th>
<th align="left">Returns</th>
</tr>
</table>
<h2><a name="characters.c" id="characters.c">Functions defined in
<tt>src/scheme/characters.c</tt></a></h2>
<table cellpadding="5">
<tr>
<th align="left">Function</th>
<th align="left">Arguments</th>
<th align="left">Returns</th>
</tr>
</table>
<h2><a name="bignum.c" id="bignum.c">Functions defined in
<tt>src/scheme/bignum.c</tt></a></h2>
<table cellpadding="5">
<tr>
<th align="left">Function</th>
<th align="left">Arguments</th>
<th align="left">Returns</th>
</tr>
</table>
<h2><a name="ioprims.c" id="ioprims.c">Functions defined in
<tt>src/scheme/ioprims.c</tt></a></h2>
<table cellpadding="5">
<tr>
<th align="left">Function</th>
<th align="left">Arguments</th>
<th align="left">Returns</th>
</tr>
</table>
<h2><a name="arith.c" id="arith.c">Functions defined in
<tt>src/scheme/arith.c</tt></a></h2>
<table cellpadding="5">
<tr>
<th align="left">Function</th>
<th align="left">Arguments</th>
<th align="left">Returns</th>
</tr>
</table>
<h2><a name="special.c" id="special.c">Functions defined in
<tt>src/scheme/special.c</tt></a></h2>
<table cellpadding="5">
<tr>
<th align="left">Function</th>
<th align="left">Arguments</th>
<th align="left">Returns</th>
</tr>
</table>
<h2><a name="libfdscheme.c" id="libfdscheme.c">Functions defined in
<tt>src/scheme/libfdscheme.c</tt></a></h2>
<table cellpadding="5">
<tr>
<th align="left">Function</th>
<th align="left">Arguments</th>
<th align="left">Returns</th>
</tr>
</table>
<h2><a name="strings.c" id="strings.c">Functions defined in
<tt>src/scheme/strings.c</tt></a></h2>
<p><a href="#fd_string_length"><tt>fd_string_length</tt></a> |
<a href="#fd_string_ref"><tt>fd_string_ref</tt></a> | <a href=
"#fd_string_set"><tt>fd_string_set</tt></a> |</p>
<table cellpadding="5">
<tr>
<th align="left">Function</th>
<th align="left">Arguments</th>
<th align="left">Returns</th>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name="fd_string_set"
id="fd_string_set">fd_string_set</a></td>
<td class="ccode">fd_lisp str,int index,unichar_t ch</td>
<td class="ccode">void</td>
</tr>
<tr>
<th></th>
<td>a lisp pointer to a string, an int, and a unicode
character</td>
<td>void</td>
</tr>
<tr>
<th></th>
<td><em>Modifies the string so that a particular character is
changed.</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name=
"fd_string_length" id="fd_string_length">fd_string_length</a></td>
<td class="ccode">lisp str</td>
<td class="ccode">int</td>
</tr>
<tr>
<th></th>
<td>a lisp pointer to a string</td>
<td>the length (in unicode characters) of a string</td>
</tr>
<tr>
<th></th>
<td></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name="fd_string_ref"
id="fd_string_ref">fd_string_ref</a></td>
<td class="ccode">lisp string,int index</td>
<td class="ccode">unichar_t</td>
</tr>
<tr>
<th></th>
<td>a lisp pointer to a string and an int</td>
<td>an unsigned int encoding a unicode character</td>
</tr>
<tr>
<th></th>
<td></td>
<td></td>
</tr>
</table>
<h2><a name="records.c" id="records.c">Functions defined in
<tt>src/scheme/records.c</tt></a></h2>
<table cellpadding="5">
<tr>
<th align="left">Function</th>
<th align="left">Arguments</th>
<th align="left">Returns</th>
</tr>
</table>
{}
<h2><a name="framerd.c" id="framerd.c">Functions defined in
<tt>src/fdscript/framerd.c</tt></a></h2>
<table cellpadding="5">
<tr>
<th align="left">Function</th>
<th align="left">Arguments</th>
<th align="left">Returns</th>
</tr>
</table>
<h2><a name="osprims.c" id="osprims.c">Functions defined in
<tt>src/fdscript/osprims.c</tt></a></h2>
<p><a href=
"#fd_register_url_protocol"><tt>fd_register_url_protocol</tt></a> |
<a href="#fd_urlget"><tt>fd_urlget</tt></a> |</p>
<table cellpadding="5">
<tr>
<th align="left">Function</th>
<th align="left">Arguments</th>
<th align="left">Returns</th>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name=
"fd_register_url_protocol" id=
"fd_register_url_protocol">fd_register_url_protocol</a></td>
<td class="ccode">char *protocol,fd_lisp (*getter</td>
<td class="ccode">void</td>
</tr>
<tr>
<th></th>
<td>a string and a pointer to an URL handler</td>
<td>void</td>
</tr>
<tr>
<th></th>
<td><em>Registers the handler for a particular protocol
name.</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name="fd_urlget" id=
"fd_urlget">fd_urlget</a></td>
<td class="ccode">char *url</td>
<td class="ccode">fd_lisp</td>
</tr>
<tr>
<th></th>
<td>a string and a pointer to an int</td>
<td>a string (actually a pointer to a byte array)</td>
</tr>
<tr>
<th></th>
<td><em>Gets the contents of a remote URL as a character string,
storing the size in the second argument (if non-NULL)</em></td>
<td></td>
</tr>
</table>
<h2><a name="libfdscript.c" id="libfdscript.c">Functions defined in
<tt>src/fdscript/libfdscript.c</tt></a></h2>
<table cellpadding="5">
<tr>
<th align="left">Function</th>
<th align="left">Arguments</th>
<th align="left">Returns</th>
</tr>
</table>
<h2><a name="prims.c" id="prims.c">Functions defined in
<tt>src/fdscript/prims.c</tt></a></h2>
<table cellpadding="5">
<tr>
<th align="left">Function</th>
<th align="left">Arguments</th>
<th align="left">Returns</th>
</tr>
</table>
<h2><a name="seq.c" id="seq.c">Functions defined in
<tt>src/fdscript/seq.c</tt></a></h2>
<table cellpadding="5">
<tr>
<th align="left">Function</th>
<th align="left">Arguments</th>
<th align="left">Returns</th>
</tr>
</table>
<h2><a name="printout.c" id="printout.c">Functions defined in
<tt>src/fdscript/printout.c</tt></a></h2>
<table cellpadding="5">
<tr>
<th align="left">Function</th>
<th align="left">Arguments</th>
<th align="left">Returns</th>
</tr>
</table>
<h2><a name="hashprims.c" id="hashprims.c">Functions defined in
<tt>src/fdscript/hashprims.c</tt></a></h2>
<table cellpadding="5">
<tr>
<th align="left">Function</th>
<th align="left">Arguments</th>
<th align="left">Returns</th>
</tr>
</table>
<h2><a name="maint.c" id="maint.c">Functions defined in
<tt>src/fdscript/maint.c</tt></a></h2>
<table cellpadding="5">
<tr>
<th align="left">Function</th>
<th align="left">Arguments</th>
<th align="left">Returns</th>
</tr>
</table>
{}
<h2><a name="match.c" id="match.c">Functions defined in
<tt>src/text/match.c</tt></a></h2>
<table cellpadding="5">
<tr>
<th align="left">Function</th>
<th align="left">Arguments</th>
<th align="left">Returns</th>
</tr>
</table>
<h2><a name="mime.c" id="mime.c">Functions defined in
<tt>src/text/mime.c</tt></a></h2>
<p><a href="#fd_parse_mime"><tt>fd_parse_mime</tt></a> |</p>
<table cellpadding="5">
<tr>
<th align="left">Function</th>
<th align="left">Arguments</th>
<th align="left">Returns</th>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name="fd_parse_mime"
id="fd_parse_mime">fd_parse_mime</a></td>
<td class="ccode">char *packet,int len</td>
<td class="ccode">fd_lisp</td>
</tr>
<tr>
<th></th>
<td>a C string and an integer length</td>
<td>a slotmap</td>
</tr>
<tr>
<th></th>
<td><em>The slotmap is derived from MIME-parsing the string; the
CONTENT slot of the returned slotmap is either a string or a list
of slotmaps (for multipart mime messages).</em></td>
<td></td>
</tr>
</table>
<h2><a name="text.c" id="text.c">Functions defined in
<tt>src/text/text.c</tt></a></h2>
<p><a href="#fd_text_subst"><tt>fd_text_subst</tt></a> |</p>
<table cellpadding="5">
<tr>
<th align="left">Function</th>
<th align="left">Arguments</th>
<th align="left">Returns</th>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name="fd_text_subst"
id="fd_text_subst">fd_text_subst</a></td>
<td class="ccode">fd_lisp pat,fd_lisp string</td>
<td class="ccode">fd_lisp</td>
</tr>
<tr>
<th></th>
<td>a pattern (a lisp pointer) and a string (also a lisp
pointer)</td>
<td>another lisp string</td>
</tr>
<tr>
<th></th>
<td><em>Applies the substitutions specified in the pattern to the
string, returning the result.</em></td>
<td></td>
</tr>
</table>
<h2><a name="xml.c" id="xml.c">Functions defined in
<tt>src/text/xml.c</tt></a></h2>
<p><a href="#fd_make_xmltag"><tt>fd_make_xmltag</tt></a> | <a href=
"#fd_parse_html"><tt>fd_parse_html</tt></a> | <a href=
"#fd_parse_xml"><tt>fd_parse_xml</tt></a> | <a href=
"#fd_xml_attributes"><tt>fd_xml_attributes</tt></a> | <a href=
"#fd_xml_content"><tt>fd_xml_content</tt></a> | <a href=
"#fd_xml_tag"><tt>fd_xml_tag</tt></a> | <a href=
"#fd_xmltag_name"><tt>fd_xmltag_name</tt></a> | <a href=
"#fd_xmltag_namespace"><tt>fd_xmltag_namespace</tt></a> |</p>
<table cellpadding="5">
<tr>
<th align="left">Function</th>
<th align="left">Arguments</th>
<th align="left">Returns</th>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name=
"fd_xmltag_namespace" id=
"fd_xmltag_namespace">fd_xmltag_namespace</a></td>
<td class="ccode">fd_lisp tag</td>
<td class="ccode">fd_lisp</td>
</tr>
<tr>
<th></th>
<td>a lisp object (symbol or xml tag)</td>
<td>the tag's namespace (possibly #f)</td>
</tr>
<tr>
<th></th>
<td><em>For symbols, this just returns #F; for tags, it returns the
tag's namespace.</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name=
"fd_xml_attributes" id=
"fd_xml_attributes">fd_xml_attributes</a></td>
<td class="ccode">fd_lisp x</td>
<td class="ccode">fd_lisp</td>
</tr>
<tr>
<th></th>
<td>a lisp pointer</td>
<td>a lisp pointer</td>
</tr>
<tr>
<th></th>
<td><em>Gets the attributes of a pair or OID describing an XML
element. Note that the attributes are a property list of
lists.</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name=
"fd_xmltag_name" id="fd_xmltag_name">fd_xmltag_name</a></td>
<td class="ccode">fd_lisp tag</td>
<td class="ccode">fd_lisp</td>
</tr>
<tr>
<th></th>
<td>a lisp object (symbol or xml tag)</td>
<td>the tag's name</td>
</tr>
<tr>
<th></th>
<td><em>For symbols, this is just the identity; for tags, it
returns whatever the base of the xmltag is.</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name="fd_xml_tag"
id="fd_xml_tag">fd_xml_tag</a></td>
<td class="ccode">fd_lisp x</td>
<td class="ccode">fd_lisp</td>
</tr>
<tr>
<th></th>
<td>a lisp pointer</td>
<td>a lisp pointer</td>
</tr>
<tr>
<th></th>
<td><em>Gets the tag (or element type) of an pair or OID describing
an XML element.</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name="fd_parse_html"
id="fd_parse_html">fd_parse_html</a></td>
<td class="ccode">fd_u8char *string</td>
<td class="ccode">fd_lisp</td>
</tr>
<tr>
<th></th>
<td>a UTF8-string</td>
<td>A nested pair structure based on the HTML structure of the
given string</td>
</tr>
<tr>
<th></th>
<td><em>This knows about the empty HTML tags and will handle them
appropriately. It also automatically terminates paragraphs and list
items.</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name="fd_parse_xml"
id="fd_parse_xml">fd_parse_xml</a></td>
<td class="ccode">fd_u8char *string,int err_level,fd_lisp ns</td>
<td class="ccode">fd_lisp</td>
</tr>
<tr>
<th></th>
<td>a UTF8-string, an error level, and a namespace (a lisp
pointer)</td>
<td>A nested pair structure based on the XML structure of the given
string</td>
</tr>
<tr>
<th></th>
<td><em>Unqualified element and attribute names will be created in
the given namespace, unless it is false (#f,FD_FALSE), in which
case they will just be created as symbols. The error level is an
int in the range [0,2]: 0 XML_LAX Try and fix XML mismatches and
other syntax errors 1 XML_ATTENTIVE Warn about XML mismatches and
other syntax errors (and try to fix them) 2 XML_PARANOID Raise an
exception for XML mismatches and other syntax errors</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name=
"fd_make_xmltag" id="fd_make_xmltag">fd_make_xmltag</a></td>
<td class="ccode">fd_lisp ns,fd_lisp base</td>
<td class="ccode">fd_lisp</td>
</tr>
<tr>
<th></th>
<td>a namespace (a string or symbol), and a type (a symbol)</td>
<td>an lisp object describing a qualified xmltag</td>
</tr>
<tr>
<th></th>
<td><em>If the namespace is false (#f), this just returns the type.
Otherwise, it conses a lisp record.</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name=
"fd_xml_content" id="fd_xml_content">fd_xml_content</a></td>
<td class="ccode">fd_lisp x</td>
<td class="ccode">fd_lisp</td>
</tr>
<tr>
<th></th>
<td>a lisp pointer</td>
<td>a lisp pointer</td>
</tr>
<tr>
<th></th>
<td><em>Gets the content of a pair or OID describing an XML
element. Note that this should always be a list of either strings
or other elements.</em></td>
<td></td>
</tr>
</table>
<h2><a name="md5c.c" id="md5c.c">Functions defined in
<tt>src/text/md5c.c</tt></a></h2>
<table cellpadding="5">
<tr>
<th align="left">Function</th>
<th align="left">Arguments</th>
<th align="left">Returns</th>
</tr>
</table>
<h2><a name="htmlgen.c" id="htmlgen.c">Functions defined in
<tt>src/text/htmlgen.c</tt></a></h2>
<p><a href="#fd_http_puts"><tt>fd_http_puts</tt></a> | <a href=
"#fd_http_write_bytes"><tt>fd_http_write_bytes</tt></a> | <a href=
"#fd_set_http_output_methods"><tt>fd_set_http_output_methods</tt></a>
| <a href="#fd_start_http"><tt>fd_start_http</tt></a> | <a href=
"#fd_start_http_output"><tt>fd_start_http_output</tt></a> |
<a href="#fd_unparse_xml"><tt>fd_unparse_xml</tt></a> |</p>
<table cellpadding="5">
<tr>
<th align="left">Function</th>
<th align="left">Arguments</th>
<th align="left">Returns</th>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name=
"fd_unparse_xml" id="fd_unparse_xml">fd_unparse_xml</a></td>
<td class="ccode">fd_lisp expr,fd_lispenv env,fd_htstream *hs</td>
<td class="ccode">void</td>
</tr>
<tr>
<th></th>
<td>an xml element rep, an environment, and an http stream</td>
<td>void</td>
</tr>
<tr>
<th></th>
<td><em>Outputs a text representation of the xml/html structure
represented by the first argument. Any tags which have bindings in
the environment are interpreted as function calls. If the html flag
is true, the generation process will try and generate HTML rather
than XML.</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name=
"fd_start_http_output" id=
"fd_start_http_output">fd_start_http_output</a></td>
<td class="ccode">fd_htstream *s</td>
<td class="ccode">void</td>
</tr>
<tr>
<th></th>
<td>a pointer to an fd_htstream</td>
<td>void</td>
</tr>
<tr>
<th></th>
<td><em>Begins output to the designated htstream, setting it as the
thread-local HTTP output stream and setting the initial phasse of
the HTTP output process.</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name=
"fd_set_http_output_methods" id=
"fd_set_http_output_methods">fd_set_http_output_methods</a></td>
<td class="ccode">void (*_puts</td>
<td class="ccode">void</td>
</tr>
<tr>
<th></th>
<td>three functions</td>
<td>void</td>
</tr>
<tr>
<th></th>
<td><em>Sets the methods used for HTTP output. The first function
is for outputting null-terminated strings in their entirety; the
second function is for outputing single characters; and the third
function is for outputing substrings given a start and a
length.</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name="fd_start_http"
id="fd_start_http">fd_start_http</a></td>
<td class="ccode">char *mime</td>
<td class="ccode">void</td>
</tr>
<tr>
<th></th>
<td>a string containing a mime type specification</td>
<td>void</td>
</tr>
<tr>
<th></th>
<td><em>Outputs a content-type header field, including a charset
specifier which refers to the current default character
encoding.</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name="fd_http_puts"
id="fd_http_puts">fd_http_puts</a></td>
<td class="ccode">char *s,fd_htstream *stream</td>
<td class="ccode">void</td>
</tr>
<tr>
<th></th>
<td>a pointer to a null-terminated string and an FD_HTTP_STREAM
struct</td>
<td>void</td>
</tr>
<tr>
<th></th>
<td><em>Writes the string to the stream.</em></td>
<td></td>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name=
"fd_http_write_bytes" id=
"fd_http_write_bytes">fd_http_write_bytes</a></td>
<td class="ccode">char *s,int n,fd_htstream *stream</td>
<td class="ccode">void</td>
</tr>
<tr>
<th></th>
<td>a pointer to a null-terminated string and an FD_HTTP_STREAM
struct</td>
<td>void</td>
</tr>
<tr>
<th></th>
<td><em>Writes the string to the stream.</em></td>
<td></td>
</tr>
</table>
<h2><a name="getnames.c" id="getnames.c">Functions defined in
<tt>src/text/getnames.c</tt></a></h2>
<table cellpadding="5">
<tr>
<th align="left">Function</th>
<th align="left">Arguments</th>
<th align="left">Returns</th>
</tr>
</table>
<h2><a name="stem.c" id="stem.c">Functions defined in
<tt>src/text/stem.c</tt></a></h2>
<p><a href=
"#fd_stem_english_word"><tt>fd_stem_english_word</tt></a> |</p>
<table cellpadding="5">
<tr>
<th align="left">Function</th>
<th align="left">Arguments</th>
<th align="left">Returns</th>
</tr>
<tr>
<td align="left" valign="top" class="ccode"><a name=
"fd_stem_english_word" id=
"fd_stem_english_word">fd_stem_english_word</a></td>
<td class="ccode">fd_u8char *original</td>
<td class="ccode">char *</td>
</tr>
<tr>
<th></th>
<td>an ASCII string</td>
<td>a stemmed string (malloc'd)</td>
</tr>
<tr>
<th></th>
<td><em>Applies all the Porter rules for stemming a word. If the
word is too long (more than 200 characters) it just gives up. This
returns a malloc'd string containing the porter stem. Note that the
porter stem is usually not itself a word you would
recognize.</em></td>
<td></td>
</tr>
</table>
{}
<h2><a name="console.c" id="console.c">Functions defined in
<tt>src/misc/console.c</tt></a></h2>
<table cellpadding="5">
<tr>
<th align="left">Function</th>
<th align="left">Arguments</th>
<th align="left">Returns</th>
</tr>
</table>
<h2><a name="cgiparse.c" id="cgiparse.c">Functions defined in
<tt>src/misc/cgiparse.c</tt></a></h2>
<table cellpadding="5">
<tr>
<th align="left">Function</th>
<th align="left">Arguments</th>
<th align="left">Returns</th>
</tr>
</table>
<h2><a name="indextools.c" id="indextools.c">Functions defined in
<tt>src/misc/indextools.c</tt></a></h2>
<table cellpadding="5">
<tr>
<th align="left">Function</th>
<th align="left">Arguments</th>
<th align="left">Returns</th>
</tr>
</table>
<h2><a name="server.c" id="server.c">Functions defined in
<tt>src/misc/server.c</tt></a></h2>
<table cellpadding="5">
<tr>
<th align="left">Function</th>
<th align="left">Arguments</th>
<th align="left">Returns</th>
</tr>
</table>
{}
</body>
</html>
