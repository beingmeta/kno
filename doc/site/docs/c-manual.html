<!DOCTYPE html>
<html>
  <head>
    <meta name="generator" content=
	  "HTML Tidy for HTML5 for Linux version 4.9.27">
    <title>Using FramerD from C</title>
    <link rel="stylesheet" type="text/css" href=
	  "/static/framerd/documentation.css">
  </head>
  <body>
    <table align="left" width='100%'>
      <tr>
	<th class="bigtitle" align="left" width='70%'>Using FramerD From
	  C<br>
	  <span class="author">Ken Haase</span></th>
	<th align="right" rowspan="2"><a href=
					 "http://www.framerd.org/"><img border="0" src=
									"fdlogo.png"></a></th>
      </tr>
    </table>
    <br clear="left">
    <p class="quickref">Quick ref: [<a href="#fcnmorph">Function name
	morphology</a>]&nbsp; [<a href="#lisppointers">Lisp
	pointers</a>]&nbsp; [<a href="#exceptions">Exception
	Handling</a>]&nbsp; [<a href="#unicode">Unicode
	Representation</a>]&nbsp; [<a href="#stringinput">Input from
	strings</a>]&nbsp; [<a href="#stringoutput">Output to
	strings</a>]&nbsp; [<a href="#lisptypes">Lisp Types</a>]&nbsp;
      (esp. <a href="#immediates">immediates</a>, <a href=
						     "#strings">strings</a>, <a href="#composite">composites</a>)
      [<a href="#evaltypes">Evaluator Types</a>]&nbsp; [<a href=
							   "#evalfcns">Evaluator Functions</a>]&nbsp; [<a href=
													  "#modules">Implementing Modules</a>]&nbsp; [<a href=
																			 "#dirstructure">Directory Structure</a>]&nbsp; [<a href=
																									    "#files">Source Files</a>]&nbsp;</p>
    <hr>
    <p>The kernel of FramerD is written in ANSI C and one way of using
      FramerD is by writing C or C++ code and using the FramerD libraries
      in either static or dynamic form. This provisional document
      describes programming with these libraries and also describes the
      structure of the FramerD source tree.</p>
    <h1>Programming with FramerD</h1>
    <p>In order to program using FramerD from C, you need to know what
      compile flags to use and where to find headers and include files.
      The script <tt>fdxs</tt> provides this information in the form of
      command line strings which can be passed directly to compilers and
      linkers. For these purposes, there are three forms of the
      <tt>fdxs</tt> commands:</p>
    <table>
      <tr>
	<td><tt class="commands">fdxs cflags</tt></td>
	<td>returns the command line options to use for compiling programs
	  which use the FramerD libraries. This includes options specifying
	  where the FramerD include files live as well as other flags such as
	  (on some platforms) <tt>-fshort-enums</tt>.</td>
      </tr>
      <tr>
	<td><tt class="commands">fdxs libs</tt></td>
	<td>returns the arguments for linking against the FramerD
	  libraries, including the <tt>-L</tt> argument indicating where the
	  libraries live and individual <tt>-l<var>lib</var></tt> arguments
	  for the various FramerD libraries themselves.</td>
      </tr>
      <tr>
	<td><tt class="commands">fdxs modules</tt></td>
	<td>returns the directory where FramerD modules should be
	  installed.</td>
      </tr>
    </table>
    <p>The fdxs command can be used to write portable makefiles by
      using the backquoted shell escape to execute an <tt class=
							  "command">fdxs</tt> and include its results in the compilation
      commands. For instance, here is the makefile for the
      <tt>xframerd</tt> module:</p>
    <pre>
      CFLAGS = `fdxs cflags` `libwww-config --cflags` $(XCFLAGS)
      
      all:  w3fd.so
      
      tidy:
      rm -f w3fd.o *~
      clean: tidy
      rm -f w3fd.so
      
      w3fd.so: w3fd.o makefile
      ld -shared -o $@ w3fd.o `libwww-config --libs` `fdxs libs`
      
      install: w3fd.so
      cp -f w3fd.so `fdxs modules`
    </pre>
    <p>which uses <tt>`fdxs cflags`</tt> to get the C compiler command
      line, <tt>`fdxs libs`</tt> to get the linker command line
      arguments, and <tt>`fdxs modules`</tt> to get the modules
      directory.</p>
    <h3><a name="fcnmorph" id="fcnmorph">Function name
	morphology</a></h3>
    <p>There are a few heuristics for determining the semantics of
      functions and macros based on their names. First, nearly all
      library functions and macros start with the prefix <tt class=
							     "ccode">fd_</tt> or <tt class="ccode">FD_</tt>; if the preprocessor
      variable <tt class="ccode">FD_SOURCE</tt> is defined to be
      <tt>1</tt> before the FramerD include files are referenced, some
      aliases without the <tt class="ccode">fd_</tt> prefix will be
      defined.</p>
    <p>Function names starting with <tt class="ccode">_fd_</tt> are
      internal library functions typically used by preprocessor macros,
      and should not be directly called by user code. Most functions in
      the library should be <em>threadsafe</em>, but some functions have
      variants with the suffix <tt class="ccode">_nolock</tt> indicating
      that they are <strong>not</strong> threadsafe.</p>
    <p>Case is used to distinguish "well-behaved type-checking"
      functions from riskier functions. Lower case functions (or
      preprocessor macros which can be called as functions) typically do
      type checking (when handed LISP pointers) and obey standard
      conventions for interaction with the garbage collector (if they
      hold onto an argument they will <em>incref</em> it and if the
      return a lisp pointer it will need to be <em>decref</em>ed unless
      further returned. Some functions have upper case names (and are
      often implemented as macros or inline functions) and make no such
      guarantees. Other uppercase identifiers act as semi-syntactic
      elements, rather than as functions, and these are always
      implemented by C preprocessor macros (though they may have helper
      functions, generally starting with <tt class="ccode">_fd_</tt>.
      These are mostly used in the <a href="#exceptions">exception
	handling system</a>.</p>
    <p>The FramerD libraries are divided into five core collections of
      functions:</p>
    <dl>
      <dt>dtype</dt>
      <dd>provides utility functions, the core LISP data types used by
	FramerD, and binary DType I/O allowing these data types
	transmission and storage;</dd>
      <dt>framerd</dt>
      <dd>provides the basic object database, the associative indices
	used to do fast searches for objects, the core of the FDScript
	evaluator (including threading and the module and security system),
	and basic procedures for accessing frames and making simple
	inferences;</dd>
      <dt>scheme</dt>
      <dd>provides much of the R4RS scheme functionality, including the
	full arithmetic system, string and character operations, and I/O
	primitives; currently, these functions are lumped into the
	<strong>fdscript</strong> library from the developer's point of
	view;</dd>
      <dt>fdscript</dt>
      <dd>provides FDScript's special extensions, including more advanced
	FramerD access and maintenance functions, operating system access,
	the <tt class="lcode">PRINTOUT</tt> family of functions, imports
	from Common LISP (including sequence functions, <tt class=
							    "lcode">DOLIST</tt>, <tt class="lcode">DOTIMES</tt>, etc.</dd>
      <dt>fdtext</dt>
      <dd>provides FDScript's text analysis tools, including a powerful
	and extensible textual pattern matcher, HTML and XML generation and
	parsing (including XML namespace handling), MIME and RFC-822
	parsing, MD5 hashing, the Porter stemmer, and a simple proper name
	extractor.</dd>
    </dl>
    <p>All externally available functions are prefixed by a
      preprocessor macro providing information to the linker. In the core
      FramerD code, these macros are:</p>
    <blockquote><tt class="ccode">DTYPES_EXPORT</tt>, <tt class=
							  "ccode">FRAMERD_EXPORT</tt>, <tt class=
											   "ccode">FDSCRIPT_EXPORT</tt>, <tt class="ccode">FDTEXT_EXPORT</tt>,
      <tt class="ccode">EXPORTED</tt></blockquote>
    <h1><a name="lisppointers" id="lisppointers">LISP Pointers:
	<tt class="ccode">fd_lisp</tt></a></h1>
    <p>This is a typed pointer. In the standard implementation, this is
      a struct of type <tt class="ccode">struct FD_LISP_PTR</tt>
      consisting of a type tag (of enumerated type <tt class=
						       "ccode">fd_lisp_type</tt> stored in the <tt class="ccode">type</tt>
      field) and a data pointer (of union type fd_lisp_data stored in the
      <tt class="ccode">-&gt;data</tt> field). The type of a pointer can
      be directly tested with the macro <tt class=
					    "ccode">FD_PRIM_TYPEP(x,type)</tt> where <tt class="ccode">x</tt>
      is the lisp pointer and <tt class="ccode">type</tt> is one of the
      values of <tt class="ccode">fd_lisp_type</tt>. The data portion can
      be extracted with the function <tt class=
					 "ccode">FD_PTR_DATA(x,field)</tt> where <tt class=
										     "ccode">field</tt> indicates a particular kind of data.</p>
    <p><strong>Garbage Collection</strong>&nbsp;&nbsp;FramerD uses a
      reference counting garbage collector, the important external
      functions/macros are:</p>
    <ul>
      <li><tt class="ccode">fd_incref(x)</tt> increases the "reference
	count" of the object referred to by the lisp pointer <var>x</var>.
	Note that if <var>x</var> is a fixnum, immediate, symbol, or object
	reference, this is simply the identity.</li>
      <li><tt class="ccode">fd_decref(x)</tt> reduces the "reference
	count" of the object referred to by the lisp pointer <var>x</var>
	and --- if the reference count reaches zero --- frees the storage
	it is using for other purposes.</li>
      <li><tt class="ccode">fd_copy_lisp(x)</tt> returns a copy of the
	object referred to be the lisp pointer <i>x</i>. Note that if
	<var>x</var> is a fixnum, immediate, symbol, or object reference,
	this is simply the identity.</li>
    </ul>
    <p>The contract between <tt>fd_copy_lisp</tt> and
      <tt>fd_decref</tt> is that if an object y is created by
      <tt>fd_copy_lisp(x)</tt>, it will be unaffected by a subsequent
      <tt>fd_decref(x)</tt>. Nearly all normal FramerD library functions
      and preprocessor macros which take lisp pointers as arguments will
      <em>incref</em> those pointers if they will hang onto them;
      likewise nearly all functions returning LISP pointers will
      implicitly <em>incref</em> their argument. Functions and macros
      which do not do this will have either uppercase names or begin with
      an underscore "_", indicating that the function is an internal
      function.</p>
    <p><strong>Comparing Objects</strong>&nbsp;&nbsp;Lisp objects can
      also be compared with one another:</p>
    <ul>
      <li><tt class="ccode">FD_LISP_EQUAL(obj1,obj2)</tt><br>
	Returns 1 if <var>obj1</var> and <var>obj2</var> are equal, zero
	otherwise.</li>
      <li><tt class="ccode">FD_LISP_EQ(obj1,obj2)</tt><br>
	Returns 1 if <var>obj1</var> and <var>obj2</var> have identical
	types and literal data fields; this is the same as <tt class=
							       "ccode">LISP_EQUAL</tt> for fixnums, flonums, immediate values,
	symbols, and OIDs.</li>
      <li><tt class="ccode">fd_memberp(object,list)</tt><br>
	Returns 1 if an object is in a list.</li>
      <li>fd_choice_containsp(object,coice)<br>
	Returns 1 if an object is an element of the choice
	<var>choice</var>.</li>
    </ul>
    <p>Functions and macros for generating or accessing particular
      types of objects are shown below.</p>
    <h2>Printing LISP objects</h2>
    <dl>
      <dt>fd_object_to_string(object)</dt>
      <dd>Returns a string containing a printed representation for
	object.</dd>
      <dt>fd_parse_lisp_from_stream(stream)</dt>
      <dd>Returns an object generated from a printed representation read
	from stream (of type <tt class="ccode">FILE *</tt>).</dd>
      <dt>fd_parse_lisp_from_string</dt>
      <dd>Returns an object generated from a printed representation
	stored in string</dd>
      <dt>fd_print_dtype(object,file stream)</dt>
      <dd>Emits a printed representation of an object onto file
	stream.</dd>
      <dt>fd_print_dtype_to_stdout(object)</dt>
      <dd>Writes a printed representation of object to the standard
	output, followed by a carriage return.</dd>
      <dt>fd_print_dtype_to_string(object,string stream)</dt>
      <dd>Writes a printed representation of object to a string data
	structure.</dd>
      <dt>fd_read_dtype_from_file(filestring)</dt>
      <dt>fd_str2lisp(string)</dt>
      <dd>Converts a string containing a printed representation into a
	lisp object.</dd>
      <dt>fd_arg2lisp(string)</dt>
      <dd>Returns an object based on the printed representation in
	<i>string</i>. It is designed for parsing command line arguments as
	lisp objects and favors returning LISP strings. In particular, only
	arguments beginning with a colon are interpreted as symbols.</dd>
    </dl>
    <h2>Reading and Writing DTypes</h2>
    <dl>
      <dt><tt class="ccode">fd_dread_dtype</tt>(data_buffer)</dt>
      <dd>Takes a data buffer and returns the object specified by the
	DType representation within it.</dd>
      <dt><tt class="ccode">fd_dtype_compare</tt>(object,stream)</dt>
      <dd>Returns 1 if the stream specifies a DTYPE representation for
	OBJECT.</dd>
      <dt><tt class="ccode">fd_dwrite_dtype</tt>(object,data_buffer)</dt>
      <dd>Writes a dtype representation for an object into a data
	buffer.</dd>
      <dt><tt class="ccode">fd_fignore_dtype</tt>(stream)</dt>
      <dd>Skips over one dtype representation on stream.</dd>
      <dt><tt class="ccode">fd_fread_dtype</tt>(filestream)</dt>
      <dd>Reads a dtype representation from a binary filestream,
	returning the corresponding object.</dd>
      <dt><tt class="ccode">fd_fwrite_dtype</tt>(object,filestream)</dt>
      <dd>Writes a DType representation of object to a filestream.</dd>
      <dt><tt class=
	      "ccode">fd_write_dtype_to_file</tt>(object,filestring)</dt>
      <dd>Writes a dtype representation of an object to the specified
	file.</dd>
    </dl>
    <h1><a name="exceptions" id="exceptions">Exception
	Handling</a></h1>
    <p>The type <tt class="ccode">fd_exception</tt> is used by
      FramerD's exception handling system, this is a pointer to a string
      (<tt class="ccode">char *</tt>) describing an error. The functions
      for dealing with errors can be found in <tt>src/os/except.c</tt>.
      The key functions for signalling errors are</p>
    <ul compact>
      <li><tt class=
	      "ccode">fd_raise_exception(<var>exception</var>)</tt></li>
      <li><tt class=
	      "ccode">fd_raise_detailed_exception(<var>exception</var>,details
	  string)</tt></li>
      <li><tt class=
	      "ccode">fd_raise_lisp_exception(<var>exception</var>,details
	  string,lisp irritant)</tt></li>
    </ul>
    <p>Catching exceptions is done with macros that make C look a
      little like LISP. The basic schemas are:</p>
    <pre>
      {
      WITH_HANDLING {
      ... do some stuff ... }
      ON_EXCEPTION {
      ... do stuff when an exception gets raised ... }
      END_HANDLING
      }
    </pre>
    <p>for catching exceptions and</p>
    <pre>
      {
      UNWIND_PROTECT {
      ... do some stuff ... }
      ON_UNWIND {
      ... do this even if an exception is raised ... }
      END_UNWIND
      }
    </pre>
    <p>to ensure that cleanup code gets run despite exceptions. In
      either case, you can use the function <tt class=
						"ccode">fd_theException()</tt> to get the exception which was
      signalled, <tt class="ccode">fd_exception_details()</tt> to get the
      details string for the exception, and <tt class=
						"ccode">fd_exception_object()</tt> to get whatever LISP object was
      associated with the acception (or <tt class="ccode">FD_VOID</tt> if
      there wasn't any).</p>
    <p>The exception handliing or protection code can call <tt class=
							       "ccode">fd_reraise()</tt> to pass on the current exception, or
      <tt class="ccode">fd_clear_exception()</tt> to clear the current
      exception. The protection code will automatically reraise the
      exception unless it has been cleared.</p>
    <!---
	(generate-api-refs "fd_raise_exception" "fd_raise_detailed_exception" "fd_raise_lisp_exception"
        "fd_type_error" "fd_exception" "fd_exception_details" "fd_exception_object")
	=-->
    <h3>Some Standard Exceptions</h3>
    <dl>
      <dt><tt class="ccode">fd_Out_Of_Memory</tt></dt>
      <dd>An exception signalled when a system call to malloc() has
	failed</dd>
      <dt><tt class="ccode">fd_Parse_Error</tt></dt>
      <dd>An exception signalled when the parser for LISP expressions
	encounters an unexpected token</dd>
      <dt><tt class="ccode">fd_Unexpected_EOD</tt></dt>
      <dd>An exception signalled when a data buffer ends
	unexpectedly.</dd>
      <dt><tt class="ccode">fd_Unexpected_EOF</tt></dt>
      <dd>An exception signalled when a data stream ends
	unexpectedly.</dd>
      <dt><tt class="ccode">fd_Unknown_Record_Type</tt></dt>
      <dd>An exception signalled when the system tries to operate on an
	unknown record type.</dd>
      <dt><tt class="ccode">fd_Unknown_Type_Code</tt></dt>
      <dd>An exception signalled when when an unknown DTYPE data code is
	read. It generally occurs when mis-aligned data has been written
	out, which none of the built-in procedures should ever do.</dd>
    </dl>
    <h1><a name="unicode" id="unicode">Unicode</a></h1>
    <p>FramerD uses UTF-8 as its internal coding for Unicode strings.
      UTF-8 encodes ASCII characters using a single byte and encodes
      other Unicode code points using a series of non-ASCII (decimal
      value &gt; 255) characters. Most strings in FramerD are UTF-8
      strings and are typed as either <tt class=
					  "ccode">fd_utf8_string</tt> or (more commonly) a pointer to an
      array of type <tt class="ccode">fd_u8char</tt> (which is just an
      unsigned character).</p>
    <p>Translations from external character sets to UTF-8 is managed by
      FramerD using structures of type <tt class="ccode">struct
	FD_TEXT_ENCODING</tt>. The function <tt class=
						"ccode">fd_get_encoding(char *)</tt> returns a particular named
      encoding, e.g. <tt class="ccode">fd_get_encoding("LATIN-1")</tt>
      returns the LATIN-1 encoding for Western European characters.</p>
    <p>The function <tt class="ccode">fd_make_utf8(char *start,char
	*end,struct FD_TEXT_ENCODING *e)</tt> returns a newly malloc'd
      UTF-8 string based on the characters between <var>start</var> and
      <var>end</var> based on the encoding <var>e</var>. If
      <var>end</var> is <tt class="ccode">NULL</tt>, the entire string
      <var>start</var> is used; if <var>e</var> is NULL, the default
      encoding is used.</p>
    <p>The function <tt class="ccode">fd_convert_utf8(u8char *start,int
	len,struct FD_TEXT_ENCODING *e,int *sizep)</tt> does the opposite
      conversion, taking a UTF-8 string and producing a newly malloc'd
      string of characters using encoding <var>e</var>. If a given
      character cannot be represented in this encoding, an error is
      signalled. The length of the resulting string is stored in
      <var>sizep</var> if it is non-NULL (this is especially important if
      the generated string contains NULs ('\0') which will mislead the C
      libraries <tt>strlen</tt>.</p>
    <p>The function <tt class="ccode">fd_localize_utf8(u8char
	*start,struct FD_TEXT_ENCODING *e)</tt> does the opposite
      conversion, taking a UTF-8 string and producing a newly malloc'd
      string of characters using encoding <var>e</var>. If a given
      character cannot be represented in this encoding, an error is
      signalled.</p>
    <p>FramerD provides a structure called an <tt class=
						  "ccode">FD_XFILE</tt> (which deals with alien characters) for doing
      I/O using character sets. The function <tt class=
						 "ccode">fd_get_xfile(FILE *f,struct FD_TEXT_ENCODING *e)</tt>
      returns an FD_XFILE structure (malloc'ing it if neccessary) which
      reads its input or writes its output using <var>f</var> together
      with the encoding <var>e</var>. This structure should be freed with
      the function <tt class="ccode">fd_free_xfile</tt>.</p>
    <p>The functions for directly using XFILEs are:</p>
    <ul>
      <li><tt class="ccode">fd_xputc(int c,struct FD_XFILE *xf)</tt>
	writes a representation of the unicode code point <var>c</var> to
	<var>xf</var></li>
      <li style="list-style: none">. This signals an error if the
	encoding of <var>xf</var> cannot represent <var>c</var>.</li>
      <li><tt class="ccode">fd_xgetc(struct FD_XFILE *xf)</tt> returns
	the <tt class="ccode">int</tt> code point for the character from
	<var>xf</var></li>
      <li style="list-style: none">, based on the encoding assigned to
	<tt class="ccode">xf</tt>.</li>
      <li><tt class="ccode">fd_xputc_escaped(int c,struct FD_XFILE
	  *xf)</tt> writes a representation of the unicode code point
	<var>c</var> to <var>xf</var></li>
      <li style="list-style: none">. If the encoding for <var>xf</var>
	cannot represent <var>c</var>, an escape sequence of the form
	<tt class="lcode">\uXXXX</tt> or <tt class="lcode">\UXXXXXXXX</tt>
	is used to encode the character, where each <tt class=
							"lcode">XXXX</tt> or <tt class="lcode">XXXXXXXX</tt> is the
	hexadecimal code for the character.</li>
      <li><tt class="ccode">fd_xgetc_escaped(int c,struct FD_XFILE
	  *xf)</tt> returns the <tt class="ccode">int</tt> code point for the
	character from <var>xf</var></li>
      <li style="list-style: none">, based on the encoding assigned to
	<tt class="ccode">xf</tt>. This will parse escapes generated by
	<tt class="ccode">fd_xputc_encoded</tt>.</li>
    </ul>
    <p>The FramerD internationalization library also provides a layer
      for using stdio <tt class="ccode">FILE *</tt> pointers directly,
      without the intervening <tt class="ccode">XFILE</tt>s. The function
      <tt class="ccode">fd_set_file_encoding(FILE *f,char *name)</tt>
      associates the encoding named <var>name</var> with the file
      <var>f</var>. After this association, the following functions
      provide automatic encoding and decoding:</p>
    <ul>
      <li><tt class="ccode">fd_fgetc(FILE *f)</tt> returns a
	character</li>
      <li><tt class="ccode">fd_fputc(int c,FILE *f)</tt> writes
	<var>c</var> to <var>f</var></li>
      <li><tt class="ccode">fd_fputs_raw(u8char *s,int len,FILE *f)</tt>
	writes <var>len</var> bytes of the UTF-8 encoded string
	<var>s</var> to <var>f</var>, signalling an error if the encoding
	for <var>f</var> cannot represent a character.</li>
      <li><tt class="ccode">fd_fputs_escaped(u8char *s,int len,FILE
	  *f)</tt> writes <var>len</var> bytes of the UTF-8 encoded string
	<var>s</var> to <var>f</var>, expressing any unrepresentable
	characters by <tt class="lcode">\uXXXX</tt> or <tt class=
							   "lcode">\UXXXXXXXX</tt> escape sequences.</li>
    </ul>
    <p>The encoding assigned by <tt class=
				    "ccode">fd_set_file_encoding</tt> can be retrieved by <tt class=
											      "ccode">fd_get_file_encoding</tt>.</p>
    <p>In addition to file specific and XFILE encodings, there are
      three special global encodings: the <strong>console
	encoding</strong> is used for output to the console
      (stdin/stdout/stderr); the <strong>system encoding</strong> is used
      to convert strings before and after system or library calls, for
      instance filenames; finally, the <strong>default encoding</strong>
      is used whenever neither of these encodings are relevant and no
      other encoding is explicity provided.</p>
    <p>The function <tt class="ccode">fd_set_default_encoding(struct
	FD_TEXT_ENCODING *e)</tt> sets the default encoding and the
      function <tt class="ccode">fd_get_default_encoding()</tt> retrieves
      it. Similarly, for the system encoding, the function <tt class=
							       "ccode">fd_set_system_encoding(struct FD_TEXT_ENCODING *e)</tt>
      sets the default encoding and the function <tt class=
						     "ccode">fd_get_system_encoding()</tt> retrieves it. The console
      encoding can be modified by applying the functions above</p>
    <p>FramerD normally comes with built-in encodings for ASCII,
      LATIN-[1-9], ISO-8859/[1-15], UTF-8, UCS-2, and KOI-8. In addition,
      the function <tt class="ccode">fd_load_encoding(char *name,char
	*file)</tt> loads a named encoding from an external file. It is
      able to interpret both the "charset mapping files" provided by the
      Unicode Consortium (<a href=
			     "ftp://ftp.unicode.org/Public/MAPPINGS/">ftp://ftp.unicode.org/Public/MAPPINGS/</a>)
      and the native character set encoding used by Linux and some other
      operating systems. Under Linux, these mappings usually live in the
      <tt class="file">/usr/share/i18n/charmaps/</tt> directory.</p>
    <p>The environment variable <tt>ENCODINGS_PATH</tt> can refer to a
      number of directories where FramerD automatically searches for
      encodings in this format. In this search, encoding names are
      canonicalized by removal of of punctuation characters and
      upper-casing of alphabetic characters.</p>
    <p>The following program translates the standard input to the
      standard output, doing character translations automatically:</p>
    <pre>
      int main()
      {
      struct FD_TEXT_ENCODING *in, *out; int c;
      in=fd_get_encoding(argv[1]); out=fd_get_encoding(argv[2]);
      fd_set_file_encoding(stdin,in); fd_set_file_encoding(stdout,out);
      while ((c=fd_fgetc(stdin)) &gt;= 0) fd_fputc(c,stdout);
      exit(0);
      }
    </pre>
    <h2>Composed Characters</h2>
    <p>Some unicode characters are <strong>combining
	characters</strong> which work by modifying preceding or succeeding
      characters with (for instance) diacritical or other marks. This
      leads to a potential for ambiguity because some modified characters
      have two representations: a direct representation as a single
      unicode character and a combined representation consisting of the
      unmodified character and a subsequent modifier. The function
      <tt class="ccode">fd_decompose_char(unsigned int ch)</tt> returns a
      UTF-8 string encoding <var>ch</var> as a sequence of base character
      plus modifiers; the function <tt class=
				       "ccode">fd_recompose_char(fd_u8char *s)</tt> returns the single
      unicode character (if it exists) represented by the character and
      modifiers in the UTF-8 string <var>s</var> It returns <tt>-1</tt>
      if the string does not describe a combined character with a single
      character equivalent.</p>
    <p>The standard I/O functions (such as fd_fgetc) do not normally
      interpret combined characters, but return base and combining
      characters separately. The functions above are designed to be used
      when programs need to interpret such combined characters.</p>
    <h1><a name="stringoutput" id="stringoutput">String
	Streams</a></h1>
    <p>String streams are for generating strings programmatically and
      are used extensively by FDScript and especially its text processing
      utilities. String streams grow automatically as output is received.
      A string stream is initialized by the macro <tt class=
						      "ccode">FD_INITIALIZE_STRING_STREAM(ssp,isize)</tt> where
      <var>ssp</var> is a pointer to a string stream and <var>isize</var>
      is the initial number of bytes allocated to its buffer. This buffer
      is kept in the <tt class="ccode">-&gt;ptr</tt> field of the
      <tt class="ccode">FD_STRING_STREAM</tt> (of type <tt class=
							   "ccode">fd_u8char *</tt>). The current capacity of this buffer is
      an int in the <var>limit</var> and the current actual size is in
      the <var>size</var> field. These sizes are in bytes and the number
      of represented unicode characters may differ, since some Unicode
      characters take more than one byte of UTF-8 encoding.</p>
    <p>As indicated by the type of the buffer, string streams use UTF-8
      to represent Unicode output. The functions for doing output to
      string streams are:</p>
    <ul>
      <li><tt class="ccode">fd_sputc(fd_string_stream,int c)</tt> writes
	the unicode character represented by <var>c</var>;</li>
      <li><tt class="ccode">fd_sputs(fd_string_stream,u8char *s)</tt>
	writes the UTF-8 string <var>s</var> to the stream;</li>
      <li><tt class="ccode">fd_sputn(fd_string_stream,u8char *s,int
	  n)</tt> writes the UTF-8 string between <var>s</var> and
	<var>s+n</var> to the stream.</li>
    </ul>
    <p>For example, the following procedure returns a string based on a
      character range:</p>
    <pre>
      u8char *enumerate_char_range(int bot,int top)
      {
      /* Return a string of characters from bot to top */
      struct FD_STRING_STREAM s; int i=bot;
      FD_INITIALIZE_STRING_STREAM(&amp;s,(top-bot)*2);
      while (i &lt; top) {fd_sputc(&amp;s,i); i++;}
      return s.ptr;
      }
    </pre>
    <p>The macro <tt class=
		     "ccode">FD_INITIALIZE_FIXED_STRING_STREAM</tt> initializes a string
      stream of fixed size; output beyond the specified size is a no-op.
      It takes three arguments: a pointer to the string stream to
      initialize, the size of the buffer, and a pointer to the buffer
      (which is typically on the stack). We could use this to implement a
      limited version of the procedure above:</p>
    <pre>
      u8char *enumerate_char_range(int bot,int top)
      {
      /* Return a string of characters from bot to top */
      struct FD_STRING_STREAM s; int i=bot; char buf[128];
      if ((top-bot)*2 &gt; 128)
      fd_raise_exception("Range might be too big");
      else {
      FD_INITIALIZE_FIXED_STRING_STREAM(&amp;s,128,buf);
      while (i &lt; top) {fd_sputc(&amp;s,i); i++;}
      /* We have to copy it because it is in this stack frame. */
      return fd_strdup(s.ptr);}
      }
    </pre>
    <p>The function <tt class="ccode">fd_printf(fd_string_stream,char
	*fmt,...)</tt> is a version of the <tt class="ccode">printf</tt>
      which takes a string stream as argument and also supports several
      additional format directives:</p>
    <ul>
      <li>"%q" prints a lisp pointer</li>
      <li>"%Q" prints a lisp pointer using the pretty printer</li>
      <li>"%t" prints the current time</li>
      <li>"%lt" prints the current time and date</li>
      <li>"%m" prints a `message' string which should be processed by GNU
	<tt>gettext</tt> for translation before printing.</li>
    </ul>
    <p>The function <tt class="ccode">fd_fprintf</tt> takes a
      <tt class="ccode">FILE *</tt> pointer as its first argument. It
      will also obey any encoding assigned to the file pointer by
      <tt>fd_set_file_encoding</tt>. The function <tt class=
						      "ccode">fd_xprintf(char *fmt,...)</tt> handles <em>exceptional
	i/o</em> which goes to either the standard error output or a
      dynamically declared error stream.</p>
    <p>The functions <tt class="ccode">fd_notify(char *fmt,...)</tt>
      and <tt class="ccode">fd_warn(char *fmt,...)</tt> are both
      specialized versions of <tt class="ccode">fd_printf</tt> which use
      globally declared handlers to display output to the user. These
      functions might, for instance, pop up a dialog box rather than
      doing output to the console. Both functions produce strings which
      are then passed to handlers. The handler for <tt>fd_notify</tt> is
      defined by <tt>fd_set_notify_handler</tt>: its argument is a
      function which takes a string and returns void. The handler for
      <tt>fd_warn</tt> is defined by <tt>fd_set_warn_handler</tt>: its
      argument is also a function which takes a string and returns void.
      The function <tt>fd_disable_notifications()</tt> turns
      <tt>fd_notify</tt> into a no-op. There is no way to turn off
      warnings. In the case of both functions, the default action is to
      do output to the standard error stream (stderr).</p>
    <h2><a name="stringinput" id="stringinput">Reading from
	Strings</a></h2>
    <p>UTF-8 strings can also be read from using a set of functions
      which parallel the FILE and XFILE reading functions. In this case,
      an input string is simply a pointer to a pointer to a UTF-8 string
      (i.e. <tt class="ccode">fd_utf8 **</tt>; as characters are read,
      the pointer is advanced. The function <tt class=
						"ccode">fd_sgetc(fd_u8char **ss)</tt> reads a character from such a
      stream. The function <tt class=
			       "ccode">fd_parse_lisp_from_string(fd_u8char **ss)</tt> parses a
      LISP object from the representation in the string.</p>
    <h1><a name="lisptypes" id="lisptypes">Lisp Types</a></h1>
    <p>There are four basic kinds of lisp types in FramerD:</p>
    <ul>
      <li><strong>immediate types</strong> (fixnums, flonums, characters,
	and constants) take up no additional storage (beyond the pointer
	itself, which is typically stack-allocated</li>
      <li><strong>consed types</strong> (strings or symbols, for
	instance) point to an internal FramerD structures of some sort;
	some of these (such as symbols) may be interned, so that LISP
	equality and pointer identity are equivalent. And in some of these
	cases, such as symbols, the consed data is permanent and cannot be
	reclaimed. Note that object identifiers, OIDs, are a special case,
	depending on how FramerD is compiled; when FramerD is compiled with
	<strong>consed oids</strong> (currently the default), OIDs are a
	native type and point to a lisp strcuture; when FramerD is compiled
	with <strong>lightweight oids</strong>, OIDs are an immediate type
	which may not have a corresponding structure.</li>
      <li><strong>composite types</strong> contain other pointers as
	elements</li>
      <li><strong>foreign types</strong> contain reference counted C
	pointers to other objects</li>
    </ul>
    <p><a name="immediates" id="immediates">The immediate types
	are:</a></p>
    <ul>
      <li><strong>fixnums</strong> (tagged with <tt class=
						    "ccode">fixnum_type</tt>)<br>
	<tt class="ccode">FD_FIXNUMP(x)</tt> is <tt class="ccode">1</tt> if
	<var>x</var> is a fixnum;<br>
	<tt class="ccode">FD_LISPFIX(int)</tt> converts a C int into a
	tagged lisp pointer; <tt class="ccode">FD_FIXLISP(lisp_int)</tt>
	extracts the integer value from a lisp pointer; <tt class=
							    "ccode">fixlisp(lisp_int)</tt> does the same but signals an error
	if <var>lisp_int</var> is not tagged as a fixnum.</li>
      <li><strong>constants</strong> (tagged with <tt class=
						      "ccode">immediate_type</tt> and including true, false, the empty
	list, the empty choice, the `void' value, and the end of file
	marker);<br>
	constants are returned by <tt class="ccode">FD_TRUE</tt>,
	<tt class="ccode">FD_FALSE</tt>, <tt class=
					     "ccode">FD_EMPTY_LIST</tt>, <tt class="ccode">FD_EMPTY_CHOICE</tt>,
	<tt class="ccode">FD_VOID</tt>, and <tt class=
						"ccode">FD_EOF_OBJECT</tt>;<br>
	values are tested by <tt class="ccode">FD_TRUEP</tt>, <tt class=
								  "ccode">FD_FALSEP</tt>, <tt class="ccode">FD_EMPTY_LISTP</tt>,
	<tt class="ccode">FD_EMPTYP</tt>, <tt class="ccode">FD_VOIDP</tt>,
	and <tt class="ccode">FD_EOF_OBJECTP</tt>;</li>
      <li><strong>characters</strong> (tagged with <tt class=
						       "ccode">character_type</tt>)<br>
	<tt class="ccode">FD_CHARACTERP(x)</tt> is <tt class="ccode">1</tt>
	if <var>x</var> is a character object;<br>
	<tt class="ccode">FD_CODE_CHAR(int)</tt> returns a character object
	representing the code point <var>int</var>; <tt class=
							"ccode">FD_CHAR_CODE(x)</tt> returns the integer code point for
	<var>x</var>; <tt class="ccode">fd_char_code(x)</tt> does the same
	but signals an error if <var>v</var> is not a character object
	<tt class="ccode">fd_make_character(int x)</tt> returns a LISP
	character object for the integer code point for <var>x</var></li>
      <li><strong>OIDs</strong> (when OIDS are lightweight) are unsigned
	ints whose first 8 bits indicate a <em>pseudo pool</em> and whose
	remaining 24 bits indicate an offset into that pool. These pseudo
	pools may or may not align with actual pools of OIDs used by the
	object database.<br>
	<tt class="ccode">FD_OIDP(x)</tt> is <tt class="ccode">1</tt> if
	<var>x</var> is an OID;<br>
	<tt class="ccode">fd_oid_current_value(x)</tt> returns the value
	associated with the OID <var>x</var> if it has been set or loaded
	already; <tt class="ccode">fd_oid_value(x)</tt> returns the value
	associated with the OID <var>x</var>, retrieving it if neccessary
	and incref'ing the result;<br>
	<tt class="ccode">FD_OID_ADDR_HIGH(x)</tt> returns the top 32-bits
	of the unique 64-bit ID of <var>x</var>; <tt class=
						     "ccode">FD_OID_ADDR_LOW(x)</tt> returns the lower 32-bits of the
	unique 64-bit ID of <var>x</var>;<br></li>
    </ul>
    <p>The primary consed types are:</p>
    <ul>
      <li><a name="strings" id="strings"><strong>strings</strong></a> are
	pointers to structures of type <tt class="ccode">struct
	  FD_STRING</tt> which store length information<br>
	<tt class="ccode">FD_STRINGP(x)</tt> is <tt class="ccode">1</tt> if
	<var>x</var> is a string; <tt class=
				      "ccode">FD_ASCII_STRINGP(x)</tt> will tell you if <var>x</var> is
	an ASCII string<br>
	<tt class="ccode">FD_STRING_DATA(x)</tt> returns the UTF-8 string
	data of a string; <tt class="ccode">FD_STRING_LENGTH(x)</tt>
	returns the number of bytes used in this string; <tt class=
							     "ccode">fd_strdata(x)</tt> and <tt class="ccode">fd_strlen(x)</tt>
	do type checking<br>
	<tt class="ccode">fd_init_string(fd_u8char *s,int len)</tt> creates
	a new string object, using the string <var>s</var> as data;
	<var>s</var> is not copied and it's UTF-8 validity is not normally
	checked; <tt class="ccode">fd_copy_string(fd_u8char *s)</tt>
	returns a string object based on the UTF-8 string <var>s</var>,
	however it also does not validate the UTF-8 string; <tt class=
								"ccode">fd_make_string(char *s)</tt> returns a string object based
	on the string <var>s</var> using the default character encoding to
	convert <var>s</var> to UTF-8; <tt class=
					   "ccode">fd_make_substring(fd_u8char *start,fd_u8char *end)</tt>
	returns a string object based on the substring starting at
	<var>start</var> and ending at <var>end&gt;.</var></li>
      <li><var><strong>symbols</strong> are pointers to structures of
	  type <tt class="ccode">struct FD_SYMBOL</tt> and have associated
	  names and global values; symbols are interned, so all symbols with
	  the same name will actually be the same <tt class="ccode">struct
	    FD_SYMBOL</tt> structure and <tt class="ccode">fd_decref(x)</tt> on
	  a symbol does nothing<br>
	  <tt class="ccode">FD_SYMBOLP(x)</tt> is <tt class="ccode">1</tt> if
	  <var>x</var> is a symbol;<br>
	  <tt class="ccode">FD_SYMBOL_NAME(x)</tt> returns the name of the
	  symbol <var>x</var>, a UTF-8 string (<tt class="ccode">u8char
	    *</tt>) which should not be modified. <tt class=
						      "ccode">FD_SYMBOL_VALUE(x)</tt> returns the lisp value globally
	  associated with the symbol <var>x</var>;<br>
	  <tt class="ccode">fd_make_symbol(string)</tt> returns the symbol
	  with the name <var>string</var> (a UTF-8 string which will be
	  copied). This will always return the same pointer with equal
	  arguments and will cons a new <tt class="ccode">struct
	    FD_SYMBOL</tt> if neccessary;<br>
	  <tt class="ccode">fd_probe_symbol(string)</tt> is like <tt class=
								     "ccode">fd_make_symbol</tt> but returns <tt class=
														 "ccode">FD_EMPTY_CHOICE</tt> if the symbol has not already been
	  returned.</var></li>
      <li><strong>OIDs</strong> (when OIDS are consed) are pointers to
	structures of type <tt class="ccode">struct FD_OID</tt> which
	combine a unique 64-bit identifier with a lisp value; they are also
	interned, like symbols;<br>
	<tt class="ccode">FD_OIDP(x)</tt> is <tt class="ccode">1</tt> if
	<var>x</var> is an OID;<br>
	<tt class="ccode">FD_OID_VALUE(x)</tt> returns the value associated
	with the OID <var>x</var> if it has been set or loaded; <tt class=
								    "ccode">FD_OID_ADDR_HIGH(x)</tt> returns the top 32-bits of the
	unique 64-bit ID of <var>x</var>; <tt class=
					      "ccode">FD_OID_ADDR_LOW(x)</tt> returns the lower 32-bits of the
	unique 64-bit ID of <var>x</var>;<br>
	there are a lot of functions and macros for dealing with OIDs; the
	are described here (to be written).</li>
      <li><strong>flonums</strong> (tagged with <tt class=
						    "ccode">flonum_type</tt>) are pointers to C <tt class=
												    "ccode">double</tt>s<br>
	<tt class="ccode">FD_FLONUMP(x)</tt> is <tt class="ccode">1</tt> if
	<var>x</var> is a flonum object;<br>
	<tt class="ccode">FD_LISPFLOAT(fl)</tt> returns a floating point
	object with value <var>fl</var>; <tt class=
					     "ccode">FD_FLOATLISP(x)</tt> returns the floating point value of
	<var>x</var> and <tt class="ccode">fd_lisp2float(x)</tt> does the
	same conversion together with a type check on <var>x</var></li>
      <li><strong>C records</strong> are C pointers tagged with a lisp
	object for type information; they are implemented by the <tt class=
								     "ccode">struct FD_RECORD</tt> structure;<br>
	<tt class="ccode">FD_RECORDP(x)</tt> is <tt class="ccode">1</tt> if
	<var>x</var> is a C record;<br>
	<tt class="ccode">FD_RECORD_TAG(x)</tt> returns the LISP object
	used as a type tag for <var>x</var>; <tt class=
						 "ccode">FD_RECORD_DATA(x)</tt> returns a <tt class="ccode">void
	  *</tt> pointer describing the data for <var>x</var>;<br>
	<tt class="ccode">fd_record_tag(x)</tt> returns the LISP object
	used as a type tag for <var>x</var>, signalling an error if
	<var>x</var> is not a record; <tt class=
					  "ccode">fd_record_data(x,type)</tt> returns a <tt class=
											    "ccode">void *</tt> pointer describing the data for <var>x</var>,
	but will signal an error if <var>x</var> is not a record with type
	tag <var>type</var>;<br>
	<tt class="ccode">fd_make_record(ltag,ptr)</tt> returns a C record
	with the tag <var>tag</var> and containing the pointer
	<var>ptr</var> (which should be of type <var>void *</var></li>
    </ul>
    <p><a name="composite" id="composite">The primary composite types
	are:</a></p>
    <ul>
      <li><strong>conses</strong> are pairs of two other pointers;<br>
	<tt class="ccode">FD_PAIRP(x)</tt> is <tt class="ccode">1</tt> if
	<var>x</var> is a pair;<br>
	<tt class="ccode">FD_MAKE_PAIR(x,y)</tt> makes a cons out of
	<var>x</var> and <var>y</var> (without <tt class=
						   "ccode">incref</tt>ing them); <tt class=
										     "ccode">fd_make_pair(x,y)</tt> does the same but increfs its
	arguments; <tt class="ccode">FD_MAKE_LIST1(elt)</tt> returns a list
	with one element <var>elt</var> (not incref'd);<br>
	<tt class="ccode">FD_CAR(x)</tt> will get <var>x</var> back,
	<tt class="ccode">FD_CDR(x)</tt> will be <var>y</var> back.
	<tt class="ccode">fd_car(x)</tt> and <tt class=
						 "ccode">fd_cdr(x)</tt> will do the same with type checking and an
	incref; <tt class="ccode">fd_car_noref</tt>, and <tt class=
							     "ccode">fd_cdr_noref</tt> do the type checking but not the
	incref<br>
	<tt class="ccode">fd_list_length(x)</tt> returns the number of
	elements in <var>x</var></li>
      <li><strong>vectors</strong> are composed of a fixed number of
	other pointers with a specific order;<br>
	<tt class="ccode">FD_VECTORP(x)</tt> is <tt class="ccode">1</tt> if
	<var>x</var> is a vector;<br>
	<tt class="ccode">FD_VECTOR_LENGTH(x)</tt> returns the number of
	elements in <var>x</var>; <tt class="ccode">FD_VECTOR_REF(x,i)</tt>
	returns the <var>i</var><sup>th</sup> element; <tt class=
							   "ccode">FD_VECTOR_SET(v,i,x)</tt> sets the
	<var>i</var><sup>th</sup> element of the vector <var>v</var> to
	<var>x</var>;<br>
	<tt class="ccode">fd_vector_length(x)</tt> and <tt class=
							   "ccode">fd_vector_ref(x,i)</tt> do type and bounds checking.</li>
      <li><strong>choices</strong> represent unordered sets of objects
	(pointers) and are used by the evaluator to implement
	non-deterministic evaluation and by the frame language to implement
	many-valued slots; technically, a regular lisp object is a
	<em>singular choice</em>, and most of the macros and functions
	below will do the right thing with regular objects. When a choice
	is non-singular and non-empty, it is represented by a pointer to a
	<tt class="ccode">struct FD_CHOICE</tt> structure<br>
	<tt class="ccode">FD_CHOICEP(x)</tt> is <tt class="ccode">1</tt> if
	<var>x</var> is a non-singular choice; <tt class=
						   "ccode">FD_CHOICE_SIZE(x)</tt> returns the number of elements in
	<var>x</var> and returns <tt class="ccode">1</tt> if <var>x</var>
	is not a choice and <tt class="ccode">0</tt> if <var>x</var> is the
	empty choice;<br>
	the macro <tt class="ccode">FD_ADD_TO_CHOICE(loc,x)</tt> adds a
	pointer to <var>x</var> to the choice stored in <var>loc</var>; for
	example, <tt class=
		     "ccode">FD_ADD_TO_CHOICE(answers,LISPFIX(3));</tt> adds the fixnum
	<tt class="ccode">3</tt> to the choice stored in the C variable
	<tt class="ccode">answers</tt>. Note that answers should have been
	initialized to some lisp pointer (typically the empty choice);<br>
	the macro pattern <tt class=
			      "ccode">FD_DO_CHOICES(x,choice)<var>body</var>END_FD_DO_CHOICES;</tt>
	iterates over the elements of a choice, processing for the next C
	statement for each element of <var>choice</var> and binding
	<var>x</var> to the element. Note that <tt class=
						   "ccode">FD_DO_CHOICES</tt> declares some internal variables, so it
	must occur before any non-declarations in a C block.<br>
	choices are internally divided into <em>proper choices</em> (which
	have no repeated elements) and <em>sorted choices</em> (which are
	sorted to optimize certain operations). The macros <tt class=
							       "ccode">FD_PROPER_CHOICEP(x)</tt> and <tt class=
													 "ccode">FD_SORTED_CHOICEP(x)</tt> check the manifest type of
	<var>x</var> (they don't actually check the data). The functions
	<tt class="ccode">fd_return_proper_choice(x)</tt> and <tt class=
								  "ccode">fd_return_sorted_choice(x)</tt> generate proper or sorted
	choices from <var>x</var> (they also may free their argument
	<var>x</var> and return a different pointer).</li>
      <li><strong>slotmaps</strong> represent sets of assocations between
	<em>keys</em> (typically symbols or OIDs) and lisp values; they are
	kept in a <tt class="ccode">struct FD_SLOTMAP</tt> structure<br>
	<tt class="ccode">FD_SLOTMAPP(x)</tt> is <tt class="ccode">1</tt>
	if <var>x</var> is a slotmap; <tt class=
					  "ccode">FD_SLOTMAP_PTR(x)</tt> returns a pointer to the slotmap
	structure used for <var>x</var><br>
	<tt class="ccode">SLOTMAP_SIZE(x)</tt> returns the number of
	associations in <var>x</var>; <tt class=
					  "ccode">FD_SLOTMAP_KEY(sm,i)</tt> returns the key for the
	<var>i</var><sup>th</sup> association; <tt class=
						   "ccode">FD_SLOTMAP_VALUE(sm,i)</tt> returns its value;<br>
	<tt class="ccode">fd_make_slotmap(size)</tt> makes a new slotmap
	with initial space for <var>size</var> associations; these
	assocations can be modified by several functions:
	<ul>
	  <li><tt class="ccode">fd_slotmap_set(sm,key,val)</tt> sets the
	    value associated with <var>key</var> in the slotmap <var>sm</var>
	    to <var>val</var>;</li>
	  <li><tt class="ccode">fd_slotmap_add(sm,key,val)</tt> adds
	    <var>val</var> to the values associated with <var>key</var> in the
	    slotmap <var>sm</var>;</li>
	  <li><tt class="ccode">fd_slotmap_get(sm,key,default)</tt> returns
	    the values associated with <var>key</var> in the slotmap
	    <var>sm</var>, or returns <var>default</var> if there are no
	    associations in <var>sm</var>;</li>
	  <li><tt class="ccode">fd_slotmap_test(sm,key,val)</tt> returns
	    <tt class="ccode">1</tt> if <var>val</var> is associated with
	    <var>key</var> in <var>sm</var>;</li>
	</ul>
	<p>there are other slotmap functions as well.</p>
      </li>
      <li><strong>lisp records</strong> are lisp objects tagged with type
	information represented by a LISP tag (which could be a symbol, a
	string, an OID, anything);<br>
	<tt class="ccode">FD_LRECORDP(x)</tt> is <tt class="ccode">1</tt>
	if <var>x</var> is a lisp record; <tt class=
					      "ccode">LRECORD_TAG(x)</tt> returns the lisp object being used to
	tag <var>x</var>; <tt class="ccode">FD_LRECORD_TAG(x)</tt> returns
	the lisp type tag of <var>x</var>.<br>
	<tt class="ccode">FD_LRECORD_DATA(x)</tt> returns the lisp data of
	<var>x</var>.<br>
	<tt class="ccode">FD_LRECORD_TYPEP(x,tag)</tt> is <tt class=
							      "ccode">1</tt> if the tag on <var>x</var> is <tt class=
													       "ccode">EQ?</tt> to <var>tag</var>.<br>
	<tt class="ccode">fd_lrecord_tag(x)</tt> returns the lisp object
	describing the type of <var>x</var> and signals an error if
	<var>x</var> is not an LRECORD.<br>
	<tt class="ccode">fd_lrecord_data(x,type)</tt> returns the lisp
	data for <var>x</var> but signals an error if <var>x</var> is not
	an LRECORD with type tag <var>type</var>.<br>
	<tt class="ccode">fd_make_record(ltag,ldata)</tt> returns a lisp
	record whose tag is <var>tag</var> and whose data is
	<var>data</var>.</li>
    </ul>
    <p><strong>Foreign types</strong> are reference counted C pointers.
      The pointer of a foreign type can be extracted by the macro
      <tt class="ccode">FD_CPTR_DATA(x)</tt>, and an object of foreign
      type is created by the function <tt class=
					  "ccode">fd_make_cptr(type,ptr)</tt> where <var>type</var> is one of
      the legal <tt class="ccode">fd_lisp_type</tt> values.</p>
    <p>This table lists the foreign types, the kind of pointer which
      <tt class="ccode">CPTR_DATA</tt>, and the chief file where that
      data structure is defined and used will return:</p>
    <table width="75%" border="2" cellpadding="5">
      <tr>
	<th>Type</th>
	<th>FD_CPTR_DATA is</th>
	<th>file(s)</th>
      </tr>
      <tr>
	<td>dtype_server_type</td>
	<td>struct FD_SERVER *</td>
	<td>src/eval/eval.c</td>
      </tr>
      <tr>
	<td>pool_type</td>
	<td>struct FD_POOL *</td>
	<td>src/odb/odb.c</td>
      </tr>
      <tr>
	<td>index_type</td>
	<td>struct FD_INDEX *</td>
	<td>src/index/index.c</td>
      </tr>
      <tr>
	<td>hashtable_type</td>
	<td>struct FD_HASHTABLE *</td>
	<td rowspan="2">src/cons/hash.c<br>
	  src/fdscript/hashprims.c</td>
      </tr>
      <tr>
	<td>hashset_type</td>
	<td>struct FD_HASHSET *</td>
      </tr>
      <tr>
	<td>input_file_type</td>
	<td>FILE *</td>
	<td rowspan="5">src/fdscript/ioprims.c</td>
      </tr>
      <tr>
	<td>output_file_type</td>
	<td>FILE *</td>
      </tr>
      <tr>
	<td>io_file_type</td>
	<td>FILE *</td>
      </tr>
      <tr>
	<td>input_string_type</td>
	<td>struct FD_STRING_ISTREAM *</td>
      </tr>
      <tr>
	<td>output_string_type</td>
	<td>struct FD_STRING_STREAM *</td>
      </tr>
      <tr>
	<td>mutex_type</td>
	<td>pthread_mutex_t *</td>
	<td>src/eval/threads.c</td>
      </tr>
      <tr>
	<td>mystery_type</td>
	<td>struct FD_MYSTERY *</td>
      </tr>
      <tr>
	<td>segmented_stream_type</td>
	<td>struct FD_MYSTERY *</td>
	<td rowspan="2">src/text/text.c</td>
      </tr>
      <tr>
	<td>record_stream_type</td>
	<td>struct FD_MYSTERY *</td>
      </tr>
      <tr>
	<td>tx_closure_type</td>
	<td>struct TX_CLOSURE *</td>
	<td>src/text/match.c</td>
      </tr>
    </table>
    <p><a name="evaltypes" id="evaltypes">In addition, a number of
	special `foreign' types are used by the evaluator; this table
	summarizes them. For the time being, if you have any questions,
	"Use the Source, Luke".</a></p>
    <table width="75%" border="2" cellpadding="5">
      <tr>
	<th>type</th>
	<td>FD_PTR_DATA is</td>
	<th>Description</th>
      </tr>
      <tr>
	<td>tail_call_type</td>
	<td>struct FD_VECTOR *</td>
	<td>Represents a partially evaluated expression, used to allow
	  constant-space tail recursion</td>
      </tr>
      <tr>
	<td>cproc_type</td>
	<td>struct FD_CPROC *</td>
	<td>a C primitive accessible from FDScript</td>
      </tr>
      <tr>
	<td>sproc_type</td>
	<td>struct FD_SPROC *</td>
	<td>a Scheme procedure definition, closed in a particular
	  environment</td>
      </tr>
      <tr>
	<td>ssproc_type</td>
	<td>struct FD_SSPROC *</td>
	<td>a "synchronized" scheme procedure, which is guaranteed to only
	  be running in any one thread at any one time</td>
      </tr>
      <tr>
	<td>continuation_type</td>
	<td>a FD_CPTR to a char *</td>
	<td>indicates a dynamic return point somewhere up the stack; the
	  continuation passing mechanism uses FramerD's native exception
	  handling to implement its upward continuations</td>
      </tr>
      <tr>
	<td>gproc_type</td>
	<td>struct FD_GPROC *</td>
	<td>a procedure which returns the empty choice when called
	  recursively on the same arguments; used for certain special sorts
	  of programming</td>
      </tr>
      <tr>
	<td>rproc_type</td>
	<td>struct FD_RPROC *</td>
	<td>a procedure which uses a remote server to get its value</td>
      </tr>
      <tr>
	<td>multiple_value_type</td>
	<td>struct FD_VECTOR *</td>
	<td>used to represent multiple values returned from a procedure;
	  note that these multiple values are different from
	  <em>choices</em></td>
      </tr>
      <tr>
	<td>delay_type</td>
	<td>struct FD_PAIR *</td>
	<td>a delayed value; the <tt class="ccode">CAR</tt> is the delay's
	  <em>thunk</em>, the <tt class="ccode">CDR</tt> is the value
	  returned by it and the thunk is freed after itis called.</td>
      </tr>
      <tr>
	<td>env_type</td>
	<td>struct FD_LISPENV *</td>
	<td>a pointer to an environment structure; when this structure has
	  a <tt class="ccode">-&gt;module</tt> field, it is a top level
	  module</td>
      </tr>
      <tr>
	<td>quoted_choice_type</td>
	<td>struct FD_CHOICE *</td>
	<td>This is used to temporarily suspend non-determinism when
	  passing an argument; a quoted choice is automatically unquoted
	  whenever it is passed to a primitive or bound to a variable</td>
      </tr>
    </table>
    <h1><a name="evalfcns" id="evalfcns">FDScript Evaluator
	Functions</a></h1>
    <dl>
      <dt><tt class=
	      "ccode">fd_add_cproc</tt>("fdscript-name",arity,c_procedure)</dt>
      <dd>Declares a new primitive in the scripting language with the
	name <i>"fdscript-name"</i>, implemented by <i>c_procedure</i>, and
	taking <i>arity</i>. Evaluating the expression <tt class=
							   "ccode">(fdscript-name <i>arg1</i> <i>arg2</i> ...)</tt> calls the
	<i>c_procedure</i> on the result of evaluating each of the
	arguments.</dd>
      <dt><tt class=
	      "ccode">fd_add_cform</tt>("fdscript-name",c_procedure)</dt>
      <dd>Declares a new special form in the scripting language with the
	name <i>"fdscript-name"</i>, implemented by <i>c_procedure</i>.
	Evaluating the expression <tt class="ccode">(fdscript-name
	  <i>arg1</i> <i>arg2</i> ...)</tt> calls the <i>c_procedure</i> on
	the entire expression without evaluating any arguments.</dd>
      <dt><tt class=
	      "ccode">fd_add_nary_cproc</tt>("fdscript-name",c_procedure)</dt>
      <dd>Declares a new primitive in the scripting language with the
	name <i>"fdscript-name"</i>, implemented by <i>c_procedure</i>, and
	taking any number of arguments. Evaluating the expression
	<tt class="ccode">(fdscript-name <i>arg1</i> <i>arg2</i> ...)</tt>
	calls the <i>c_procedure</i> on a list whose elements are the
	results of evaluating each <var>arg<sub>i</sub></var>. If the
	argument evaluations return non-deterministic values, the values
	are passed as elements of the list, rather than calling
	<var>c_procedure</var> repeatedly on each combination.</dd>
      <dt><tt class="ccode">fd_eval</tt>(expr)</dt>
      <dd>Evaluates an expression in this process.</dd>
      <dt><tt class="ccode">fd_eval_loop</tt>(input,output)</dt>
      <dd>Enters a read-eval-print loop going to a specified input and
	output stream.</dd>
      <dt><tt class="ccode">fd_get_arg</tt>(expr,arg_number,default)</dt>
      <dd>Given an expression, returns the arg_numberth element if it
	exists and the default otherwise. If the default value is
	<tt>FD_VOID</tt>, an error is signalled if the argument is not
	provided.</dd>
      <dt><tt class="ccode">fd_get_body</tt>(expr,offset)</dt>
      <dd>Given an expression, returns the sublist starting after the
	offset<sup>th</sup> element.</dd>
      <dt><tt class="ccode">fd_interactive_loop</tt>(input file
	stream,output file stream)</dt>
      <dd>Iteratively reads expressions from the input file stream (a
	FILE *), evaluates them, and outputs them to the output file
	stream.</dd>
      <dt><tt class="ccode">fd_load_init</tt>(filestring)</dt>
      <dd>Loads and evaluates a file of FDScript expressions.</dd>
    </dl>
    <h1><a name="modules" id="modules">Writing a Module</a></h1>
    <p>To write a C module to link FDScript with some existing library,
      take a look at the automatic code generator in <tt class=
							 "ccode">extras/c-bindings/cbind.fdx</tt>. Otherwise, this section
      offers a few pointers and you can look at <tt class=
						    "ccode">samples/c-modules/</tt> for example code.</p>
    <p>There are three basic kinds of primitives: cprocs, lexprs, and
      special forms. A cproc takes some fixed number of arguments, all of
      which are evaluated; a lexpr takes an arbitrary number of
      arguments, all of which are evaluted; a special form takes an
      expression and an environment and does whatever it pleases with
      it.</p>
    <p>Special forms are declared by the function <tt class=
						      "ccode">fd_add_special_form(env,"name",cproc)</tt> which defines a
      special form bound to the symbol <var>name</var> in <var>env</var>
      which will be handled by the C function <var>cproc</var>. The C
      function <var>cproc</var> should have the signature <tt class=
							      "ccode">lisp <var>cproc</var>(lisp expr,fd_lispenv env)</tt>.</p>
    <p>CPROCs are declared by the function <tt class=
					       "ccode">fd_add_cproc("name",n_args,cproc)</tt> which defines a
      CPROC that takes <var>n_args</var> arguments (surprise) and is
      handled by the C function <var>cproc</var>. The C function
      <var>cproc</var> should have the signature <tt class="ccode">lisp
	<var>cproc</var>(lisp arg1,lisp arg2,...)</tt>. The compiler will
      not warn you if the number of arguments doesn't match. This binds
      the symbol <var>name</var> to this primitive in the environment
      <var>env</var>.</p>
    <p>LEXPRs come in two flavors and are declared by the function
      <tt class="ccode">fd_add_lexpr("name",lexpr_type,cprc)</tt> where
      <var>lexpr_type</var> is either <tt class=
					  "ccode">NORMAL_LEXPR_ARGS</tt> or <tt class=
										"ccode">SPECIAL_LEXPR_ARGS</tt>. If the type is <tt class=
																    "ccode">NORMAL_LEXPR_ARGS</tt>, the evaluator will automatically
      enumerate any choices passed as arguments (so <var>cproc</var> may
      be called multiple times). Otherwise, <var>cproc</var> will only be
      called once, but the argument list it receives may contain
      non-singular <em>choices</em>. This binds the symbol
      <var>name</var> to this primitive in the environment
      <var>env</var>.</p>
    <p>A C module normally contains a series of <tt class=
						    "ccode">static</tt> functions which implement the primitives and an
      <em>initialization function</em> which calls the function
      <tt class="ccode">fd_make_module()</tt> to make an empty module
      (which has C type <tt class="ccode">fd_lispenv</tt>). It then makes
      a series of calls to <tt class="ccode">fd_add_cproc</tt> and its
      siblings to populate this environment with siblings. Finally, it
      calls the function <tt class=
			     "ccode">fd_register_module(name,env)</tt> on the module to bind
      <var>name</var> in the global environment to the module where a
      call to <tt class="ccode">USE-MODULE!</tt> can find it.
      (Alternatively, it can call the function <tt class=
						   "ccode">fd_register_restricted_module</tt> to bind the module in
      FDScript's `restricted environment'.)</p>
    <p>If the <var>env</var> argument to the <tt class=
						 "ccode">fd_add_</tt> functions is <tt class="ccode">NULL</tt>, the
      primitive is defined in the global environment. This will allow for
      faster accesses, but access cannot be restricted and there is a
      risk of name collisions.</p>
    <h1><a name="dirstructure" id="dirstructure">The Directories of
	FramerD</a></h1>
    <p>The top level of the FramerD directory tree (which you get when
      you unpack a source tarball or do a CVS checkout) is organized into
      multiple subdirectories show in <a href="#dirs">this table</a>.</p>
    <table width="75%" border="2" cellpadding="5">
      <caption>Top Level FramerD directory structure</caption>
      <tr>
	<td>src</td>
	<td>contains the source for the C libraries and executables; the
	  structure of these sources is described <a href=
						     "#sources">below</a>.</td>
      </tr>
      <tr>
	<td class="file">include/</td>
	<td>contains C header files used by the FramerD source files</td>
      </tr>
      <tr>
	<td class="file">include/framerd/</td>
	<td>contains C header files used by external FramerD libraries as
	  well as the FramerD source files</td>
      </tr>
      <tr>
	<td class="file">bin/</td>
	<td>is the directory into which executable files are compiled</td>
      </tr>
      <tr>
	<td class="file">lib/</td>
	<td>is the directory into which static and shared libraries are
	  compiled</td>
      </tr>
      <tr>
	<td class="file">etc/</td>
	<td>contains the Emacs Lisp (ELISP) interface to FramerD, the
	  FDScript installation scripts, and various shell scripts for server
	  management.</td>
      </tr>
      <tr>
	<td class="file">extras/</td>
	<td>contains subdirectories for various FDScript extension
	  libraries written in C. Each has its own makefile and produces
	  static and dynamic libraries</td>
      </tr>
      <tr>
	<td class="file">extras/c-bindings</td>
	<td>The file <tt>cbind.fdx</tt> implements a package which
	  automatically generates interfaces from FDScript to C libraries.
	  The individual `.fdx' files in this directory implement various
	  bindings for common libraries.</td>
      </tr>
      <tr>
	<td class="file">docs/</td>
	<td>contains documentation for FramerD in HTML, together with a
	  handful of <tt>.png</tt> format images.</td>
      </tr>
      <tr>
	<td class="file">tests/</td>
	<td>contains a FramerD test suites, including Aubrey Jaffer's R4RS
	  test suite, custom tests for FramerD itself, and regression tests
	  to catch the return of past bugs.</td>
      </tr>
      <tr>
	<td class="file">tests/gabriel</td>
	<td>contains Scheme versions of the Gabriel benchmarks for
	  evaluating FDScript performance</td>
      </tr>
      <tr>
	<td class="file">scripts/</td>
	<td>contains FDScript programs to be installed as command line
	  utilities. These utilities include pool and index maintenance
	  utilities as well as command line tools for browsing FramerD
	  databases.</td>
      </tr>
      <tr>
	<td class="file">samples/</td>
	<td>contains subdirectories of various collections of sample code
	  for servers, shell commands, web scripting, and email parsing</td>
      </tr>
    </table>
    <p>In addition, the top level directory contains configuration and
      make files (configure, configure.in, and makefile.in) as well as
      text files describing how to compile FramerD (<tt>BUILD</tt>), how
      to install it (<tt>INSTALL</tt>), news about changes
      (<tt>README</tt>), and a copy of the GNU General Public License
      (<tt>LICENSE</tt>).</p>
    <p>Conceptually, the FramerD sources can be divided into six
      modules, summarized in <a href="#sources">this table</a>. <a name=
								   "sources" id="sources"></a></p>
    <table width="75%" border="3" cellpadding="5">
      <caption>Structure of FramerD source modules</caption>
      <tr>
	<th>directories</th>
	<th>libraries</th>
	<th>Description</th>
	<th>header files</th>
      </tr>
      <tr>
	<td class="file">src/os</td>
	<td rowspan="2" class="file">libdtypes</td>
	<td>a system module provides for OS-independent
	  internationalization, environment access, and file system
	  operations</td>
	<td class="file">include/framerd/os.h<br>
	  include/framerd/except.h<br>
	  include/framerd/strstream.h</td>
      </tr>
      <tr>
	<td class="file">src/cons</td>
	<td>a data module provides the basic LISP data structures, printed
	  and binary object i/o, and some derived structures, including
	  hashtables and slotmaps</td>
	<td class="file">include/framerd/cons.h<br>
	  include/framerd/lisp.h</td>
      </tr>
      <tr>
	<td class="file">src/odb<br>
	  src/index<br>
	  src/eval</td>
	<td class="file">libframerd</td>
	<td>the FramerD core provides management for object (OID)
	  databases, persistent associative indices, and a minimal evaluator
	  for a subset of Scheme</td>
	<td class="file">include/framerd/odb.h<br>
	  include/framerd/index.h<br>
	  include/framerd/eval.h</td>
      </tr>
      <tr>
	<td class="file">src/scheme</td>
	<td rowspan="2" class="file">libfdscript</td>
	<td>the Scheme module provides most of the R5RS scheme functions,
	  including rational, complex, and arbitrary precision
	  arithmetic</td>
	<td>include/framerd/bignum.h<br>
	  include/framerd/bignmint.h</td>
      </tr>
      <tr>
	<td class="file">src/fdscript</td>
	<td>the FDScript module provides further advancec functions,
	  including operating system access, bindings for internal utilities
	  in the system, data and FramerD modules, formatted output, generic
	  sequences, and console interaction</td>
	<td>&nbsp;</td>
      </tr>
      <tr>
	<td class="file">src/text</td>
	<td class="file">libfdtext</td>
	<td>the text module provides pattern matching and parsing functions
	  for natural and artifical languages, especially intended for
	  implementing transducers between existing programs and databases
	  and FramerD.</td>
	<td class="file">include/framerd/fdtext.h</td>
      </tr>
      <tr>
	<td class="file">src/exe<br>
	  src/misc</td>
	<td class="file">&nbsp;</td>
	<td>the executables themsleves which are linked against the
	  libraries above; the directory <tt>src/misc</tt> contains code used
	  with the server and CGI executables. A description of the standard
	  executables can be found <a href="#executables">here</a></td>
	<td class="file">&nbsp;</td>
      </tr>
    </table>
    <p>The "standard executables" in FramerD are compiled from files in
      <tt>src/exe</tt>, linked against the above libraries. The server
      and web gateway executables are also linked together with the files
      <tt>src/misc/server.c</tt> and <tt>src/misc/cgiparse.c</tt>. These
      standard executables are summarized in <a href="#executables">this
	table</a>. <a name="executables" id="executables"></a></p>
    <table width="75%" border="2" cellpadding="5">
      <caption>Standard FramerD executables</caption>
      <tr>
	<td class="file">print-dtype</td>
	<td>prints and ASCII representation of a DTYPE stored in a
	  file</td>
      </tr>
      <tr>
	<td class="file">make-dtype</td>
	<td>makes a DTYPE in a file given an ASCII representation from the
	  command line</td>
      </tr>
      <tr>
	<td class="file">dtcall</td>
	<td>does a remote procedure call using the DType protocol.</td>
      </tr>
      <tr>
	<td class="file">pool-get</td>
	<td>prints the value of an OID in a pool</td>
      </tr>
      <tr>
	<td class="file">index-get</td>
	<td>prints the values associated with a key in an index</td>
      </tr>
      <tr>
	<td class="file">analyze-index</td>
	<td>analyzes and index file for hashing properties and
	  statistics</td>
      </tr>
      <tr>
	<td class="file">fdscript</td>
	<td>runs an FDScript interpreter, either interactively or on a
	  command file; this is used to implement command-line access to
	  FramerD databases</td>
      </tr>
      <tr>
	<td class="file">fdcgi</td>
	<td>runs an FDScript interpreter, intended to use with a web
	  server's <strong>common gateway interface</strong> to provide
	  WWW-hosted interaction with FramerD databases</td>
      </tr>
      <tr>
	<td class="file">fdserver</td>
	<td>starts a FramerD server on a specified port, which may provide
	  access to pools or indices in local files</td>
      </tr>
    </table>
    <h1><a name="files" id="files">The Files of FramerD</a></h1>
    <table width="75%" border="2" cellpadding="5">
      <tr>
	<td class="file"><a href=
			    "framerd-capi.html#except.c">src/cons/except.c</a></td>
	<td>implements basic exception handling based on the C runtime
	  <tt>setjmp</tt> and <tt>longjmp</tt></td>
      </tr>
      <tr>
	<td class="file"><a href=
			    "framerd-capi.html#data.c">src/cons/data.c</a></td>
	<td>implements data types such as lists and integers and the
	  facilities for implementing new datatypes in C</td>
      </tr>
      <tr>
	<td class="file"><a href=
			    "framerd-capi.html#hash.c">src/cons/hash.c</a></td>
	<td>interned datatypes (symbols and object identifiers (OIDs))
	  which rely on them</td>
      </tr>
      <tr>
	<td class="file"><a href=
			    "framerd-capi.html#xdata.c">src/cons/xdata.c</a></td>
	<td>datatypes, including vectors, slotmaps, bignums, unicode
	  strings, etc</td>
      </tr>
      <tr>
	<td class="file"><a href="framerd-capi.html#io.c">src/cons/io.c<br>
	    src/cons/dtio.c<br>
	    src/cons/txio.c</a></td>
	<td>implements the binary DTYPE format for transmitting data across
	  the network and storing it persistently in disk files; it is
	  included twice in the file <tt>io.c</tt> to implement I/O to and
	  form buffers in memory and I/O using the C stdio library.
	  <ul>
	    <li><tt>src/cons/io.c</tt> provides a wrapper for the binary DTYPE
	      functions as well as functions for producing and parsing printed
	      representations of objects. It also includes the functions for
	      getting miscellaneous enviromental information (including accessing
	      the WIN32 registry)</li>
	  </ul>
	</td>
      </tr>
      <tr>
	<td class="file"><a href=
			    "framerd-capi.html#network.c">src/os/network.c</a></td>
	<td>implements basic generic network access functions across
	  operating systems</td>
      </tr>
      <tr>
	<td class="file"><a href=
			    "framerd-capi.html#fdprintf.c">src/os/fdprintf.c</a></td>
	<td>with a <strong>printf</strong> syntax extended for the
	  presentation of lisp objects. Output can be either directed to
	  files or to the <em>string streams</em> used throughout FramerD.
	  This file also implements <em>exceptional i/o</em> facilities for
	  managing reports of unexpected events.</td>
      </tr>
      <tr>
	<td class="file"><a href=
			    "framerd-capi.html#i18n.c">src/os/i18n.c</a></td>
	<td>provides an OS independent layer for dealing with Unicode
	  strings and character set conversions</td>
      </tr>
      <tr>
	<td class="file"><a href=
			    "framerd-capi.html#envfns.c">src/os/envfns.c</a></td>
	<td>provides an OS independent layer for dealing with environment
	  queries, including time and system functions</td>
      </tr>
      <tr>
	<td class="file"><a href=
			    "framerd-capi.html#filefns.c">src/os/filefns.c</a></td>
	<td>provides an OS independent layer for dealing with file access
	  and information</td>
      </tr>
      <tr>
	<td class="file"><a href=
			    "framerd-capi.html#odb.c">src/odb/odb.c</a></td>
	<td>implements the object database which maps OIDs to their values,
	  whether stored in local files or remote servers; it also manages
	  the locking and unlocking of OIDs and the organization of OIDs into
	  disjoint <i>pools</i>.</td>
      </tr>
      <tr>
	<td class="file"><a href=
			    "framerd-capi.html#pools.c">src/odb/pools.c</a></td>
	<td>implements the management of the pools into which the object
	  address space is divided.</td>
      </tr>
      <tr>
	<td class="file"><a href=
			    "framerd-capi.html#file-pool.c">src/odb/file-pool.c</a></td>
	<td>implements access to subsets of the object database stored in
	  disk files, called <i>file pools</i></td>
      </tr>
      <tr>
	<td class="file"><a href=
			    "framerd-capi.html#network-pool.c">src/odb/network-pool.c</a></td>
	<td>implements access to subsets of the object database stored on
	  remote servers, called <i>network pools</i></td>
      </tr>
      <tr>
	<td class="file"><a href=
			    "framerd-capi.html#frames.c">src/odb/frames.c</a></td>
	<td>implements <strong>frames</strong> which are OIDs whose values
	  are slotmaps implementing an attribute value structure with the
	  possibility for complex inferences over some of their values.</td>
      </tr>
      <tr>
	<td class="file"><a href=
			    "framerd-capi.html#index.c">src/index/index.c</a></td>
	<td>implements access to persistent indices mapping Scheme objects
	  to each other and especially matching key objects to OIDs</td>
      </tr>
      <tr>
	<td class="file"><a href=
			    "framerd-capi.html#file-index.c">src/index/file-index.c</a></td>
	<td>implements access to on-disk hash tables as indices.</td>
      </tr>
      <tr>
	<td class="file"><a href=
			    "framerd-capi.html#network-index.c">src/index/network-index.c</a></td>
	<td>implements access remote DTYPE servers used as indices.</td>
      </tr>
      <tr>
	<td class="file"><a href=
			    "framerd-capi.html#search.c">src/index/search.c</a></td>
	<td>combines the frames implemented in the object database with the
	  indexing facility to do automatic or semi-automatic frame
	  indexing</td>
      </tr>
      <tr>
	<td class="file"><a href=
			    "framerd-capi.html#eval.c">src/eval/eval.c</a></td>
	<td>contains the evaluator kernel and a small set of evaluator
	  related functions.</td>
      </tr>
      <tr>
	<td class="file"><a href=
			    "framerd-capi.html#ndeval.c">src/eval/ndeval.c</a></td>
	<td>contains handlers for dealing with non-determinism in
	  evaluation and application</td>
      </tr>
      <tr>
	<td class="file"><a href=
			    "framerd-capi.html#mini.c">src/eval/mini.c</a></td>
	<td>contains basic core functions (no binding constructs) to be
	  used by FramerD inference methods</td>
      </tr>
      <tr>
	<td class="file"><a href=
			    "framerd-capi.html#lambda.c">src/eval/lambda.c</a></td>
	<td>implements environment structures and lambdas to support user
	  definitions.</td>
      </tr>
      <tr>
	<td class="file"><a href=
			    "framerd-capi.html#sandbox.c">src/eval/sandbox.c</a></td>
	<td>implements basic symbol level access in order to support
	  limited-capability interpreters for more secure FDScript
	  environments</td>
      </tr>
      <tr>
	<td class="file"><a href=
			    "framerd-capi.html#threads.c">src/eval/threads.c</a></td>
	<td>contains support for multi-threaded programming, including
	  mutexes and spawning new threads.</td>
      </tr>
      <tr>
	<td class="file"><a href=
			    "framerd-capi.html#load.c">src/eval/load.c</a></td>
	<td>implements procedures for loading disk files containing
	  FDScript code.</td>
      </tr>
      <tr>
	<td class="file"><a href=
			    "framerd-capi.html#arith.c">src/scheme/arith.c</a></td>
	<td>contains arithmetic primitives</td>
      </tr>
      <tr>
	<td class="file"><a href=
			    "framerd-capi.html#bignum.c">src/scheme/bignum.c</a></td>
	<td>contains the code for arbitrary precision integers, inherited
	  from MIT Scheme</td>
      </tr>
      <tr>
	<td class="file"><a href=
			    "framerd-capi.html#strings.c">src/scheme/strings.c</a></td>
	<td>contains special string manipulation primitives</td>
      </tr>
      <tr>
	<td class="file"><a href=
			    "framerd-capi.html#pairs.c">src/scheme/pairs.c</a></td>
	<td>contains special pair/list manipulation primitives</td>
      </tr>
      <tr>
	<td class="file"><a href=
			    "framerd-capi.html#characters.c">src/scheme/characters.c</a></td>
	<td>contains special character access and manipulation
	  primitives</td>
      </tr>
      <tr>
	<td class="file"><a href=
			    "framerd-capi.html#reflect.c">src/scheme/reflect.c</a></td>
	<td>contains forms for environment manipulation</td>
      </tr>
      <tr>
	<td class="file"><a href=
			    "framerd-capi.html#special.c">src/scheme/special.c</a></td>
	<td>contains Scheme and Common Lisp special forms</td>
      </tr>
      <tr>
	<td class="file"><a href=
			    "framerd-capi.html#cxr.c">src/scheme/cxr.c</a></td>
	<td>contains list access primitives of the form "C[AD]+R"</td>
      </tr>
      <tr>
	<td class="file"><a href=
			    "framerd-capi.html#ioprims.c">src/scheme/ioprims.c</a></td>
	<td>contains primitives for binary and character I/0, including the
	  R4RS I/0 primitives</td>
      </tr>
      <tr>
	<td class="file"><a href=
			    "framerd-capi.html#prims.c">src/fdscript/prims.c</a></td>
	<td>contains a miscellaneous primitives for FDScript</td>
      </tr>
      <tr>
	<td class="file"><a href=
			    "framerd-capi.html#printout.c">src/fdscript/printout.c</a></td>
	<td>implements the <tt>PRINTOUT</tt> facility for producing
	  formatted output.</td>
      </tr>
      <tr>
	<td class="file"><a href=
			    "framerd-capi.html#seq.c">src/fdscript/seq.c</a></td>
	<td>contains special sequence functions inherited from Common
	  Lisp</td>
      </tr>
      <tr>
	<td class="file"><a href=
			    "framerd-capi.html#osprims.c">src/fdscript/osprims.c</a></td>
	<td>contains primitives for operating system access</td>
      </tr>
      <tr>
	<td class="file"><a href=
			    "framerd-capi.html#framerd.c">src/fdscript/framerd.c</a></td>
	<td>contains primitives for accessing FramerD objects, frames,
	  pools, and indices</td>
      </tr>
      <tr>
	<td class="file"><a href=
			    "framerd-capi.html#maint.c">src/fdscript/maint.c</a></td>
	<td>contains primitives for maintaining FramerD pools and
	  indices</td>
      </tr>
      <tr>
	<td class="file"><a href=
			    "framerd-capi.html#hashprims.c">src/fdscript/hashprims.c</a></td>
	<td>contains primitives for using hashtables and hashsets</td>
      </tr>
    </table>
  </body>
</html>
