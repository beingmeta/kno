<!DOCTYPE html>
<html>
  <head>
    <meta name="generator" content=
	  "HTML Tidy for HTML5 for Linux version 4.9.27">
    <title>FramerD Concepts</title>
    <link rel="stylesheet" type="text/css" href=
	  "/static/framerd/documentation.css">
  </head>
  <body>
    <table align="left" width='100%'>
      <tr>
	<th class="bigtitle" align="left" width='70%'>FramerD Concepts<br>
	  <span class="author">Ken Haase</span></th>
	<th align="right" rowspan="2"><a href=
					 "http://www.framerd.org/"><img border="0" src=
									"fdlogo.png"></a></th>
      </tr>
    </table>
    <br clear="left">
    <p class="quickref">Quick ref: [<a href="#oids">OIDs and the Object
	Database</a>]&nbsp; [<a href="#indices">Persistent
	Indices</a>]&nbsp; [<a href="#frames">Frames in FramerD</a>]&nbsp;
      [<a href="#search">Searching for Frames</a>]&nbsp; [<a href=
							     "#dtypes">The DTYPE Protocol</a>]&nbsp;</p>
    <hr>
    <div class="section" id="architecture">
      <table class="header" width="100%" cellpadding="0">
	<tr>
	  <th class="title">Architecture</th>
	  <td class="gloss">FramerD has a layered architecture</td>
	</tr>
      </table>
    </div>
    <div class="section" id="oids">
      <table class="header" width="100%" cellpadding="0">
	<tr>
	  <th class="title">OIDs and the object database</th>
	  <td class="gloss">FramerD provides a simple object database which
	    associates numeric <strong>object identifers</strong> (OIDs) with
	    DType structures. DType structures can contain these object
	    identifiers so that one DType structure can point to the location
	    in the object database where another DType structure is
	    stored.</td>
	</tr>
      </table>
    </div>
    <p>One of the major components of FramerD is a distributed
      persistent object database. Objects in the database are designated
      by unique object identifiers or OIDs. The allocation of OIDs is
      managed so that different users, projects, or programs will not use
      the same OID for different purposes.</p>
    <p>An OID is a 64-bit address pointing into a virtual memory space
      whose locations are associated with complex structured objects.
      These objects can also contain pointers to other OIDs. The idea is
      that one program can associate an OID with a particular value (for
      instance, the integer <tt>3</tt> or the list <tt>("Three" THREE
	3)</tt>). Other programs can retrieve this value (or whatever value
      replaces it) by just knowing the OID to which it was assigned. OIDs
      can be included in other structures, written to files, and accessed
      through indices, so that application users need not typically worry
      about the exact numerical value of an OID.</p>
    <p>OID's numeric IDs are further organized into continuous ranges
      called <strong>pools</strong>. Pools are used to organize the
      storage and management of the values associated with OIDs. There
      are currently two kinds of pools: file pools are disk files
      containing DTYPE representations for the values associated with a
      particular range of OIDs; network pools are network servers using
      the DTYPE protocol which likewise provide access to a particular
      range of OIDs.</p>
    <h2>OID values</h2>
    <p>OIDs are associated with values which applications may access or
      modify. When an application makes changes to an OID's value, those
      changes are local to the application until they are
      <strong>committed</strong>, at which point they are saved to the
      appropriate file or network pool. When this occurs, the new value
      will be visible to other applications which request it.</p>
    <p>Access and revision control is managed by locking particular
      OIDs. When an application locks an OID, two things are guaranteed:
      that the value which the application sees for the OID is the latest
      value; and that the value will not be changed by any other
      application until either the OID is committed or it is unlocked.
      Locking of OIDs is normally invisible to applications. When an
      application sets an OID's value locally, it locks it. When the
      value is committed, it unlocks it.</p>
    <p>For file pools, locking any OID in the pool locks the entire
      pool; for network pools, OIDs are locked on an individual
      basis.</p>
    <p>Pools reflect both implementational and administrative
      properties: the values associated with the OIDs in a particular
      pool are generally provided by a particular file or server; the
      allocation of new OIDs and the modification of the value for
      existing OIDs is generally the responsibility of one administrative
      entity.</p>
    <h2>External Representations</h2>
    <p>OIDs have two different external representations. A <dfn>literal
	OID reference</dfn> has the form @hi/lo where hi is the high 32
      bits of the address and lo is the low 32 bits, both in hex. For
      example, an OID that looks like this <tt>@1/1b54e</tt> refers to
      the address <tt>0x000000010001b54e</tt>. A <dfn>logical OID
	reference</dfn> has the form
      <tt>@/<em>pool-id</em>/<em>offset</em></tt> and indicates an OID in
      a particular pool. Thus, the reference <tt>@/brico/1b54e</tt>
      refers to the same object shown above if the pool <tt>brico</tt>
      starts at <tt>@1/0</tt>. In addition, when the system can figure
      out a name for an OID, it appears after the @-expression
      identifying its address, e.g.:</p>
    <pre class="typescript">
      @/brico/1b54e"NOUN.COGNITION synset for example, illustration, instance, and representative"
      
    </pre>
    <p>to make it less cryptic to the user.</p>
    <p>The high 32 bits of an object identifer indicate the <dfn>super
	pool</dfn> of the OID. The OID above, for instance, is in the super
      pool <tt>0x1</tt>. The allocation of new object identifiers is
      based on the division of the 64 bit address space into smaller
      <strong>pools</strong>. The first such division is into super pools
      and subsequent divisions divide super pools into smaller chunks.
      Each chunk consists of 2<sup>i</sup> object identifiers.</p>
    <h2>Getting Pools, OIDs, and their values</h2>
    <blockquote>
      <div align="right"><em>The Lisp programmer knows the value of
	  everything but the cost of nothing.</em><br>
	Alan Perlis</div>
    </blockquote>
    <p>The FDScript procedure <tt>use-pool</tt> arranges for the
      current session to access a particular pool of OIDs. It's single
      argument is either a filename or a network specification of the
      sort used for remote evaluation (e.g. `brico@framerd.org'). Once
      <tt>use-pool</tt> has been called, the value of an OID in the pool
      can be extracted by the procedure <tt>OID-VALUE</tt> e.g.</p>
    <pre class="typescript">
      [fdscript] <strong>(USE-POOL "brico@framerd.org")</strong>
      [11:57:27 Session id=fdscript haase@eliza.media.mit.edu /OS:DIGITAL UNIX /Compiled:Feb 10 1997 /Started:Tue Feb 11 11:57:27 1997]
      [11:57:27 Added pool brico@framerd.org]
      [#POOL brico@framerd.org @1/0+1048576 {}]
      [fdscript] <strong>(OID-VALUE @1/33334)</strong>
      [SPELLING: "cause_to_tip" OBJ-NAME: "cause_to_tip" 
      SENSES: @/brico/32f96"VERB.MOTION synset for tip, cause_to_tip, and cause_to_tilt"
      RANKED-SENSES:
      (V 1 @/brico/32f96"VERB.MOTION synset for tip, cause_to_tip, and cause_to_tilt")]
      
    </pre>
    <p>One can use the procedure <tt>random-oid</tt> to pick a random
      OID from a pool, e.g.</p>
    <pre class="typescript">
      [fdscript] <strong>(RANDOM-OID (USE-POOL "brico@framerd.org"))</strong>
      @/brico/58e1"ADJ.ALL synset for functional"
      [fdscript] <strong>(RANDOM-OID (USE-POOL "brico@framerd.org"))</strong>
      @/brico/21a5e"alpha_particle"
      
    </pre>
    <p>Pools can be stored in variables and used as arguments, e.g.</p>
    <pre class="typescript">
      [fdscript] <strong>(define WORDNET (USE-POOL "brico@framerd.org"))</strong>
      [fdscript] <strong>(RANDOM-OID wordnet)</strong>
      @/brico/148d3"NOUN.ARTIFACT synset for stoup and stoop"
      
    </pre>
    <p>Also, procedures which expect pools as arguments (like
      <tt>ALLOCATE-OID</tt>) will also take strings and automatically
      interpret them as pool specifications), for example:</p>
    <pre class="typescript">
      [fdscript] <strong>(RANDOM-OID "brico@framerd.org")</strong>
      @/brico/1d9a7"NOUN.COMMUNICATION synset for hillbilly_music"
      
    </pre>
    <h2>Allocating and changing OIDs</h2>
    <p>The procedure <tt>ALLOCATE-OID</tt> returns an OID from a pool;
      pools can be either stored in files on disk or servers on a
      network. So we can say:</p>
    <pre class="typescript">
      [fdscript] <strong>(ALLOCATE-OID (USE-POOL "temp@framerd.org"))</strong>
      [11:59:57 Added pool temp@framerd.org]
      @/temp/40001
      
    </pre>
    <p>to allocate an OID in the network pool
      <tt>"temp@framerd.org"</tt>. (This pool is maintained for demo
      purposes at the Media Laboratory. Values stored in this pool are
      subject to erasure whenever our disk space gets tight). If we call
      ALLOCATE-OID again, we get a different oid:</p>
    <pre class="typescript">
      [fdscript] <strong>(ALLOCATE-OID (USE-POOL "temp@framerd.org"))</strong>
      @/temp/40002
      
    </pre>
    <p>When an OID is newly allocated it has no values assigned to it,
      E.G. a call to <tt>OID-VALUE</tt></p>
    <pre class="typescript">
      [fdscript] <strong>(OID-VALUE @/temp/40001)</strong>
      {}
      
    </pre>
    <p>fails by returning no results. One can set the value of an OID
      with the <tt>SET-OID-VALUE!</tt> procedure:</p>
    <pre class="typescript">
      (SET-OID-VALUE! @/temp/40001 "My first OID")
      
    </pre>
    <p>allowing us to get the value we put there:</p>
    <pre class="typescript">
      [fdscript] <strong>(OID-VALUE @a/40001)</strong>
      "My first OID"
      
    </pre>
    <h2>Saving and Reverting OID values</h2>
    <p>When you modify the value associated with an OID, the value is
      only changed locally until the changes are <em>committed</em> to
      the pool containing the object. There are three basic `commitment'
      procedures for OIDs and pools:</p>
    <dl compact>
      <dt><strong><tt><a name="COMMIT-OID" id="COMMIT-OID">(COMMIT-OID
	      <em>oid</em>)</a></tt></strong></dt>
      <dd>saves the changes associated with a particular OID.</dd>
      <dt><strong><tt><a name="COMMIT-POOL" id="COMMIT-POOL">(COMMIT-POOL
	      <em>pool</em>)</a></tt></strong></dt>
      <dd>saves all the changes to a particular pool;</dd>
      <dt><strong><tt><a name="COMMIT-POOLS" id=
			 "COMMIT-POOLS">(COMMIT-POOLS)</a></tt></strong></dt>
      <dd>saves all the changes to OIDs in the current session, and</dd>
    </dl>
    <p><font color="red"><strong>All changes are automatically
	  committed if your FDScript session exits normally (and lost if it
	  exits abnormally).</strong></font></p>
    <p>Not all OIDs can be changed or modified. If you change an OID in
      a file pool, the system attempts to lock the corresponding file
      before making the change. The file stays locked until your process
      exits or the file is explicitly unlocked. If you cannot lock the
      file --- because someone else has locked it or the file is
      read-only --- you cannot change the value associated with the OID
      stored in the file.</p>
    <p>If you change an OID in a network pool, the system attempts to
      lock the individual OID before making the change. If this succeeds,
      the local value for the OID is changed and the remote OID will be
      unlocked when your changes are committed. If this fails, (for
      instance, the network server will not permit you to lock the OID),
      the OID cannot be modified. A server might refuse to lock an OID
      because another user has locked the OID or because the OID is
      declared read-only.</p>
    <p>Before you've committed your changes, it is possible to back out
      of the changes by <em>reverting</em> the modifications:</p>
    <dl compact>
      <dt><strong><tt><a name="REVERT-OID" id="REVERT-OID">(REVERT-OID
	      <em>oid</em>)</a></tt></strong></dt>
      <dd>undoes your changes to the individual OID <em>oid</em>.</dd>
      <dt><strong><tt><a name="REVERT-POOL" id="REVERT-POOL">(REVERT-POOL
	      <em>pool</em>)</a></tt></strong></dt>
      <dd>undoes all the changes to OIDs in a particular pool</dd>
      <dt><strong><tt><a name="REVERT-POOLS" id=
			 "REVERT-POOLS">(REVERT-POOLS)</a></tt></strong></dt>
      <dd>undoes all the changes to OIDs in the current session that have
	not yet been committed.</dd>
    </dl>
    <p>Two caveats: remember that committed changes cannot be reverted
      in this way; also, only changes that directly affect the OID or its
      value can be reverted. If you store a pointer to an OID in a
      hashtable, for instance, reverting the OID will not remove the hash
      table entry.</p>
    <h2>Making file pools</h2>
    <p>The frames created above were allocated and stored on a
      demonstration server at MIT. Though the values might stay around
      for a few days, they are unlikely to last longer for administrative
      reasons. To create objects with more presistence, one has to either
      use <strong>file pools</strong> maintained in files on the local
      file system or use <strong>network pools</strong> maintained by
      oneself or others with more persistence. Actually, the network
      servers you would use will rely on pools maintained in files on
      their local file system, so eventually someone has to worry about
      how OIDs live on disk in file pools. Fortunately, dealing with file
      pools is straightforward.</p>
    <p>The procedure <tt>MAKE-FILE-POOL</tt> creates a file pool in the
      local file system, E.G.</p>
    <pre class="typescript">
      [fdscript] <strong>(MAKE-FILE-POOL "test.pool" 32)</strong>
      [#POOL test.pool @a/140000+0/32 {}]
      
    </pre>
    <p>creates a file pool containing 32 possible and no actual objects
      and and whose first object will be @a/140000. We can allocate that
      first object with <tt>allocate-oid</tt>:</p>
    <pre class="typescript">
      [fdscript] <strong>(allocate-oid "test.pool")</strong>
      @/test/0 ; <em>or @a/140000 if printed "literally"</em>
      
    </pre>
    <p>Creating a pool automatically causes the pool to be
      <em>used</em>, just as if you had called <tt>use-pool</tt> on the
      argument.</p>
    <p>The command-line program <tt>make-file-pool</tt> also creates
      file pools; it looks just like the FDScript call, but without the
      parentheses, e.g.</p>
    <pre class="typescript">
      sh% make-file-pool test.pool 32
      Created test.pool with space for 32 OIDs starting at @a/100
      
    </pre>
    <p>This command line program is written in and invokes FDScript,
      but it doesn't require that the user deal with the listener and
      associated parentheses. It also generates a message describing what
      it has done.</p>
    <div class="section" id="frames">
      <table class="header" width="100%" cellpadding="0">
	<tr>
	  <th class="title">Frames in FramerD</th>
	  <td class="gloss">Frames are at the heart of FramerD, providing a
	    way to build complex extensible descriptions and to share pointers
	    to these descriptions between different databases and
	    applications.</td>
	</tr>
      </table>
      <p>The word "frame" in FramerD comes from its support for frames, a
	popular AI representation model. A <dfn>frame</dfn> in FramerD is
	an OID whose value consists of a set of slots. Each slot consists
	of a <dfn>slotid</dfn> --- either a symbol or an OID --- and a set
	of values. Slots divide the description of objects into several
	labelled parts. For instance, the following frame from the FramerD
	port of WordNet represents the concept (synset) of an
	"example":</p>
      <pre class="typescript">
        SYNSET-ID:  3946824 <strong>[[[<em>Slot values may be numbers or strings.</em>]]]</strong>
        SYNSET-TYPE:  "n"
        WORDS: (4 values) <strong>[[[<em>A slot may have any number of values</em>]]]</strong>
        "representative"
        "instance"
        "illustration"
        "example"
        DESCRIPTION:  "a single item that is representative of a type"
        OBJ-NAME:  "NOUN.COGNITION synset for example, illustration, instance, and representative"
        SENSE:  NOUN.COGNITION
        HYPERNYM:  @/brico/b709"NOUN.COGNITION synset for information"
        HYPONYM: (5 values) <strong>[[[<em>The values can also be pointers to other frames</em>]]]</strong>
        @/brico/1b56e"NOUN.COGNITION synset for exception"
        @/brico/1b56f"NOUN.COGNITION synset for precedent and case_in_point"
        @/brico/1b570"NOUN.COGNITION synset for quintessence"
        @/brico/1b571"NOUN.COGNITION synset for sample"
        @/brico/1b572"NOUN.COGNITION synset for specimen"
        A:  @/brico/b709"NOUN.COGNITION synset for information"
        SYNSET-DEPTH:  4
        SYNSET-HEIGHT:  3
        SYNSET-TOTAL-HYPONYMS:  8
        SYNSET-TOTAL-BRANCHING:  2
        
      </pre>
      <p>The description above lists a number of <dfn>slots</dfn>, each
	of which associates a particular <dfn>slotid</dfn> (e.g.
	<tt>HYPERNYM</tt>) with a set of <dfn>slot values</dfn> (which are
	abitrary objects). This set of associations is called a
	<tt>slotmap</tt>. A <dfn>frame</dfn> is an OID whose value in the
	object database is a slotmap. Using OIDs allows different programs
	and databases to keep separate references to a frame while managing
	to share changes and augmentations.</p>
      <p>Operations on slots include getting their value(s), adding a
	value, removing a value, and checking whether they contain a
	particular value. The value may be non-deterministic (a choice), in
	which case we may refer to the <em>values</em> of the slot.</p>
      <p>When the slotid is a symbol, operations on the value of the slot
	are just operations on the slot's data. Getting the slot's value
	retrieves the slot data and adding a value to a slot adds an
	element to the slot's data (which is represented as a
	non-deterministic value). Except for this last point, frames whose
	slotids are symbols function much as property lists of symbols in
	languages like LISP or associative arrays in Perl. (From a
	computational standpoint, slotmaps are not a very efficient way to
	store large numbers of associations. For that, it is better to use
	a hashtable or an external index.)</p>
      <p>When the slotid is itself a frame (i.e. an OID whose value is a
	slotmap), operations on the slot are more complicated. Instead of
	just operating on the slot's data, operations evaluate methods for
	computing or testing for values, adding or removing elements, or
	checking that the given frames or values are correct. The methods
	are expressions in FDScript, the FramerD scripting language, which
	can access the variables frame, slotid, data, and value which
	contain the details of the particular slot and (when appropriate)
	the value being added, removed, or tested for. The expressions are
	stored in the following slots of the slotid:</p>
      <ul>
	<li><tt>GET-METHODS</tt> evaluated to get the value of the
	  slot</li>
	<li><tt>TEST-METHODS</tt> evaluated to determine whether or not the
	  slot has a particular value; the slot "has a value" whenever any of
	  these methods returnst true.</li>
	<li><tt>VALIDATE-METHODS</tt> evaluated whenever a value is added
	  to a slot; an error is signalled (and the value is not added)
	  whenever any of these methods returns false.</li>
	<li><tt>ADD-EFFECTS</tt> evaluated whenever a new value is added to
	  a slot</li>
	<li><tt>REMOVE-EFFECTS</tt> evaluated whenever a value is removed
	  from a slot</li>
      </ul>
      <p>Methods can operate on slots of the same or other frames and
	normally this simply invokes the corresponding methods, except when
	this is likely to recur infinitely. This can occur when the
	inference relations between slots are implicitly circular. For
	example, slots describing the width, height, and area of a
	rectangle might be defined in terms of one another. However, this
	could lead to an infinite recursion if, for instance, by the
	following path:</p>
      <ul>
	<li>To know the area of X, figure out the width and height of
	  X</li>
	<li>To know the width of X, figure out the area and height of
	  X</li>
	<li>To know the area of X, figure out the width and height of
	  X....</li>
      </ul>
      <p>To avoid this recursion, operations on a complex slots always
	check whether an identical operation (getting the same slot,
	adding, removing, or testing for the same value) is already being
	performed. If it is already being performed, the recursive
	operation either:</p>
      <ul>
	<li>returns the empty set (for getting a value)</li>
	<li>returns false (for testing for a value)</li>
	<li>does nothing (for adding or removing a value)</li>
      </ul>
      <p>This allows slots to freely refer to one another without concern
	for infinite recursion.</p>
      <h2>Getting at Frames from FDScript</h2>
      <p>The procedure <tt>FRAME-CREATE</tt> creates a frame and requires
	specifying a <var>pool</var> in which the frame's OID will be
	allocated. The value returned by <tt>FRAME-CREATE</tt> is this OID.
	If the pool argument is <tt>#f</tt> (false), a raw slotmap (rather
	than an OID whose value is a slotmap) is returned. All of the frame
	procedures will take a raw slotmap as an argument, but the unique
	identity of the slotmap will not be preserved between FramerD
	sessions.</p>
      <p><font size="-1">This is a subtle but important point. If you
	  save a raw slotmap, subsequent changes to the slotmap will not be
	  shared. If you save a frame (an OID whose value is a slotmap),
	  subsequent changes will be changed. In general, it is important to
	  use frames for descriptions which may persist beyond the current
	  session.</font></p>
      <p>In addition to the pool argument, <tt>frame-create</tt> takes a
	number of other arguments. If it is given one argument, it should
	be a slotmap to which the corresponding OID's value is initialized.
	If it is given more than one argument, they are intepreted as a
	series of slots and values initially assigned to the frame,
	e.g.</p>
      <pre class="typescript">
        [fdscript] (frame-create "temp@framerd.org"
        'obj-name "test" 'test-slot 'test-value
        'another-test-slot "another-value")
        @a/40010"test" ;&lt;- Prints out using the obj-name slot
        
      </pre>
      <p>the slot <tt>OBJ-NAME</tt> is used by FDScript when displaying
	the frame's OID, as you can see in the printed value above.</p>
      <p>The procedure <tt>FGET</tt> extracts a slot from a frame given a
	slotid, E.G.</p>
      <pre class="typescript">
        [fdscript] <strong>(fget @a/40010"test" 'test-slot)</strong>
        TEST-VALUE
        
      </pre>
      <p>When the slotid is a symbol, <tt>FGET</tt> simply retrieves
	whatever was initially or subsequently stored in the slot. The
	rules are different when the slotid is itself a frame, when certain
	inferences may happen, but we discuss that below.</p>
      <p>The procedure <tt>FADD!</tt> adds a new value to a frame for a
	given slotid, E.G.</p>
      <pre class="typescript">
        [fdscript] <strong>(fadd! @a/40010"test" 'test-slot 'another-value)</strong>
        [fdscript] <strong>(fget @a/40010"test" 'test-slot)</strong>
        {TEST-VALUE ANOTHER-VALUE}
        
      </pre>
      <p>A formatted description of a frame can be gotten with the
	procedure <tt>FDD</tt>:</p>
      <pre class="typescript">
        [fdscript] (FDD @a/40010)
        ---------------------------------------------------------------
        The frame @a/40010:
        OBJ-NAME:  "test"
        TEST-SLOT: (2 values)
        TEST-VALUE
        ANOTHER-VALUE
        ANOTHER-TEST-SLOT:  "another-value"
        @a/40010"test"
        
      </pre>
      <p>FDD is also a command line program with the same name, so you
	can do <tt>fdd</tt> (lowercase for Unix) at the shell.</p>
      <p>Since frames are OIDs, changes to frames are not permanent until
	either the session exits normally or the changes are explicitly
	committed. The procedures <tt>COMMIT-OID</tt>,
	<tt>COMMIT-POOL</tt>, and <tt>COMMIT-POOLS</tt> all work to save
	changes to frames and the additional procedure
	<tt>COMMIT-FRAME</tt> is just another name for
	<tt>COMMIT-OID</tt>.</p>
      <p>The procedure <tt>FRAME-SLOTS</tt> returns all the slotids
	associated with a frame, E.G.</p>
      <pre class="typescript">
        [fdscript] (frame-slots @a/40010)
        {obj-name test-slot another-test-slot}
        
      </pre>
      <p>For example, The following code converts a frame into an
	association list (i.e. a list of key value pairs):</p>
      <pre class="typescript">
        [fdscript] (define (get-alist-entry unit slotid)
        (cons slotid (set-&gt;list (frame-get unit slotid))))
        [fdscript] (define (frame-&gt;alist frame)
        (set-&gt;list (get-alist-entry frame (frame-slots frame))))
        (frame-&gt;alist @a/40010)
        ((ANOTHER-TEST-SLOT "another-value") 
        (TEST-SLOT ANOTHER-VALUE TEST-VALUE)
        (OBJ-NAME "test"))
        
      </pre>
      <h2>Inferences over slots</h2>
      <p>When a slotid is another frame, procedures like <tt>fget</tt>
	and <tt>fadd!</tt> act a little differently based on the slots of
	that frame. Each operation has a special slot associated with it
	and that slot contains a set of FDScript expressions which may be
	evaluated when the operation is performed:</p>
      <center>
	<table padding="5">
	  <tr>
	    <th>OPERATION</th>
	    <th>SLOT</th>
	    <th>VARIABLES BOUND</th>
	  </tr>
	  <tr>
	    <td>fget</td>
	    <td>GET-METHODS</td>
	    <td><tt><strong>frame, slotid, data</strong></tt></td>
	  </tr>
	  <tr>
	    <td>ftest</td>
	    <td>TEST-METHODS</td>
	    <td><strong><tt>frame, slotid, data, value</tt></strong></td>
	  </tr>
	  <tr>
	    <td>fadd!</td>
	    <td>ADD-EFFECTS</td>
	    <td><strong><tt>frame, slotid, data, value</tt></strong></td>
	  </tr>
	  <tr>
	    <td>fzap!</td>
	    <td>ZAP-EFFECTS</td>
	    <td><strong><tt>frame, slotid, data, value</tt></strong></td>
	  </tr>
	</table>
      </center>
      <p>when these values are evaluated, certain variables are
	bound:</p>
      <dl>
	<dt><tt>frame</tt></dt>
	<dd>is bound to the frame being operated upon</dd>
	<dt><tt>slotid</tt></dt>
	<dd>is bound to the slot being operated upon</dd>
	<dt><tt>data</tt></dt>
	<dd>is bound to primitive values associated with the slotid</dd>
	<dt><tt>value</tt></dt>
	<dd>is bound to the value being tested for, added, or removed</dd>
      </dl>
      <p>allowing the procedure to compute extra values, make additional
	changes, or notify users of changes. For instance, the following
	definition..</p>
      <pre class="typescript">
        [fdscript] (frame-create test-pool 
        'obj-name "n-hyponyms"
        'get-methods (set-size (GET frame 'hyponyms)))
        @1/3338"n-hyponyms"
        
      </pre>
      <p>so that we can ask:</p>
      <pre class="typescript">
        [fdscript] (fget @/brico/1b54e @/brico/3338"n-hyponyms")
        5
        
    </pre></div>
    <div class="section" id="indices">
      <table class="header" width="100%" cellpadding="0">
	<tr>
	  <th class="title">Persistent Indices</th>
	  <td class="gloss">Indices are a way of storing and manipulating
	    associations between objects and descriptions. They can be used to
	    go from words to their roots (e.g. "flew" to "fly") or from
	    features to findings (e.g. "BROTHER-OF Ken" to "Bruce"). FramerD's
	    indices are persistent <strong>incremental</strong> data structures
	    designed to support millions of keys.</td>
	</tr>
      </table>
      <h2>Indices are persistent</h2>
      <p class="first">The mappings described by an index are maintained
	outside of the application using the index. An application can
	change an index and those changes will be automatically available
	to later instantiations of the application or even of other
	applications. Changes are not visible at once, however; an
	application must explicitly <em>commit</em> its changes to make
	them persistent and shared.</p>
      <p>Because indices are persistent, they are typically used as
	resources by programs and may represent the accumulation of results
	from many computations and many different processes. A suite of
	applications may have a set of indices which they share and
	update.</p>
      <h2>Indices are demand-driven</h2>
      <p class="first">When an application uses an index, it normally
	only uses resources for a fraction of the index. The rest of the
	index is maintained --- on a remote server or in the file system
	--- for when it is needed. When neccessary, it goes to the server
	or file and retrieves the needed mappings. A quite small
	application can access a huge index through this method.</p>
      <p>FramerD has two sorts of built-in indices. File indices store
	mappings in a file on a local or remote disk and retrieve mappings
	by random access in the file. Network indices use a simple protocol
	to access DType servers which provide mappings to their clients.
	These two types are interchangable.</p>
      <h2>Indices are incremental</h2>
      <p class="first">Indices are designed to efficiently support
	incremental changes. In particular, it is supposed to be efficient
	to both add new values to existing keys and to add initial values
	to new keys. This makes index files useful for storing <em>inverted
	  indices</em> used in many information retrieval applications. It is
	also easy to get the <em>number</em> of values associated with a
	particular key, which is important for certain kinds of statistical
	retrieval algorithms.</p>
      <p>Indices also cache values in two directions. When an index goes
	to a file or server to get a mapping, it caches the result locally
	so that a subsequent request can proceed much faster. For this
	reason, some FramerD applications may speed up over time as they
	cache commonly referenced index keys.</p>
      <p>When an index is modified, the modifications are stored locally
	with the application making the modifications. Only when the index
	is <em>committed</em> do the changes go into the files on disk or
	across the network.</p>
      <h2>Indices can index objects</h2>
      <p class="first">Indices are the basis of a general object indexing
	facility. This uses the convention that keys of the form: <tt>(slot
	  . value)</tt> refer to frames whose <tt>slot</tt> contains
	<tt>value</tt>. For example, the key <tt>(year-of-birth .
	  1961)</tt> would be associated with all the frames whose
	<tt>year-of-birth</tt> slot was <tt>1961</tt>. These indices can be
	used to find frames with particular properties or combinations of
	properties as well as for more flexible "fuzzy" searches.</p>
      <h2>Using indices from FDScript</h2>
      <p>Indices are accessed by the function
	<strong><tt>USE-INDEX</tt></strong>:</p>
      <pre class="typescript">
        [fdscript] <strong>(USE-INDEX "/local/test-index")</strong>
        [#INDEX "/local/test-index"]
        
      </pre>
      <p>which can also take a network server specification, as in:</p>
      <pre class="typescript">
        [fdscript] <strong>(USE-INDEX "testi@somehost")</strong>
        [#INDEX "testi@somehost"]
        
      </pre>
      <p>The functions for accessing an index are just like the functions
	for accessing a hashtable:</p>
      <dl compact>
	<dt><strong><tt><a name="INDEX-GET" id="INDEX-GET">(INDEX-GET
		<var>index</var> <var>key</var>)</a></tt></strong></dt>
	<dd>gets the values associated with <var>key</var> in
	  <var>index</var>.</dd>
	<dt><strong><tt><a name="INDEX-ADD!" id="INDEX-ADD!">(INDEX-ADD!
		<var>index</var> <var>key</var>
		<var>new</var>)</a></tt></strong></dt>
	<dd>adds <var>new</var> to the values associated with
	  <var>key</var> in <var>index</var>.</dd>
	<dt><strong><tt><a name="INDEX-SET!" id="INDEX-SET!">(INDEX-SET!
		<var>index</var> <var>key</var>
		<var>new</var>)</a></tt></strong></dt>
	<dd>makes <var>new</var> be the only value associated with
	  <var>key</var> in <var>index</var></dd>
	<dt><strong><tt><a name="INDEX-ZAP!" id="INDEX-ZAP!">(INDEX-ZAP!
		<var>index</var> <var>key</var>)</a></tt></strong></dt>
	<dd>ensures that no values will be associated with <var>key</var>
	  in <var>index</var>.</dd>
	<dt><strong><tt><a name="INDEX-KEYS" id="INDEX-KEYS">(INDEX-KEYS
		<var>index</var>)</a></tt></strong></dt>
	<dd>returns all of the keys stored in an index.</dd>
      </dl>
      <p>Changes to indices are like changes to pools in that they need
	to be <strong>committed</strong> to be permanent. Changes are
	committed automatically if the FDScript session exits normally.
	Changes can also be committed manually:</p>
      <dl compact>
	<dt><strong><tt><a name="COMMIT-INDEX" id=
			   "COMMIT-INDEX">(COMMIT-INDEX
		<var>index</var>)</a></tt></strong></dt>
	<dd>saves the changes made all the keys in <var>index</var></dd>
	<dt><strong><tt><a name="COMMIT-INDICES" id=
			   "COMMIT-INDICES">(COMMIT-INDICES)</a></tt></strong></dt>
	<dd>saves the changes made to all the keys in all of the
	  indices</dd>
      </dl>
      <p>As with pools, changes to indices can be
	<var>reverted</var>:</p>
      <dl>
	<dt><strong><tt><a name="REVERT-INDEX" id=
			   "REVERT-INDEX">(REVERT-INDEX
		<var>index</var>)</a></tt></strong></dt>
	<dd>removes all the changes made to keys in <var>index</var>.</dd>
	<dt><strong><tt><a name="REVERT-INDICES" id=
			   "REVERT-INDICES">(REVERT-INDICES)</a></tt></strong></dt>
	<dd>removes all the changes made to keys in all indices.</dd>
      </dl>
      <p>As with pools, changes cannot be reverted once they are
	committed and reversion applies only to the associations in the
	index and not to other relations involving the keys or values.</p>
      <h2>File indices</h2>
      <p class="first">There are a number of special functions for
	dealing with file indices.</p>
      <dl compact>
	<dt><strong><tt><a name="make-file-index" id=
			   "make-file-index">(make-file-index <var>filename</var>
		<var>minsize</var>)</a></tt></strong></dt>
	<dd>Creates a new file index in the file <var>filename</var> that
	  contains at least <var>minsize</var> slots. Note that file indices
	  have a fixed size and need to be explicitly grown using maintenance
	  tools built into FDScript or available from the command prompt.
	  This is because growing a file index with millions of keys can be
	  very time consuming and couldn't be "transparent" even if you
	  wanted it to be. <a name="cache-index" id="cache-index"></a></dd>
	<dt><strong><tt>(cache-index <var>index</var>)</tt></strong></dt>
	<dd>When <var>index</var> is a file index, this keeps a copy of the
	  files offset table in memory, which improves access time by
	  avoiding one disk seek. This is especially useful when disk seeks
	  are particularly slow (for instance with CD-ROM drives).</dd>
	<dt><strong><tt><a name="auto-cache-file-indices" id=
			   "auto-cache-file-indices">(auto-cache-file-indices)</a></tt></strong></dt>
	<dd>Arranges for file indices to be automatically cached when
	  referenced. This is a good idea for programs which do a lot of
	  index accesses or for speed when the index file is on a slow device
	  (such as a CD-ROM or network disk).</dd>
      </dl>
      <p>In addition, there are several command line utilities for
	dealing with file indices:</p>
      <dl compact>
	<dt><tt>make-file-index <var>filename</var>
	    <var>minsize</var></tt></dt>
	<dd>Creates a file index with (at least) a particular size.</dd>
	<dt><tt>analyze-index <var>filename</var> --keys | --values |
	    --stats</tt></dt>
	<dd>Returns information about the index file in
	  <var>filename</var>. The options can be combined and have the
	  following interpretation:
	  <ul>
	    <li><tt>--stats</tt> reports hashtable statistics (number of keys,
	      average and max misses per key, most common keys, etc)</li>
	    <li><tt>--keys</tt> lists all of the keys with the number of values
	      for each</li>
	    <li><tt>--values</tt> lists all of the values</li>
	  </ul>
	  With no arguments, <tt>analyze-index</tt> simply prints the number
	  of slots in the index.</dd>
      </dl>
      <p>File indices have standard sizes at roughly powers of 2 and user
	specified sizes are rounded up to the nearest standard size.</p>
    </div>
    <div class="section" id="search">
      <table class="header" width="100%" cellpadding="0">
	<tr>
	  <th class="title">Searching for Frames</th>
	  <td class="gloss">FramerD builds an object indexing facility on top
	    of the general association facility described above.
	    <dfn>Indexing</dfn> a frame stores inverse pointers from its
	    properties to the frame. This allows the frame to be found later
	    based on a set of properties or to find objects similar (i.e. with
	    common properties) to one particular frame.</td>
	</tr>
      </table>
      <p>FramerD builds an object indexing facility on top of the general
	association facility described above. <dfn>Indexing</dfn> a frame
	stores inverse pointers from its properties to the frame. This
	allows the frame to be found later based on a set of properties or
	to find objects similar (i.e. with common properties) to one
	particular frame.</p>
      <p>There are three main ways of indexing frames:</p>
      <dl compact>
	<dt><strong><tt><a name="index-frame" id="index-frame">(index-frame
		<em>index</em> <em>frame</em>)</a></tt></strong></dt>
	<dd>Indexes all the properties actually stored on <em>frame</em> in
	  <em>index</em>.</dd>
	<dt><strong><tt>(index-frame <em>index</em> <em>frame</em>
	      <em>slot1</em> <em>slot2</em>...
	      <em>slot<sub>n</sub></em>)</tt></strong></dt>
	<dd>Indexes all the specified slots (<em>slot1</em>,
	  <em>slot2</em>, through <em>slot<sub>n</sub></em>) on frame. If
	  some of the slots are frames, they may be computed even if they
	  aren't actually stored on <em>frame</em>.</dd>
	<dt><strong><tt><a name="index-slot-value" id=
			   "index-slot-value">(index-slot-value <em>index</em> <em>frame</em>
		<em>slot</em> <em>value</em>)</a></tt></strong></dt>
	<dd>Indexes frame as having SLOT with VALUE (whether it does or
	  not).</dd>
      </dl>
      <p>Once a frame has been indexed, one can search for it either
	strictly --- based on certain combinations of slots and values ---
	or "fuzzily" based on similarity to an instance or set of
	instances.</p>
      <h2>Strict Searching</h2>
      <div align="right"><em>I'll have the french onion soup, without the
	  cheese on top,<br>
	  the green salad with honey-mustard dressing on the side,<br>
	  and a decaffeinated coffee with one sugar.</em><br>
	Sally, in <strong>When Harry Met Sally</strong></div>
      <p>Strict searching uses the <em>FIND-FRAMES</em> procedure:</p>
      <pre class="typescript">
        (find-frames <em>index</em> 
        <em>slot<sub>1</sub></em> <em>value<sub>1</sub></em>
        ... <em>slot<sub>n</sub></em> <em>value<sub>n</sub></em>)
        
      </pre>
      <p>which finds all objects that have all the specified slots and
	values. If any of the <em>value<sub>i</sub></em> are
	non-deterministic sets, the slot need only have one of the
	specified values, allowing some variations. For example, in the
	WordNet database, the expression:</p>
      <pre class="typescript">
        [fdscript] <strong>(find-frames "brico@framerd.org" 'words {"hack" "chop"})</strong>
        {@1/31813"VERB.COMPETITION synset for hack and kick_on_the_arm" 
        @1/151a5"NOUN.ARTIFACT synset for cab, hack, taxi, and taxicab" 
        @1/316ff"VERB.COMPETITION synset for chop and hit_sharply" 
        @1/23e1b"NOUN.PERSON synset for machine_politician, ward-heeler, political_hack, and hack" 
        @1/321a4"VERB.CONTACT synset for chop and strike_sharply" 
        @1/303a5"VERB.CHANGE synset for hack and hack_on" 
        @1/1299a"NOUN.ANIMAL synset for hack, jade, nag, and plug" 
        @1/cdc6"NOUN.ACT synset for chop and chop_shot" 
        @1/31c45"VERB.CONTACT synset for hack and clear" 
        @1/20578"NOUN.PERSON synset for hack, hack_writer, and literary_hack" 
        @1/31c3d"VERB.CONTACT synset for chop and hack" 
        @1/2ee62"VERB.BODY synset for hack and whoop" 
        @1/32cfe"VERB.MOTION synset for chop and move_suddenly" 
        @1/31812"VERB.COMPETITION synset for hack and kick_on_the_shins" 
        @1/129cd"NOUN.ANIMAL synset for hack" 
        @1/1ed62"NOUN.FOOD synset for chop" 
        @1/2262a"NOUN.PERSON synset for hack, drudge, and hacker" 
        @1/31c3f"VERB.CONTACT synset for chop, chop_up, and cut_into_pieces" 
        @1/2f7e3"VERB.CHANGE synset for hack and cut_up" 
        @1/12999"NOUN.ANIMAL synset for hack" 
        @1/bc17"NOUN.ACT synset for chop and chopper"}
        
      </pre>
      <p>finds all the synsets containing either the words "hack" or
	"chop", while</p>
      <pre class="typescript">
        [fdscript] (find-frames "brico@framerd.org" 'words "hack" 'words "chop")
        @1/31c3d"VERB.CONTACT synset for chop and hack"
        
      </pre>
      <p>finds only the synsets containing both the words "hack" and
	"chop". One way to think about this visually, is the search
	performed by <tt>find-frames</tt> is conjunctive horizontally
	(along the list of arguments) and disjunctive vertically (within
	each argument).</p>
      <h2>Fuzzy Searching</h2>
      <div align="right"><em>I'll have a burger with fries and a
	  chocolate shake.</em><br>
	Harry in <strong>When Harry met Sally</strong></div>
      <p>A fuzzy search does not require an exact match, but returns the
	best possible match measured by the number of overlapping
	properties. There are a variety of fuzzy search functions as well
	as a set of tools for writing your own fuzzy search routines. The
	chief function find-best, looks just like find-frames:</p>
      <pre class="typescript">
        (find-frames <em>index</em> 
        <em>slot<sub>1</sub></em> <em>value<sub>1</sub></em>
        ... <em>slot<sub>n</sub></em> <em>value<sub>n</sub></em>)
        
      </pre>
      <p>but returns those objects with the largest number of matching
	properties.</p>
      <h2>Similarity Searching</h2>
      <div align="right"><em>I'll have what she's having.</em><br>
	from <strong>When Harry Met Sally</strong></div>
      <p>One of the most powerful search mechanisms in FramerD and
	FDscript is "similarity searching" which begins with an object or
	set of objects and finds objects which have the same properties as
	those objects, weighting as higher those which are more in common
	among the set of initial descriptions.</p>
      <dl>
	<dt><strong><tt><a name="find-similar" id=
			   "find-similar">(find-similar <em>indices</em>
		<em>frame</em>)</a></tt></strong></dt>
	<dd>Returns the frames indexed in <em>indices</em> which have the
	  most number of slot values in common with <em>frame</em>.</dd>
	<dt><strong><tt><a name="find-similar" id=
			   "find-similar">(find-similar <em>indices</em>
		<em>frame</em><em>slots</em>)</a></tt></strong></dt>
	<dd>limits the search for similarity to <em>slots</em>. Returns the
	  frames indexed in <em>indices</em> which have the most number of
	  slot values in common with <em>frame</em>.</dd>
      </dl>
      <p>For example, the following search finds words with similar
	meanings to the common sense of "hack" and "chop":</p>
      <pre class="typescript">
        [fdscript] (find-similar "brico@framerd.org"
        @1/31c3d"VERB.CONTACT synset for chop and hack")
        {@1/31be9"VERB.CONTACT synset for shave, trim, and cut_closely" 
        @1/31c3f"VERB.CONTACT synset for chop, chop_up, and cut_into_pieces" 
        @1/31e95"VERB.CONTACT synset for mow and cut_down" 
        @1/325d4"VERB.CONTACT synset for rebate and cut_a_rebate_in" 
        @1/325d7"VERB.CONTACT synset for saw and cut_with_a_saw"}
        
      </pre>
      <strong>Fuzzy searching and non-determinism.</strong> When the
      <em>frame</em> argument to <tt>find-similar</tt> is
      non-deterministic, the search mechanism does a single search but
      uses features from each of the frames in combination. As a
      consequence, the search weighs properties common between the frames
      more heavily. For example, in this retrieval,
      <pre class="typescript">
        [fdscript] (find-similar "brico@framerd" 
        (amb @1/31c3f"VERB.CONTACT synset for chop, chop_up, and cut_into_pieces" 
        @1/31e95"VERB.CONTACT synset for mow and cut_down"))
	@1/31c3d"VERB.CONTACT synset for chop and hack"
      </pre>
      <p>the properties common to the two synsets selects the search
	pattern which put them together in the first place.</p>
    </div>
    <div class="section" id="dtypes">
      <table class="header" width="100%" cellpadding="0">
	<tr>
	  <th class="title">The DTYPE Protocol</th>
	  <td class="gloss">DTypes are a binary data format and
	    communications protocol underlying FramerD. DTypes allow the
	    storage and transmission of complex recursively structured objects.
	    DTypes can be extended to encode application-specific data while
	    still using generic facilities for storage and search.</td>
	</tr>
      </table>
      <hr>
      <p>DTypes are a portable data representation used throughout the
	FramerD suite of libraries, tools, and applications. There are two
	basic levels to the DType representation: a minimal set of "core
	data types" and an extensible external binary representation for
	those types and their extensions. Applications and libraries use
	and extend the native data types, taking advantage of
	communication, persistence, and indexing facilities which use the
	external representation.</p>
      <p>DTypes differ from other data sharing approaches in not
	depending on explicit data declarations for sharing complex
	structures. Distributed processing models like CORBA rely on shared
	data declarations for communicating complex data structures. DTypes
	allow a `sloppier' approach where basic data types include nested
	and labelled heterogenous structures. This allows for fast
	prototyping of applications and protocols as well as their on-line
	extension.</p>
      <p>The minimal set of native types include fixed and floating point
	numbers, ASCII strings and symbols, vectors and pair structures. It
	also includes some special types, especially the OID (Object
	IDentifier) pointers used by the FramerD object database. The
	external binary representation is used in three primary ways:</p>
      <ul>
	<li>in communicating among clients and servers using a remote
	  procedure call protocol;</li>
	<li>in storing the values associated global "Object IDentifiers"
	  (OIDs) by FramerD's <a href="odb.html">object database</a>;</li>
	<li>in associating structured objects to one another through
	  <a href="indices.html">FramerD indices</a>.</li>
      </ul>
      <p>The DType core representation includes the following types:</p>
      <ul>
	<li>literal constants for truth, falsity, the empty list, and a
	  void value</li>
	<li>small signed integers (32 bits)</li>
	<li>limited precision floating point numbers (again, 32 bits)</li>
	<li>ASCII strings</li>
	<li>Symbols ("interned" ascii strings)</li>
	<li>Pairs (of any two other types, which can be composed into
	  lists)</li>
	<li>Vectors (of any mixture of types)</li>
	<li>Packets (arbitrary vectors of bytes)</li>
	<li>OIDs (object identifiers) identifying in a virtual 64-bit
	  address space</li>
	<li>Exceptions and Errors (representing unusual conditions)</li>
      </ul>
      <p>Native applications can provide their own types and use FramerD
	storage and indexing facilities by implementing extensions to the
	external binary representation for their types. These extensions
	can either be in the form of compounds or package types.</p>
      <p>A compound representation consists of a type name (a tag) and a
	"canonical form" which can be used to identify and regenerate the
	object. Logically, neither the tag nor the the canonical form can
	include the object being described or else the translation would
	recur indefinitely.</p>
      <p>A packaged representation consists of a two byte type code
	followed by 1 or 4 bytes of size information and some amount of
	additional data. The value of the first byte identifies a "package"
	for the extension; the value of the second byte (which is defined
	by the package maintainer) specifies a more precise type code and
	also specifies the format of the subsequent data in a fashion which
	FramerD facilities can manipulate without interpreting.</p>
      <p>The core FramerD libraries introduce new datatypes with packaged
	data representations for:</p>
      <ul>
	<li><strong>choices</strong> used to represent unordered sets of
	  alternative results and values</li>
	<li><strong>slotmaps</strong> providing simple associations between
	  keys and values</li>
	<li>various <strong>numerical types</strong>, including:
	  <ul>
	    <li>arbitrary precision integers</li>
	    <li>rational numbers</li>
	    <li>complex numbers</li>
	  </ul>
	</li>
	<li>extended <strong>character types</strong>, including:
	  <ul>
	    <li>unicode and ascii characters</li>
	    <li>unicode strings</li>
	    <li>unicode symbols (interned unicode strings)</li>
	  </ul>
	</li>
      </ul>
    </div>
  </body>
</html>
