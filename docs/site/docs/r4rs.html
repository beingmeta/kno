<HTML>
<HEAD>
<!-- This HTML file has been created by texi2html 1.39
     from r4rs.texi on 21 Febuary 1996 -->

<TITLE>Scheme</TITLE>
</HEAD>
<BODY bgcolor="FFFFFF">
<H1>Scheme</H1>


<H1><A NAME="SEC1" HREF="r4rs_toc.html#SEC1">Summary</A></H1>

<P>
The report gives a defining description of the programming language
Scheme.  Scheme is a statically scoped and properly tail-recursive
dialect of the Lisp programming language invented by
Guy Lewis Steele Jr. and Gerald Jay Sussman.  It was designed
to have an
exceptionally clear and simple semantics and few different ways to
form expressions.  A wide variety of programming paradigms, including
imperative, functional, and message passing styles, find convenient
expression in Scheme.

</P>
<P>
The introduction offers a brief history of the language and of
the report.

</P>
<P>
The first three chapters present the fundamental ideas of the
language and describe the notational conventions used for describing the
language and for writing programs in the language.

</P>
<P>
section <A HREF="r4rs.html#SEC25">Expressions</A> and section <A HREF="r4rs.html#SEC40">Program structure</A> describe
the syntax and semantics of expressions, programs, and definitions.

</P>
<P>
section <A HREF="r4rs.html#SEC45">Standard procedures</A> describes Scheme's built-in
procedures, which include all of the language's data manipulation and
input/output primitives.

</P>
<P>
section <A HREF="r4rs.html#SEC66">Formal syntax and semantics</A> provides a formal syntax for Scheme
written in extended BNF, along with a formal denotational semantics.
An example of the use of the language follows the formal syntax and
semantics.

</P>
<P>
The appendix describes a macro facility that may be used to
extend the syntax of Scheme.

</P>
<P>
The report concludes with a bibliography and an alphabetic index.

</P>



<H1><A NAME="SEC2" HREF="r4rs_toc.html#SEC2">Introduction</A></H1>



<H2><A NAME="SEC3" HREF="r4rs_toc.html#SEC3">History</A></H2>

<P>
Programming languages should be designed not by piling feature on top of
feature, but by removing the weaknesses and restrictions that make additional
features appear necessary.  Scheme demonstrates that a very small number
of rules for forming expressions, with no restrictions on how they are
composed, suffice to form a practical and efficient programming language
that is flexible enough to support most of the major programming
paradigms in use today.

</P>
<P>
Scheme
was one of the first programming languages to incorporate first class
procedures as in the lambda calculus, thereby proving the usefulness of
static scope rules and block structure in a dynamically typed language.
Scheme was the first major dialect of Lisp to distinguish procedures
from lambda expressions and symbols, to use a single lexical
environment for all variables, and to evaluate the operator position
of a procedure call in the same way as an operand position.  By relying
entirely on procedure calls to express iteration, Scheme emphasized the
fact that tail-recursive procedure calls are essentially goto's that
pass arguments.  Scheme was the first widely used programming language to
embrace first class escape procedures, from which all previously known
sequential control structures can be synthesized.  More recently, building
upon the design of generic arithmetic in Common Lisp, Scheme introduced
the concept of exact and inexact numbers.
With the appendix to this report Scheme becomes the first programming
language to support hygienic macros, which permit the syntax of a
block-structured language to be extended reliably.

</P>



<H2><A NAME="SEC4" HREF="r4rs_toc.html#SEC4">Background</A></H2>

<P>
The first description of Scheme was written in
1975 [SCHEME75].  A revised report [SCHEME78]
appeared in 1978, which described the evolution
of the language as its MIT implementation was upgraded to support an
innovative compiler [RABBIT].  Three distinct projects began in
1981 and 1982 to use variants of Scheme for courses at MIT, Yale, and
Indiana University [REES82] [MITSCHEME] [SCHEME311].  An
introductory computer science textbook using Scheme was published in
1984 <A HREF="r4rs.html#BIB2">[SICP]</A>.

</P>
<P>
As Scheme became more widespread,
local dialects began to diverge until students and researchers
occasionally found it difficult to understand code written at other
sites.
Fifteen representatives of the major implementations of Scheme therefore
met in October 1984 to work toward a better and more widely accepted
standard for Scheme.

</P>
<P>
Their report <A HREF="r4rs.html#BIB8">[RRRS]</A>
was published at MIT and Indiana University in the summer of 1985.
Another round of revision took place in the spring of 1986 <A HREF="r4rs.html#BIB68">[R3RS]</A>.
The present report reflects further revisions agreed upon in a meeting
that preceded the 1988 ACM Conference on Lisp and Functional Programming
and in subsequent electronic mail.

</P>

<P>

<P>
We intend this report to belong to the entire Scheme community, and so
we grant permission to copy it in whole or in part without fee.  In
particular, we encourage implementors of Scheme to use this report as
a starting point for manuals and other documentation, modifying it as
necessary.

</P>


<H2><A NAME="SEC5" HREF="r4rs_toc.html#SEC5">Acknowledgements</A></H2>

<P>
We would like to thank the following people for their help: Alan Bawden, Michael
Blair, George Carrette, Andy Cromarty, Pavel Curtis, Jeff Dalton, Olivier Danvy,
Ken Dickey, Andy Freeman, Richard Gabriel, Yekta G\"ursel, Ken Haase, Robert
Hieb, Paul Hudak,
Richard Kelsey, Morry Katz, Chris Lindblad, Mark Meyer, Jim Miller, Jim Philbin,
John Ramsdell, Mike Shaff, Jonathan Shapiro, Julie Sussman,
Perry Wagle, Daniel Weise, Henry Wu, and Ozan Yigit.
We thank Carol Fessenden, Daniel
Friedman, and Christopher Haynes for permission to use text from the Scheme 311
version 4 reference manual.  We thank Texas Instruments, Inc. for permission to
use text from the <EM>TI Scheme Language Reference Manual.</EM> We gladly
acknowledge the influence of manuals for MIT Scheme, T, Scheme 84,
Common Lisp, and Algol 60.

</P>
<P>
We also thank Betty Dexter for the extreme effort she put into
setting this report in TeX, and Donald Knuth for designing the program
that caused her troubles.

</P>
<P>
The Artificial Intelligence Laboratory of the
Massachusetts Institute of Technology, the Computer Science
Department of Indiana University, and the Computer and Information
Sciences Department of the University of Oregon supported the
preparation of this report.  Support for the MIT work was provided in part by
the Advanced Research Projects Agency of the Department of Defense under Office
of Naval Research contract N00014-80-C-0505.  Support for the Indiana
University work was provided by NSF grants NCS 83-04567 and NCS
83-03325.

</P>



<H1><A NAME="SEC6" HREF="r4rs_toc.html#SEC6">Overview of Scheme</A></H1>



<H2><A NAME="SEC7" HREF="r4rs_toc.html#SEC7">Semantics</A></H2>

<P>
This section gives an overview of Scheme's semantics.  A
detailed informal semantics is the subject of
section <A HREF="r4rs.html#SEC19">Basic concepts</A> through section <A HREF="r4rs.html#SEC45">Standard procedures</A>.  For reference
purposes, section <A HREF="r4rs.html#SEC73">Formal semantics</A> provides a formal
semantics of Scheme.

</P>
<P>
Following Algol, Scheme is a statically scoped programming
language.  Each use of a variable is associated with a lexically
apparent binding of that variable.

</P>
<P>
Scheme has latent as opposed to manifest types.  Types
are associated with values (also called objects)
<A NAME="IDX1"></A>
rather than
with variables.  (Some authors refer to languages with latent types as
weakly typed or dynamically typed languages.)  Other languages with
latent types are APL, Snobol, and other dialects of Lisp.  Languages
with manifest types (sometimes referred to as strongly typed or
statically typed languages) include Algol 60, Pascal, and C.

</P>
<P>
All objects created in the course of a Scheme computation, including
procedures and continuations, have unlimited extent.
No Scheme object is ever destroyed.  The reason that
implementations of Scheme do not (usually!) run out of storage is that
they are permitted to reclaim the storage occupied by an object if
they can prove that the object cannot possibly matter to any future
computation.  Other languages in which most objects have unlimited
extent include APL and other Lisp dialects.

</P>
<P>
Implementations of Scheme are required to be properly tail-recursive.
This allows the execution of an iterative computation in constant space,
even if the iterative computation is described by a syntactically
recursive procedure.  Thus with a tail-recursive implementation,
iteration can be expressed using the ordinary procedure-call
mechanics, so that special iteration constructs are useful only as
syntactic sugar.

</P>
<P>
Scheme procedures are objects in their own right.  Procedures can be
created dynamically, stored in data structures, returned as results of
procedures, and so on.  Other languages with these properties include
Common Lisp and ML.

</P>
<P>
One distinguishing feature of Scheme is that continuations, which
in most other languages only operate behind the scenes, also have
"first-class" status.  Continuations are useful for implementing a
wide variety of advanced control constructs, including non-local exits,
backtracking, and coroutines.  See section <A HREF="r4rs.html#SEC60">Control features</A>.

</P>
<P>
Arguments to Scheme procedures are always passed by value, which
means that the actual argument expressions are evaluated before the
procedure gains control, whether the procedure needs the result of the
evaluation or not.  ML, C, and APL are three other languages that always
pass arguments by value.
This is distinct from the lazy-evaluation semantics of Haskell,
or the call-by-name semantics of Algol 60, where an argument
expression is not evaluated unless its value is needed by the
procedure.

</P>

<P>
Scheme's model of arithmetic is designed to remain as independent as
possible of the particular ways in which numbers are represented within a
computer. In Scheme, every integer is a rational number, every rational is a
real, and every real is a complex number.  Thus the distinction between integer
and real arithmetic, so important to many programming languages, does not
appear in Scheme.  In its place is a distinction between exact arithmetic,
which corresponds to the mathematical ideal, and inexact arithmetic on
approximations.  As in Common Lisp, exact arithmetic is not limited to
integers.

</P>


<H2><A NAME="SEC8" HREF="r4rs_toc.html#SEC8">Syntax</A></H2>

<P>
Scheme, like most dialects of Lisp, employs a fully parenthesized prefix
notation for programs and (other) data; the grammar of Scheme generates a
sublanguage of the language used for data.  An important
consequence of this simple, uniform representation is the susceptibility of
Scheme programs and data to uniform treatment by other Scheme programs.

</P>
<P>
The <STRONG>read</STRONG>
<A NAME="IDX2"></A>
procedure performs syntactic as well as lexical decomposition of the
data it reads.  The <STRONG>read</STRONG> procedure parses its input as data
(section <A HREF="r4rs.html#SEC22">External representations</A>), not as program.

</P>
<P>
The formal syntax of Scheme is described in section <A HREF="r4rs.html#SEC67">Formal syntax</A>.

</P>


<H2><A NAME="SEC9" HREF="r4rs_toc.html#SEC9">Notation and terminology</A></H2>



<H3><A NAME="SEC10" HREF="r4rs_toc.html#SEC10">Essential and non-essential features</A></H3>

<P>
It is required that every implementation of Scheme support
features that are marked as being <STRONG>essential</STRONG>.  Features not
explicitly marked as essential are not essential.  Implementations are
free to omit non-essential features of Scheme or to add extensions,
provided the extensions are not in conflict with the language reported
here.  In particular, implementations must support portable code by
providing a syntactic mode that preempts no lexical conventions of this
report and reserves no identifiers other than those listed as syntactic
keywords in section <A HREF="r4rs.html#SEC16">Identifiers</A>.

</P>


<H3><A NAME="SEC11" HREF="r4rs_toc.html#SEC11">Error situations and unspecified behavior</A></H3>

<P>
<A NAME="IDX3"></A>
When speaking of an error situation, this report uses the phrase "an
error is signalled" to indicate that implementations must detect and
report the error.  If such wording does not appear in the discussion of
an error, then implementations are not required to detect or report the
error, though they are encouraged to do so.  An error situation that
implementations are not required to detect is usually referred to simply
as "an error."

</P>
<P>
For example, it is an error for a procedure to be passed an argument that
the procedure is not explicitly specified to handle, even though such
domain errors are seldom mentioned in this report.  Implementations may
extend a procedure's domain of definition to include such arguments.

</P>
<P>
This report uses the phrase "may report a violation of an
implementation restriction" to indicate circumstances under which an
implementation is permitted to report that it is unable to continue
execution of a correct program because of some restriction imposed by the
implementation.  Implementation restrictions are of course discouraged,
but implementations are encouraged to report violations of implementation
restrictions.
<A NAME="IDX4"></A>

</P>
<P>
For example, an implementation may report a violation of an
implementation restriction if it does not have enough storage to run a
program.

</P>
<P>
If the value of an expression is said to be "unspecified," then
the expression must evaluate to some object without signalling an error,
but the value depends on the implementation; this report explicitly does
not say what value should be returned.
<A NAME="IDX5"></A>

</P>



<H3><A NAME="SEC12" HREF="r4rs_toc.html#SEC12">Entry format</A></H3>

<P>
section <A HREF="r4rs.html#SEC25">Expressions</A> and section <A HREF="r4rs.html#SEC45">Standard procedures</A> are organized
into entries.  Each entry describes one language feature or a group of
related features, where a feature is either a syntactic construct or a
built-in procedure.  An entry begins with one or more header lines of the form

</P>
<P>
<U>{essential:</U> <B><VAR>category</VAR>}</B> <I>template</I><P>
<A NAME="IDX6"></A>
if the feature is an essential feature, or simply

</P>
<P>
<U><VAR>category</VAR>:</U> <B>template</B><P>
<A NAME="IDX7"></A>

</P>
<P>
if the feature is not an essential feature.

</P>
<P>
If <VAR>category</VAR> is "syntax", the entry describes an expression
type, and the header line gives the syntax of the expression type.
Components of expressions are designated by syntactic variables, which
are written using angle brackets, for example, &#60;expression&#62;,
&#60;variable&#62;.  Syntactic variables should be understood to denote segments of
program text; for example, &#60;expression&#62; stands for any string of
characters which is a syntactically valid expression.  The notation

<PRE>
&#60;thing 1&#62; ...
</PRE>

<P>
indicates zero or more occurrences of a &#60;thing&#62;, and

<PRE>
&#60;thing 1&#62; &#60;thing 2&#62; ...
</PRE>

<P>
indicates one or more occurrences of a &#60;thing&#62;.

</P>
<P>
If <VAR>category</VAR> is "procedure", then the entry describes a procedure, and
the header line gives a template for a call to the procedure.  Argument
names in the template are <VAR>italicized</VAR>.  Thus the header line

</P>
<P>
<U>essential procedure:</U> <B>vector-ref</B> <I>vector k</I><P>
<A NAME="IDX8"></A>

</P>
<P>
indicates that the essential built-in procedure <CODE>vector-ref</CODE> takes
two arguments, a vector <VAR>vector</VAR> and an exact non-negative integer
<VAR>k</VAR> (see below).  The header lines

</P>
<P>
<U>essential procedure:</U> <B>make-vector</B> <I>k</I><P>
<A NAME="IDX9"></A>
<U>procedure:</U> <B>make-vector</B> <I>k fill</I><P>
<A NAME="IDX10"></A>

</P>
<P>
indicate that in all implementations, the <CODE>make-vector</CODE> procedure
must be defined to take one argument, and some implementations will
extend it to take two arguments.

</P>
<P>
It is an error for an operation to be presented with an argument that it
is not specified to handle.  For succinctness, we follow the convention
that if an argument name is also the name of a type listed in
section <A HREF="r4rs.html#SEC23">Disjointness of types</A>, then that argument must be of the named type.
For example, the header line for <CODE>vector-ref</CODE> given above dictates that the
first argument to <CODE>vector-ref</CODE> must be a vector.  The following naming
conventions also imply type restrictions:

<UL>
<LI><VAR>obj</VAR> any object

<LI><VAR>list</VAR>, <VAR>list1</VAR>, ...<VAR>listj</VAR>, ...	list (see section <A HREF="r4rs.html#SEC48">Pairs and lists</A>)

<LI><VAR>z</VAR>, <VAR>z1</VAR>, ...<VAR>zj</VAR>, ...	complex number

<LI><VAR>x</VAR>, <VAR>x1</VAR>, ...<VAR>xj</VAR>, ...	real number

<LI><VAR>y</VAR>, <VAR>y1</VAR>, ...<VAR>yj</VAR>, ...	real number

<LI><VAR>q</VAR>, <VAR>q1</VAR>, ...<VAR>qj</VAR>, ...	rational number

<LI><VAR>n</VAR>, <VAR>n1</VAR>, ...<VAR>nj</VAR>, ...	integer

<LI><VAR>k</VAR>, <VAR>k1</VAR>, ...<VAR>kj</VAR>, ...	exact non-negative integer

</UL>



<H3><A NAME="SEC13" HREF="r4rs_toc.html#SEC13">Evaluation examples</A></H3>

<P>
The symbol "=>" used in program examples should be read
"evaluates to."  For example,

</P>

<PRE>
(* 5 8)                     =>  40
</PRE>

<P>
means that the expression <CODE>(* 5 8)</CODE> evaluates to the object <CODE>40</CODE>.
Or, more precisely:  the expression given by the sequence of characters
"<CODE>(* 5 8)</CODE>" evaluates, in the initial environment, to an object
that may be represented externally by the sequence of characters
"<CODE>40</CODE>".  See section <A HREF="r4rs.html#SEC22">External representations</A> for a
discussion of external
representations of objects.

</P>


<H3><A NAME="SEC14" HREF="r4rs_toc.html#SEC14">Naming conventions</A></H3>

<P>
By convention, the names of procedures that always return a boolean
value usually end
in "<SAMP>`?'</SAMP>".  Such procedures are called predicates.
<A NAME="IDX11"></A>

</P>
<P>
By convention, the names of procedures that store values into previously
allocated locations (see section <A HREF="r4rs.html#SEC24">Storage model</A>) usually end in
"<SAMP>`!'</SAMP>".
Such procedures are called mutation procedures.
By convention, the value returned by a mutation procedure is unspecified.
<A NAME="IDX12"></A>

</P>
<P>
By convention, "<SAMP>`-&#62;'</SAMP>" appears within the names of procedures that
take an object of one type and return an analogous object of another type.
For example, <CODE>list-&#62;vector</CODE> takes a list and returns a vector whose
<A NAME="IDX13"></A>
elements are the same as those of the list.
<A NAME="IDX14"></A>

</P>



<H1><A NAME="SEC15" HREF="r4rs_toc.html#SEC15">Lexical conventions</A></H1>

<P>
This section gives an informal account of some of the lexical
conventions used in writing Scheme programs.  For a formal syntax of
Scheme, see section <A HREF="r4rs.html#SEC67">Formal syntax</A>.

</P>
<P>
Upper and lower case forms of a letter are never distinguished
except within character and string constants.  For example, <CODE>Foo</CODE>
is
<A NAME="IDX15"></A>
the same identifier as <CODE>FOO</CODE>, and <CODE>#x1AB</CODE> is the same number
as
<A NAME="IDX16"></A>
<CODE>#X1ab</CODE>.

</P>



<H2><A NAME="SEC16" HREF="r4rs_toc.html#SEC16">Identifiers</A></H2>

<P>
Most identifiers
<A NAME="IDX17"></A>
allowed by other programming
languages are also acceptable to Scheme.  The precise rules for forming
identifiers vary among implementations of Scheme, but in all
implementations a sequence of letters, digits, and "extended alphabetic
characters" that begins with a character that cannot begin a number is
an identifier.  In addition, <CODE>+</CODE>, <CODE>-</CODE>, and <CODE>...</CODE> are identifiers.
<A NAME="IDX18"></A>
<A NAME="IDX19"></A>
<A NAME="IDX20"></A>
Here are some examples of identifiers:

</P>

<PRE>
lambda                   q
list-&#62;vector             soup
+                        V17a
&#60;=?                      a34kTMNs
the-word-recursion-has-many-meanings
</PRE>

<P>
Extended alphabetic characters may be used within identifiers as if
they were letters.  The following are extended alphabetic characters:

</P>

<PRE>
+ - . * / &#60; = &#62; ! ? : $ % _ &#38; ~ ^
</PRE>

<P>
See section <A HREF="r4rs.html#SEC68">Lexical structure</A> for a formal syntax of identifiers.

</P>
<P>
Identifiers have several uses within Scheme programs:

<UL>
<LI>Certain identifiers are reserved for use as syntactic keywords

(see below).
<A NAME="IDX21"></A>
<A NAME="IDX22"></A>

<LI>Any identifier that is not a syntactic keyword may be used as a

variable (see section <A HREF="r4rs.html#SEC20">Variables and regions</A>).
<A NAME="IDX23"></A>

<LI>When an identifier appears as a literal or within a literal

(see section <A HREF="r4rs.html#SEC28">Literal expressions</A>), it is being used to denote a
<EM>symbol</EM> (see section <A HREF="r4rs.html#SEC49">Symbols</A>).

</UL>

<P>
The following identifiers are syntactic keywords, and should not be used
as variables:

</P>

<PRE>
=&#62;           do            or
and          else          quasiquote
begin        if            quote
case         lambda        set!
cond         let           unquote
define       let*          unquote-splicing
delay        letrec
</PRE>

<P>
Some implementations allow all identifiers, including syntactic
keywords, to be used as variables.  This is a compatible extension to
the language, but ambiguities in the language result when the
restriction is relaxed, and the ways in which these ambiguities are
resolved vary between implementations.

</P>


<H2><A NAME="SEC17" HREF="r4rs_toc.html#SEC17">Whitespace and comments</A></H2>

<P>
<STRONG>Whitespace</STRONG> characters are spaces and newlines.
(Implementations typically provide additional whitespace characters such
as tab or page break.)  Whitespace is used for improved readability and
as necessary to separate tokens from each other, a token being an
indivisible lexical unit such as an identifier or number, but is
otherwise insignificant.  Whitespace may occur between any two tokens,
but not within a token.  Whitespace may also occur inside a string,
where it is significant.

</P>
<P>
A semicolon (<CODE>;</CODE>) indicates the start of a comment.
<A NAME="IDX24"></A>
<A NAME="IDX25"></A>
The comment continues to the end of the line on which the semicolon
appears.  Comments are invisible to Scheme, but the end of the line is
visible as whitespace.  This prevents a comment from appearing in the
middle of an identifier or number.

</P>

<PRE>
;;; The FACT procedure computes the factorial
;;; of a non-negative integer.
(define fact
  (lambda (n)
    (if (= n 0)
        1        ;Base case: return 1
        (* n (fact (- n 1))))))
</PRE>



<H2><A NAME="SEC18" HREF="r4rs_toc.html#SEC18">Other notations</A></H2>

<P>
For a description of the notations used for numbers, see
section <A HREF="r4rs.html#SEC50">Numbers</A>.

</P>
<DL COMPACT>

<DT><TT>. + -</TT>
<DD>
These are used in numbers, and may also occur anywhere in an identifier
except as the first character.  A delimited plus or minus sign by itself
is also an identifier.
A delimited period (not occurring within a number or identifier) is used
in the notation for pairs (section <A HREF="r4rs.html#SEC48">Pairs and lists</A>), and to indicate a
rest-parameter in a  formal parameter list (section <A HREF="r4rs.html#SEC30">Lambda expressions</A>).
A delimited sequence of three successive periods is also an identifier.

<DT><TT>( )</TT>
<DD>
Parentheses are used for grouping and to notate lists
(section <A HREF="r4rs.html#SEC48">Pairs and lists</A>).

<DT><TT>'</TT>
<DD>
The single quote character is used to indicate literal data (section <A HREF="r4rs.html#SEC28">Literal expressions</A>).

<DT><TT>`</TT>
<DD>
The backquote character is used to indicate almost-constant
data (section <A HREF="r4rs.html#SEC39">Quasiquotation</A>).

<DT><TT>, ,@</TT>
<DD>
The character comma and the sequence comma at-sign are used in conjunction
with backquote (section <A HREF="r4rs.html#SEC39">Quasiquotation</A>).

<DT><TT>"</TT>
<DD>
The double quote character is used to delimit strings (section <A HREF="r4rs.html#SEC58">Strings</A>).

<DT><TT>\</TT>
<DD>
Backslash is used in the syntax for character constants
(section <A HREF="r4rs.html#SEC57">Characters</A>) and as an escape character within string
constants (section <A HREF="r4rs.html#SEC58">Strings</A>).

<DT><TT>[ ] { }</TT>
<DD>
Left and right square brackets and curly braces
are reserved for possible future extensions to the language.

<DT><TT>#</TT>
<DD>
Sharp sign is used for a variety of purposes depending on
the character that immediately follows it:

<DT><TT>#t #f</TT>
<DD>
These are the boolean constants (section <A HREF="r4rs.html#SEC46">Booleans</A>).

<DT><TT>#\</TT>
<DD>
This introduces a character constant (section <A HREF="r4rs.html#SEC57">Characters</A>).

<DT><TT>#(</TT>
<DD>
This introduces a vector constant (section <A HREF="r4rs.html#SEC59">Vectors</A>).  Vector
constants are terminated by <SAMP>`)'</SAMP> .

<DT><TT>#e #i #b #o #d #x</TT>
<DD>
These are used in the notation for numbers (section <A HREF="r4rs.html#SEC54">Syntax of numerical constants</A>).

</DL>



<H1><A NAME="SEC19" HREF="r4rs_toc.html#SEC19">Basic concepts</A></H1>



<H2><A NAME="SEC20" HREF="r4rs_toc.html#SEC20">Variables and regions</A></H2>

<P>
Any identifier that is not a syntactic keyword
<A NAME="IDX26"></A>
(see section <A HREF="r4rs.html#SEC16">Identifiers</A>) may be used as a variable.
<A NAME="IDX27"></A>
<A NAME="IDX28"></A>
<A NAME="IDX29"></A>
A variable may name a location where a value can be stored.  A variable
that does so is said to be <EM>bound</EM> to the location.  The set of all
visible bindings
<A NAME="IDX30"></A>
in effect at some point in a program is known as the <EM>environment</EM>
in effect at that point.  The value stored in the location to which a
variable is bound is called the variable's value.  By abuse of
terminology, the variable is sometimes said to name the value or to be
bound to the value.  This is not quite accurate, but confusion rarely
results from this practice.

</P>

<P>
Certain expression types are used to create new locations and to bind
variables to those locations.  The most fundamental of these
<EM>binding constructs</EM>
<A NAME="IDX31"></A>
<A NAME="IDX32"></A>
is the lambda expression, because all other binding constructs can be
explained in terms of lambda expressions.  The other binding constructs
are <CODE>let</CODE>, <CODE>let*</CODE>, <CODE>letrec</CODE>, and <CODE>do</CODE> expressions
(see section <A HREF="r4rs.html#SEC30">Lambda expressions</A>, section <A HREF="r4rs.html#SEC35">Binding constructs</A>, and
section <A HREF="r4rs.html#SEC37">Iteration</A>).
<A NAME="IDX33"></A>
<A NAME="IDX34"></A>
<A NAME="IDX35"></A>
<A NAME="IDX36"></A>

</P>
<P>
Like Algol and Pascal, and unlike most other dialects of Lisp except for
Common Lisp, Scheme is a statically scoped language with block
structure.  To each place where a variable is bound in a program there
corresponds a <STRONG>region</STRONG> of the program text within which the binding
is effective.  The region is determined by the particular binding
construct that establishes the binding; if the binding is established by
a lambda expression, for example, then its region is the entire lambda
expression.  Every reference to or assignment of a variable refers to
the binding of the variable that established the innermost of the
regions containing the use.  If there is no binding of the variable
whose region contains the use, then the use refers to the binding for
the variable in the top level environment, if any (section
section <A HREF="r4rs.html#SEC45">Standard procedures</A>); if there is no binding for the identifier,
it is said to be <STRONG>unbound</STRONG>.
<A NAME="IDX37"></A>
<A NAME="IDX38"></A>

</P>



<H2><A NAME="SEC21" HREF="r4rs_toc.html#SEC21">True and false</A></H2>

<P>
Any Scheme value can be used as a boolean value for the purpose of a
conditional test.  As explained in section <A HREF="r4rs.html#SEC46">Booleans</A>, all
values count as true in such a test except for <CODE>#f</CODE>.
This report uses the word "true" to refer to any
Scheme value that counts as true, and the word "false" to refer to
<CODE>#f</CODE>.
<A NAME="IDX39"></A>
<A NAME="IDX40"></A>

</P>
<P>
<EM>Note:</EM>  In some implementations the empty list also counts as
false instead of true.

</P>



<H2><A NAME="SEC22" HREF="r4rs_toc.html#SEC22">External representations</A></H2>

<P>
An important concept in Scheme (and Lisp) is that of the <EM>external
representation</EM> of an object as a sequence of characters.  For example,
an external representation of the integer 28 is the sequence of
characters "<CODE>28</CODE>", and an external representation of a list consisting
of the integers 8 and 13 is the sequence of characters "<CODE>(8 13)</CODE>".

</P>
<P>
The external representation of an object is not necessarily unique.  The
integer 28 also has representations "<CODE>#e28.000</CODE>" and
"<CODE>#x1c</CODE>", and the list in the previous paragraph also has the
representations "<CODE>( 08 13 )</CODE>" and "<CODE>(8 . (13 . ()))</CODE>"
(see section <A HREF="r4rs.html#SEC48">Pairs and lists</A>).

</P>
<P>
Many objects have standard external representations, but some, such as
procedures, do not have standard representations (although particular
implementations may define representations for them).

</P>
<P>
An external representation may be written in a program to obtain the
corresponding object (see <CODE>quote</CODE>, section <A HREF="r4rs.html#SEC28">Literal expressions</A>).
<A NAME="IDX41"></A>

</P>
<P>
External representations can also be used for input and output.  The
procedure <CODE>read</CODE> (section <A HREF="r4rs.html#SEC63">Input</A>) parses external
<A NAME="IDX42"></A>
representations, and the procedure <CODE>Output</CODE> (section <A HREF="r4rs.html#SEC64">Output</A>)
<A NAME="IDX43"></A>
generates them.  Together, they provide an elegant and powerful
input/output facility.

</P>
<P>
Note that the sequence of characters "<CODE>(+ 2 6)</CODE>" is <EM>not</EM> an
external representation of the integer 8, even though it <EM>is</EM> an
expression evaluating to the integer 8; rather, it is an external
representation of a three-element list, the elements of which are the symbol
<CODE>+</CODE> and the integers 2 and 6.  Scheme's syntax has the property that
any sequence of characters that is an expression is also the external
representation of some object.  This can lead to confusion, since it may
not be obvious out of context whether a given sequence of characters is
intended to denote data or program, but it is also a source of power,
since it facilitates writing programs such as interpreters and
compilers that treat programs as data (or vice versa).

</P>
<P>
The syntax of external representations of various kinds of objects
accompanies the description of the primitives for manipulating the
objects in the appropriate sections of section <A HREF="r4rs.html#SEC45">Standard procedures</A>.

</P>


<H2><A NAME="SEC23" HREF="r4rs_toc.html#SEC23">Disjointness of types</A></H2>

<P>
No object satisfies more than one of the following predicates:

</P>

<PRE>
boolean?          pair?
symbol?           number?
char?             string?
vector?           procedure?
</PRE>

<P>
These predicates define the types <EM>boolean</EM>, <EM>pair</EM>,
<EM>symbol</EM>, <EM>number</EM>, <EM>char</EM> (or <EM>character</EM>),
<EM>string</EM>, <EM>vector</EM>, and <EM>procedure</EM>.
<A NAME="IDX44"></A>

</P>


<H2><A NAME="SEC24" HREF="r4rs_toc.html#SEC24">Storage model</A></H2>

<P>
Variables and objects such as pairs, vectors, and strings implicitly
denote locations
<A NAME="IDX45"></A>
or sequences of locations.  A string, for
example, denotes as many locations as there are characters in the string.
(These locations need not correspond to a full machine word.) A new value may be
stored into one of these locations using the <CODE>string-set!</CODE> procedure, but
the string continues to denote the same locations as before.

</P>
<P>
An object fetched from a location, by a variable reference or by
a procedure such as <CODE>car</CODE>, <CODE>vector-ref</CODE>, or <CODE>string-ref</CODE>, is
<A NAME="IDX46"></A>
<A NAME="IDX47"></A>
<A NAME="IDX48"></A>
equivalent in the sense of <CODE>eqv?</CODE> (section
section <A HREF="r4rs.html#SEC47">Equivalence predicates</A>)
<A NAME="IDX49"></A>
to the object last stored in the location before the fetch.

</P>
<P>
Every location is marked to show whether it is in use.
No variable or object ever refers to a location that is not in use.
Whenever this report speaks of storage being allocated for a variable
or object, what is meant is that an appropriate number of locations are
chosen from the set of locations that are not in use, and the chosen
locations are marked to indicate that they are now in use before the variable
or object is made to denote them.

</P>
<P>
In many systems it is desirable for constants
<A NAME="IDX50"></A>
(i.e. the values of
literal expressions) to reside in read-only-memory.  To express this, it is
convenient to imagine that every object that denotes locations is associated
with a flag telling whether that object is mutable
<A NAME="IDX51"></A>
or immutable.
<A NAME="IDX52"></A>
The constants and the strings returned by <CODE>symbol-&#62;string</CODE> are
<A NAME="IDX53"></A>
then the immutable objects, while all objects created by the other
procedures listed in this report are mutable.  It is an error to attempt
to store a new value into a location that is denoted by an immutable
object.

</P>


<H1><A NAME="SEC25" HREF="r4rs_toc.html#SEC25">Expressions</A></H1>

<P>
A Scheme expression is a construct that returns a value, such as a
variable reference, literal, procedure call, or conditional.

</P>
<P>
Expression types are categorized as <EM>primitive</EM> or <EM>derived</EM>.
Primitive expression types include variables and procedure calls.
Derived expression types are not semantically primitive, but can instead
be explained in terms of the primitive constructs as in
section <A HREF="r4rs.html#SEC78">derived expression types</A>.  They are redundant in the strict sense of
the word, but they capture common patterns of usage, and are therefore
provided as convenient abbreviations.

</P>



<H2><A NAME="SEC26" HREF="r4rs_toc.html#SEC26">Primitive expression types</A></H2>



<H3><A NAME="SEC27" HREF="r4rs_toc.html#SEC27">Variable references</A></H3>

<P>
<U>essential syntax:</U> <B>&#60;variable&#62;</B><P>
<A NAME="IDX54"></A>

</P>
<P>
An expression consisting of a variable
<A NAME="IDX55"></A>

</P>
<P>
(section <A HREF="r4rs.html#SEC20">Variables and regions</A>) is a variable reference.  The value of
the variable reference is the value stored in the location to which the
variable is bound.  It is an error to reference an
unbound
<A NAME="IDX56"></A>
variable.

</P>

<PRE>
(define x 28)
x                           =>  28
</PRE>

<P>



<H3><A NAME="SEC28" HREF="r4rs_toc.html#SEC28">Literal expressions</A></H3>

<P>
<U>essential syntax:</U> <B>quote</B> <I>&#60;datum&#62;</I><P>
<A NAME="IDX57"></A>
<U>essential syntax:</U> <B>'&#60;datum&#62;</B><P>
<A NAME="IDX58"></A>
<U>essential syntax:</U> <B>&#60;constant&#62;</B><P>
<A NAME="IDX59"></A>

</P>
<P>
<CODE>(quote &#60;datum&#62;)</CODE> evaluates to &#60;datum&#62;.
<A NAME="IDX60"></A>
&#60;Datum&#62; may be any external representation of a Scheme object (see
section <A HREF="r4rs.html#SEC22">External representations</A>).  This notation is used to
include literal constants in Scheme code.
<A NAME="IDX61"></A>

</P>

<PRE>
(quote a)                   =>  a
(quote #(a b c))            =>  #(a b c)
(quote (+ 1 2))             =>  (+ 1 2)
</PRE>

<P>
<CODE>(quote &#60;datum&#62;)</CODE> may be abbreviated as
'&#60;datum&#62;.  The two notations are equivalent in all
respects.

</P>

<PRE>
'a                          =>  a
'#(a b c)                   =>  #(a b c)
'()                         =>  ()
'(+ 1 2)                    =>  (+ 1 2)
'(quote a)                  =>  (quote a)
''a                         =>  (quote a)
</PRE>

<P>
Numerical constants, string constants, character constants, and boolean
constants evaluate "to themselves"; they need not be quoted.

</P>

<PRE>
'"abc"                      =>  "abc"
"abc"                       =>  "abc"
'145932                     =>  145932
145932                      =>  145932
'#t                         =>  #t
#t                          =>  #t
</PRE>

<P>
As noted in section <A HREF="r4rs.html#SEC24">Storage model</A>, it is an error to alter a constant
(i.e. the value of a literal expression) using a mutation procedure like
<CODE>set-car!</CODE> or <CODE>string-set!</CODE>.
<A NAME="IDX62"></A>
<A NAME="IDX63"></A>
<A NAME="IDX64"></A>

</P>
<P>



<H3><A NAME="SEC29" HREF="r4rs_toc.html#SEC29">Procedure calls</A></H3>

<P>
<U>essential syntax:</U> <B>&#60;operator&#62;</B> <I>&#60;operand 1&#62; ...</I><P>
<A NAME="IDX65"></A>

</P>
<P>
A procedure call is written by simply enclosing in parentheses
expressions for the procedure to be called and the arguments to be
passed to it.  The operator and operand expressions are evaluated (in an
unspecified order) and the resulting procedure is passed the resulting
arguments.
<A NAME="IDX66"></A>
<A NAME="IDX67"></A>

</P>

<PRE>
(+ 3 4)                     =>  7
((if #f + *) 3 4)           =>  12
</PRE>

<P>
A number of procedures are available as the values of variables in the
initial environment; for example, the addition and multiplication
procedures in the above examples are the values of the variables
<CODE>+</CODE> and <CODE>*</CODE>.
<A NAME="IDX68"></A>
<A NAME="IDX69"></A>
New procedures are created by evaluating lambda expressions (see section
section <A HREF="r4rs.html#SEC30">Lambda expressions</A>).

</P>
<P>
Procedure calls are also called <EM>combinations</EM>.
<A NAME="IDX70"></A>

</P>
<P>
<EM>Note:</EM>  In contrast to other dialects of Lisp, the order of
evaluation is unspecified, and the operator expression and the operand
expressions are always evaluated with the same evaluation rules.

</P>
<P>
<EM>Note:</EM>  Although the order of evaluation is otherwise unspecified, the effect of
any concurrent evaluation of the operator and operand expressions is
constrained to be consistent with some sequential order of evaluation.
The order of evaluation may be chosen differently for each procedure call.

</P>
<P>
<EM>Note:</EM>  In many dialects of Lisp, the empty combination,
<CODE>()</CODE>, is a legitimate expression.  In Scheme, combinations must
have at
least one subexpression, so <CODE>()</CODE> is not a syntactically valid
expression.

</P>

<P>



<H3><A NAME="SEC30" HREF="r4rs_toc.html#SEC30">Lambda expressions</A></H3>

<P>
<U>essential syntax:</U> <B>lambda</B> <I>&#60;formals&#62; &#60;body&#62;</I><P>
<A NAME="IDX71"></A>

</P>
<P>
<EM>Syntax:</EM>  &#60;Formals&#62; should be a formal arguments list as described below,
and &#60;body&#62; should be a sequence of one or more expressions.

</P>
<P>
<EM>Semantics:</EM>  
A lambda expression evaluates to a procedure.  The environment in
effect when the lambda expression was evaluated is remembered as part of the
procedure.  When the procedure is later called with some actual
arguments, the environment in which the lambda expression was evaluated will
be extended by binding the variables in the formal argument list to
fresh locations, the corresponding actual argument values will be stored
in those locations, and the expressions in the body of the lambda expression
will be evaluated sequentially in the extended environment.  The result
of the last expression in the body will be returned as the result of
the procedure call.

</P>

<PRE>
(lambda (x) (+ x x))        =>  <EM>a procedure</EM>
((lambda (x) (+ x x)) 4)    =>  8

(define reverse-subtract
  (lambda (x y) (- y x)))
(reverse-subtract 7 10)     =>  3

(define add4
  (let ((x 4))
    (lambda (y) (+ x y))))
(add4 6)                    =>  10
</PRE>

<P>
&#60;Formals&#62; should have one of the following forms:

</P>

<UL>
<LI><CODE>(&#60;variable 1&#62; ...)</CODE>:

The procedure takes a fixed number of arguments; when the procedure is
called, the arguments will be stored in the bindings of the
corresponding variables.

<LI>&#60;variable&#62;:

The procedure takes any number of arguments; when the procedure is
called, the sequence of actual arguments is converted into a newly
allocated list, and the list is stored in the binding of the
&#60;variable&#62;.

<LI><CODE>(&#60;variable 1&#62; ... &#60;variable n-1&#62; . &#60;variable n&#62;)</CODE>:

If a space-delimited period precedes the last variable, then
the value stored in the binding of the last variable will be a
newly allocated
list of the actual arguments left over after all the other actual
arguments have been matched up against the other formal arguments.
</UL>

<P>
It is an error for a &#60;variable&#62; to appear more than once in
&#60;formals&#62;.

</P>

<PRE>
((lambda x x) 3 4 5 6)      =>  (3 4 5 6)
((lambda (x y . z) z)
 3 4 5 6)                   =>  (5 6)
</PRE>

<P>
Each procedure created as the result of evaluating a lambda expression
is tagged with a storage location, in order to make <CODE>eqv?</CODE> and
<CODE>eq?</CODE> work on procedures (see section <A HREF="r4rs.html#SEC47">Equivalence predicates</A>).
<A NAME="IDX72"></A>
<A NAME="IDX73"></A>

</P>
<P>



<H3><A NAME="SEC31" HREF="r4rs_toc.html#SEC31">Conditionals</A></H3>

<P>
<U>essential syntax:</U> <B>if</B> <I>&#60;test&#62; &#60;consequent&#62; &#60;alternate&#62;</I><P>
<A NAME="IDX74"></A>
<U>syntax:</U> <B>if</B> <I>&#60;test&#62; &#60;consequent&#62;</I><P>
<A NAME="IDX75"></A>

</P>
<P>
<EM>Syntax:</EM>  &#60;Test&#62;, &#60;consequent&#62;, and &#60;alternate&#62; may be arbitrary
expressions.

</P>
<P>
<EM>Semantics:</EM>  An <CODE>if</CODE> expression is evaluated as follows: first,
<A NAME="IDX76"></A>
&#60;test&#62; is evaluated.  If it yields a true value
<A NAME="IDX77"></A>
(see section <A HREF="r4rs.html#SEC46">Booleans</A>), then &#60;consequent&#62; is evaluated
and its value is returned.  Otherwise &#60;alternate&#62; is evaluated and
its value is returned.  If &#60;test&#62; yields a false value and no
&#60;alternate&#62; is specified, then the result of the expression is
unspecified.

</P>

<PRE>
(if (&#62; 3 2) 'yes 'no)       =>  yes
(if (&#62; 2 3) 'yes 'no)       =>  no
(if (&#62; 3 2)
    (- 3 2)
    (+ 3 2))                =>  1
</PRE>

<P>



<H3><A NAME="SEC32" HREF="r4rs_toc.html#SEC32">Assignments</A></H3>

<P>
<U>essential syntax:</U> <B>set!</B> <I>&#60;variable&#62; &#60;expression&#62;</I><P>
<A NAME="IDX78"></A>

</P>
<P>
&#60;Expression&#62; is evaluated, and the resulting value is stored in
the location to which &#60;variable&#62; is bound.  &#60;Variable&#62; must
be bound either in some region
<A NAME="IDX79"></A>
enclosing the <CODE>set!</CODE> expression
<A NAME="IDX80"></A>
or at top level.  The result of the <CODE>set!</CODE> expression is
<A NAME="IDX81"></A>
unspecified.

</P>

<PRE>
(define x 2)
(+ x 1)                     =>  3
(set! x 4)                  =>  <EM>unspecified</EM>
(+ x 1)                     =>  5
</PRE>

<P>



<H2><A NAME="SEC33" HREF="r4rs_toc.html#SEC33">Derived expression types</A></H2>

<P>
For reference purposes, section <A HREF="r4rs.html#SEC78">derived expression types</A> gives rewrite rules
that will convert constructs described in this section into the
primitive constructs described in the previous section.

</P>



<H3><A NAME="SEC34" HREF="r4rs_toc.html#SEC34">Conditionals</A></H3>

<P>
<U>essential syntax:</U> <B>cond</B> <I>&#60;clause 1&#62; &#60;clause 2&#62; ...</I><P>
<A NAME="IDX82"></A>

</P>
<P>
<EM>Syntax:</EM>  Each &#60;clause&#62; should be of the form

<PRE>
(&#60;test&#62; &#60;expression&#62; ...)
</PRE>

<P>
where &#60;test&#62; is any expression.  The last &#60;clause&#62; may be
an "else clause," which has the form

<PRE>
(else &#60;expression 1&#62; &#60;expression 2&#62; ...).
</PRE>

<P>
<A NAME="IDX83"></A>
<A NAME="IDX84"></A>

</P>
<P>
<EM>Semantics:</EM>  A <CODE>cond</CODE> expression is evaluated by evaluating the &#60;test&#62;
<A NAME="IDX85"></A>
expressions of successive &#60;clause&#62;s in order until one of them
evaluates to a true value
<A NAME="IDX86"></A>
(see section <A HREF="r4rs.html#SEC46">Booleans</A>).  When a &#60;test&#62; evaluates to a
true value, then the remaining &#60;expression&#62;s in its &#60;clause&#62; are
evaluated in order, and the result of the last &#60;expression&#62; in the
&#60;clause&#62; is returned as the result of the entire <CODE>cond</CODE>
<A NAME="IDX87"></A>
expression.  If the selected &#60;clause&#62; contains only the &#60;test&#62;
and no &#60;expression&#62;s, then the value of the &#60;test&#62; is returned
as the result.  If all &#60;test&#62;s evaluate to false values, and there
is no else clause, then the result of the conditional expression is
unspecified; if there is an else clause, then its &#60;expression&#62;s are
evaluated, and the value of the last one is returned.

</P>

<PRE>
(cond ((&#62; 3 2) 'greater)
      ((&#60; 3 2) 'less))      =>  greater

(cond ((&#62; 3 3) 'greater)
      ((&#60; 3 3) 'less)
      (else 'equal))        =>  equal
</PRE>

<P>
Some implementations support an alternative &#60;clause&#62; syntax,
<CODE>(&#60;test&#62; =&#62; &#60;recipient&#62;)</CODE>, where &#60;recipient&#62; is an
expression.  If &#60;test&#62; evaluates to a true value, then
&#60;recipient&#62; is evaluated.  Its value must be a procedure of one
argument; this procedure is then invoked on the value of the
&#60;test&#62;.

</P>

<PRE>
(cond ((assv 'b '((a 1) (b 2))) =&#62; cadr)
      (else <CODE>#f</CODE>))     =>  2
</PRE>

<P>

<U>essential syntax:</U> <B>case</B> <I>&#60;key&#62; &#60;clause 1&#62; &#60;clause 2&#62; ...</I><P>
<A NAME="IDX88"></A>

</P>
<P>
<EM>Syntax:</EM>  &#60;Key&#62; may be any expression.  Each &#60;clause&#62; should have
the form

<PRE>
((&#60;datum 1&#62; ...) &#60;expression 1&#62; &#60;expression 2&#62; ...),
</PRE>

<P>
where each &#60;datum&#62; is an external representation of some object.
All the &#60;datum&#62;s must be distinct.
The last &#60;clause&#62; may be an "else clause," which has the form

<PRE>
(else &#60;expression 1&#62; &#60;expression 2&#62; ...).
</PRE>

<P>
<A NAME="IDX89"></A>

</P>
<P>
<EM>Semantics:</EM>  A <CODE>case</CODE> expression is evaluated as follows.  &#60;Key&#62; is
<A NAME="IDX90"></A>
evaluated and its result is compared against each &#60;datum&#62;.  If the
result of evaluating &#60;key&#62; is equivalent (in the sense of
<CODE>eqv?</CODE>; see section <A HREF="r4rs.html#SEC47">Equivalence predicates</A>) to a &#60;datum&#62;, then the
<A NAME="IDX91"></A>
expressions in the corresponding &#60;clause&#62; are evaluated from left
to right and the result of the last expression in the &#60;clause&#62; is
returned as the result of the <CODE>case</CODE> expression.  If the result of
<A NAME="IDX92"></A>
evaluating &#60;key&#62; is different from every &#60;datum&#62;, then if
there is an else clause its expressions are evaluated and the
result of the last is the result of the <CODE>case</CODE> expression;
otherwise
<A NAME="IDX93"></A>
the result of the <CODE>case</CODE> expression is unspecified.
<A NAME="IDX94"></A>

</P>

<PRE>
(case (* 2 3)
  ((2 3 5 7) 'prime)
  ((1 4 6 8 9) 'composite)) =>  composite
(case (car '(c d))
  ((a) 'a)
  ((b) 'b))                 =>  <EM>unspecified</EM>
(case (car '(c d))
  ((a e i o u) 'vowel)
  ((w y) 'semivowel)
  (else 'consonant))        =>  consonant
</PRE>

<P>

<U>essential syntax:</U> <B>and</B> <I>&#60;test 1&#62; ...</I><P>
<A NAME="IDX95"></A>

</P>
<P>
The &#60;test&#62; expressions are evaluated from left to right, and the
value of the first expression that evaluates to a false value (see
section <A HREF="r4rs.html#SEC46">Booleans</A>) is returned.  Any remaining expressions
are not evaluated.  If all the expressions evaluate to true values, the
value of the last expression is returned.  If there are no expressions
then <CODE>#t</CODE> is returned.

</P>

<PRE>
(and (= 2 2) (&#62; 2 1))       =>  #t
(and (= 2 2) (&#60; 2 1))       =>  #f
(and 1 2 'c '(f g))         =>  (f g)
(and)                       =>  #t
</PRE>

<P>

<U>essential syntax:</U> <B>or</B> <I>&#60;test 1&#62; ...</I><P>
<A NAME="IDX96"></A>

</P>
<P>
The &#60;test&#62; expressions are evaluated from left to right, and the value of the
first expression that evaluates to a true value (see
section <A HREF="r4rs.html#SEC46">Booleans</A>) is returned.  Any remaining expressions
are not evaluated.  If all expressions evaluate to false values, the
value of the last expression is returned.  If there are no
expressions then <CODE>#f</CODE> is returned.

</P>

<PRE>
(or (= 2 2) (&#62; 2 1))        =>  #t
(or (= 2 2) (&#60; 2 1))        =>  #t
(or #f #f #f)               =>  #f
(or (memq 'b '(a b c))
    (/ 3 0))                =>  (b c)
</PRE>

<P>



<H3><A NAME="SEC35" HREF="r4rs_toc.html#SEC35">Binding constructs</A></H3>

<P>
The three binding constructs <CODE>let</CODE>, <CODE>let*</CODE>, and <CODE>letrec</CODE>
<A NAME="IDX97"></A>
<A NAME="IDX98"></A>
<A NAME="IDX99"></A>
give Scheme a block structure, like Algol 60.  The syntax of the three
constructs is identical, but they differ in the regions
<A NAME="IDX100"></A>
they establish
for their variable bindings.  In a <CODE>let</CODE> expression, the initial
<A NAME="IDX101"></A>
values are computed before any of the variables become bound; in a
<CODE>let*</CODE> expression, the bindings and evaluations are performed
<A NAME="IDX102"></A>
sequentially; while in a <CODE>letrec</CODE> expression, all the bindings are
in
<A NAME="IDX103"></A>
effect while their initial values are being computed, thus allowing
mutually recursive definitions.

</P>
<P>
<U>essential syntax:</U> <B>let</B> <I>&#60;bindings&#62; &#60;body&#62;</I><P>
<A NAME="IDX104"></A>

</P>
<P>
<EM>Syntax:</EM>  &#60;Bindings&#62; should have the form

<PRE>
((&#60;variable 1&#62; &#60;init 1&#62;) ...),
</PRE>

<P>
where each &#60;init&#62; is an expression, and &#60;body&#62; should be a
sequence of one or more expressions.  It is
an error for a &#60;variable&#62; to appear more than once in the list of variables
being bound.

</P>
<P>
<EM>Semantics:</EM>  The &#60;init&#62;s are evaluated in the current environment (in some
unspecified order), the &#60;variable&#62;s are bound to fresh locations
holding the results, the &#60;body&#62; is evaluated in the extended
environment, and the value of the last expression of &#60;body&#62; is
returned.  Each binding of a &#60;variable&#62; has &#60;body&#62; as its
region.
<A NAME="IDX105"></A>

</P>

<PRE>
(let ((x 2) (y 3))
  (* x y))                  =>  6

(let ((x 2) (y 3))
  (let ((x 7)
        (z (+ x y)))
    (* z x)))               =>  35
</PRE>

<P>
See also named <CODE>let</CODE>, section <A HREF="r4rs.html#SEC37">Iteration</A>.
<A NAME="IDX106"></A>

</P>
<P>

<U>syntax:</U> <B>let*</B> <I>&#60;bindings&#62; &#60;body&#62;</I><P>
<A NAME="IDX107"></A>

</P>
<P>
<EM>Syntax:</EM>  &#60;Bindings&#62; should have the form

<PRE>
((&#60;variable 1&#62; &#60;init 1&#62;) ...),
</PRE>

<P>
and &#60;body&#62; should be a sequence of
one or more expressions.

</P>
<P>
<EM>Semantics:</EM>  <CODE>Let*</CODE> is similar to <CODE>let</CODE>, but the bindings are performed
<A NAME="IDX108"></A>
<A NAME="IDX109"></A>
sequentially from left to right, and the region
<A NAME="IDX110"></A>
of a binding indicated
by <CODE>(&#60;variable&#62; &#60;init&#62;)</CODE> is that part of the <CODE>let*</CODE>
<A NAME="IDX111"></A>
expression to the right of the binding.  Thus the second binding is done
in an environment in which the first binding is visible, and so on.

</P>

<PRE>
(let ((x 2) (y 3))
  (let* ((x 7)
         (z (+ x y)))
    (* z x)))               =>  70
</PRE>

<P>

<U>essential syntax:</U> <B>letrec</B> <I>&#60;bindings&#62; &#60;body&#62;</I><P>
<A NAME="IDX112"></A>

</P>
<P>
<EM>Syntax:</EM>  &#60;Bindings&#62; should have the form

<PRE>
((&#60;variable 1&#62; &#60;init 1&#62;) ...),
</PRE>

<P>
and &#60;body&#62; should be a sequence of
one or more expressions. It is an error for a &#60;variable&#62; to appear more
than once in the list of variables being bound.

</P>
<P>
<EM>Semantics:</EM>  The &#60;variable&#62;s are bound to fresh locations
holding undefined values, the &#60;init&#62;s are evaluated in the resulting
environment (in some unspecified order), each &#60;variable&#62; is assigned
to the result of the corresponding &#60;init&#62;, the &#60;body&#62; is
evaluated in the resulting environment, and the value of the last
expression in &#60;body&#62; is returned.  Each binding of a &#60;variable&#62;
has the entire <CODE>letrec</CODE> expression as its region , making it
<A NAME="IDX113"></A>
possible to define mutually recursive procedures.
<A NAME="IDX114"></A>

</P>

<PRE>

(letrec ((even?
          (lambda (n)
            (if (zero? n)
                #t
                (odd? (- n 1)))))
         (odd?
          (lambda (n)
            (if (zero? n)
                #f
                (even? (- n 1))))))
  (even? 88))
                            =>  #t
</PRE>

<P>
One restriction on <CODE>letrec</CODE> is very important: it must be possible
<A NAME="IDX115"></A>
to evaluate each &#60;init&#62; without assigning or referring to the value of any
&#60;variable&#62;.  If this restriction is violated, then it is an error.  The
restriction is necessary because Scheme passes arguments by value rather than by
name.  In the most common uses of <CODE>letrec</CODE>, all the &#60;init&#62;s are
<A NAME="IDX116"></A>
lambda expressions and the restriction is satisfied automatically.

</P>

<P>



<H3><A NAME="SEC36" HREF="r4rs_toc.html#SEC36">Sequencing</A></H3>

<P>
<U>essential syntax:</U> <B>begin</B> <I>&#60;expression 1&#62; &#60;expression 2&#62; ...</I><P>
<A NAME="IDX117"></A>

</P>
<P>
The &#60;expression&#62;s are evaluated sequentially from left to right,
and the value of the last &#60;expression&#62; is returned.  This
expression type is used to sequence side effects such as input and
output.

</P>

<PRE>
(define x 0)

(begin (set! x 5)
       (+ x 1))             =>  6

(begin (display "4 plus 1 equals ")
       (display (+ 4 1)))   =>  <EM>unspecified</EM>
        <EM>and prints</EM>  4 plus 1 equals 5
</PRE>

<P>
<EM>Note:</EM>  <A HREF="r4rs.html#BIB2">[SICP]</A> uses the keyword <CODE>sequence</CODE> instead of <CODE>begin</CODE>.
<A NAME="IDX118"></A>
<A NAME="IDX119"></A>

</P>
<P>



<H3><A NAME="SEC37" HREF="r4rs_toc.html#SEC37">Iteration</A></H3>

<P>
<U>syntax:</U> <B>do</B> <I>&#60;bindings&#62; &#60;clause&#62; &#60;body&#62;</I><P>
<A NAME="IDX120"></A>

</P>
<P>
<EM>Syntax:</EM>  &#60;Bindings&#62; should have the form

<PRE>
((&#60;variable 1&#62; &#60;init 1&#62; &#60;step 1&#62;) ...),
</PRE>

<P>
&#60;clause&#62; should be of the form

<PRE>
(&#60;test&#62; &#60;expression&#62; ...),
</PRE>

<P>
and &#60;body&#62; should be a sequence of one or more expressions.

</P>
<P>
<CODE>Do</CODE> is an iteration construct.  It specifies a set of variables to
be bound, how they are to be initialized at the start, and how they are
to be updated on each iteration.  When a termination condition is met,
the loop exits with a specified result value.

</P>
<P>
<CODE>Do</CODE> expressions are evaluated as follows:
<A NAME="IDX121"></A>
The &#60;init&#62; expressions are evaluated (in some unspecified order),
the &#60;variable&#62;s are bound to fresh locations, the results of the
&#60;init&#62; expressions are stored in the bindings of the
&#60;variable&#62;s, and then the iteration phase begins.

</P>
<P>
Each iteration begins by evaluating &#60;test&#62;; if the result is
false (see section <A HREF="r4rs.html#SEC46">Booleans</A>), then the &#60;body&#62;
expressions are evaluated in order for effect, the &#60;step&#62;
expressions are evaluated in some unspecified order, the
&#60;variable&#62;s are bound to fresh locations, the results of the
&#60;step&#62;s are stored in the bindings of the
&#60;variable&#62;s, and the next iteration begins.

</P>
<P>
If &#60;test&#62; evaluates to a true value, then the
&#60;expression&#62;s are evaluated from left to right and the value of
the last &#60;expression&#62; is returned as the value of the <CODE>do</CODE>
<A NAME="IDX122"></A>
expression.  If no &#60;expression&#62;s are present, then the value of
the <CODE>do</CODE> expression is unspecified.
<A NAME="IDX123"></A>

</P>
<P>
The region
<A NAME="IDX124"></A>
of the binding of a &#60;variable&#62; consists of the entire <CODE>do</CODE>
<A NAME="IDX125"></A>
expression except for the &#60;init&#62;s.  It is an error for a
&#60;variable&#62; to appear more than once in the list of <CODE>do</CODE>
<A NAME="IDX126"></A>
variables.

</P>
<P>
A &#60;step&#62; may be omitted, in which case the effect is the
same as if <CODE>(&#60;variable&#62; &#60;init&#62; &#60;variable&#62;)</CODE> had
been written instead of <CODE>(&#60;variable&#62; &#60;init&#62;)</CODE>.

</P>

<PRE>
(do ((vec (make-vector 5))
     (i 0 (+ i 1)))
    ((= i 5) vec)
  (vector-set! vec i i))    =>  #(0 1 2 3 4)

(let ((x '(1 3 5 7 9)))
  (do ((x x (cdr x))
       (sum 0 (+ sum (car x))))
      ((null? x) sum)))     =>  25
</PRE>

<P>

<U>syntax:</U> <B>let</B> <I>&#60;variable&#62; &#60;bindings&#62; &#60;body&#62;</I><P>
<A NAME="IDX127"></A>

</P>
<P>
Some implementations of Scheme permit a variant on the syntax of
<CODE>let</CODE> called "named <CODE>let</CODE>" which provides a more general
<A NAME="IDX128"></A>
<A NAME="IDX129"></A>
looping construct than <CODE>do</CODE>, and may also be used to express
<A NAME="IDX130"></A>
recursions.

</P>
<P>
Named <CODE>let</CODE> has the same syntax and semantics as ordinary
<A NAME="IDX131"></A>
<CODE>let</CODE> except that &#60;variable&#62; is bound within &#60;body&#62; to a
procedure whose formal arguments are the bound variables and whose body
is &#60;body&#62;.  Thus the execution of &#60;body&#62; may be repeated by
invoking the procedure named by &#60;variable&#62;.

</P>

<PRE>
(let loop ((numbers '(3 -2 1 6 -5))
           (nonneg '())
           (neg '()))
  (cond ((null? numbers) (list nonneg neg))
        ((&#62;= (car numbers) 0)
         (loop (cdr numbers)
               (cons (car numbers) nonneg)
               neg))
        ((&#60; (car numbers) 0)
         (loop (cdr numbers)
               nonneg
               (cons (car numbers) neg)))))
                            =>  ((6 1 3) (-5 -2))
</PRE>

<P>



<H3><A NAME="SEC38" HREF="r4rs_toc.html#SEC38">Delayed evaluation</A></H3>

<P>
<U>syntax:</U> <B>delay</B> <I>&#60;expression&#62;</I><P>
<A NAME="IDX132"></A>

</P>

<P>
The <CODE>delay</CODE> construct is used together with the
procedure <CODE>force</CODE> to
<A NAME="IDX133"></A>
implement <STRONG>lazy evaluation</STRONG> or <STRONG>call by need</STRONG>.
<CODE>(delay &#60;expression&#62;)</CODE> returns an object called a
<STRONG>promise</STRONG> which at some point in the future may be asked (by
the <CODE>force</CODE> procedure)
to evaluate &#60;expression&#62; and deliver the resulting value.

</P>
<P>
See the description of <CODE>force</CODE> (section <A HREF="r4rs.html#SEC60">Control features</A>) for a
<A NAME="IDX134"></A>
more complete description of <CODE>delay</CODE>.

</P>
<P>



<H3><A NAME="SEC39" HREF="r4rs_toc.html#SEC39">Quasiquotation</A></H3>

<P>
<U>essential syntax:</U> <B>quasiquote</B> <I>&#60;template&#62;</I><P>
<A NAME="IDX135"></A>
<U>essential syntax:</U> <B>`</B> <I>&#60;template&#62;</I><P>
<A NAME="IDX136"></A>

</P>
<P>
"Backquote" or "quasiquote"
<A NAME="IDX137"></A>
expressions are useful
for constructing a list or vector structure when most but not all of the
desired structure is known in advance.  If no
commas
<A NAME="IDX138"></A>
appear within the &#60;template&#62;, the result of evaluating
<CODE>`&#60;template&#62;</CODE> is equivalent to the result of evaluating
<CODE>'&#60;template&#62;</CODE>.  If a comma
<A NAME="IDX139"></A>
appears within the
&#60;template&#62;, however, the expression following the comma is
evaluated ("unquoted") and its result is inserted into the structure
instead of the comma and the expression.  If a comma appears followed
immediately by an at-sign (@),
<A NAME="IDX140"></A>
then the following
expression must evaluate to a list; the opening and closing parentheses
of the list are then "stripped away" and the elements of the list are
inserted in place of the comma at-sign expression sequence.

</P>
<P>
<A NAME="IDX141"></A>

</P>

<PRE>
`(list ,(+ 1 2) 4)          =>  (list 3 4)
(let ((name 'a)) `(list ,name ',name))
                            =>  (list a (quote a))
`(a ,(+ 1 2) ,@(map abs '(4 -5 6)) b)
                            =>  (a 3 4 5 6 b)
`((<CODE>foo</CODE> ,(- 10 3)) ,@(cdr '(c)) . ,(car '(cons)))
<A NAME="IDX142"></A>                            =>  ((foo 7) . cons)
`#(10 5 ,(sqrt 4) ,@(map sqrt '(16 9)) 8)
                            =>  #(10 5 2 4 3 8)
</PRE>

<P>
Quasiquote forms may be nested.  Substitutions are made only for
unquoted components appearing at the same nesting level
as the outermost backquote.  The nesting level increases by one inside
each successive quasiquotation, and decreases by one inside each
unquotation.

</P>

<PRE>
`(a `(b ,(+ 1 2) ,(foo ,(+ 1 3) d) e) f)
                            =>  (a `(b ,(+ 1 2) ,(foo 4 d) e) f)
(let ((name1 'x)
      (name2 'y))
  `(a `(b ,,name1 ,',name2 d) e))
                            =>  (a `(b ,x ,'y d) e)
</PRE>

<P>
<A NAME="IDX143"></A>
The notations <CODE>`&#60;template&#62;</CODE> and
<CODE>(quasiquote &#60;template&#62;)</CODE> are identical in all respects.
<CODE>,&#60;expression&#62;</CODE> is identical to <CODE>(unquote
&#60;expression&#62;)</CODE>, and <CODE>,&#60;expression&#62;</CODE> is identical to
<CODE>(unquote-splicing &#60;expression&#62;)</CODE>.  The external syntax
generated by <CODE>write</CODE> for two-element lists whose
<A NAME="IDX144"></A>
car is one of these symbols may vary between implementations.

</P>


<PRE>
(quasiquote (list (unquote (+ 1 2)) 4))
                            =>  (list 3 4)
'(quasiquote (list (unquote (+ 1 2)) 4))
                            =>  `(list ,(+ 1 2) 4)
     <EM>i.e.,</EM> (quasiquote (list (unquote (+ 1 2)) 4))
</PRE>

<P>
Unpredictable behavior can result if any of the symbols
<CODE>quasiquote</CODE>, <CODE>unquote</CODE>, or <CODE>unquote-splicing</CODE>
<A NAME="IDX145"></A>
<A NAME="IDX146"></A>
appear in
<A NAME="IDX147"></A>
positions within a &#60;template&#62; otherwise than as described above.

</P>
<P>



<H1><A NAME="SEC40" HREF="r4rs_toc.html#SEC40">Program structure</A></H1>



<H2><A NAME="SEC41" HREF="r4rs_toc.html#SEC41">Programs</A></H2>

<P>
A Scheme program consists of a sequence of expressions and definitions.
Expressions are described in section <A HREF="r4rs.html#SEC25">Expressions</A>;
definitions are the subject of the rest of the present chapter.

</P>
<P>
Programs are typically stored in files or entered interactively to a
running Scheme system, although other paradigms are possible;
questions of user interface lie outside the scope of this report.
(Indeed, Scheme would still be useful as a notation for expressing
computational methods even in the absence of a mechanical
implementation.)

</P>
<P>
Definitions occurring at the top level of a program can be interpreted
declaratively.  They cause bindings to be created in the top level
environment.  Expressions occurring at the top level of a program are
interpreted imperatively; they are executed in order when the program is
invoked or loaded, and typically perform some kind of initialization.

</P>



<H2><A NAME="SEC42" HREF="r4rs_toc.html#SEC42">Definitions</A></H2>

<P>
Definitions are valid in some, but not all, contexts where expressions
are allowed.  They are valid only at the top level of a &#60;program&#62;
and, in some implementations, at the beginning of a &#60;body&#62;.
<A NAME="IDX148"></A>

</P>
<P>
A definition should have one of the following forms:
<A NAME="IDX149"></A>

</P>

<UL>

<LI><CODE>(define &#60;variable&#62; &#60;expression&#62;)</CODE>

This syntax is essential.

<LI><CODE>(define (&#60;variable&#62; &#60;formals&#62;) &#60;body&#62;)</CODE>

This syntax is not essential.  &#60;Formals&#62; should be either a
sequence of zero or more variables, or a sequence of one or more
variables followed by a space-delimited period and another variable (as
in a lambda expression).  This form is equivalent to

<PRE>
(define &#60;variable&#62;
  (lambda (&#60;formals&#62;) &#60;body&#62;)).
</PRE>

<LI><CODE>(define (&#60;variable&#62; . &#60;formal&#62;) &#60;body&#62;)</CODE>

This syntax is not essential.  &#60;Formal&#62; should be a single
variable.  This form is equivalent to

<PRE>
(define &#60;variable&#62;
  (lambda &#60;formal&#62; &#60;body&#62;)).
</PRE>

<LI><CODE>(begin &#60;definition 1&#62; ...)</CODE>

This syntax is essential.  This form is equivalent to the set of
definitions that form the body of the <CODE>begin</CODE>.
<A NAME="IDX150"></A>

</UL>



<H3><A NAME="SEC43" HREF="r4rs_toc.html#SEC43">Top level definitions</A></H3>

<P>
At the top level of a program, a definition

<PRE>
(define &#60;variable&#62; &#60;expression&#62;)
</PRE>

<P>
has essentially the same effect as the assignment expression

<PRE>
(set! &#60;variable&#62; &#60;expression&#62;)
<A NAME="IDX151"></A></PRE>

<P>
if &#60;variable&#62; is bound.  If &#60;variable&#62; is not bound,
however, then the definition will bind &#60;variable&#62; to a new
location before performing the assignment, whereas it would be an error
to perform a <CODE>set!</CODE> on an unbound
<A NAME="IDX152"></A>
<A NAME="IDX153"></A>
variable.

</P>

<PRE>
(define add3
  (lambda (x) (+ x 3)))
(add3 3)                    =>  6
(define first car)
(first '(1 2))              =>  1
</PRE>

<P>
All Scheme implementations must support top level definitions.

</P>
<P>
Some implementations of Scheme use an initial environment in
which all possible variables are bound to locations, most of
which contain undefined values.  Top level definitions in
such an implementation are truly equivalent to assignments.

</P>



<H3><A NAME="SEC44" HREF="r4rs_toc.html#SEC44">Internal definitions</A></H3>

<P>
Some implementations of Scheme permit definitions to occur at the
beginning of a &#60;body&#62; (that is, the body of a <CODE>lambda</CODE>,
<CODE>let</CODE>, <CODE>let*</CODE>, <CODE>letrec</CODE>, or <CODE>define</CODE>
<A NAME="IDX154"></A>
<A NAME="IDX155"></A>
<A NAME="IDX156"></A>
<A NAME="IDX157"></A>
expression).  Such
<A NAME="IDX158"></A>
definitions are known as <EM>internal definitions</EM>
<A NAME="IDX159"></A>
as opposed to the top level definitions described above.
The variable defined by an internal definition is local to the
&#60;body&#62;.  That is, &#60;variable&#62; is bound rather than assigned,
and the region of the binding is the entire &#60;body&#62;.  For example,

</P>

<PRE>
(let ((x 5))
  (define foo (lambda (y) (bar x y)))
  (define bar (lambda (a b) (+ (* a b) a)))
  (foo (+ x 3)))            =>  45
</PRE>

<P>
A &#60;body&#62; containing internal definitions can always be converted
into a completely equivalent <CODE>letrec</CODE> expression.  For example, the
<A NAME="IDX160"></A>
<CODE>let</CODE> expression in the above example is equivalent to
<A NAME="IDX161"></A>

</P>

<PRE>
(let ((x 5))
  (letrec ((foo (lambda (y) (bar x y)))
           (bar (lambda (a b) (+ (* a b) a))))
    (foo (+ x 3))))
</PRE>

<P>
Just as for the equivalent <CODE>letrec</CODE> expression, it must be
<A NAME="IDX162"></A>
possible to evaluate each &#60;expression&#62; of every internal
definition in a &#60;body&#62; without assigning or referring to
the value of any &#60;variable&#62; being defined.

</P>



<H1><A NAME="SEC45" HREF="r4rs_toc.html#SEC45">Standard procedures</A></H1>

<P>
<A NAME="IDX163"></A>
<A NAME="IDX164"></A>

</P>
<P>
This chapter describes Scheme's built-in procedures.  The initial (or
"top level") Scheme environment starts out with a number of variables
bound to locations containing useful values, most of which are primitive
procedures that manipulate data.  For example, the variable <CODE>abs</CODE>
is
<A NAME="IDX165"></A>
bound to (a location initially containing) a procedure of one argument
that computes the absolute value of a number, and the variable <CODE>+</CODE>
<A NAME="IDX166"></A>
is bound to a procedure that computes sums.

</P>



<H2><A NAME="SEC46" HREF="r4rs_toc.html#SEC46">Booleans</A></H2>

<P>
The standard boolean objects for true and false are written as
<CODE>#t</CODE> and <CODE>#f</CODE>.
<A NAME="IDX167"></A>
<A NAME="IDX168"></A>
What really matters, though, are the objects that the Scheme conditional
expressions (<CODE>if</CODE>, <CODE>cond</CODE>, <CODE>and</CODE>, <CODE>or</CODE>, <CODE>do</CODE>)
treat as true or false.
<A NAME="IDX169"></A>
<A NAME="IDX170"></A>
<A NAME="IDX171"></A>
<A NAME="IDX172"></A>
<A NAME="IDX173"></A>
<A NAME="IDX174"></A>
<A NAME="IDX175"></A>
The phrase "a true value" (or sometimes just "true") means any
object treated as true by the conditional expressions, and the phrase
"a false value" (or "false") means any object treated as false by
the conditional expressions.

</P>
<P>
Of all the standard Scheme values, only <CODE>#f</CODE>
counts as false in conditional expressions.
Except for <CODE>#f</CODE>,
all standard Scheme values, including <CODE>#t</CODE>,
pairs, the empty list, symbols, numbers, strings, vectors, and procedures,
count as true.

</P>
<P>
<EM>Note:</EM>  In some implementations the empty list counts as false, contrary
to the above.
Nonetheless a few examples in this report assume that the
empty list counts as true, as in [IEEESCHEME].

</P>

<P>
<EM>Note:</EM>  Programmers accustomed to other dialects of Lisp should be aware that
Scheme distinguishes both <CODE>#f</CODE> and the empty list from the symbol
<CODE>nil</CODE>.
<A NAME="IDX176"></A>

</P>
<P>
Boolean constants evaluate to themselves, so they don't need to be quoted
in programs.

</P>

<PRE>
#t                          =>  #t
#f                          =>  #f
'#f                         =>  #f
</PRE>

<P>
<U>essential procedure:</U> <B>not</B> <I>obj</I><P>
<A NAME="IDX177"></A>

</P>
<P>
<CODE>Not</CODE> returns <CODE>#t</CODE> if <VAR>obj</VAR> is false, and returns
<A NAME="IDX178"></A>
<CODE>#f</CODE> otherwise.

</P>

<PRE>
(not #t)                    =>  #f
(not 3)                     =>  #f
(not (list 3))              =>  #f
(not #f)                    =>  #t
(not '())                   =>  #f
(not (list))                =>  #f
(not 'nil)                  =>  #f
</PRE>

<P>

<U>essential procedure:</U> <B>boolean?</B> <I>obj</I><P>
<A NAME="IDX179"></A>

</P>
<P>
<CODE>Boolean?</CODE> returns <CODE>#t</CODE> if <VAR>obj</VAR> is either <CODE>#t</CODE> or
<A NAME="IDX180"></A>
<CODE>#f</CODE> and returns <CODE>#f</CODE> otherwise.

</P>

<PRE>
(boolean? #f)               =>  #t
(boolean? 0)                =>  #f
(boolean? '())              =>  #f
</PRE>

<P>



<H2><A NAME="SEC47" HREF="r4rs_toc.html#SEC47">Equivalence predicates</A></H2>

<P>
A <STRONG>predicate</STRONG> is a procedure that always returns a boolean
value (<CODE>#t</CODE> or <CODE>#f</CODE>).  An <STRONG>equivalence predicate</STRONG> is
the computational analogue of a mathematical equivalence relation (it is
symmetric, reflexive, and transitive).  Of the equivalence predicates
described in this section, <CODE>eq?</CODE> is the finest or most
<A NAME="IDX181"></A>
discriminating, and <CODE>equal?</CODE> is the coarsest.  <CODE>Eqv?</CODE> is
<A NAME="IDX182"></A>
<A NAME="IDX183"></A>
slightly less discriminating than <CODE>eq?</CODE>.
<A NAME="IDX184"></A>

</P>
<P>
<U>essential procedure:</U> <B>eqv?</B> <I>obj1 obj2</I><P>
<A NAME="IDX185"></A>

</P>
<P>
The <CODE>eqv?</CODE> procedure defines a useful equivalence relation on
objects.
<A NAME="IDX186"></A>
Briefly, it returns <CODE>#t</CODE> if <VAR>obj1</VAR> and <VAR>obj2</VAR> should
normally be regarded as the same object.  This relation is left slightly
open to interpretation, but the following partial specification of
<CODE>eqv?</CODE> holds for all implementations of Scheme.
<A NAME="IDX187"></A>

</P>
<P>
The <CODE>eqv?</CODE> procedure returns <CODE>#t</CODE> if:
<A NAME="IDX188"></A>

</P>

<UL>
<LI><VAR>obj1</VAR> and <VAR>obj2</VAR> are both <CODE>#t</CODE> or both <CODE>#f</CODE>.

<LI><VAR>obj1</VAR> and <VAR>obj2</VAR> are both symbols and


<PRE>
(string=? (symbol-&#62;string obj1)
          (symbol-&#62;string obj2))
                            =>  #t
</PRE>

<EM>Note:</EM>  This assumes that neither <VAR>obj1</VAR> nor <VAR>obj2</VAR> is an "uninterned
symbol" as alluded to in section <A HREF="r4rs.html#SEC49">Symbols</A>.  This report does
not presume to specify the behavior of <CODE>eqv?</CODE> on
implementation-dependent
<A NAME="IDX189"></A>
extensions.

<LI><VAR>obj1</VAR> and <VAR>obj2</VAR> are both numbers, are numerically

equal (see <CODE>=</CODE>, section <A HREF="r4rs.html#SEC50">Numbers</A>), and are either both
<A NAME="IDX190"></A>
exact or both inexact.
<A NAME="IDX191"></A>
<A NAME="IDX192"></A>

<LI><VAR>obj1</VAR> and <VAR>obj2</VAR> are both characters and are the same

character according to the <CODE>char=?</CODE> procedure (section <A HREF="r4rs.html#SEC57">Characters</A>).
<A NAME="IDX193"></A>

<LI>both <VAR>obj1</VAR> and <VAR>obj2</VAR> are the empty list.

<LI><VAR>obj1</VAR> and <VAR>obj2</VAR> are pairs, vectors, or strings that denote the

same locations in the store (section <A HREF="r4rs.html#SEC24">Storage model</A>).

<LI><VAR>obj1</VAR> and <VAR>obj2</VAR> are procedures whose location tags are

equal (section <A HREF="r4rs.html#SEC30">Lambda expressions</A>).
</UL>

<P>
The <CODE>eqv?</CODE> procedure returns <CODE>#f</CODE> if:
<A NAME="IDX194"></A>

</P>

<UL>
<LI><VAR>obj1</VAR> and <VAR>obj2</VAR> are of different types

(section <A HREF="r4rs.html#SEC23">Disjointness of types</A>).

<LI>one of <VAR>obj1</VAR> and <VAR>obj2</VAR> is <CODE>#t</CODE> but the other is

<CODE>#f</CODE>.

<LI><VAR>obj1</VAR> and <VAR>obj2</VAR> are symbols but


<PRE>
(string=? (symbol-&#62;string <VAR>obj1</VAR>)
          (symbol-&#62;string <VAR>obj2</VAR>))
                            =>  #f
</PRE>

<LI>one of <VAR>obj1</VAR> and <VAR>obj2</VAR> is an exact number but the other

is an inexact number.

<LI><VAR>obj1</VAR> and <VAR>obj2</VAR> are numbers for which the <CODE>=</CODE>

<A NAME="IDX195"></A>
procedure returns <CODE>#f</CODE>.

<LI><VAR>obj1</VAR> and <VAR>obj2</VAR> are characters for which the

<CODE>char=?</CODE>
<A NAME="IDX196"></A>
procedure returns <CODE>#f</CODE>.

<LI>one of <VAR>obj1</VAR> and <VAR>obj2</VAR> is the empty list but the other

is not.

<LI><VAR>obj1</VAR> and <VAR>obj2</VAR> are pairs, vectors, or strings that denote

distinct locations.

<LI><VAR>obj1</VAR> and <VAR>obj2</VAR> are procedures that would behave differently

(return a different value or have different side effects) for some arguments.

</UL>


<PRE>
(eqv? 'a 'a)                =>  #t
(eqv? 'a 'b)                =>  #f
(eqv? 2 2)                  =>  #t
(eqv? '() '())              =>  #t
(eqv? 100000000 100000000)  =>  #t
(eqv? (cons 1 2) (cons 1 2))=>  #f
(eqv? (lambda () 1)
      (lambda () 2))        =>  #f
(eqv? #f 'nil)              =>  #f
(let ((p (lambda (x) x)))
  (eqv? p p))               =>  #t
</PRE>

<P>
The following examples illustrate cases in which the above rules do
not fully specify the behavior of <CODE>eqv?</CODE>.  All that can be said
<A NAME="IDX197"></A>
about such cases is that the value returned by <CODE>eqv?</CODE> must be a
<A NAME="IDX198"></A>
boolean.

</P>

<PRE>
(eqv? "" "")                =>  <EM>unspecified</EM>
(eqv? '#() '#())            =>  <EM>unspecified</EM>
(eqv? (lambda (x) x)
      (lambda (x) x))       =>  <EM>unspecified</EM>
(eqv? (lambda (x) x)
      (lambda (y) y))       =>  <EM>unspecified</EM>
</PRE>

<P>
The next set of examples shows the use of <CODE>eqv?</CODE> with procedures
<A NAME="IDX199"></A>
that have local state.  <CODE>Gen-counter</CODE> must return a distinct
<A NAME="IDX200"></A>
procedure every time, since each procedure has its own internal counter.
<CODE>Gen-loser</CODE>, however, returns equivalent procedures each time,
since
<A NAME="IDX201"></A>
the local state does not affect the value or side effects of the
procedures.

</P>

<PRE>
(define gen-counter
  (lambda ()
    (let ((n 0))
      (lambda () (set! n (+ n 1)) n))))
(let ((g (gen-counter)))
  (eqv? g g))               =>  #t
(eqv? (gen-counter) (gen-counter))
                            =>  #f
(define gen-loser
  (lambda ()
    (let ((n 0))
      (lambda () (set! n (+ n 1)) 27))))
(let ((g (gen-loser)))
  (eqv? g g))               =>  #t
(eqv? (gen-loser) (gen-loser))
                            =>  <EM>unspecified</EM>

(letrec ((f (lambda () (if (eqv? f g) 'both 'f)))
         (g (lambda () (if (eqv? f g) 'both 'g)))
  (eqv? f g))
                            =>  <EM>unspecified</EM>

(letrec ((f (lambda () (if (eqv? f g) 'f 'both)))
         (g (lambda () (if (eqv? f g) 'g 'both)))
  (eqv? f g))
                            =>  #f
</PRE>

<P>
Since it is an error to modify constant objects (those returned by
literal expressions), implementations are permitted, though not
required, to share structure between constants where appropriate.  Thus
the value of <CODE>eqv?</CODE> on constants is sometimes
<A NAME="IDX202"></A>
implementation-dependent.

</P>

<PRE>
(eqv? '(a) '(a))            =>  <EM>unspecified</EM>
(eqv? "a" "a")              =>  <EM>unspecified</EM>
(eqv? '(b) (cdr '(a b)))    =>  <EM>unspecified</EM>
(let ((x '(a)))
  (eqv? x x))               =>  #t
</PRE>

<P>
<EM>Rationale:</EM>  The above definition of <CODE>eqv?</CODE> allows implementations latitude in
<A NAME="IDX203"></A>
their treatment of procedures and literals:  implementations are free
either to detect or to fail to detect that two procedures or two literals
are equivalent to each other, and can decide whether or not to
merge representations of equivalent objects by using the same pointer or
bit pattern to represent both.

</P>
<P>

<U>essential procedure:</U> <B>eq?</B> <I>obj1 obj2</I><P>
<A NAME="IDX204"></A>

</P>
<P>
<CODE>Eq?</CODE> is similar to <CODE>eqv?</CODE> except that in some cases it
<A NAME="IDX205"></A>
is
<A NAME="IDX206"></A>
capable of discerning distinctions finer than those detectable by
<CODE>eqv?</CODE>.
<A NAME="IDX207"></A>

</P>
<P>
<CODE>Eq?</CODE> and <CODE>eqv?</CODE> are guaranteed to have the same
<A NAME="IDX208"></A>
<A NAME="IDX209"></A>
behavior on symbols, booleans, the empty list, pairs, and non-empty
strings and vectors.  <CODE>Eq?</CODE>'s behavior on numbers and characters is
<A NAME="IDX210"></A>
implementation-dependent, but it will always return either true or
false, and will return true only when <CODE>eqv?</CODE> would also return
<A NAME="IDX211"></A>
true.  <CODE>Eq?</CODE> may also behave differently from <CODE>eqv?</CODE> on
<A NAME="IDX212"></A>
empty
<A NAME="IDX213"></A>
vectors and empty strings.

</P>

<PRE>
(eq? 'a 'a)                 =>  #t
(eq? '(a) '(a))             =>  <EM>unspecified</EM>
(eq? (list 'a) (list 'a))   =>  #f
(eq? "a" "a")               =>  <EM>unspecified</EM>
(eq? "" "")                 =>  <EM>unspecified</EM>
(eq? '() '())               =>  #t
(eq? 2 2)                   =>  <EM>unspecified</EM>
(eq? #\A #\A)               =>  <EM>unspecified</EM>
(eq? car car)               =>  #t
(let ((n (+ 2 3)))
  (eq? n n))                =>  <EM>unspecified</EM>
(let ((x '(a)))
  (eq? x x))                =>  #t
(let ((x '#()))
  (eq? x x))                =>  #t
(let ((p (lambda (x) x)))
  (eq? p p))                =>  #t
</PRE>

<P>
<EM>Rationale:</EM>  It will usually be possible to implement <CODE>eq?</CODE>
much
<A NAME="IDX214"></A>
more efficiently than <CODE>eqv?</CODE>, for example, as a simple pointer
<A NAME="IDX215"></A>
comparison instead of as some more complicated operation.  One reason is
that it may not be possible to compute <CODE>eqv?</CODE> of two numbers in
<A NAME="IDX216"></A>
constant time, whereas <CODE>eq?</CODE> implemented as pointer comparison
will
<A NAME="IDX217"></A>
always finish in constant time.  <CODE>Eq?</CODE> may be used like <CODE>eqv?</CODE>
<A NAME="IDX218"></A>
in applications using procedures to implement objects with state since
it obeys the same constraints as <CODE>eqv?</CODE>.
<A NAME="IDX219"></A>

</P>
<P>

<U>essential procedure:</U> <B>equal?</B> <I>obj1 obj2</I><P>
<A NAME="IDX220"></A>

</P>
<P>
<CODE>Equal?</CODE> recursively compares the contents of pairs, vectors, and
<A NAME="IDX221"></A>
strings, applying <CODE>eqv?</CODE> on other objects such as numbers and
symbols.
<A NAME="IDX222"></A>
A rule of thumb is that objects are generally <CODE>equal?</CODE> if they
print
<A NAME="IDX223"></A>
the same.  <CODE>Equal?</CODE> may fail to terminate if its arguments are
<A NAME="IDX224"></A>
circular data structures.

</P>

<PRE>
(equal? 'a 'a)              =>  #t
(equal? '(a) '(a))          =>  #t
(equal? '(a (b) c)
        '(a (b) c))         =>  #t
(equal? "abc" "abc")        =>  #t
(equal? 2 2)                =>  #t
(equal? (make-vector 5 'a)
        (make-vector 5 'a)) =>  #t
(equal? (lambda (x) x)
        (lambda (y) y))     =>  <EM>unspecified</EM>
</PRE>

<P>



<H2><A NAME="SEC48" HREF="r4rs_toc.html#SEC48">Pairs and lists</A></H2>

<P>
A <STRONG>pair</STRONG> (sometimes called a <STRONG>dotted pair</STRONG>) is a
record structure with two fields called the car and cdr fields (for
historical reasons).  Pairs are created by the procedure <CODE>cons</CODE>.
<A NAME="IDX225"></A>
The car and cdr fields are accessed by the procedures <CODE>car</CODE> and
<A NAME="IDX226"></A>
<CODE>cdr</CODE>.  The car and cdr fields are assigned by the procedures
<A NAME="IDX227"></A>
<CODE>set-car!</CODE> and <CODE>set-cdr!</CODE>.
<A NAME="IDX228"></A>
<A NAME="IDX229"></A>

</P>
<P>
Pairs are used primarily to represent lists.  A list can be defined
recursively as either the empty list
<A NAME="IDX230"></A>
or a pair whose cdr is a list.  More precisely, the set of lists is
defined as the smallest set <VAR>X</VAR> such that

</P>

<UL>
<LI>The empty list is in <VAR>X</VAR>.

<LI>If <VAR>list</VAR> is in <VAR>X</VAR>, then any pair whose cdr field contains

      <VAR>list</VAR> is also in <VAR>X</VAR>.
</UL>

<P>
The objects in the car fields of successive pairs of a list are the
elements of the list.  For example, a two-element list is a pair whose car
is the first element and whose cdr is a pair whose car is the second element
and whose cdr is the empty list.  The length of a list is the number of
elements, which is the same as the number of pairs.

</P>
<P>
The empty list
<A NAME="IDX231"></A>
is a special object of its own type (it is not a pair); it has no
elements and its length is zero.

</P>
<P>
<EM>Note:</EM>  The above definitions imply that all lists have finite length and are
terminated by the empty list.

</P>
<P>
The most general notation (external representation) for Scheme pairs is
the "dotted" notation <CODE>(<VAR>c1</VAR> . <VAR>c2</VAR>)</CODE> where
<VAR>c1</VAR> is the value of the car field and <VAR>c2</VAR> is the value of the
cdr field.  For example <CODE>(4 . 5)</CODE> is a pair whose car is 4
and whose cdr is 5.  Note that <CODE>(4 . 5)</CODE> is the external
representation of a pair, not an expression that evaluates to a pair.

</P>
<P>
A more streamlined notation can be used for lists: the elements of the
list are simply enclosed in parentheses and separated by spaces.  The
empty list
<A NAME="IDX232"></A>
is written <CODE>()</CODE>.  For example,

</P>

<PRE>
(a b c d e)
</PRE>

<P>
and

</P>

<PRE>
(a . (b . (c . (d . (e . ())))))
</PRE>

<P>
are equivalent notations for a list of symbols.

</P>
<P>
A chain of pairs not ending in the empty list is called an
<STRONG>improper list</STRONG>.  Note that an improper list is not a list.
The list and dotted notations can be combined to represent
improper lists:

</P>

<PRE>
(a b c . d)
</PRE>

<P>
is equivalent to

</P>

<PRE>
(a . (b . (c . d)))
</PRE>

<P>
Whether a given pair is a list depends upon what is stored in the cdr
field.  When the <CODE>set-cdr!</CODE> procedure is used, an object can be a
<A NAME="IDX233"></A>
list one moment and not the next:

</P>

<PRE>
(define x (list 'a 'b 'c))
(define y x)
y                           =>  (a b c)
(list? y)                   =>  #t
(set-cdr! x 4)              =>  <EM>unspecified</EM>
x                           =>  (a . 4)
(eqv? x y)                  =>  #t
y                           =>  (a . 4)
(list? y)                   =>  #f
(set-cdr! x x)              =>  <EM>unspecified</EM>
(list? x)                   =>  #f
</PRE>

<P>
Within literal expressions and representations of objects read by the
<CODE>read</CODE> procedure, the forms <CODE>'&#60;datum&#62;</CODE>,<CODE>`&#60;datum&#62;</CODE>,
<CODE>,&#60;datum&#62;</CODE>, and <CODE>,@&#60;datum&#62;</CODE> denote two-element lists
<A NAME="IDX234"></A>
<A NAME="IDX235"></A>
<A NAME="IDX236"></A>
<A NAME="IDX237"></A>
whose first elements are the symbols <CODE>quote</CODE>, <CODE>quasiquote</CODE>,
<CODE>unquote</CODE>, and
<A NAME="IDX238"></A>
<A NAME="IDX239"></A>
<A NAME="IDX240"></A>
<A NAME="IDX241"></A>
<CODE>unquote-splicing</CODE>, respectively.  The second element in each case
is &#60;datum&#62;.  This convention is supported so that arbitrary Scheme
programs may be represented as lists.
That is, according to Scheme's grammar, every
&#60;expression&#62; is also a &#60;datum&#62; (see section <A HREF="r4rs.html#SEC22">External representations</A>).
Among other things, this permits the use of the <CODE>read</CODE> procedure to
<A NAME="IDX242"></A>
parse Scheme programs.  See section <A HREF="r4rs.html#SEC22">External representations</A>.

</P>
<P>
<U>essential procedure:</U> <B>pair?</B> <I>obj</I><P>
<A NAME="IDX243"></A>

</P>
<P>
<CODE>Pair?</CODE> returns <CODE>#t</CODE> if <VAR>obj</VAR> is a pair, and otherwise
<A NAME="IDX244"></A>
returns <CODE>#f</CODE>.

</P>

<PRE>
(pair? '(a . b))            =>  #t
(pair? '(a b c))            =>  #t
(pair? '())                 =>  #f
(pair? '#(a b))             =>  #f
</PRE>

<P>

<U>essential procedure:</U> <B>cons</B> <I>obj1 obj2</I><P>
<A NAME="IDX245"></A>

</P>
<P>
Returns a newly allocated pair whose car is <VAR>obj1</VAR> and whose cdr is
<VAR>obj2</VAR>.  The pair is guaranteed to be different (in the sense of
<CODE>eqv?</CODE>) from every existing object.
<A NAME="IDX246"></A>

</P>

<PRE>
(cons 'a '())               =>  (a)
(cons '(a) '(b c d))        =>  ((a) b c d)
(cons "a" '(b c))           =>  ("a" b c)
(cons 'a 3)                 =>  (a . 3)
(cons '(a b) 'c)            =>  ((a b) . c)
</PRE>

<P>

<U>essential procedure:</U> <B>car</B> <I>pair</I><P>
<A NAME="IDX247"></A>

</P>
<P>
Returns the contents of the car field of <VAR>pair</VAR>.  Note that it is an
error to take the car of the empty list.
<A NAME="IDX248"></A>

</P>

<PRE>
(car '(a b c))              =>  a
(car '((a) b c d))          =>  (a)
(car '(1 . 2))              =>  1
(car '())                   =>  <EM>error</EM>
</PRE>

<P>

<U>essential procedure:</U> <B>cdr</B> <I>pair</I><P>
<A NAME="IDX249"></A>

</P>
<P>
Returns the contents of the cdr field of <VAR>pair</VAR>.
Note that it is an error to take the cdr of the empty list.

</P>

<PRE>
(cdr '((a) b c d))          =>  (b c d)
(cdr '(1 . 2))              =>  2
(cdr '())                   =>  <EM>error</EM>
</PRE>

<P>

<U>essential procedure:</U> <B>set-car!</B> <I>pair obj</I><P>
<A NAME="IDX250"></A>

</P>
<P>
Stores <VAR>obj</VAR> in the car field of <VAR>pair</VAR>.
The value returned by <CODE>set-car!</CODE> is unspecified.  
<A NAME="IDX251"></A>

</P>

<PRE>
(define (f) (list 'not-a-constant-list))
(define (g) '(constant-list))
(set-car! (f) 3)            =>  <EM>unspecified</EM>
(set-car! (g) 3)            =>  <EM>error</EM>
</PRE>

<P>

<U>essential procedure:</U> <B>set-cdr!</B> <I>pair obj</I><P>
<A NAME="IDX252"></A>

</P>
<P>
Stores <VAR>obj</VAR> in the cdr field of <VAR>pair</VAR>.
The value returned by <CODE>set-cdr!</CODE> is unspecified.  
<A NAME="IDX253"></A>

</P>
<P>

<U>essential procedure:</U> <B>caar</B> <I>pair</I><P>
<A NAME="IDX254"></A>
<U>essential procedure:</U> <B>cadr</B> <I>pair</I><P>
<A NAME="IDX255"></A>
...
<U>essential procedure:</U> <B>cdddar</B> <I>pair</I><P>
<A NAME="IDX256"></A>
<U>essential procedure:</U> <B>cddddr</B> <I>pair</I><P>
<A NAME="IDX257"></A>

</P>
<P>
These procedures are compositions of <CODE>car</CODE> and <CODE>cdr</CODE>, where
<A NAME="IDX258"></A>
<A NAME="IDX259"></A>
for example <CODE>caddr</CODE> could be defined by
<A NAME="IDX260"></A>

</P>

<PRE>
(define caddr (lambda (x) (car (cdr (cdr x))))).
</PRE>

<P>
Arbitrary compositions, up to four deep, are provided.  There are
twenty-eight of these procedures in all.

</P>
<P>

<U>essential procedure:</U> <B>null?</B> <I>obj</I><P>
<A NAME="IDX261"></A>

</P>
<P>
Returns <CODE>#t</CODE> if <VAR>obj</VAR> is the empty list, otherwise returns
<CODE>#f</CODE>.
<A NAME="IDX262"></A>

</P>
<P>
<A NAME="IDX263"></A>

</P>
<P>

<U>essential procedure:</U> <B>list?</B> <I>obj</I><P>
<A NAME="IDX264"></A>

</P>
<P>
Returns <CODE>#t</CODE> if <VAR>obj</VAR> is a list, otherwise returns <CODE>#f</CODE>.
By definition, all lists have finite length and are terminated by
the empty list.

</P>

<PRE>
        (list? '(a b c))    =>  #t
        (list? '())         =>  #t
        (list? '(a . b))    =>  #f
        (let ((x (list 'a)))
          (set-cdr! x x)
          (list? x))        =>  #f
</PRE>

<P>

<U>essential procedure:</U> <B>list</B> <I>obj ...</I><P>
<A NAME="IDX265"></A>

</P>
<P>
Returns a newly allocated list of its arguments.

</P>

<PRE>
(list 'a (+ 3 4) 'c)        =>  (a 7 c)
(list)                      =>  ()
</PRE>

<P>

<U>essential procedure:</U> <B>length</B> <I>list</I><P>
<A NAME="IDX266"></A>

</P>
<P>
Returns the length of <VAR>list</VAR>.

</P>

<PRE>
(length '(a b c))           =>  3
(length '(a (b) (c d e)))   =>  3
(length '())                =>  0
</PRE>

<P>

<U>essential procedure:</U> <B>append</B> <I>list ...</I><P>
<A NAME="IDX267"></A>

</P>
<P>
Returns a list consisting of the elements of the first <VAR>list</VAR>
followed by the elements of the other <VAR>list</VAR>s.

</P>

<PRE>
(append '(x) '(y))          =>  (x y)
(append '(a) '(b c d))      =>  (a b c d)
(append '(a (b)) '((c)))    =>  (a (b) (c))
</PRE>

<P>
The resulting list is always newly allocated, except that it shares
structure with the last <VAR>list</VAR> argument.  The last argument may
actually be any object; an improper list results if the last argument is not a
proper list.

</P>

<PRE>
(append '(a b) '(c . d))    =>  (a b c . d)
(append '() 'a)             =>  a
</PRE>

<P>

<U>essential procedure:</U> <B>reverse</B> <I>list</I><P>
<A NAME="IDX268"></A>

</P>
<P>
Returns a newly allocated list consisting of the elements of <VAR>list</VAR>
in reverse order.

</P>

<PRE>
(reverse '(a b c))          =>  (c b a)
(reverse '(a (b c) d (e (f))))  
                            =>  ((e (f)) d (b c) a)
</PRE>

<P>

<U>procedure:</U> <B>list-tail</B> <I>list k</I><P>
<A NAME="IDX269"></A>

</P>
<P>
Returns the sublist of <VAR>list</VAR> obtained by omitting the first <VAR>k</VAR>
elements.
<CODE>List-tail</CODE> could be defined by
<A NAME="IDX270"></A>

</P>

<PRE>
(define list-tail
  (lambda (x k)
    (if (zero? k)
        x
        (list-tail (cdr x) (- k 1)))))
</PRE>

<P>

<U>essential procedure:</U> <B>list-ref</B> <I>list k</I><P>
<A NAME="IDX271"></A>

</P>
<P>
Returns the <VAR>k</VAR>th element of <VAR>list</VAR>.  (This is the same
as the car of <CODE>(list-tail <VAR>list</VAR> <VAR>k</VAR>)</CODE>.)

</P>

<PRE>
(list-ref '(a b c d) 2)     =>  c
(list-ref '(a b c d)
          (inexact-&#62;exact (round 1.8))) 
                            =>  c
</PRE>

<P>

<U>essential procedure:</U> <B>memq</B> <I>obj list</I><P>
<A NAME="IDX272"></A>
<U>essential procedure:</U> <B>memv</B> <I>obj list</I><P>
<A NAME="IDX273"></A>
<U>essential procedure:</U> <B>member</B> <I>obj list</I><P>
<A NAME="IDX274"></A>

</P>
<P>
These procedures return the first sublist of <VAR>list</VAR> whose car is
<VAR>obj</VAR>, where the sublists of <VAR>list</VAR> are the non-empty lists
returned by <CODE>(list-tail <VAR>list</VAR> <VAR>k</VAR>)</CODE> for <VAR>k</VAR> less
than the length of <VAR>list</VAR>.  If
<VAR>obj</VAR> does not occur in <VAR>list</VAR>, then <CODE>#f</CODE> (not the empty list) is
returned.  <CODE>Memq</CODE> uses <CODE>eq?</CODE> to compare <VAR>obj</VAR> with the
<A NAME="IDX275"></A>
elements of
<A NAME="IDX276"></A>
<VAR>list</VAR>, while <CODE>memv</CODE> uses <CODE>eqv?</CODE> and <CODE>member</CODE>
<A NAME="IDX277"></A>
<A NAME="IDX278"></A>
uses <CODE>equal?</CODE>.
<A NAME="IDX279"></A>
<A NAME="IDX280"></A>

</P>

<PRE>
(memq 'a '(a b c))          =>  (a b c)
(memq 'b '(a b c))          =>  (b c)
(memq 'a '(b c d))          =>  #f
(memq (list 'a) '(b (a) c)) =>  #f
(member (list 'a)
        '(b (a) c))         =>  ((a) c)
(memq 101 '(100 101 102))   =>  <EM>unspecified</EM>
(memv 101 '(100 101 102))   =>  (101 102)
</PRE>

<P>

<U>essential procedure:</U> <B>assq</B> <I>obj alist</I><P>
<A NAME="IDX281"></A>
<U>essential procedure:</U> <B>assv</B> <I>obj alist</I><P>
<A NAME="IDX282"></A>
<U>essential procedure:</U> <B>assoc</B> <I>obj alist</I><P>
<A NAME="IDX283"></A>

</P>
<P>
<VAR>Alist</VAR> (for "association list") must be a list of pairs.  These
procedures find the first pair in <VAR>alist</VAR> whose car field is
<VAR>obj</VAR>, and returns that pair.  If no pair in <VAR>alist</VAR> has
<VAR>obj</VAR> as its car, then <CODE>#f</CODE> (not the empty list) is returned.
<CODE>Assq</CODE> uses <CODE>eq?</CODE> to compare <VAR>obj</VAR> with the car fields of
the pairs in <VAR>alist</VAR>, while <CODE>assv</CODE> uses <CODE>eqv?</CODE> and
<CODE>assoc</CODE> uses <CODE>equal?</CODE>.
<A NAME="IDX284"></A>
<A NAME="IDX285"></A>
<A NAME="IDX286"></A>
<A NAME="IDX287"></A>
<A NAME="IDX288"></A>
<A NAME="IDX289"></A>

</P>

<PRE>
(define e '((a 1) (b 2) (c 3)))
(assq 'a e)                 =>  (a 1)
(assq 'b e)                 =>  (b 2)
(assq 'd e)                 =>  #f
(assq (list 'a) '(((a)) ((b)) ((c))))
                            =>  #f
(assoc (list 'a) '(((a)) ((b)) ((c))))
                            =>  ((a))
(assq 5 '((2 3) (5 7) (11 13)))
                            =>  <EM>unspecified</EM>
(assv 5 '((2 3) (5 7) (11 13)))
                            =>  (5 7)
</PRE>

<P>
<EM>Rationale:</EM>  Although they are ordinarily used as predicates,
<CODE>memq</CODE>, <CODE>memv</CODE>, <CODE>member</CODE>, <CODE>assq</CODE>, <CODE>assv</CODE>, and
symbols<CODE>assoc</CODE> do not
<A NAME="IDX290"></A>
<A NAME="IDX291"></A>
<A NAME="IDX292"></A>
<A NAME="IDX293"></A>
<A NAME="IDX294"></A>
<A NAME="IDX295"></A>
have question marks in their names because they return useful values
rather than just <CODE>#t</CODE> or <CODE>#f</CODE>.

</P>


<H2><A NAME="SEC49" HREF="r4rs_toc.html#SEC49">Symbols</A></H2>

<P>
Symbols are objects whose usefulness rests on the fact that two symbols
are identical (in the sense of <CODE>eqv?</CODE>) if and only if their
<A NAME="IDX296"></A>
names are spelled the same way.  This is exactly the property needed to
represent identifiers
<A NAME="IDX297"></A>
in programs, and so most implementations of Scheme use them internally
for that purpose.  Symbols are useful for many other applications; for
instance, they may be used the way enumerated values are used in Pascal.

</P>
<P>
The rules for writing a symbol are exactly the same as the rules for
writing an identifier; see section <A HREF="r4rs.html#SEC16">Identifiers</A>
and section <A HREF="r4rs.html#SEC68">Lexical structure</A>.

</P>
<P>
It is guaranteed that any symbol that has been returned as part of
a literal expression, or read using the <CODE>read</CODE> procedure, and
<A NAME="IDX298"></A>
subsequently written out using the <CODE>write</CODE> procedure, will read
back
<A NAME="IDX299"></A>
in as the identical symbol (in the sense of <CODE>eqv?</CODE>).  The
<A NAME="IDX300"></A>
<CODE>string-&#62;symbol</CODE> procedure, however, can create symbols for
<A NAME="IDX301"></A>
which this write/read invariance may not hold because their names
contain special characters or letters in the non-standard case.

</P>
<P>
<EM>Note:</EM>  Some implementations of Scheme have a feature known as "slashification"
in order to guarantee write/read invariance for all symbols, but
historically the most important use of this feature has been to
compensate for the lack of a string data type.

</P>
<P>
Some implementations also have "uninterned symbols", which
defeat write/read invariance even in implementations with slashification,
and also generate exceptions to the rule that two symbols are the same
if and only if their names are spelled the same.

</P>
<P>
<U>essential procedure:</U> <B>symbol?</B> <I>obj</I><P>
<A NAME="IDX302"></A>

</P>
<P>
Returns <CODE>#t</CODE> if <VAR>obj</VAR> is a symbol, otherwise returns <CODE>#f</CODE>.

</P>

<PRE>
(symbol? 'foo)              =>  #t
(symbol? (car '(a b)))      =>  #t
(symbol? "bar")             =>  #f
(symbol? 'nil)              =>  #t
(symbol? '())               =>  #f
(symbol? #f)                =>  #f
</PRE>

<P>

<U>essential procedure:</U> <B>symbol-&#62;string</B> <I>symbol</I><P>
<A NAME="IDX303"></A>

</P>
<P>
Returns the name of <VAR>symbol</VAR> as a string.  If the symbol was part of
an object returned as the value of a literal expression
(section <A HREF="r4rs.html#SEC28">Literal expressions</A>) or by a call to the <CODE>read</CODE>
<A NAME="IDX304"></A>
procedure,
and its name contains alphabetic characters, then the string returned
will contain characters in the implementation's preferred standard
case--some implementations will prefer upper case, others lower case.
If the symbol was returned by <CODE>string-&#62;symbol</CODE>, the case of
<A NAME="IDX305"></A>
characters in the string returned will be the same as the case in the
string that was passed to <CODE>string-&#62;symbol</CODE>.  It is an error
<A NAME="IDX306"></A>
to apply mutation procedures like <CODE>string-set!</CODE> to strings returned
<A NAME="IDX307"></A>
by this procedure.

</P>
<P>
The following examples assume that the implementation's standard case is
lower case:

</P>

<PRE>
(symbol-&#62;string 'flying-fish)
                            =>  "flying-fish"
(symbol-&#62;string 'Martin)    =>  "martin"
(symbol-&#62;string
   (string-&#62;symbol "Malvina"))
                            =>  "Malvina"
</PRE>

<P>

<U>essential procedure:</U> <B>string-&#62;symbol</B> <I>string</I><P>
<A NAME="IDX308"></A>

</P>
<P>
Returns the symbol whose name is <VAR>string</VAR>.  This procedure can
create symbols with names containing special characters or letters in
the non-standard case, but it is usually a bad idea to create such
symbols because in some implementations of Scheme they cannot be read as
themselves.  See <CODE>symbol-&#62;string</CODE>.
<A NAME="IDX309"></A>

</P>
<P>
The following examples assume that the implementation's standard case is
lower case:

</P>

<PRE>
(eq? 'mISSISSIppi 'mississippi)  
                            =>  #t
(string-&#62;symbol "mISSISSIppi")  
                            =>  the symbol with name "mISSISSIppi"
(eq? 'bitBlt (string-&#62;symbol "bitBlt"))     
                            =>  #f
(eq? 'JollyWog
     (string-&#62;symbol
       (symbol-&#62;string 'JollyWog)))  
                            =>  #t
(string=? "K. Harper, M.D."
          (symbol-&#62;string
            (string-&#62;symbol "K. Harper, M.D.")))  
                            =>  #t
</PRE>

<P>



<H2><A NAME="SEC50" HREF="r4rs_toc.html#SEC50">Numbers</A></H2>

<P>
<A NAME="IDX310"></A>

</P>

<P>
Numerical computation has traditionally been neglected by the Lisp
community.  Until Common Lisp there was no carefully thought out
strategy for organizing numerical computation, and with the exception of
the MacLisp system [PITMAN83] little effort was made to
execute numerical code efficiently.  This report recognizes the excellent work
of the Common Lisp committee and accepts many of their recommendations.
In some ways this report simplifies and generalizes their proposals in a manner
consistent with the purposes of Scheme.

</P>
<P>
It is important to distinguish between the mathematical numbers, the
Scheme numbers that attempt to model them, the machine representations
used to implement the Scheme numbers, and notations used to write numbers.
This report uses the types <I>number</I>, <I>complex</I>, <I>real</I>,
<I>rational</I>, and <I>integer</I> to refer to both mathematical numbers
and Scheme numbers.  Machine representations such as fixed point and
floating point are referred to by names such as <I>fixnum</I> and
<I>flonum</I>.

</P>



<H3><A NAME="SEC51" HREF="r4rs_toc.html#SEC51">Numerical types</A></H3>

<P>
<A NAME="IDX311"></A>

</P>

<P>
Mathematically, numbers may be arranged into a tower of subtypes
in which each level is a subset of the level above it:

<UL>
<LI>number

<LI>complex

<LI>real

<LI>rational

<LI>integer

</UL>

<P>
For example, 3 is an integer.  Therefore 3 is also a rational,
a real, and a complex.  The same is true of the Scheme numbers
that model 3.  For Scheme numbers, these types are defined by the
predicates <CODE>number?</CODE>, <CODE>complex?</CODE>, <CODE>real?</CODE>,
<CODE>rational?</CODE>, and <CODE>integer?</CODE>.
<A NAME="IDX312"></A>
<A NAME="IDX313"></A>
<A NAME="IDX314"></A>
<A NAME="IDX315"></A>
<A NAME="IDX316"></A>

</P>
<P>
There is no simple relationship between a number's type and its
representation inside a computer.  Although most implementations of
Scheme will offer at least two different representations of 3, these
different representations denote the same integer.

</P>

<P>
Scheme's numerical operations treat numbers as abstract data, as
independent of their representation as possible.  Although an implementation
of Scheme may use fixnum, flonum, and perhaps other representations for
numbers, this should not be apparent to a casual programmer writing
simple programs.

</P>
<P>
It is necessary, however, to distinguish between numbers that are
represented exactly and those that may not be.  For example, indexes
into data structures must be known exactly, as must some polynomial
coefficients in a symbolic algebra system.  On the other hand, the
results of measurements are inherently inexact, and irrational numbers
may be approximated by rational and therefore inexact approximations.
In order to catch uses of inexact numbers where exact numbers are
required, Scheme explicitly distinguishes exact from inexact numbers.
This distinction is orthogonal to the dimension of type.

</P>


<H3><A NAME="SEC52" HREF="r4rs_toc.html#SEC52">Exactness</A></H3>

<P>
<A NAME="IDX317"></A>

</P>
<P>
Scheme numbers are either <I>exact</I> or <I>inexact</I>.  A number is
exact if it was written as an exact constant or was derived from
exact numbers using only exact operations.  A number is
inexact if it was written as an inexact constant,
if it was
derived using inexact ingredients, or if it was derived using
inexact operations. Thus inexactness is a contagious
property of a number.

</P>
<P>
If two implementations produce exact results for a
computation that did not involve inexact intermediate results,
the two ultimate results will be mathematically equivalent.  This is
generally not true of computations involving inexact numbers
since approximate methods such as floating point arithmetic may be used,
but it is the duty of each implementation to make the result as close as
practical to the mathematically ideal result.

</P>
<P>
Rational operations such as <CODE>+</CODE> should always produce
<A NAME="IDX318"></A>
exact results when given exact arguments.
If the operation is unable to produce an exact result,
then it may either report the violation of an implementation restriction
or it may silently coerce its
result to an inexact value.
See section <A HREF="r4rs.html#SEC53">Implementation restrictions</A>.

</P>
<P>
With the exception of <CODE>inexact-&#62;exact</CODE>, the operations described in
<A NAME="IDX319"></A>
this section must generally return inexact results when given any inexact
arguments.  An operation may, however, return an exact result if it can
prove that the value of the result is unaffected by the inexactness of its
arguments.  For example, multiplication of any number by an exact zero
may produce an exact zero result, even if the other argument is
inexact.

</P>


<H3><A NAME="SEC53" HREF="r4rs_toc.html#SEC53">Implementation restrictions</A></H3>

<P>
<A NAME="IDX320"></A>

</P>
<P>
Implementations of Scheme are not required to implement the whole
tower of subtypes given in section <A HREF="r4rs.html#SEC51">Numerical types</A>,
but they must implement a coherent subset consistent with both the
purposes of the implementation and the spirit of the Scheme language.
For example, an implementation in which all numbers are real
may still be quite useful.

</P>
<P>
Implementations may also support only a limited range of numbers of
any type, subject to the requirements of this section.  The supported
range for exact numbers of any type may be different from the
supported range for inexact numbers of that type.  For example,
an implementation that uses flonums to represent all its
inexact real numbers may
support a practically unbounded range of exact integers
and rationals
while limiting the range of inexact reals (and therefore
the range of inexact integers and rationals)
to the dynamic range of the flonum format.
Furthermore
the gaps between the representable inexact integers and
rationals are
likely to be very large in such an implementation as the limits of this
range are approached.

</P>
<P>
An implementation of Scheme must support exact integers
throughout the range of numbers that may be used for indexes of
lists, vectors, and strings or that may result from computing the length of a
list, vector, or string.  The <CODE>length</CODE>, <CODE>vector-length</CODE>,
<A NAME="IDX321"></A>
<A NAME="IDX322"></A>
and <CODE>string-length</CODE> procedures must return an exact
<A NAME="IDX323"></A>
integer, and it is an error to use anything but an exact integer as an
index.  Furthermore any integer constant within the index range, if
expressed by an exact integer syntax, will indeed be read as an exact
integer, regardless of any implementation restrictions that may apply
outside this range.  Finally, the procedures listed below will always
return an exact integer result provided all their arguments are exact integers
and the mathematically expected result is representable as an exact integer
within the implementation:

</P>

<PRE>
+            -             *
quotient     remainder     modulo
max          min           abs
numerator    denominator   gcd
lcm          floor         ceiling
truncate     round         rationalize
expt
</PRE>

<P>
Implementations are encouraged, but not required, to support
exact integers and exact rationals of
practically unlimited size and precision, and to implement the
above procedures and the <CODE>/</CODE> procedure in
<A NAME="IDX324"></A>
such a way that they always return exact results when given exact
arguments.  If one of these procedures is unable to deliver an exact
result when given exact arguments, then it may either report a
violation of an
implementation restriction or it may silently coerce its result to an
inexact number.  Such a coercion may cause an error later.

</P>

<P>
<A NAME="IDX325"></A>
<A NAME="IDX326"></A>

</P>
<P>
An implementation may use floating point and other approximate
representation strategies for inexact numbers.

</P>

<P>
This report recommends, but does not require, that the IEEE 32-bit
and 64-bit floating point standards be followed by implementations that use
flonum representations, and that implementations using
other representations should match or exceed the precision achievable
using these floating point standards <A HREF="r4rs.html#BIB49">[IEEE]</A>.

</P>
<P>
In particular, implementations that use flonum representations
must follow these rules: A flonum result
must be represented with at least as much precision as is used to express any of
the inexact arguments to that operation.  It is desirable (but not required) for
potentially inexact operations such as <CODE>sqrt</CODE>, when applied to
exact
<A NAME="IDX327"></A>
arguments, to produce exact answers whenever possible (for example the
square root of an exact 4 ought to be an exact 2).
If, however, an
exact number is operated upon so as to produce an inexact result
(as by <CODE>sqrt</CODE>), and if the result is represented as a
flonum, then
<A NAME="IDX328"></A>
the most precise flonum format available must be used; but if the result
is represented in some other way then the representation must have at least as
much precision as the most precise flonum format available.

</P>
<P>
Although Scheme allows a variety of written
notations for
numbers, any particular implementation may support only some of them.
For example, an implementation in which all numbers are real
need not support the rectangular and polar notations for complex
numbers.  If an implementation encounters an exact numerical constant that
it cannot represent as an exact number, then it may either report a
violation of an implementation restriction or it may silently represent the
constant by an inexact number.

</P>


<H3><A NAME="SEC54" HREF="r4rs_toc.html#SEC54">Syntax of numerical constants</A></H3>

<P>
The syntax of the written representations for numbers is described formally in
section <A HREF="r4rs.html#SEC68">Lexical structure</A>.

</P>
<P>
A number may be written in binary, octal, decimal, or
hexadecimal by the use of a radix prefix.  The radix prefixes are
<CODE>#b</CODE> (binary),
<A NAME="IDX329"></A>
<CODE>#o</CODE> (octal),
<A NAME="IDX330"></A>
<CODE>#d</CODE> (decimal), and
<A NAME="IDX331"></A>
<CODE>#x</CODE> (hexadecimal).
<A NAME="IDX332"></A>
With no radix prefix, a number is assumed to be expressed in decimal.

</P>
<P>
A
numerical constant may be specified to be either exact or
inexact by a prefix.  The prefixes are <CODE>#e</CODE>
<A NAME="IDX333"></A>
for exact, and <CODE>#i</CODE>
<A NAME="IDX334"></A>
for inexact.  An exactness
prefix may appear before or after any radix prefix that is used.  If
the written representation of a number has no exactness prefix, the
constant may be either inexact or exact.  It is
inexact if it contains a decimal point, an
exponent, or a "#" character in the place of a digit,
otherwise it is exact.

</P>

<P>
In systems with inexact numbers
of varying precisions it may be useful to specify
the precision of a constant.  For this purpose, numerical constants
may be written with an exponent marker that indicates the
desired precision of the inexact
representation.  The letters <CODE>s</CODE>, <CODE>f</CODE>,
<A NAME="IDX335"></A>
<A NAME="IDX336"></A>
<CODE>d</CODE>, and <CODE>l</CODE> specify the use of <VAR>short</VAR>, <VAR>single</VAR>,
<A NAME="IDX337"></A>
<A NAME="IDX338"></A>
<VAR>double</VAR>, and <VAR>long</VAR> precision, respectively.  (When fewer
than four internal
inexact
representations exist, the four size
specifications are mapped onto those available.  For example, an
implementation with two internal representations may map short and
single together and long and double together.)  In addition, the
exponent marker <CODE>e</CODE> specifies the default precision for the
<A NAME="IDX339"></A>
implementation.  The default precision has at least as much precision
as <VAR>double</VAR>, but
implementations may wish to allow this default to be set by the user.

</P>

<PRE>
3.14159265358979F0
        Round to single --- 3.141593
0.6L0
        Extend to long --- .600000000000000
</PRE>



<H3><A NAME="SEC55" HREF="r4rs_toc.html#SEC55">Numerical operations</A></H3>

<P>
The reader is referred to section <A HREF="r4rs.html#SEC12">Entry format</A> for a summary
of the naming conventions used to specify restrictions on the types of
arguments to numerical routines.

</P>
<P>
The examples used in this section assume that any numerical constant written
using an exact notation is indeed represented as an exact
number.  Some examples also assume that certain numerical constants written
using an inexact notation can be represented without loss of
accuracy; the inexact constants were chosen so that this is
likely to be true in implementations that use flonums to represent
inexact numbers.

</P>

<P>
<U>essential procedure:</U> <B>number?</B> <I>obj</I><P>
<A NAME="IDX340"></A>
<U>essential procedure:</U> <B>complex?</B> <I>obj</I><P>
<A NAME="IDX341"></A>
<U>essential procedure:</U> <B>real?</B> <I>obj</I><P>
<A NAME="IDX342"></A>
<U>essential procedure:</U> <B>rational?</B> <I>obj</I><P>
<A NAME="IDX343"></A>
<U>essential procedure:</U> <B>integer?</B> <I>obj</I><P>
<A NAME="IDX344"></A>

</P>
<P>
These numerical type predicates can be applied to any kind of
argument, including non-numbers.  They return <CODE>#t</CODE> if the object is
of the named type, and otherwise they return <CODE>#f</CODE>.
In general, if a type predicate is true of a number then all higher
type predicates are also true of that number.  Consequently, if a type
predicate is false of a number, then all lower type predicates are
also false of that number.

</P>
<P>
If <VAR>z</VAR> is an inexact complex number, then <CODE>(real? <VAR>z</VAR>)</CODE> is true if
and only if <CODE>(zero? (imag-part <VAR>z</VAR>))</CODE> is true.  If <VAR>x</VAR> is an inexact
real number, then <CODE>(integer? <VAR>x</VAR>)</CODE> is true if and only if
<CODE>(= <VAR>x</VAR> (round <VAR>x</VAR>))</CODE>.

</P>

<PRE>
(complex? 3+4i)             =>  #t
(complex? 3)                =>  #t
(real? 3)                   =>  #t
(real? -2.5+0.0i)           =>  #t
(real? #e1e10)              =>  #t
(rational? 6/10)            =>  #t
(rational? 6/3)             =>  #t
(integer? 3+0i)             =>  #t
(integer? 3.0)              =>  #t
(integer? 8/4)              =>  #t
</PRE>

<P>
<EM>Note:</EM>  The behavior of these type predicates on inexact numbers
is unreliable, since any inaccuracy may affect the result.

</P>
<P>
<EM>Note:</EM>  In many implementations the <CODE>rational?</CODE> procedure will be the same
<A NAME="IDX345"></A>
as <CODE>real?</CODE>, and the <CODE>complex?</CODE> procedure will be the same
<A NAME="IDX346"></A>
as
<A NAME="IDX347"></A>
<CODE>number?</CODE>, but unusual implementations may be able to represent
<A NAME="IDX348"></A>
some irrational numbers exactly or may extend the number system to
support some kind of non-complex numbers.

</P>
<P>

<U>essential procedure:</U> <B>exact?</B> <I>z</I><P>
<A NAME="IDX349"></A>
<U>essential procedure:</U> <B>inexact?</B> <I>z</I><P>
<A NAME="IDX350"></A>

</P>
<P>
These numerical predicates provide tests for the exactness of a
quantity.  For any Scheme number, precisely one of these predicates
is true.

</P>
<P>

<U>essential procedure:</U> <B>=</B> <I>z1 z2 z3 ...</I><P>
<A NAME="IDX351"></A>
<U>essential procedure:</U> <B>&#60;</B> <I>x1 x2 x3 ...</I><P>
<A NAME="IDX352"></A>
<U>essential procedure:</U> <B>&#62;</B> <I>x1 x2 x3 ...</I><P>
<A NAME="IDX353"></A>
<U>essential procedure:</U> <B>&#60;=</B> <I>x1 x2 x3 ...</I><P>
<A NAME="IDX354"></A>
<U>essential procedure:</U> <B>&#62;=</B> <I>x1 x2 x3 ...</I><P>
<A NAME="IDX355"></A>

</P>
<P>
These procedures return <CODE>#t</CODE> if their arguments are (respectively):
equal, monotonically increasing, monotonically decreasing,
monotonically nondecreasing, or monotonically nonincreasing.

</P>
<P>
These predicates are required to be transitive.

</P>
<P>
<EM>Note:</EM>  The traditional implementations of these predicates in Lisp-like
languages are not transitive.

</P>
<P>
<EM>Note:</EM>  While it is not an error to compare inexact numbers using these
predicates, the results may be unreliable because a small inaccuracy
may affect the result; this is especially true of <CODE>=</CODE> and <CODE>zero?</CODE>.
<A NAME="IDX356"></A>
<A NAME="IDX357"></A>
When in doubt, consult a numerical analyst.

</P>
<P>

<U>essential procedure:</U> <B>zero?</B> <I>z</I><P>
<A NAME="IDX358"></A>
<U>essential procedure:</U> <B>positive?</B> <I>x</I><P>
<A NAME="IDX359"></A>
<U>essential procedure:</U> <B>negative?</B> <I>x</I><P>
<A NAME="IDX360"></A>
<U>essential procedure:</U> <B>odd?</B> <I>n</I><P>
<A NAME="IDX361"></A>
<U>essential procedure:</U> <B>even?</B> <I>n</I><P>
<A NAME="IDX362"></A>

</P>
<P>
These numerical predicates test a number for a particular property,
returning <CODE>#t</CODE> or <CODE>#f</CODE>.  See note above.

</P>
<P>

<U>essential procedure:</U> <B>max</B> <I>x1 x2 ...</I><P>
<A NAME="IDX363"></A>
<U>essential procedure:</U> <B>min</B> <I>x1 x2 ...</I><P>
<A NAME="IDX364"></A>

</P>
<P>
These procedures return the maximum or minimum of their arguments.

</P>

<PRE>
(max 3 4)                   =>  4    ; exact
(max 3.9 4)                 =>  4.0  ; inexact
</PRE>

<P>
<EM>Note:</EM>  If any argument is inexact, then the result will also be inexact (unless
the procedure can prove that the inaccuracy is not large enough to affect the
result, which is possible only in unusual implementations).  If
<CODE>min</CODE> or
<A NAME="IDX365"></A>
<CODE>max</CODE> is used to compare numbers of mixed exactness, and the
numerical
<A NAME="IDX366"></A>
value of the result cannot be represented as an inexact number without loss of
accuracy, then the procedure may report a violation of an implementation
restriction.

</P>
<P>
<U>essential procedure:</U> <B>+</B> <I>z1 ...</I><P>
<A NAME="IDX367"></A>
<U>essential procedure:</U> <B>*</B> <I>z1 ...</I><P>
<A NAME="IDX368"></A>

</P>
<P>
These procedures return the sum or product of their arguments.

</P>

<PRE>
(+ 3 4)                     =>  7
(+ 3)                       =>  3
(+)                         =>  0
(* 4)                       =>  4
(*)                         =>  1
</PRE>

<P>

<U>essential procedure:</U> <B>-</B> <I>z1 z2</I><P>
<A NAME="IDX369"></A>
<U>essential procedure:</U> <B>-</B> <I>z</I><P>
<A NAME="IDX370"></A>
<U>procedure:</U> <B>-</B> <I>z1 z2 ...</I><P>
<A NAME="IDX371"></A>
<U>essential procedure:</U> <B>/</B> <I>z1 z2</I><P>
<A NAME="IDX372"></A>
<U>essential procedure:</U> <B>/</B> <I>z</I><P>
<A NAME="IDX373"></A>
<U>procedure:</U> <B>/</B> <I>z1 z2 ...</I><P>
<A NAME="IDX374"></A>

</P>
<P>
With two or more arguments, these procedures return the difference or
quotient of their arguments, associating to the left.  With one argument,
however, they return the additive or multiplicative inverse of their argument.

</P>

<PRE>
(- 3 4)                     =>  -1
(- 3 4 5)                   =>  -6
(- 3)                       =>  -3
(/ 3 4 5)                   =>  3/20
(/ 3)                       =>  1/3
</PRE>

<P>

<U>essential procedure:</U> <B>abs</B> <I>x</I><P>
<A NAME="IDX375"></A>

</P>
<P>
<CODE>Abs</CODE> returns the magnitude of its argument.
<A NAME="IDX376"></A>
<A NAME="IDX377"></A>

<PRE>
(abs -7)                    =>  7
</PRE>

<P>

<U>essential procedure:</U> <B>quotient</B> <I>n1 n2</I><P>
<A NAME="IDX378"></A>
<U>essential procedure:</U> <B>remainder</B> <I>n1 n2</I><P>
<A NAME="IDX379"></A>
<U>essential procedure:</U> <B>modulo</B> <I>n1 n2</I><P>
<A NAME="IDX380"></A>

</P>
<P>
These
procedures implement number-theoretic (integer)
division: For positive integers <VAR>n1</VAR> and <VAR>n2</VAR>, if <VAR>n3</VAR> and
<VAR>n4</VAR> are integers such that 
<DL COMPACT>

<DT><CODE>(= n1 (+ (* n2 n3) n4))</CODE>,
<DD>
<DT><CODE>(&#60;= 0 n4)</CODE>, and
<DD>
<DT><CODE>(&#60; n4 n2)</CODE>.
<DD>
</DL>
<P>
Then

<PRE>
(quotient <VAR>n1</VAR> <VAR>n2</VAR>)            =>  <VAR>n3</VAR>
(remainder <VAR>n1</VAR> <VAR>n2</VAR>)           =>  <VAR>n4</VAR>
(modulo <VAR>n1</VAR> <VAR>n2</VAR>)              =>  <VAR>n4</VAR>
</PRE>

<P>
For integers <VAR>n1</VAR> and <VAR>n2</VAR> with <VAR>n2</VAR> not equal to 0,

</P>

<PRE>
(= <VAR>n1</VAR> (+ (* <VAR>n2</VAR> (quotient <VAR>n1</VAR> <VAR>n2</VAR>))
               (remainder <VAR>n1</VAR> <VAR>n2</VAR>)))
                            =>  #t
</PRE>

<P>
provided all numbers involved in that computation are exact.

</P>
<P>
The value returned by <CODE>quotient</CODE> always has the sign of the
<A NAME="IDX381"></A>
product of its arguments.  <CODE>Remainder</CODE> and <CODE>modulo</CODE> differ
<A NAME="IDX382"></A>
on negative
<A NAME="IDX383"></A>
arguments--the
<CODE>remainder</CODE> is either zero or has the sign of the dividend,
<A NAME="IDX384"></A>
while the <CODE>modulo</CODE>
<A NAME="IDX385"></A>
always has the sign of the divisor:

</P>

<PRE>
(modulo 13 4)               =>  1
(remainder 13 4)            =>  1

(modulo -13 4)              =>  3
(remainder -13 4)           =>  -1

(modulo 13 -4)              =>  -3
(remainder 13 -4)           =>  1

(modulo -13 -4)             =>  -1
(remainder -13 -4)          =>  -1

(remainder -13 -4.0)        =>  -1.0  ; inexact
</PRE>

<P>

<U>essential procedure:</U> <B>gcd</B> <I>n1 ...</I><P>
<A NAME="IDX386"></A>
<U>essential procedure:</U> <B>lcm</B> <I>n1 ...</I><P>
<A NAME="IDX387"></A>

</P>
<P>
These procedures return the greatest common divisor or least common
multiple of their arguments.  The result is always non-negative.

</P>

<PRE>
(gcd 32 -36)                =>  4
(gcd)                       =>  0
(lcm 32 -36)                =>  288
(lcm 32.0 -36)              =>  288.0  ; inexact
(lcm)                       =>  1
</PRE>

<P>

<U>procedure:</U> <B>numerator</B> <I>q</I><P>
<A NAME="IDX388"></A>
<U>procedure:</U> <B>denominator</B> <I>q</I><P>
<A NAME="IDX389"></A>

</P>
<P>
These procedures return the numerator or denominator of their
argument; the result is computed as if the argument was represented as
a fraction in lowest terms.  The denominator is always positive.  The
denominator of 0 is defined to be 1.

</P>


<PRE>
(numerator (/ 6 4))         =>  3
(denominator (/ 6 4))       =>  2
(denominator
  (exact-&#62;inexact (/ 6 4))) =>  2.0
</PRE>

<P>

<U>essential procedure:</U> <B>floor</B> <I>x</I><P>
<A NAME="IDX390"></A>
<U>essential procedure:</U> <B>ceiling</B> <I>x</I><P>
<A NAME="IDX391"></A>
<U>essential procedure:</U> <B>truncate</B> <I>x</I><P>
<A NAME="IDX392"></A>
<U>essential procedure:</U> <B>round</B> <I>x</I><P>
<A NAME="IDX393"></A>

</P>
<P>
These procedures return integers.
<CODE>Floor</CODE> returns the largest integer not larger than <VAR>x</VAR>.
<A NAME="IDX394"></A>
<CODE>Ceiling</CODE> returns the smallest integer not smaller than <VAR>x</VAR>.
<A NAME="IDX395"></A>
<CODE>Truncate</CODE> returns the integer closest to <VAR>x</VAR> whose absolute
<A NAME="IDX396"></A>
value is not larger than the absolute value of <VAR>x</VAR>.  <CODE>Round</CODE>
returns the
<A NAME="IDX397"></A>
closest integer to <VAR>x</VAR>, rounding to even when <VAR>x</VAR> is halfway between two
integers.

</P>
<P>
<EM>Rationale:</EM>  <CODE>Round</CODE> rounds to even for consistency with the default rounding
<A NAME="IDX398"></A>
mode specified by the IEEE floating point standard.

</P>
<P>
<EM>Note:</EM>  If the argument to one of these procedures is inexact, then the result
will also be inexact.  If an exact value is needed, the
result should be passed to the <CODE>inexact-&#62;exact</CODE> procedure.
<A NAME="IDX399"></A>

</P>

<PRE>
(floor -4.3)                =>  -5.0
(ceiling -4.3)              =>  -4.0
(truncate -4.3)             =>  -4.0
(round -4.3)                =>  -4.0

(floor 3.5)                 =>  3.0
(ceiling 3.5)               =>  4.0
(truncate 3.5)              =>  3.0
(round 3.5)                 =>  4.0  ; inexact

(round 7/2)                 =>  4    ; exact
(round 7)                   =>  7
</PRE>

<P>

<U>procedure:</U> <B>rationalize</B> <I>x y</I><P>
<A NAME="IDX400"></A>

</P>
<P>
<CODE>Rationalize</CODE> returns the <EM>simplest</EM> rational number
<A NAME="IDX401"></A>
differing from <VAR>x</VAR> by no more than <VAR>y</VAR>.  A rational number
<VAR>r1</VAR> is <EM>simpler</EM> than another rational number <VAR>r2</VAR> if
<A NAME="IDX402"></A>
<DL COMPACT>

<DT><CODE>(= r1 (/ p1 q1))</CODE> and
<DD>
<DT><CODE>(= r2 (/ p2 q2))</CODE> (in lowest terms) and
<DD>
<DT><CODE>(&#60;= (abs p1) (abs p2))</CODE> and
<DD>
<DT><CODE>(&#60;= (abs q1) (abs q2))</CODE>.
<DD>
</DL>
<P>
Thus <CODE>(3/5)</CODE> is simpler than <CODE>(4/7)</CODE>.  Although not all
rationals are comparable in this ordering (consider <CODE>(2/7)</CODE> and
<CODE>(3/5)</CODE>) any interval contains a rational number that is simpler
than every other rational number in that interval (the simpler
<CODE>(2/5)</CODE> lies between <CODE>(2/7)</CODE> and <CODE>(3/5)</CODE>).  Note that 0
(<CODE>0/1</CODE>) is the simplest rational of all.

</P>

<PRE>
(rationalize
  (inexact-&#62;exact .3) 1/10)  =>  1/3    ; exact
(rationalize .3 1/10)        =>  #i1/3  ; inexact
</PRE>

<P>

<U>procedure:</U> <B>exp</B> <I>z</I><P>
<A NAME="IDX403"></A>
<U>procedure:</U> <B>log</B> <I>z</I><P>
<A NAME="IDX404"></A>
<U>procedure:</U> <B>sin</B> <I>z</I><P>
<A NAME="IDX405"></A>
<U>procedure:</U> <B>cos</B> <I>z</I><P>
<A NAME="IDX406"></A>
<U>procedure:</U> <B>tan</B> <I>z</I><P>
<A NAME="IDX407"></A>
<U>procedure:</U> <B>asin</B> <I>z</I><P>
<A NAME="IDX408"></A>
<U>procedure:</U> <B>acos</B> <I>z</I><P>
<A NAME="IDX409"></A>
<U>procedure:</U> <B>atan</B> <I>z</I><P>
<A NAME="IDX410"></A>
<U>procedure:</U> <B>atan</B> <I>y x</I><P>
<A NAME="IDX411"></A>

</P>
<P>
These procedures are part of every implementation that supports
general
real numbers; they compute the usual transcendental functions.
<CODE>Log</CODE>
<A NAME="IDX412"></A>
computes the natural logarithm of <VAR>z</VAR> (not the base ten logarithm).
<CODE>Asin</CODE>, <CODE>acos</CODE>, and <CODE>atan</CODE> compute arcsine
<A NAME="IDX413"></A>
<A NAME="IDX414"></A>
<A NAME="IDX415"></A>
, arccosine
, and arctangent
, respectively.
The two-argument variant of <CODE>atan</CODE> computes <CODE>(angle
(make-rectangular <VAR>x</VAR> <VAR>y</VAR>))</CODE> (see below), even in
implementations that don't support general complex numbers.
<A NAME="IDX416"></A>

</P>
<P>
In general, the mathematical functions log, arcsine, arccosine, and
arctangent are multiply defined.
For nonzero real <VAR>x</VAR>, the value of
<CODE>(log x)</CODE> is defined to be
the one whose imaginary part lies in the range 
<CODE>-pi</CODE> (exclusive) to <CODE>pi</CODE> (inclusive).  <CODE>(log 0)</CODE> is
undefined.  The value of <CODE>(log z)</CODE> when <VAR>z</VAR> is complex is
defined according to the formula

</P>


<PRE>
<TT>(define (log z) (+ (log (magnitude z)) (* +i (angle z))))</TT>
</PRE>

<P>
With <CODE>(log)</CODE> defined this way, the values of <CODE>arcsin</CODE>,
<CODE>arccos</CODE>, and <CODE>arctan</CODE> are according to the following
formulae:

</P>


<PRE>
<TT>(define (asin z) (* -i (log (+ (* +i z) (sqrt (- 1 (* z z)))))))</TT>

<TT>(define (acos z) (- (/ pi 2) (asin z)))</TT>

<TT>(define (atan z) (/ (log (/ (+ 1 (* +i z)) (- 1 (* +i z)))) (* +i 2))</TT>
</PRE>

<P>
The above specification follows [CLTL], which in turn
cites [PENFIELD81]; refer to these sources for more detailed
discussion of branch cuts, boundary conditions, and implementation of
these functions.  When it is possible these procedures produce a real
result from a real argument.

</P>
<P>
<U>procedure:</U> <B>sqrt</B> <I>z</I><P>
<A NAME="IDX417"></A>

</P>
<P>
Returns the principal square root of <VAR>z</VAR>.  The result will have
either positive real part, or zero real part and non-negative imaginary
part.

</P>
<P>
<U>procedure:</U> <B>expt</B> <I>z1 z2</I><P>
<A NAME="IDX418"></A>

</P>
<P>
Returns <VAR>z1</VAR> raised to the power <VAR>z2</VAR>:

</P>

<PRE>
(define (expt z1 z2) (exp z2 (log z1)))
</PRE>

<P>
<CODE>(expt 0 0)</CODE> is defined to be equal to 1.

</P>

<P>
<U>procedure:</U> <B>make-rectangular</B> <I>x1 x2</I><P>
<A NAME="IDX419"></A>
<U>procedure:</U> <B>make-polar</B> <I>x3 x4</I><P>
<A NAME="IDX420"></A>
<U>procedure:</U> <B>real-part</B> <I>z</I><P>
<A NAME="IDX421"></A>
<U>procedure:</U> <B>imag-part</B> <I>z</I><P>
<A NAME="IDX422"></A>
<U>procedure:</U> <B>magnitude</B> <I>z</I><P>
<A NAME="IDX423"></A>
<U>procedure:</U> <B>angle</B> <I>z</I><P>
<A NAME="IDX424"></A>

</P>
<P>
These procedures are part of every implementation that supports
general complex numbers.  Suppose <VAR>x1</VAR>, <VAR>x2</VAR>, <VAR>x3</VAR>, and
<VAR>x4</VAR> are real numbers and <VAR>z</VAR> is a complex number such that

</P>
<P>
<CODE>(= z (+ x1 (* +i x2) (* x3 (exp (* +i x4)))))</CODE>

</P>
<P>
Then <CODE>make-rectangular</CODE> and <CODE>make-polar</CODE> return <VAR>z</VAR>,
<A NAME="IDX425"></A>
<A NAME="IDX426"></A>
<CODE>real-part</CODE> returns <VAR>x1</VAR>, <CODE>imag-part</CODE> returns <VAR>x2</VAR>,
<A NAME="IDX427"></A>
<A NAME="IDX428"></A>
<CODE>magnitude</CODE> returns <VAR>x3</VAR>, and <CODE>angle</CODE> returns <VAR>x4</VAR>.
<A NAME="IDX429"></A>
<A NAME="IDX430"></A>
In the case of <CODE>angle</CODE>, whose value is not uniquely determined by
the preceding rule, the value returned will be the one in the range
<CODE>-pi</CODE> (exclusive) to <CODE>pi</CODE> (inclusive).

</P>
<P>
<EM>Rationale:</EM>  <CODE>Magnitude</CODE> is the same as <CODE>abs</CODE> for a real argument,
<A NAME="IDX431"></A>
<A NAME="IDX432"></A>
but <CODE>abs</CODE> must be present in all implementations, whereas
<A NAME="IDX433"></A>
<CODE>magnitude</CODE> need only be present in implementations that support
<A NAME="IDX434"></A>
general complex numbers.

</P>
<P>

<U>procedure:</U> <B>exact-&#62;inexact</B> <I>z</I><P>
<A NAME="IDX435"></A>
<U>procedure:</U> <B>inexact-&#62;exact</B> <I>z</I><P>
<A NAME="IDX436"></A>

</P>
<P>
<CODE>Exact-&#62;inexact</CODE> returns an inexact representation of
<VAR>z</VAR>.
<A NAME="IDX437"></A>
The value returned is the
inexact number that is numerically closest to the argument.
If an exact argument has no reasonably close inexact equivalent,
then a violation of an implementation restriction may be reported.

</P>
<P>
<CODE>Inexact-&#62;exact</CODE> returns an exact representation of
<A NAME="IDX438"></A>
<VAR>z</VAR>.  The value returned is the exact number that is numerically
closest to the argument.
If an inexact argument has no reasonably close exact equivalent,
then a violation of an implementation restriction may be reported.

</P>

<P>
These procedures implement the natural one-to-one correspondence between
exact and inexact integers throughout an
implementation-dependent range.  See section <A HREF="r4rs.html#SEC53">Implementation restrictions</A>.

</P>


<H3><A NAME="SEC56" HREF="r4rs_toc.html#SEC56">Numerical input and output</A></H3>

<P>
<U>essential procedure:</U> <B>number-&#62;string</B> <I>number</I><P>
<A NAME="IDX439"></A>
<U>essential procedure:</U> <B>number-&#62;string</B> <I>number radix</I><P>
<A NAME="IDX440"></A>

</P>
<P>
<VAR>Radix</VAR> must be an exact integer, either 2, 8, 10, or 16.  If omitted,
<VAR>radix</VAR> defaults to 10.
The procedure <CODE>number-&#62;string</CODE> takes a
<A NAME="IDX441"></A>
number and a radix and returns as a string an external representation of
the given number in the given radix such that

<PRE>
(let ((number <VAR>number</VAR>)
      (radix <VAR>radix</VAR>))
  (eqv? number
        (string-&#62;number (number-&#62;string number
                                        radix)
                        radix)))
</PRE>

<P>
is true.  It is an error if no possible result makes this expression true.

</P>
<P>
If <VAR>number</VAR> is inexact, the radix is 10, and the above expression
can be satisfied by a result that contains a decimal point,
then the result contains a decimal point and is expressed using the
minimum number of digits (exclusive of exponent and trailing
zeroes) needed to make the above expression
true [HOWTOPRINT], [HOWTOREAD];
otherwise the format of the result is unspecified.

</P>
<P>
The result returned by <CODE>number-&#62;string</CODE>
<A NAME="IDX442"></A>
never contains an explicit radix prefix.

</P>
<P>
<EM>Note:</EM>  The error case can occur only when <VAR>number</VAR> is not a complex number
or is a complex number with a non-rational real or imaginary part.

</P>
<P>
<EM>Rationale:</EM>  If <VAR>number</VAR> is an inexact number represented using flonums, and
the radix is 10, then the above expression is normally satisfied by
a result containing a decimal point.  The unspecified case
allows for infinities, NaNs, and non-flonum representations.

</P>
<P>

<U>essential procedure:</U> <B>string-&#62;number</B> <I>string</I><P>
<A NAME="IDX443"></A>
<U>essential procedure:</U> <B>string-&#62;number</B> <I>string radix</I><P>
<A NAME="IDX444"></A>

</P>

<P>
Returns a number of the maximally precise representation expressed by the
given <VAR>string</VAR>.  <VAR>Radix</VAR> must be an exact integer, either 2, 8, 10,
or 16.  If supplied, <VAR>radix</VAR> is a default radix that may be overridden
by an explicit radix prefix in <VAR>string</VAR> (e.g. <CODE>"#o177"</CODE>).  If <VAR>radix</VAR>
is not supplied, then the default radix is 10.  If <VAR>string</VAR> is not
a syntactically valid notation for a number, then <CODE>string-&#62;number</CODE>
<A NAME="IDX445"></A>
returns <CODE>#f</CODE>.

</P>

<PRE>
(string-&#62;number "100")      =>  100
(string-&#62;number "100" 16)   =>  256
(string-&#62;number "1e2")      =>  100.0
(string-&#62;number "15##")     =>  1500.0
</PRE>

<P>
<EM>Note:</EM>  Although <CODE>string-&#62;number</CODE> is an essential procedure,
<A NAME="IDX446"></A>
an implementation may restrict its domain in the
following ways.  <CODE>String-&#62;number</CODE> is permitted to return
<A NAME="IDX447"></A>
<CODE>#f</CODE> whenever <VAR>string</VAR> contains an explicit radix prefix.
If all numbers supported by an implementation are real, then
<CODE>string-&#62;number</CODE> is permitted to return <CODE>#f</CODE> whenever
<A NAME="IDX448"></A>
<VAR>string</VAR> uses the polar or rectangular notations for complex
numbers.  If all numbers are integers, then
<CODE>string-&#62;number</CODE> may return <CODE>#f</CODE> whenever
<A NAME="IDX449"></A>
the fractional notation is used.  If all numbers are exact, then
<CODE>string-&#62;number</CODE> may return <CODE>#f</CODE> whenever
<A NAME="IDX450"></A>
an exponent marker or explicit exactness prefix is used, or if
a <CODE>#</CODE> appears in place of a digit.  If all inexact
numbers are integers, then
<CODE>string-&#62;number</CODE> may return <CODE>#f</CODE> whenever
<A NAME="IDX451"></A>
a decimal point is used.

</P>
<P>



<H2><A NAME="SEC57" HREF="r4rs_toc.html#SEC57">Characters</A></H2>

<P>
Characters are objects that represent printed characters such as
letters and digits.
Characters are written using the notation <TT>#\</TT>&#60;character&#62;
or <TT>#\</TT>&#60;character name&#62;.
For example:

</P>
<DL COMPACT>

<DT><CODE>#\a</CODE>
<DD>
lower case letter
<DT><CODE>#\A</CODE>
<DD>
upper case letter
<DT><CODE>#\(</CODE>
<DD>
left parenthesis
<DT><CODE>#\ </CODE>
<DD>
the space character
<DT><CODE>#\space</CODE>
<DD>
the preferred way to write a space
<DT><CODE>#\newline</CODE>
<DD>
the newline character
</DL>

<P>
Case is significant in <TT>#\</TT>&#60;character&#62;, but not in
<TT>#\</TT>&#60;character name&#62;.  If &#60;character&#62; in
<TT>#\</TT>&#60;character&#62; is alphabetic, then the character
following &#60;character&#62; must be a delimiter character such as a
space or parenthesis.  This rule resolves the ambiguous case where, for
example, the sequence of characters "<CODE>#\space</CODE>"
could be taken to be either a representation of the space character or a
representation of the character "<CODE>#\s</CODE>" followed
by a representation of the symbol "<CODE>pace</CODE>."

</P>

<P>
Characters written in the <TT>#\</TT> notation are self-evaluating.
That is, they do not have to be quoted in programs.

</P>
<P>
Some of the procedures that operate on characters ignore the difference
between upper case and lower case.  The procedures that ignore case have
"<CODE>-ci</CODE>" (for "case insensitive") embedded in their names.

</P>
<P>
<U>essential procedure:</U> <B>char?</B> <I>obj</I><P>
<A NAME="IDX452"></A>

</P>
<P>
Returns <CODE>#t</CODE> if <VAR>obj</VAR> is a character, otherwise returns <CODE>#f</CODE>.

</P>
<P>

<U>essential procedure:</U> <B>char=?</B> <I>char1 char2</I><P>
<A NAME="IDX453"></A>
<U>essential procedure:</U> <B>char&#60;?</B> <I>char1 char2</I><P>
<A NAME="IDX454"></A>
<U>essential procedure:</U> <B>char&#62;?</B> <I>char1 char2</I><P>
<A NAME="IDX455"></A>
<U>essential procedure:</U> <B>char&#60;=?</B> <I>char1 char2</I><P>
<A NAME="IDX456"></A>
<U>essential procedure:</U> <B>char&#62;=?</B> <I>char1 char2</I><P>
<A NAME="IDX457"></A>

</P>
<P>
These procedures impose a total ordering on the set of characters.  It
is guaranteed that under this ordering:

</P>

<UL>
<LI>The upper case characters are in order.  For example,

<CODE>(char&#60;? #\A #\B)</CODE> returns <CODE>#t</CODE>.
<LI>The lower case characters are in order.  For example,

<CODE>(char&#60;? #\a #\b)</CODE> returns <CODE>#t</CODE>.
<LI>The digits are in order.  For example,

<CODE>(char&#60;? #\0 #\9)</CODE> returns <CODE>#t</CODE>.
<LI>Either all the digits precede all the upper case letters, or vice versa.

<LI>Either all the digits precede all the lower case letters, or vice versa.

</UL>

<P>
Some implementations may generalize these procedures to take more than
two arguments, as with the corresponding numerical predicates.

</P>
<P>

<U>essential procedure:</U> <B>char-ci=?</B> <I>char1 char2</I><P>
<A NAME="IDX458"></A>
<U>essential procedure:</U> <B>char-ci&#60;?</B> <I>char1 char2</I><P>
<A NAME="IDX459"></A>
<U>essential procedure:</U> <B>char-ci&#62;?</B> <I>char1 char2</I><P>
<A NAME="IDX460"></A>
<U>essential procedure:</U> <B>char-ci&#60;=?</B> <I>char1 char2</I><P>
<A NAME="IDX461"></A>
<U>essential procedure:</U> <B>char-ci&#62;=?</B> <I>char1 char2</I><P>
<A NAME="IDX462"></A>

</P>
<P>
These procedures are similar to <CODE>char=?</CODE> et cetera, but they treat
<A NAME="IDX463"></A>
upper case and lower case letters as the same.  For example,
<CODE>(char-ci=? #\A #\a)</CODE> returns <CODE>#t</CODE>.
Some implementations may generalize these procedures to take more than
two arguments, as with the corresponding numerical predicates.

</P>
<P>

<U>essential procedure:</U> <B>char-alphabetic?</B> <I>char</I><P>
<A NAME="IDX464"></A>
<U>essential procedure:</U> <B>char-numeric?</B> <I>char</I><P>
<A NAME="IDX465"></A>
<U>essential procedure:</U> <B>char-whitespace?</B> <I>char</I><P>
<A NAME="IDX466"></A>
<U>essential procedure:</U> <B>char-upper-case?</B> <I>letter</I><P>
<A NAME="IDX467"></A>
<U>essential procedure:</U> <B>char-lower-case?</B> <I>letter</I><P>
<A NAME="IDX468"></A>

</P>
<P>
These procedures return <CODE>#t</CODE> if their arguments are alphabetic,
numeric, whitespace, upper case, or lower case characters, respectively,
otherwise they return <CODE>#f</CODE>.  The following remarks, which are specific to
the ASCII character set, are intended only as a guide:  The alphabetic characters
are the 52 upper and lower case letters.  The numeric characters are the
ten decimal digits.  The whitespace characters are space, tab, line
feed, form feed, and carriage return.

</P>

<P>
<U>essential procedure:</U> <B>char-&#62;integer</B> <I>char</I><P>
<A NAME="IDX469"></A>
<U>essential procedure:</U> <B>integer-&#62;char</B> <I>n</I><P>
<A NAME="IDX470"></A>

</P>
<P>
Given a character, <CODE>char-&#62;integer</CODE> returns an exact integer
<A NAME="IDX471"></A>
representation of the character.  Given an exact integer that is the image of
a character under <CODE>char-&#62;integer</CODE>, <CODE>integer-&#62;char</CODE>
<A NAME="IDX472"></A>
<A NAME="IDX473"></A>
returns that character.  These procedures implement injective order isomorphisms
between the set of characters under the <CODE>char&#60;=?</CODE>
<A NAME="IDX474"></A>
ordering and some subset of the integers under the <CODE>&#60;=</CODE>
<A NAME="IDX475"></A>
ordering.  That is, if
<CODE>(char&#60;=? <VAR>a</VAR> <VAR>b</VAR>) => #t  and  (&#60;= <VAR>x</VAR> <VAR>y</VAR>) => #t</CODE>
and <VAR>x</VAR> and <VAR>y</VAR> are in the domain of
<CODE>integer-&#62;char</CODE>, then
<A NAME="IDX476"></A>

</P>

<PRE>
(&#60;= (char-&#62;integer <VAR>a</VAR>)
    (char-&#62;integer <VAR>b</VAR>))       =>  #t

(char&#60;=? (integer-&#62;char <VAR>x</VAR>)
         (integer-&#62;char <VAR>y</VAR>))  =>  #t
</PRE>

<P>

<U>essential procedure:</U> <B>char-upcase</B> <I>char</I><P>
<A NAME="IDX477"></A>
<U>essential procedure:</U> <B>char-downcase</B> <I>char</I><P>
<A NAME="IDX478"></A>

</P>
<P>
These procedures return a character <VAR>char2</VAR> such that <CODE>
(char-ci=? <VAR>char</VAR> <VAR>char2</VAR>)</CODE>.  In addition, if <VAR>char</VAR> is
alphabetic, then the result of <CODE>char-upcase</CODE> is upper case and the
<A NAME="IDX479"></A>
result of <CODE>char-downcase</CODE> is lower case.
<A NAME="IDX480"></A>

</P>
<P>



<H2><A NAME="SEC58" HREF="r4rs_toc.html#SEC58">Strings</A></H2>

<P>
Strings are sequences of characters.
<A NAME="IDX481"></A>
Strings are written as sequences of characters enclosed within doublequotes
(<CODE>"</CODE>).  A doublequote can be written inside a string only by escaping
it with a backslash (<TT>\</TT>), as in

</P>

<PRE>
"The word \"recursion\" has many meanings."
</PRE>

<P>
A backslash can be written inside a string only by escaping it with another
backslash.  Scheme does not specify the effect of a backslash within a
string that is not followed by a doublequote or backslash.

</P>
<P>
A string constant may continue from one line to the next, but
the exact contents of such a string are unspecified.

</P>
<P>
The <EM>length</EM> of a string is the number of characters that it
contains.  This number is a non-negative integer that is fixed when the
string is created.  The <STRONG>valid indexes</STRONG> of a string are the
exact non-negative integers less than the length of the string.  The first
character of a string has index 0, the second has index 1, and so on.

</P>
<P>
In phrases such as "the characters of <VAR>string</VAR> beginning with
index <VAR>start</VAR> and ending with index <VAR>end</VAR>," it is understood
that the index <VAR>start</VAR> is inclusive and the index <VAR>end</VAR> is
exclusive.  Thus if <VAR>start</VAR> and <VAR>end</VAR> are the same index, a null
substring is referred to, and if <VAR>start</VAR> is zero and <VAR>end</VAR> is
the length of <VAR>string</VAR>, then the entire string is referred to.

</P>
<P>
Some of the procedures that operate on strings ignore the
difference between upper and lower case.  The versions that ignore case
have "<CODE>-ci</CODE>" (for "case insensitive") embedded in their
names.

</P>
<P>
<U>essential procedure:</U> <B>string?</B> <I>obj</I><P>
<A NAME="IDX482"></A>

</P>
<P>
Returns <CODE>#t</CODE> if <VAR>obj</VAR> is a string, otherwise returns <CODE>#f</CODE>.

</P>
<P>
<U>essential procedure:</U> <B>make-string</B> <I>k</I><P>
<A NAME="IDX483"></A>
<U>essential procedure:</U> <B>make-string</B> <I>k char</I><P>
<A NAME="IDX484"></A>

</P>
<P>
<CODE>Make-string</CODE> returns a newly allocated string of
<A NAME="IDX485"></A>
length <VAR>k</VAR>.  If <VAR>char</VAR> is given, then all elements of the string
are initialized to <VAR>char</VAR>, otherwise the contents of the
<VAR>string</VAR> are unspecified.

</P>
<P>

<U>essential procedure:</U> <B>string</B> <I>char ...</I><P>
<A NAME="IDX486"></A>

</P>
<P>
Returns a newly allocated string composed of the arguments.

</P>
<P>

<U>essential procedure:</U> <B>string-length</B> <I>string</I><P>
<A NAME="IDX487"></A>

</P>
<P>
Returns the number of characters in the given <VAR>string</VAR>.

</P>
<P>
<U>essential procedure:</U> <B>string-ref</B> <I>string k</I><P>
<A NAME="IDX488"></A>

</P>
<P>
<VAR>k</VAR> must be a valid index of <VAR>string</VAR>.
<CODE>String-ref</CODE> returns character <VAR>k</VAR> of <VAR>string</VAR> using
zero-origin indexing.
<A NAME="IDX489"></A>

</P>
<P>
<U>essential procedure:</U> <B>string-set!</B> <I>string k char</I><P>
<A NAME="IDX490"></A>

</P>
<P>
<VAR>k</VAR> must be a valid index of <VAR>string</VAR>%, and <VAR>char</VAR> must be a character
.
<CODE>String-set!</CODE> stores <VAR>char</VAR> in element <VAR>k</VAR> of <VAR>string</VAR>
<A NAME="IDX491"></A>
and returns an unspecified value.  

</P>

<PRE>
(define (f) (make-string 3 #\*))
(define (g) "***")
(string-set! (f) 0 #\?)     =>  <EM>unspecified</EM>
(string-set! (g) 0 #\?)     =>  <EM>error</EM>
(string-set! (symbol-&#62;string 'immutable)
             0
             #\?)           =>  <EM>error</EM>
</PRE>

<P>

<U>essential procedure:</U> <B>string=?</B> <I>string1 string2</I><P>
<A NAME="IDX492"></A>
<U>essential procedure:</U> <B>string-ci=?</B> <I>string1 string2</I><P>
<A NAME="IDX493"></A>

</P>
<P>
Returns <CODE>#t</CODE> if the two strings are the same length and contain the same
characters in the same positions, otherwise returns <CODE>#f</CODE>.
<CODE>String-ci=?</CODE> treats
<A NAME="IDX494"></A>
upper and lower case letters as though they were the same character, but
<CODE>string=?</CODE> treats upper and lower case as distinct characters.
<A NAME="IDX495"></A>

</P>
<P>

<U>essential procedure:</U> <B>string&#60;?</B> <I>string1 string2</I><P>
<A NAME="IDX496"></A>
<U>essential procedure:</U> <B>string&#62;?</B> <I>string1 string2</I><P>
<A NAME="IDX497"></A>
<U>essential procedure:</U> <B>string&#60;=?</B> <I>string1 string2</I><P>
<A NAME="IDX498"></A>
<U>essential procedure:</U> <B>string&#62;=?</B> <I>string1 string2</I><P>
<A NAME="IDX499"></A>
<U>essential procedure:</U> <B>string-ci&#60;?</B> <I>string1 string2</I><P>
<A NAME="IDX500"></A>
<U>essential procedure:</U> <B>string-ci&#62;?</B> <I>string1 string2</I><P>
<A NAME="IDX501"></A>
<U>essential procedure:</U> <B>string-ci&#60;=?</B> <I>string1 string2</I><P>
<A NAME="IDX502"></A>
<U>essential procedure:</U> <B>string-ci&#62;=?</B> <I>string1 string2</I><P>
<A NAME="IDX503"></A>

</P>
<P>
These procedures are the lexicographic extensions to strings of the
corresponding orderings on characters.  For example, <CODE>string&#60;?</CODE> is
<A NAME="IDX504"></A>
the lexicographic ordering on strings induced by the ordering
<CODE>char&#60;?</CODE> on characters.  If two strings differ in length but
<A NAME="IDX505"></A>
are the same up to the length of the shorter string, the shorter string
is considered to be lexicographically less than the longer string.

</P>
<P>
Implementations may generalize these and the <CODE>string=?</CODE> and
<A NAME="IDX506"></A>
<CODE>string-ci=?</CODE> procedures to take more than two arguments, as with
<A NAME="IDX507"></A>
the corresponding numerical predicates.

</P>
<P>

<U>essential procedure:</U> <B>substring</B> <I>string start end</I><P>
<A NAME="IDX508"></A>

</P>
<P>
<VAR>String</VAR> must be a string, and <VAR>start</VAR> and <VAR>end</VAR>
must be exact integers satisfying

</P>
<P>
<CODE>(&#60;= 0 <I>start</I> <I>end</I> (string-length <I>string</I>).)</CODE>

</P>
<P>
<CODE>Substring</CODE> returns a newly allocated string formed from the
characters of
<A NAME="IDX509"></A>
<VAR>string</VAR> beginning with index <VAR>start</VAR> (inclusive) and ending with index
<VAR>end</VAR> (exclusive).

</P>
<P>
<U>essential procedure:</U> <B>string-append</B> <I>string ...</I><P>
<A NAME="IDX510"></A>

</P>
<P>
Returns a newly allocated string whose characters form the concatenation of the
given strings.

</P>
<P>

<U>essential procedure:</U> <B>string-&#62;list</B> <I>string</I><P>
<A NAME="IDX511"></A>
<U>essential procedure:</U> <B>list-&#62;string</B> <I>chars</I><P>
<A NAME="IDX512"></A>

</P>
<P>
<CODE>String-&#62;list</CODE> returns a newly allocated list of the
<A NAME="IDX513"></A>
characters that make up the given string.  <CODE>List-&#62;string</CODE>
<A NAME="IDX514"></A>
returns a newly allocated string formed from the characters in the list
<VAR>chars</VAR>. <CODE>String-&#62;list</CODE> and <CODE>list-&#62;string</CODE> are
<A NAME="IDX515"></A>
<A NAME="IDX516"></A>
inverses so far as <CODE>equal?</CODE> is concerned.
<A NAME="IDX517"></A>

</P>
<P>

<U>procedure:</U> <B>string-copy</B> <I>string</I><P>
<A NAME="IDX518"></A>

</P>
<P>
Returns a newly allocated copy of the given <VAR>string</VAR>.

</P>
<P>

<U>procedure:</U> <B>string-fill!</B> <I>string char</I><P>
<A NAME="IDX519"></A>

</P>
<P>
Stores <VAR>char</VAR> in every element of the given <VAR>string</VAR> and returns an
unspecified value.  

</P>
<P>



<H2><A NAME="SEC59" HREF="r4rs_toc.html#SEC59">Vectors</A></H2>

<P>
Vectors are heterogenous structures whose elements are indexed
by integers.  A vector typically occupies less space than a list
of the same length, and the average time required to access a randomly
chosen element is typically less for the vector than for the list.

</P>
<P>
The <EM>length</EM> of a vector is the number of elements that it
contains.  This number is a non-negative integer that is fixed when the
vector is created.  The <EM>valid indexes</EM>
<A NAME="IDX520"></A>
of a vector are the exact non-negative integers less than the length of
the vector.  The first element in a vector is indexed by zero, and the
last element is indexed by one less than the length of the vector.

</P>
<P>
Vectors are written using the notation <CODE>#(<VAR>obj</VAR> ...)</CODE>.
For example, a vector of length 3 containing the number zero in element
0, the list <CODE>(2 2 2 2)</CODE> in element 1, and the string <CODE>"Anna"</CODE> in
element 2 can be written as following:

</P>

<PRE>
#(0 (2 2 2 2) "Anna")
</PRE>

<P>
Note that this is the external representation of a vector, not an
expression evaluating to a vector.  Like list constants, vector
constants must be quoted:

</P>

<PRE>
'#(0 (2 2 2 2) "Anna")  
          =>  #(0 (2 2 2 2) "Anna")
</PRE>

<P>
<U>essential procedure:</U> <B>vector?</B> <I>obj</I><P>
<A NAME="IDX521"></A>

</P>
<P>
Returns <CODE>#t</CODE> if <VAR>obj</VAR> is a vector, otherwise returns <CODE>#f</CODE>.

</P>
<P>
<U>essential procedure:</U> <B>make-vector</B> <I>k</I><P>
<A NAME="IDX522"></A>
<U>procedure:</U> <B>make-vector</B> <I>k fill</I><P>
<A NAME="IDX523"></A>

</P>
<P>
Returns a newly allocated vector of <VAR>k</VAR> elements.  If a second
argument is given, then each element is initialized to <VAR>fill</VAR>.
Otherwise the initial contents of each element is unspecified.

</P>
<P>

<U>essential procedure:</U> <B>vector</B> <I>obj ...</I><P>
<A NAME="IDX524"></A>

</P>
<P>
Returns a newly allocated vector whose elements contain the given
arguments.  Analogous to <CODE>list</CODE>.
<A NAME="IDX525"></A>

</P>

<PRE>
(vector 'a 'b 'c)           =>  #(a b c)
</PRE>

<P>

<U>essential procedure:</U> <B>vector-length</B> <I>vector</I><P>
<A NAME="IDX526"></A>

</P>
<P>
Returns the number of elements in <VAR>vector</VAR>.

</P>
<P>
<U>essential procedure:</U> <B>vector-ref</B> <I>vector k</I><P>
<A NAME="IDX527"></A>

</P>
<P>
<VAR>k</VAR> must be a valid index of <VAR>vector</VAR>.
<CODE>Vector-ref</CODE> returns the contents of element <VAR>k</VAR> of
<A NAME="IDX528"></A>
<VAR>vector</VAR>.

</P>

<PRE>
(vector-ref '#(1 1 2 3 5 8 13 21)
            5)  
          =>  8
(vector-ref '#(1 1 2 3 5 8 13 21)
            (inexact-&#62;exact
              (round (* 2 (acos -1))))) 
          =>  13
</PRE>

<P>

<U>essential procedure:</U> <B>vector-set!</B> <I>vector k obj</I><P>
<A NAME="IDX529"></A>

</P>
<P>
<VAR>k</VAR> must be a valid index of <VAR>vector</VAR>.
<CODE>Vector-set!</CODE> stores <VAR>obj</VAR> in element <VAR>k</VAR> of <VAR>vector</VAR>.
<A NAME="IDX530"></A>
The value returned by <CODE>vector-set!</CODE> is unspecified.  
<A NAME="IDX531"></A>

</P>

<PRE>
(let ((vec (vector 0 '(2 2 2 2) "Anna")))
  (vector-set! vec 1 '("Sue" "Sue"))
  vec)      
          =>  #(0 ("Sue" "Sue") "Anna")

(vector-set! '#(0 1 2) 1 "doe")  
          =>  <EM>error</EM>  ; constant vector
</PRE>

<P>

<U>essential procedure:</U> <B>vector-&#62;list</B> <I>vector</I><P>
<A NAME="IDX532"></A>
<U>essential procedure:</U> <B>list-&#62;vector</B> <I>list</I><P>
<A NAME="IDX533"></A>

</P>
<P>
<CODE>Vector-&#62;list</CODE> returns a newly allocated list of the objects
contained
<A NAME="IDX534"></A>
in the elements of <VAR>vector</VAR>.  <CODE>List-&#62;vector</CODE> returns a newly
<A NAME="IDX535"></A>
created vector initialized to the elements of the list <VAR>list</VAR>.

</P>

<PRE>
(vector-&#62;list '#(dah dah didah))  
          =>  (dah dah didah)
(list-&#62;vector '(dididit dah))   
          =>  #(dididit dah)
</PRE>

<P>

<U>procedure:</U> <B>vector-fill!</B> <I>vector fill</I><P>
<A NAME="IDX536"></A>

</P>
<P>
Stores <VAR>fill</VAR> in every element of <VAR>vector</VAR>.
The value returned by <CODE>vector-fill!</CODE> is unspecified.  
<A NAME="IDX537"></A>

</P>
<P>



<H2><A NAME="SEC60" HREF="r4rs_toc.html#SEC60">Control features</A></H2>

<P>
This chapter describes various primitive procedures which control the
flow of program execution in special ways.
The <CODE>procedure?</CODE> predicate is also described here.
<A NAME="IDX538"></A>

</P>

<P>
<U>essential procedure:</U> <B>procedure?</B> <I>obj</I><P>
<A NAME="IDX539"></A>

</P>
<P>
Returns <CODE>#t</CODE> if <VAR>obj</VAR> is a procedure, otherwise returns <CODE>#f</CODE>.

</P>

<PRE>
(procedure? car)            =>  #t
(procedure? 'car)           =>  #f
(procedure? (lambda (x) (* x x)))
                            =>  #t
(procedure? '(lambda (x) (* x x)))
                            =>  #f
(call-with-current-continuation procedure?)
                            =>  #t
</PRE>

<P>

<U>essential procedure:</U> <B>apply</B> <I>proc args</I><P>
<A NAME="IDX540"></A>
<U>procedure:</U> <B>apply</B> <I>proc arg1 ... args</I><P>
<A NAME="IDX541"></A>

</P>
<P>
<VAR>Proc</VAR> must be a procedure and <VAR>args</VAR> must be a list.
The first (essential) form calls <VAR>proc</VAR> with the elements of
<VAR>args</VAR> as the actual arguments.  The second form is a generalization
of the first that calls <VAR>proc</VAR> with the elements of the list
<CODE>(append (list <VAR>arg1</VAR> ...) <VAR>args</VAR>)</CODE> as the actual
arguments.

</P>

<PRE>
(apply + (list 3 4))        =>  7

(define compose
  (lambda (f g)
    (lambda args
      (f (apply g args)))))

((compose sqrt *) 12 75)    =>  30
</PRE>

<P>

<U>essential procedure:</U> <B>map</B> <I>proc list1 list2 ...</I><P>
<A NAME="IDX542"></A>

</P>
<P>
The <VAR>list</VAR>s must be lists, and <VAR>proc</VAR> must be a
procedure taking as many arguments as there are <I>list</I>s.  If more
than one <VAR>list</VAR> is given, then they must all be the same length.
<CODE>Map</CODE> applies <VAR>proc</VAR> element-wise to the elements of the
<A NAME="IDX543"></A>
<VAR>list</VAR>s and returns a list of the results, in order from left to right.
The dynamic order in which <VAR>proc</VAR> is applied to the elements of the
<VAR>list</VAR>s is unspecified.

</P>

<PRE>
(map cadr '((a b) (d e) (g h)))   
                            =>  (b e h)

(map (lambda (n) (expt n n))
     '(1 2 3 4 5))                
                            =>  (1 4 27 256 3125)

(map + '(1 2 3) '(4 5 6))   =>  (5 7 9)

(let ((count 0))
  (map (lambda (ignored)
         (set! count (+ count 1))
         count)
       '(a b c)))           =>  <EM>unspecified</EM>
</PRE>

<P>

<U>essential procedure:</U> <B>for-each</B> <I>proc list1 list2 ...</I><P>
<A NAME="IDX544"></A>

</P>
<P>
The arguments to <CODE>for-each</CODE> are like the arguments to <CODE>map</CODE>, but
<A NAME="IDX545"></A>
<A NAME="IDX546"></A>
<CODE>for-each</CODE> calls <VAR>proc</VAR> for its side effects rather than for
its values.  Unlike <CODE>map</CODE>, <CODE>for-each</CODE> is guaranteed to call
<VAR>proc</VAR> on the elements of the <VAR>list</VAR>s in order from the first
element to the last, and the value returned by <CODE>for-each</CODE> is
unspecified.

</P>

<PRE>
(let ((v (make-vector 5)))
  (for-each (lambda (i)
              (vector-set! v i (* i i)))
            '(0 1 2 3 4))
  v)                        =>  #(0 1 4 9 16)
</PRE>

<P>

<U>procedure:</U> <B>force</B> <I>promise</I><P>
<A NAME="IDX547"></A>

</P>
<P>
Forces the value of <VAR>promise</VAR> (see section <A HREF="r4rs.html#SEC38">Delayed evaluation</A>).

</P>
<P>
<A NAME="IDX548"></A>
<A NAME="IDX549"></A>
If no value has been computed for the promise, then a value is computed
and returned.  The value of the promise is cached (or "memoized") so
that if it is forced a second time, the previously computed value is
returned.

</P>

<PRE>
(force (delay (+ 1 2)))     =>  3
(let ((p (delay (+ 1 2))))
  (list (force p) (force p)))
                            =>  (3 3)

(define a-stream
  (letrec ((next
            (lambda (n)
              (cons n (delay (next (+ n 1)))))))
    (next 0)))
(define head car)
(define tail
  (lambda (stream) (force (cdr stream))))

(head (tail (tail a-stream)))
                            =>  2
</PRE>

<P>
<CODE>Force</CODE> and <CODE>delay</CODE> are mainly intended for programs written
<A NAME="IDX550"></A>
<A NAME="IDX551"></A>
in functional style.  The following examples should not be considered to
illustrate good programming style, but they illustrate the property that
only one value is computed for a promise, no matter how many times it is
forced.

</P>

<PRE>
(define count 0)
(define p
  (delay (begin (set! count (+ count 1))
                (if (&#62; count x)
                    count
                    (force p)))))
(define x 5)
p                           =>  <EM>a promise</EM>
(force p)                   =>  6
p                           =>  <EM>a promise, still</EM>
(begin (set! x 10)
       (force p))           =>  6
</PRE>

<P>
Here is a possible implementation of <CODE>delay</CODE> and <CODE>force</CODE>.
<A NAME="IDX552"></A>
<A NAME="IDX553"></A>
Promises are implemented here as procedures of no arguments,
and <CODE>force</CODE> simply calls its argument:
<A NAME="IDX554"></A>

</P>

<PRE>
(define force
  (lambda (object)
    (object)))
</PRE>

<P>
We define the expression

</P>

<PRE>
(delay &#60;expression&#62;)
</PRE>

<P>
to have the same meaning as the procedure call

</P>

<PRE>
(make-promise (lambda () &#60;expression&#62;)),
</PRE>

<P>
where <CODE>make-promise</CODE> is defined as follows:
<A NAME="IDX555"></A>

</P>


<PRE>
(define make-promise
  (lambda (proc)
    (let ((result-ready? #f)
          (result #f))
      (lambda ()
        (if result-ready?
            result
            (let ((x (proc)))
              (if result-ready?
                  result
                  (begin (set! result-ready? #t)
                         (set! result x)
                         result))))))))
</PRE>

<P>
<EM>Rationale:</EM>  A promise may refer to its own value, as in the last example above.
Forcing such a promise may cause the promise to be forced a second time
before the value of the first force has been computed.
This complicates the definition of <CODE>make-promise</CODE>.
<A NAME="IDX556"></A>

</P>
<P>
Various extensions to this semantics of <CODE>delay</CODE> and <CODE>force</CODE>
<A NAME="IDX557"></A>
<A NAME="IDX558"></A>
are supported in some implementations:

</P>

<UL>
<LI>Calling <CODE>force</CODE> on an object that is not a promise may simply

<A NAME="IDX559"></A>
return the object.

<LI>It may be the case that there is no means by which a promise can be

operationally distinguished from its forced value.  That is, expressions
like the following may evaluate to either <CODE>#t</CODE> or to <CODE>#f</CODE>,
depending on the implementation:


<PRE>
(eqv? (delay 1) 1)          =>  <EM>unspecified</EM>
(pair? (delay (cons 1 2)))  =>  <EM>unspecified</EM>
</PRE>

<LI>Some implementations may implement "implicit forcing," where

the value of a promise is forced by primitive procedures like <CODE>cdr</CODE>
<A NAME="IDX560"></A>
and <CODE>+</CODE>:
<A NAME="IDX561"></A>


<PRE>
(+ (delay (* 3 7)) 13)      =>  34
</PRE>

</UL>

<P>

<U>essential procedure:</U> <B>call-with-current-continuation</B> <I>proc</I><P>
<A NAME="IDX562"></A>

</P>
<P>
<VAR>Proc</VAR> must be a procedure of one
argument. The procedure <CODE>call-with-current-continuation</CODE> packages
<A NAME="IDX563"></A>
up the current continuation (see the rationale below) as an "escape
procedure"
<A NAME="IDX564"></A>
and passes it as an argument to
<VAR>proc</VAR>.  The escape procedure is a Scheme procedure of one
argument that, if it is later passed a value, will ignore whatever
continuation is in effect at that later time and will give the value
instead to the continuation that was in effect when the escape procedure
was created.

</P>
<P>
The escape procedure that is passed to <VAR>proc</VAR> has
unlimited extent just like any other procedure in Scheme.  It may be stored
in variables or data structures and may be called as many times as desired.

</P>
<P>
The following examples show only the most common uses of
<CODE>call-with-current-continuation</CODE>.  If all real programs were as
<A NAME="IDX565"></A>
simple as these examples, there would be no need for a procedure with
the power of <CODE>call-with-current-continuation</CODE>.
<A NAME="IDX566"></A>

</P>

<PRE>
(call-with-current-continuation
  (lambda (exit)
    (for-each (lambda (x)
                (if (negative? x)
                    (exit x)))
              '(54 0 37 -3 245 19))
    #t))                    =>  -3

(define list-length
  (lambda (obj)
    (call-with-current-continuation
      (lambda (return)
        (letrec ((r
                  (lambda (obj)
                    (cond ((null? obj) 0)
                          ((pair? obj)
                           (+ (r (cdr obj)) 1))
                          (else (return #f))))))
          (r obj))))))

(list-length '(1 2 3 4))    =>  4

(list-length '(a b . c))    =>  #f
</PRE>

<P>
<EM>Rationale:</EM>  
A common use of <CODE>call-with-current-continuation</CODE> is for
<A NAME="IDX567"></A>
structured, non-local exits from loops or procedure bodies, but in fact
<CODE>call-with-current-continuation</CODE> is extremely useful for
implementing a
<A NAME="IDX568"></A>
wide variety of advanced control structures.

</P>
<P>
Whenever a Scheme expression is evaluated there is a
<STRONG>continuation</STRONG> wanting the result of the expression.  The continuation
represents an entire (default) future for the computation.  If the expression is
evaluated at top level, for example, then the continuation might take the
result, print it on the screen, prompt for the next input, evaluate it, and
so on forever.  Most of the time the continuation includes actions
specified by user code, as in a continuation that will take the result,
multiply it by the value stored in a local variable, add seven, and give
the answer to the top level continuation to be printed.  Normally these
ubiquitous continuations are hidden behind the scenes and programmers don't
think much about them.  On rare occasions, however, a programmer may
need to deal with continuations explicitly.
<CODE>Call-with-current-continuation</CODE> allows Scheme programmers to do
<A NAME="IDX569"></A>
that by creating a procedure that acts just like the current
continuation.

</P>
<P>
Most programming languages incorporate one or more special-purpose
escape constructs with names like <CODE>exit</CODE>, <CODE>return</CODE>, or
<A NAME="IDX570"></A>
even <CODE>goto</CODE>.  In 1965, however, Peter Landin [LANDIN65]
invented a general purpose escape operator called the J-operator.  John
Reynolds [REYNOLDS72] described a simpler but equally powerful
construct in 1972.  The <CODE>catch</CODE> special form described by Sussman
<A NAME="IDX571"></A>
and Steele in the 1975 report on Scheme is exactly the same as
Reynolds's construct, though its name came from a less general construct
in MacLisp.  Several Scheme implementors noticed that the full power of the
<CODE>catch</CODE> construct could be provided by a procedure instead of by a
<A NAME="IDX572"></A>
special syntactic construct, and the name
<CODE>call-with-current-continuation</CODE> was coined in 1982.  This name is
<A NAME="IDX573"></A>
descriptive, but opinions differ on the merits of such a long name, and
some people use the name <CODE>call/cc</CODE> instead.
<A NAME="IDX574"></A>

</P>
<P>



<H2><A NAME="SEC61" HREF="r4rs_toc.html#SEC61">Input and output</A></H2>



<H3><A NAME="SEC62" HREF="r4rs_toc.html#SEC62">Ports</A></H3>

<P>
Ports represent input and output devices.  To Scheme, an input port is a
Scheme object that can deliver characters upon command, while an output port
is a Scheme object that can accept characters.
<A NAME="IDX575"></A>

</P>

<P>
<U>essential procedure:</U> <B>call-with-input-file</B> <I>string proc</I><P>
<A NAME="IDX576"></A>
<U>essential procedure:</U> <B>call-with-output-file</B> <I>string proc</I><P>
<A NAME="IDX577"></A>

</P>
<P>
<VAR>Proc</VAR> should be a procedure of one argument, and
<VAR>string</VAR> should be a string naming a file.  For
<CODE>call-with-input-file</CODE>, the file must already exist; for
<A NAME="IDX578"></A>
<CODE>call-with-output-file</CODE>, the effect is unspecified if the file
<A NAME="IDX579"></A>
already exists. These procedures call <VAR>proc</VAR> with one argument: the
port obtained by opening the named file for input or output.  If the
file cannot be opened, an error is signalled.  If the procedure returns,
then the port is closed automatically and the value yielded by the
procedure is returned.  If the procedure does not return, then
the port will not be closed automatically unless it is possible to
prove that the port will never again be used for a read or write
operation.

</P>
<P>
<EM>Rationale:</EM>  Because Scheme's escape procedures have unlimited extent, it  is
possible to escape from the current continuation but later to escape back in.
If implementations were permitted to close the port on any escape from the
current continuation, then it would be impossible to write portable code using
both <CODE>call-with-current-continuation</CODE> and
<CODE>call-with-input-file</CODE> or <CODE>call-with-output-file</CODE>.
<A NAME="IDX580"></A>
<A NAME="IDX581"></A>
<A NAME="IDX582"></A>

</P>
<P>

<U>essential procedure:</U> <B>input-port?</B> <I>obj</I><P>
<A NAME="IDX583"></A>
<U>essential procedure:</U> <B>output-port?</B> <I>obj</I><P>
<A NAME="IDX584"></A>

</P>
<P>
Returns <CODE>#t</CODE> if <VAR>obj</VAR> is an input port or output port
respectively, otherwise returns <CODE>#f</CODE>.

</P>

<P>

<U>essential procedure:</U> <B>current-input-port</B><P>
<A NAME="IDX585"></A>
<U>essential procedure:</U> <B>current-output-port</B><P>
<A NAME="IDX586"></A>

</P>
<P>
Returns the current default input or output port.

</P>
<P>

<U>procedure:</U> <B>with-input-from-file</B> <I>string thunk</I><P>
<A NAME="IDX587"></A>
<U>procedure:</U> <B>with-output-to-file</B> <I>string thunk</I><P>
<A NAME="IDX588"></A>

</P>
<P>
<VAR>Thunk</VAR> must be a procedure of no arguments, and
<VAR>string</VAR> must be a string naming a file.  For
<CODE>with-input-from-file</CODE>, the file must already exist; for
<A NAME="IDX589"></A>
<CODE>with-output-to-file</CODE>, the effect is unspecified if the file
already
<A NAME="IDX590"></A>
exists. The file is opened for input or output, an input or output port
connected to it is made the default value returned by
<CODE>current-input-port</CODE> or <CODE>current-output-port</CODE>, and the
<A NAME="IDX591"></A>
<A NAME="IDX592"></A>
<VAR>thunk</VAR> is called with no arguments.  When the <VAR>thunk</VAR> returns,
the port is closed and the previous default is restored.
<CODE>With-input-from-file</CODE> and <CODE>with-output-to-file</CODE> return the
<A NAME="IDX593"></A>
<A NAME="IDX594"></A>
value yielded by <VAR>thunk</VAR>.
If an escape procedure
is used to escape from the continuation of these procedures, their
behavior is implementation dependent.

</P>

<P>

<U>essential procedure:</U> <B>open-input-file</B> <I>filename</I><P>
<A NAME="IDX595"></A>

</P>
<P>
Takes a string naming an existing file and returns an input port capable of
delivering characters from the file.  If the file cannot be opened, an error is
signalled.

</P>
<P>

<U>essential procedure:</U> <B>open-output-file</B> <I>filename</I><P>
<A NAME="IDX596"></A>

</P>
<P>
Takes a string naming an output file to be created and returns an output
port capable of writing characters to a new file by that name.  If the file
cannot be opened, an error is signalled.  If a file with the given name
already exists, the effect is unspecified.

</P>
<P>

<U>essential procedure:</U> <B>close-input-port</B> <I>port</I><P>
<A NAME="IDX597"></A>
<U>essential procedure:</U> <B>close-output-port</B> <I>port</I><P>
<A NAME="IDX598"></A>

</P>
<P>
Closes the file associated with <VAR>port</VAR>, rendering the <VAR>port</VAR>
incapable of delivering or accepting characters.

</P>
<P>
These routines have no effect if the file has already been closed.
The value returned is unspecified.

</P>

<P>



<H3><A NAME="SEC63" HREF="r4rs_toc.html#SEC63">Input</A></H3>

<P>
<U>essential procedure:</U> <B>read</B><P>
<A NAME="IDX599"></A>
<U>essential procedure:</U> <B>read</B> <I>port</I><P>
<A NAME="IDX600"></A>

</P>
<P>
<CODE>Read</CODE> converts external representations of Scheme objects into the
<A NAME="IDX601"></A>
objects themselves.  That is, it is a parser for the nonterminal
&#60;datum&#62; (see section <A HREF="r4rs.html#SEC22">External representations</A> and
section <A HREF="r4rs.html#SEC48">Pairs and lists</A>).  <CODE>Read</CODE> returns the next
object parsable from the given input <VAR>port</VAR>, updating <VAR>port</VAR> to point to
the first character past the end of the external representation of the object.

</P>
<P>
If an end of file is encountered in the input before any characters are
found that can begin an object, then an end of file object is returned.
The port remains open, and further attempts to read will also return an
end of file object.  If an end of file is encountered after the
beginning of an object's external representation, but the external
representation is incomplete and therefore not parsable, an error is
signalled.

</P>
<P>
The <VAR>port</VAR> argument may be omitted, in which case it defaults to the
value returned by <CODE>current-input-port</CODE>.  It is an error to read
from a closed port.
<A NAME="IDX602"></A>

</P>
<P>
<U>essential procedure:</U> <B>read-char</B><P>
<A NAME="IDX603"></A>
<U>essential procedure:</U> <B>read-char</B> <I>port</I><P>
<A NAME="IDX604"></A>

</P>
<P>
Returns the next character available from the input <VAR>port</VAR>, updating
the <VAR>port</VAR> to point to the following character.  If no more characters
are available, an end of file object is returned.  <VAR>Port</VAR> may be
omitted, in which case it defaults to the value returned by
<CODE>current-input-port</CODE>.
<A NAME="IDX605"></A>

</P>
<P>

<U>essential procedure:</U> <B>peek-char</B><P>
<A NAME="IDX606"></A>
<U>essential procedure:</U> <B>peek-char</B> <I>port</I><P>
<A NAME="IDX607"></A>

</P>
<P>
Returns the next character available from the input <VAR>port</VAR>,
<EM>without</EM> updating
the <VAR>port</VAR> to point to the following character.  If no more characters
are available, an end of file object is returned.  <VAR>Port</VAR> may be
omitted, in which case it defaults to the value returned by
<CODE>current-input-port</CODE>.
<A NAME="IDX608"></A>

</P>
<P>
<EM>Note:</EM>  The value returned by a call to <CODE>peek-char</CODE> is the same as the
<A NAME="IDX609"></A>
value that would have been returned by a call to <CODE>read-char</CODE> with
the
<A NAME="IDX610"></A>
same <VAR>port</VAR>.  The only difference is that the very next call to
<CODE>read-char</CODE> or <CODE>peek-char</CODE> on that <VAR>port</VAR> will return
<A NAME="IDX611"></A>
the
<A NAME="IDX612"></A>
value returned by the preceding call to <CODE>peek-char</CODE>.  In
particular, a call
<A NAME="IDX613"></A>
to <CODE>peek-char</CODE> on an interactive port will hang waiting for input
<A NAME="IDX614"></A>
whenever a call to <CODE>read-char</CODE> would have hung.
<A NAME="IDX615"></A>

</P>
<P>

<U>essential procedure:</U> <B>eof-object?</B> <I>obj</I><P>
<A NAME="IDX616"></A>

</P>
<P>
Returns <CODE>#t</CODE> if <VAR>obj</VAR> is an end of file object, otherwise returns
<CODE>#f</CODE>.  The precise set of end of file objects will vary among
implementations, but in any case no end of file object will ever be an object
that can be read in using <CODE>read</CODE>.
<A NAME="IDX617"></A>

</P>
<P>

<U>procedure:</U> <B>char-ready?</B><P>
<A NAME="IDX618"></A>
<U>procedure:</U> <B>char-ready?</B> <I>port</I><P>
<A NAME="IDX619"></A>

</P>
<P>
Returns <CODE>#t</CODE> if a character is ready on the input <VAR>port</VAR> and
returns <CODE>#f</CODE> otherwise.  If <CODE>char-ready?</CODE> returns <CODE>#t</CODE>
then
<A NAME="IDX620"></A>
the next <CODE>read-char</CODE> operation on the given <VAR>port</VAR> is
guaranteed
<A NAME="IDX621"></A>
not to hang.  If the <VAR>port</VAR> is at end of file then
<CODE>char-ready?</CODE> returns <CODE>#t</CODE>.
<A NAME="IDX622"></A>
<VAR>Port</VAR> may be omitted, in which case it defaults to
the value returned by <CODE>current-input-port</CODE>.
<A NAME="IDX623"></A>

</P>
<P>
<EM>Rationale:</EM>  <CODE>Char-ready?</CODE> exists to make it possible for a program to
<A NAME="IDX624"></A>
accept characters from interactive ports without getting stuck waiting
for input.  Any input editors associated with such ports must ensure
that characters whose existence has been asserted by <CODE>char-ready?</CODE>
<A NAME="IDX625"></A>
cannot be rubbed out.  If <CODE>char-ready?</CODE> were to return <CODE>#f</CODE> at
end of file, a port at end of file would be indistinguishable from an
interactive port that has no ready characters.

</P>


<H3><A NAME="SEC64" HREF="r4rs_toc.html#SEC64">Output</A></H3>

<P>
<U>essential procedure:</U> <B>write</B> <I>obj</I><P>
<A NAME="IDX626"></A>
<U>essential procedure:</U> <B>write</B> <I>obj port</I><P>
<A NAME="IDX627"></A>

</P>
<P>
Writes a written representation of <VAR>obj</VAR> to the given <VAR>port</VAR>.  Strings
that appear in the written representation are enclosed in doublequotes, and
within those strings backslash and doublequote characters are
escaped by backslashes.  <CODE>Write</CODE> returns an unspecified value.  The
<A NAME="IDX628"></A>
<VAR>port</VAR> argument may be omitted, in which case it defaults to the value
returned by <CODE>current-output-port</CODE>.
<A NAME="IDX629"></A>

</P>
<P>

<U>essential procedure:</U> <B>display</B> <I>obj</I><P>
<A NAME="IDX630"></A>
<U>essential procedure:</U> <B>display</B> <I>obj port</I><P>
<A NAME="IDX631"></A>

</P>
<P>
Writes a representation of <VAR>obj</VAR> to the given <VAR>port</VAR>.  Strings
that appear in the written representation are not enclosed in
doublequotes, and no characters are escaped within those strings.  Character
objects appear in the representation as if written by <CODE>write-char</CODE>
<A NAME="IDX632"></A>
instead of by <CODE>write</CODE>.  <CODE>Display</CODE> returns an unspecified
<A NAME="IDX633"></A>
value.
<A NAME="IDX634"></A>
The <VAR>port</VAR> argument may be omitted, in which case it defaults to the
value returned by <CODE>current-output-port</CODE>.
<A NAME="IDX635"></A>

</P>
<P>
<EM>Rationale:</EM>  <CODE>Write</CODE> is intended
<A NAME="IDX636"></A>
for producing machine-readable output and <CODE>display</CODE> is for
producing
<A NAME="IDX637"></A>
human-readable output.  Implementations that allow "slashification"
within symbols will probably want <CODE>write</CODE> but not <CODE>display</CODE>
<A NAME="IDX638"></A>
to
<A NAME="IDX639"></A>
slashify funny characters in symbols.

</P>
<P>
<U>essential procedure:</U> <B>newline</B><P>
<A NAME="IDX640"></A>
<U>essential procedure:</U> <B>newline</B> <I>port</I><P>
<A NAME="IDX641"></A>

</P>
<P>
Writes an end of line to <VAR>port</VAR>.  Exactly how this is done differs
from one operating system to another.  Returns an unspecified value.
The <VAR>port</VAR> argument may be omitted, in which case it defaults to the
value returned by <CODE>current-output-port</CODE>.
<A NAME="IDX642"></A>

</P>
<P>

<U>essential procedure:</U> <B>write-char</B> <I>char</I><P>
<A NAME="IDX643"></A>
<U>essential procedure:</U> <B>write-char</B> <I>char port</I><P>
<A NAME="IDX644"></A>

</P>
<P>
Writes the character <VAR>char</VAR> (not an external representation of the
character) to the given <VAR>port</VAR> and returns an unspecified value.  The
<VAR>port</VAR> argument may be omitted, in which case it defaults to the value
returned by <CODE>current-output-port</CODE>.
<A NAME="IDX645"></A>

</P>
<P>



<H3><A NAME="SEC65" HREF="r4rs_toc.html#SEC65">System interface</A></H3>

<P>
Questions of system interface generally fall outside of the domain of this
report.  However, the following operations are important enough to
deserve description here.

</P>
<P>
<U>essential procedure:</U> <B>load</B> <I>filename</I><P>
<A NAME="IDX646"></A>

</P>

<P>
<VAR>Filename</VAR> should be a string naming an existing file
containing Scheme source code. The <CODE>load</CODE> procedure reads
<A NAME="IDX647"></A>
expressions and definitions from the file and evaluates them
sequentially.  It is unspecified whether the results of the expressions
are printed.  The <CODE>load</CODE> procedure does not affect the values
<A NAME="IDX648"></A>
returned by <CODE>current-input-port</CODE> and <CODE>current-output-port</CODE>.
<A NAME="IDX649"></A>
<A NAME="IDX650"></A>
<CODE>Load</CODE> returns an unspecified value.
<A NAME="IDX651"></A>

</P>
<P>
<EM>Rationale:</EM>  For portability, <CODE>load</CODE> must operate on source files.
<A NAME="IDX652"></A>
Its operation on other kinds of files necessarily varies among
implementations.

</P>
<P>
<U>procedure:</U> <B>transcript-on</B> <I>filename</I><P>
<A NAME="IDX653"></A>
<U>procedure:</U> <B>transcript-off</B><P>
<A NAME="IDX654"></A>

</P>
<P>
<VAR>Filename</VAR> must be a string naming an output file to be
created. The effect of <CODE>transcript-on</CODE> is to open the named file
<A NAME="IDX655"></A>
for output, and to cause a transcript of subsequent interaction between
the user and the Scheme system to be written to the file.  The
transcript is ended by a call to <CODE>transcript-off</CODE>, which closes the
<A NAME="IDX656"></A>
transcript file.  Only one transcript may be in progress at any time,
though some implementations may relax this restriction.  The values
returned by these procedures are unspecified.

</P>
<P>



<H1><A NAME="SEC66" HREF="r4rs_toc.html#SEC66">Formal syntax and semantics</A></H1>

<P>
This chapter provides formal descriptions of what has already been
described informally in previous chapters of this report.

</P>



<H2><A NAME="SEC67" HREF="r4rs_toc.html#SEC67">Formal syntax</A></H2>

<P>
This section provides a formal syntax for Scheme written in an extended
BNF.  The syntax for the entire language, including features which are
not essential, is given here.

</P>
<P>
All spaces in the grammar are for legibility.  Case is insignificant;
for example, <CODE>#x1A</CODE> and <CODE>#X1a</CODE> are equivalent.  &#60;empty&#62;
stands for the empty string.

</P>
<P>
The following extensions to BNF are used to make the description more
concise:  &#60;thing&#62;* means zero or more occurrences of
&#60;thing&#62;; and &#60;thing&#62;+ means at least one
&#60;thing&#62;.

</P>



<H3><A NAME="SEC68" HREF="r4rs_toc.html#SEC68">Lexical structure</A></H3>

<P>
This section describes how individual tokens
<A NAME="IDX657"></A>
(identifiers, numbers, etc.) are formed from sequences of characters.
The following sections describe how expressions and programs are formed
from sequences of tokens.

</P>
<P>
&#60;Intertoken space&#62; may occur on either side of any token, but not
within a token.

</P>
<P>
Tokens which require implicit termination (identifiers, numbers,
characters, and dot) may be terminated by any &#60;delimiter&#62;, but not
necessarily by anything else.

</P>

<PRE>
&#60;token&#62; ==> &#60;identifier&#62; | &#60;boolean&#62; | &#60;number&#62;
<A NAME="IDX658"></A>     | &#60;character&#62; | &#60;string&#62;
     | ( | ) | #( | ' | `{} | , | , | <B>.</B>
&#60;delimiter&#62; ==> &#60;whitespace&#62; | ( | ) | " | ;
&#60;whitespace&#62; ==> &#60;space or newline&#62;
&#60;comment&#62; ==> ; \= &#60;all subsequent characters up to a line break&#62;
<A NAME="IDX659"></A>&#60;atmosphere&#62; ==> &#60;whitespace&#62; | &#60;comment&#62;
&#60;intertoken space&#62; ==> &#60;atmosphere&#62;*
</PRE>


<PRE>
&#60;identifier&#62; ==> &#60;initial&#62; &#60;subsequent&#62;*
     | &#60;peculiar identifier&#62;
&#60;initial&#62; ==> &#60;letter&#62; | &#60;special initial&#62;
&#60;letter&#62; ==> a | b | c | ... | z
&#60;special initial&#62; ==> ! | \$ | \% | \verb"&#38;" | * | / | : | &#60; | =
     | &#62; | ? | \verb" " | \verb"_" | \verb"^"
&#60;subsequent&#62; ==> &#60;initial&#62; | &#60;digit&#62;
     | &#60;special subsequent&#62;
&#60;digit&#62; ==> 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9
&#60;special subsequent&#62; ==> . | + | -
&#60;peculiar identifier&#62; ==> + | - | ...
&#60;syntactic keyword&#62; ==> &#60;expression keyword&#62;
     | else | =&#62; | define
     | unquote | unquote-splicing
&#60;expression keyword&#62; ==> quote | lambda | if
     | set! | begin | cond | and | or | case
     | let | let* | letrec | do | delay
     | quasiquote
<A NAME="IDX660"></A><A NAME="IDX661"></A><A NAME="IDX662"></A>
&#60;boolean&#62; ==> <CODE>#t</CODE> | <CODE>#f</CODE>
&#60;character&#62; ==> <TT>#\</TT> &#60;any character&#62;
     | <TT>#\</TT> &#60;character name&#62;
&#60;character name&#62; ==> space | newline

&#60;string&#62; ==> " &#60;string element&#62;* "
&#60;string element&#62; ==> &#60;any character other than <TT>"</TT> or <TT>\</TT>&#62;
     | <TT>\"</TT> | <TT>\\</TT>
</PRE>


<PRE>
&#60;number&#62; ==> &#60;num <I>2</I>&#62; | &#60;num <I>8</I>&#62;
     | &#60;num <I>10</I>&#62; | &#60;num <I>16</I>&#62;
</PRE>

<P>
The following rules for &#60;num <I>R</I>&#62;, &#60;complex <I>R</I>&#62;, &#60;real
<I>R</I>&#62;, &#60;ureal <I>R</I>&#62;, &#60;uinteger <I>R</I>&#62;, and &#60;prefix <I>R</I>&#62;
should be replicated for <I>R = 2, 8, 10,</I>
and <I>16</I>.  There are no rules for &#60;decimal <I>2</I>&#62;, &#60;decimal
<I>8</I>&#62;, and &#60;decimal <I>16</I>&#62;, which means that numbers containing
decimal points or exponents must be in decimal radix.

</P>


<PRE>
&#60;num <I>R</I>&#62; ==> &#60;prefix <I>R</I>&#62; &#60;complex <I>R</I>&#62;
&#60;complex <I>R</I>&#62; ==> &#60;real <I>R</I>&#62; | &#60;real <I>R</I>&#62;  &#60;real <I>R</I>&#62;
     | &#60;real <I>R</I>&#62; + &#60;ureal <I>R</I>&#62; i | &#60;real <I>R</I>&#62; - &#60;ureal <I>R</I>&#62; i
     | &#60;real <I>R</I>&#62; + i | &#60;real <I>R</I>&#62; - i
     | + &#60;ureal <I>R</I>&#62; i | - &#60;ureal <I>R</I>&#62; i | + i | - i
&#60;real <I>R</I>&#62; ==> &#60;sign&#62; &#60;ureal <I>R</I>&#62;
&#60;ureal <I>R</I>&#62; ==> &#60;uinteger <I>R</I>&#62;
     | &#60;uinteger <I>R</I>&#62; / &#60;uinteger <I>R</I>&#62;
     | &#60;decimal <I>R</I>&#62;
&#60;decimal <I>10</I>&#62; ==> &#60;uinteger <I>10</I>&#62; &#60;suffix&#62;
     | . &#60;digit <I>10</I>&#62;+ #* &#60;suffix&#62;
     | &#60;digit <I>10</I>&#62;+ . &#60;digit <I>10</I>&#62;* #* &#60;suffix&#62;
     | &#60;digit <I>10</I>&#62;+ #+ . #* &#60;suffix&#62;
&#60;uinteger <I>R</I>&#62; ==> &#60;digit <I>R</I>&#62;+ #*
&#60;prefix <I>R</I>&#62; ==> &#60;radix <I>R</I>&#62; &#60;exactness&#62;
     | &#60;exactness&#62; &#60;radix <I>R</I>&#62;
</PRE>


<PRE>
&#60;suffix&#62; ==> &#60;empty&#62;
     | &#60;exponent marker&#62; &#60;sign&#62; &#60;digit <I>10</I>&#62;+
&#60;exponent marker&#62; ==> e | s | f | d | l
&#60;sign&#62; ==> &#60;empty&#62;  | + |  -
&#60;exactness&#62; ==> &#60;empty&#62; | #i | #e
<A NAME="IDX663"></A><A NAME="IDX664"></A>&#60;radix 2&#62; ==> #b
<A NAME="IDX665"></A>&#60;radix 8&#62; ==> #o
<A NAME="IDX666"></A>&#60;radix 10&#62; ==> &#60;empty&#62; | #d
&#60;radix 16&#62; ==> #x
<A NAME="IDX667"></A>&#60;digit 2&#62; ==> 0 | 1
&#60;digit 8&#62; ==> 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7
&#60;digit 10&#62; ==> &#60;digit&#62;
&#60;digit 16&#62; ==> &#60;digit <I>10</I>&#62; | a | b | c | d | e | f
</PRE>



<H3><A NAME="SEC69" HREF="r4rs_toc.html#SEC69">External representation</A></H3>

<P>
&#60;Datum&#62; is what the <CODE>read</CODE> procedure (section <A HREF="r4rs.html#SEC63">Input</A>)
<A NAME="IDX668"></A>
successfully parses.  Note that any string that parses as an
&#60;expression&#62; will also parse as a &#60;datum&#62;.

</P>

<PRE>
&#60;datum&#62; ==> &#60;simple datum&#62; | &#60;compound datum&#62;
&#60;simple datum&#62; ==> &#60;boolean&#62; | &#60;number&#62;
     | &#60;character&#62; | &#60;string&#62; |  &#60;symbol&#62;
&#60;symbol&#62; ==> &#60;identifier&#62;
&#60;compound datum&#62; ==> &#60;list&#62; | &#60;vector&#62;
&#60;list&#62; ==> (&#60;datum&#62;*) | (&#60;datum&#62;+ . &#60;datum&#62;)
     | &#60;abbreviation&#62;
&#60;abbreviation&#62; ==> &#60;abbrev prefix&#62; &#60;datum&#62;
&#60;abbrev prefix&#62; ==> ' | ` | , | ,@
&#60;vector&#62; ==> #(&#60;datum&#62;*)
</PRE>



<H3><A NAME="SEC70" HREF="r4rs_toc.html#SEC70">Expressions</A></H3>


<PRE>
&#60;expression&#62; ==> &#60;variable&#62;
     | &#60;literal&#62;
     | &#60;procedure call&#62;
     | &#60;lambda expression&#62;
     | &#60;conditional&#62;
     | &#60;assignment&#62;
     | &#60;derived expression&#62;

&#60;literal&#62; ==> &#60;quotation&#62; | &#60;self-evaluating&#62;
&#60;self-evaluating&#62; ==> &#60;boolean&#62; | &#60;number&#62;
     | &#60;character&#62; | &#60;string&#62;
&#60;quotation&#62; ==> '&#60;datum&#62; | (quote &#60;datum&#62;)
&#60;procedure call&#62; ==> (&#60;operator&#62; &#60;operand&#62;*)
&#60;operator&#62; ==> &#60;expression&#62;
&#60;operand&#62; ==> &#60;expression&#62;

&#60;lambda expression&#62; ==> (lambda &#60;formals&#62; &#60;body&#62;)
&#60;formals&#62; ==> (&#60;variable&#62;*) | &#60;variable&#62;
     | (&#60;variable&#62;+ . &#60;variable&#62;)
&#60;body&#62; ==> &#60;definition&#62;* &#60;sequence&#62;
&#60;sequence&#62; ==> &#60;command&#62;* &#60;expression&#62;
&#60;command&#62; ==> &#60;expression&#62;

&#60;conditional&#62; ==> (if &#60;test&#62; &#60;consequent&#62; &#60;alternate&#62;)
&#60;test&#62; ==> &#60;expression&#62;
&#60;consequent&#62; ==> &#60;expression&#62;
&#60;alternate&#62; ==> &#60;expression&#62; | &#60;empty&#62;

&#60;assignment&#62; ==> (set! &#60;variable&#62; &#60;expression&#62;)

&#60;derived expression&#62; ==>
      (cond &#60;cond clause&#62;+)
     | (cond &#60;cond clause&#62;* (else &#60;sequence&#62;))
     | (case &#60;expression&#62;
        &#60;case clause&#62;+)
     | (case &#60;expression&#62;
        &#60;case clause&#62;*
        (else &#60;sequence&#62;))
     | (and &#60;test&#62;*)
     | (or &#60;test&#62;*)
     | (let (&#60;binding spec&#62;*) &#60;body&#62;)
     | (let &#60;variable&#62; (&#60;binding spec&#62;*) &#60;body&#62;)
     | (let* (&#60;binding spec&#62;*) &#60;body&#62;)
     | (letrec (&#60;binding spec&#62;*) &#60;body&#62;)
     | (begin &#60;sequence&#62;)
     | (do (&#60;iteration spec&#62;*)
          (&#60;test&#62; &#60;sequence&#62;)
        &#60;command&#62;*)
     | (delay &#60;expression&#62;)
     | &#60;quasiquotation&#62;

&#60;cond clause&#62; ==> (&#60;test&#62; &#60;sequence&#62;)
     | (&#60;test&#62;)
     | (&#60;test&#62; =&#62; &#60;recipient&#62;)
&#60;recipient&#62; ==> &#60;expression&#62;
&#60;case clause&#62; ==> ((&#60;datum&#62;*) &#60;sequence&#62;)

&#60;binding spec&#62; ==> (&#60;variable&#62; &#60;expression&#62;)
&#60;iteration spec&#62; ==> (&#60;variable&#62; &#60;init&#62; &#60;step&#62;)
     | (&#60;variable&#62; &#60;init&#62;)
&#60;init&#62; ==> &#60;expression&#62;
&#60;step&#62; ==> &#60;expression&#62;
</PRE>



<H3><A NAME="SEC71" HREF="r4rs_toc.html#SEC71">Quasiquotations</A></H3>

<P>
The following grammar for quasiquote expressions is not context-free.
It is presented as a recipe for generating an infinite number of
production rules.  Imagine a copy of the following rules for
<I>D = 1, 2, 3, ...</I>.  <I>D</I> keeps track of the nesting depth.

</P>

<PRE>
&#60;quasiquotation&#62; ==> &#60;quasiquotation 1&#62;
&#60;template 0&#62; ==> &#60;expression&#62;
&#60;quasiquotation <I>D</I>&#62; ==> `&#60;template <I>D</I>&#62;
     | (quasiquote &#60;template <I>D</I>&#62;)
&#60;template <I>D</I>&#62; ==> &#60;simple datum&#62;
     | &#60;list template <I>D</I>&#62;
     | &#60;vector template <I>D</I>&#62;
     | &#60;unquotation <I>D</I>&#62;
&#60;list template <I>D</I>&#62; ==> (&#60;template or splice <I>D</I>&#62;*)
     | (&#60;template or splice <I>D</I>&#62;+ . &#60;template <I>D</I>&#62;)
     | '&#60;template <I>D</I>&#62;
     | &#60;quasiquotation <I>D+1</I>&#62;
&#60;vector template <I>D</I>&#62; ==> #(&#60;template or splice <I>D</I>&#62;*)
&#60;unquotation <I>D</I>&#62; ==> ,&#60;template <I>D-1</I>&#62;
     | (unquote &#60;template <I>D-1</I>&#62;)
&#60;template or splice <I>D</I>&#62; ==> &#60;template <I>D</I>&#62;
     | &#60;splicing unquotation <I>D</I>&#62;
&#60;splicing unquotation <I>D</I>&#62; ==> ,&#60;template <I>D-1</I>&#62;
     | (unquote-splicing &#60;template <I>D-1</I>&#62;)
</PRE>

<P>
In &#60;quasiquotation&#62;s, a &#60;list template <I>D</I>&#62; can sometimes be
confused with either an &#60;unquotation <I>D</I>&#62; or a
&#60;splicing unquotation <I>D</I>&#62;.  The interpretation as an
&#60;unquotation&#62; or &#60;splicing unquotation <I>D</I>&#62; takes precedence.

</P>


<H3><A NAME="SEC72" HREF="r4rs_toc.html#SEC72">Programs and definitions</A></H3>


<PRE>
&#60;program&#62; ==> &#60;command or definition&#62;*
&#60;command or definition&#62; ==> &#60;command&#62; | &#60;definition&#62;
&#60;definition&#62; ==> (define &#60;variable&#62; &#60;expression&#62;)
     | (define (&#60;variable&#62; &#60;def formals&#62;) &#60;body&#62;)
     | (begin &#60;definition&#62;*)
&#60;def formals&#62; ==> &#60;variable&#62;*
     | &#60;variable&#62;+ . &#60;variable&#62;
</PRE>



<H2><A NAME="SEC73" HREF="r4rs_toc.html#SEC73">Formal semantics</A></H2>

<P>
This section provides a formal denotational semantics for the primitive
expressions of Scheme and selected built-in procedures.  The concepts
and notation used here are described in [STOY77].

</P>

<BLOCKQUOTE>
<P>
<EM>Note:</EM> The formal semantics section was written in LaTeX which
is incompatible with TeXinfo.  See pages 34--36 of <A HREF="r4rs.html#BIB69">[R4RS]</A>, the
original document from which this was derived.
</BLOCKQUOTE>



<H3><A NAME="SEC74" HREF="r4rs_toc.html#SEC74">Abstract syntax</A></H3>



<H3><A NAME="SEC75" HREF="r4rs_toc.html#SEC75">Domain equations</A></H3>



<H3><A NAME="SEC76" HREF="r4rs_toc.html#SEC76">Semantic functions</A></H3>



<H3><A NAME="SEC77" HREF="r4rs_toc.html#SEC77">Auxiliary functions</A></H3>



<H2><A NAME="SEC78" HREF="r4rs_toc.html#SEC78">derived expression types</A></H2>

<P>
This section gives rewrite rules for the derived expression types.  By
the application of these rules, any expression can be reduced to a
semantically equivalent expression in which only the primitive
expression types (literal, variable, call, <CODE>lambda</CODE>, <CODE>if</CODE>,
<A NAME="IDX669"></A>
<A NAME="IDX670"></A>
<CODE>set!</CODE>) occur.
<A NAME="IDX671"></A>

</P>


<PRE>
<TT>(cond (&#60;test&#62; &#60;sequence&#62;)
      &#60;clause 2&#62; ...)
  ==  (if &#60;test&#62;
          (begin &#60;sequence&#62;)
          (cond &#60;clause 2&#62; ...))

(cond (&#60;test&#62;)
      &#60;clause 2&#62; ...)
  ==  (or &#60;test&#62; (cond &#60;clause 2&#62; ...))

(cond (&#60;test&#62; =&#62; &#60;recipient&#62;)
      &#60;clause 2&#62; ...)
  ==  (let ((test-result &#60;test&#62;)
            (thunk2 (lambda () &#60;recipient&#62;))
            (thunk3 (lambda () (cond &#60;clause 2&#62; ...))))
        (if test-result
            ((thunk2) test-result)
            (thunk3)))

(cond (else &#60;sequence&#62;))
  ==  (begin &#60;sequence&#62;)

(cond)
  ==  &#60;some expression returning an unspecified value&#62;

(case &#60;key&#62;
  ((d1 ...) &#60;sequence&#62;)
  ...)
  ==  (let ((key &#60;key&#62;)
            (thunk1 (lambda () &#60;sequence&#62;))
            ...)
        (cond ((&#60;memv&#62; key '(d1 ...)) (thunk1))
               ...))

(case &#60;key&#62;
  ((d1 ...) &#60;sequence&#62;)
  ...
  (else f1 f2 ...))
  ==  (let ((key &#60;key&#62;)
            (thunk1 (lambda () &#60;sequence&#62;))
            ...
            (elsethunk (lambda () f1 f2 ...)))
        (cond ((&#60;memv&#62; key '(d1 ...)) (thunk1))
               ...
              (else (elsethunk))))</TT>
</PRE>

<P>
where &#60;memv&#62; is an expression evaluating to the <CODE>memv</CODE>
procedure.
<A NAME="IDX672"></A>

</P>

<PRE>
<TT>(and)              ==  <CODE>#t</CODE>
(and &#60;test&#62;)        ==  &#60;test&#62;
(and &#60;test 1&#62; &#60;test 2&#62; ...)
  ==  (let ((x &#60;test 1&#62;)
            (thunk (lambda () (and &#60;test 2&#62; ...))))
        (if x (thunk) x))

(or)               ==  <CODE>#f</CODE>
(or &#60;test&#62;)         ==  &#60;test&#62;
(or &#60;test 1&#62; &#60;test 2&#62; ...)
  ==  (let ((x &#60;test 1&#62;)
            (thunk (lambda () (or &#60;test 2&#62; ...))))
        (if x x (thunk)))

(let ((&#60;variable 1&#62; &#60;init 1&#62;) ...)
  &#60;body&#62;)
  ==  ((lambda (&#60;variable 1&#62; ...) &#60;body&#62;) &#60;init 1&#62; ...)

(let* () &#60;body&#62;)
  ==  ((lambda () &#60;body&#62;))
(let* ((&#60;variable 1&#62; &#60;init 1&#62;)
       (&#60;variable 2&#62; &#60;init 2&#62;)
       ...)
  &#60;body&#62;)
  ==  (let ((&#60;variable 1&#62; &#60;init 1&#62;))
        (let* ((&#60;variable 2&#62; &#60;init 2&#62;)
               ...)
          &#60;body&#62;))

(letrec ((&#60;variable 1&#62; &#60;init 1&#62;)
         ...)
  &#60;body&#62;)
  ==  (let ((&#60;variable 1&#62; &#60;undefined&#62;)
            ...)
         (let ((&#60;temp 1&#62; &#60;init 1&#62;)
               ...)
           (set! &#60;variable 1&#62; &#60;temp 1&#62;)
           ...)
         &#60;body&#62;)</TT>
</PRE>

<P>
where &#60;temp 1&#62;, &#60;temp 2&#62;, ... are variables, distinct
from &#60;variable 1&#62;, ..., that do not free occur in the
original &#60;init&#62; expressions, and &#60;undefined&#62; is an expression
which returns something that when stored in a location makes it an
error to try to obtain the value stored in the location.  (No such
expression is defined, but one is assumed to exist for the purposes of this
rewrite rule.)  The second <CODE>let</CODE> expression in the expansion is not
<A NAME="IDX673"></A>
strictly necessary, but it serves to preserve the property that the
&#60;init&#62; expressions are evaluated in an arbitrary order.

</P>

<PRE>
<TT>
(begin &#60;sequence&#62;)
  ==  ((lambda () &#60;sequence&#62;))</TT>
</PRE>

<P>
<A NAME="IDX674"></A>
The following alternative expansion for <CODE>begin</CODE> does not make use
of the ability to write more than one expression in the body of a lambda
expression.  In any case, note that these rules apply only if
&#60;sequence&#62; contains no definitions.

</P>

<PRE>
<TT>(begin &#60;expression&#62;)  ==  &#60;expression&#62;
(begin &#60;command&#62; &#60;sequence&#62;)
  ==  ((lambda (ignore thunk) (thunk))
       &#60;command&#62;
       (lambda () (begin &#60;sequence&#62;)))</TT>
</PRE>

<P>
<A NAME="IDX675"></A>
The following expansion for <CODE>do</CODE> is simplified by the assumption
that no &#60;step&#62; is omitted.  Any <CODE>do</CODE> expression in which a
&#60;step&#62; is omitted can be replaced by an equivalent <CODE>do</CODE>
expression in which the corresponding &#60;variable&#62; appears as
the &#60;step&#62;.

</P>

<PRE>
<TT>(do ((&#60;variable 1&#62; &#60;init 1&#62; &#60;step 1&#62;)
     ...)
    (&#60;test&#62; &#60;sequence&#62;)
  &#60;command 1&#62; ...)
  ==  (letrec ((&#60;loop&#62;
                (lambda (&#60;variable 1&#62; ...)
                  (if &#60;test&#62;
                      (begin &#60;sequence&#62;)
                      (begin &#60;command 1&#62;
                             ...
                             (&#60;loop&#62; &#60;step 1&#62; ...))))))
        (&#60;loop&#62; &#60;init 1&#62; ...))</TT>
</PRE>

<P>
where &#60;loop&#62; is any variable which is distinct from
&#60;variable 1&#62;, ..., and which does not occur free in the <CODE>do</CODE>
expression.
<A NAME="IDX676"></A>

</P>

<PRE>
<TT>(let &#60;variable 0&#62; ((&#60;variable 1&#62; &#60;init 1&#62;) ...)
  &#60;body&#62;)
  ==  ((letrec ((&#60;variable 0&#62; (lambda (&#60;variable 1&#62; ...)
                             &#60;body&#62;)))
          &#60;variable 0&#62;)
       &#60;init 1&#62; ...)

(delay &#60;expression&#62;)
  ==  (&#60;make-promise&#62; (lambda () &#60;expression&#62;))</TT>
</PRE>

<P>
where &#60;make-promise&#62; is an expression evaluating to some procedure
which behaves appropriately with respect to the <CODE>force</CODE> procedure;
<A NAME="IDX677"></A>
see section <A HREF="r4rs.html#SEC60">Control features</A>.

</P>



<H1><A NAME="SEC79" HREF="r4rs_toc.html#SEC79">NOTES</A></H1>

<H2>Language changes</H2>

<P>
This section enumerates the changes that have been made to Scheme since
the "Revised(3) report" <A HREF="r4rs.html#BIB68">[R3RS]</A> was published.

</P>

<UL>
<LI>Although implementations may extend Scheme, they must offer

a syntactic mode that adds no reserved words and preempts no lexical conventions
of Scheme.

<LI>Implementations may report violations of

implementation restrictions.

<LI>It is no longer specified whether the empty list counts as true

or as false in conditional expressions.  It should be noted that the
IEEE standard for Scheme requires the empty list to count as true
[IEEESCHEME].

<LI>The sets defined by <CODE>boolean?</CODE>, <CODE>pair?</CODE>, <CODE>symbol?</CODE>,

<CODE>number?</CODE>, <CODE>char?</CODE>, <CODE>string?</CODE>, <CODE>vector?</CODE>,and
<CODE>procedure?</CODE> are required to be disjoint.
<A NAME="IDX678"></A>
<A NAME="IDX679"></A>
<A NAME="IDX680"></A>
<A NAME="IDX681"></A>
<A NAME="IDX682"></A>
<A NAME="IDX683"></A>
<A NAME="IDX684"></A>
<A NAME="IDX685"></A>

<LI>The variables bound by a <CODE>lambda</CODE>, <CODE>let</CODE>, <CODE>letrec</CODE>,

and <CODE>do</CODE> must not contain duplicates.
<A NAME="IDX686"></A>
<A NAME="IDX687"></A>
<A NAME="IDX688"></A>
<A NAME="IDX689"></A>

<LI>Nested <CODE>begin</CODE> expressions containing definitions are treated

<A NAME="IDX690"></A>
as a sequence of definitions.

<LI>The <CODE>eqv?</CODE> procedure is no longer required to be true of any

<A NAME="IDX691"></A>
two empty strings or two empty vectors.

<LI>The syntax of numerical constants has been changed, and the exactness

implied by each syntax has been specified.

<LI>The semantics of many numerical procedures have been clarified.

<LI><CODE>Rationalize</CODE> has been restricted to two arguments and its

<A NAME="IDX692"></A>
specification clarified.

<LI>The <CODE>number-&#62;string</CODE> and <CODE>string-&#62;number</CODE> procedures

<A NAME="IDX693"></A>
<A NAME="IDX694"></A>
have been changed.

<LI><CODE>Integer-&#62;char</CODE> now requires an exact integer argument.

<A NAME="IDX695"></A>

<LI>The specification of the <CODE>force</CODE> procedure has been

<A NAME="IDX696"></A>
weakened.  The previous specification was unimplementable.

<LI>Variables removed: <CODE>t</CODE>, <CODE>nil</CODE>.

<A NAME="IDX697"></A>
<A NAME="IDX698"></A>

<LI>Procedures removed: <CODE>approximate</CODE>, <CODE>last-pair</CODE>.

<A NAME="IDX699"></A>
<A NAME="IDX700"></A>

<LI>Procedures added: <CODE>list?</CODE>, <CODE>peek-char</CODE>.

<A NAME="IDX701"></A>
<A NAME="IDX702"></A>

<LI>Syntaxes made essential: <CODE>case</CODE>, <CODE>and</CODE>, <CODE>or</CODE>,

<A NAME="IDX703"></A>
<A NAME="IDX704"></A>
<A NAME="IDX705"></A>
<CODE>quasiquote</CODE>.
<A NAME="IDX706"></A>

<LI>Procedures made essential:

</UL>


<PRE>
reverse        char-ci=?        make-string
max            char-ci&#60;?        string-set!
min            char-ci&#62;?        string-ci=?
modulo         char-ci&#60;=?       string-ci&#60;?
gcd            char-ci&#62;=?       string-ci&#62;?
lcm            char-alphabetic? string-ci&#60;=?
floor          char-numeric?    string-ci&#62;=?
ceiling        char-whitespace? string-append
truncate       char-lower-case? open-input-file
round          char-upper-case? open-output-file
number-&#62;string char-upcase      close-input-port
string-&#62;number char-downcase    close-output-port
</PRE>


<UL>
<LI>Procedures required to accept more general numbers of arguments:

<CODE>append</CODE>, <CODE>+</CODE>, <CODE>*</CODE>, <CODE>-</CODE> (one argument),
<A NAME="IDX707"></A>
<A NAME="IDX708"></A>
<A NAME="IDX709"></A>
<CODE>/</CODE> (one argument), <CODE>=</CODE>, <CODE>&#60;</CODE>, <CODE>&#62;</CODE>, <CODE>&#60;=</CODE>, <CODE>&#62;=</CODE>,
<A NAME="IDX710"></A>
<A NAME="IDX711"></A>
<CODE>map</CODE>, <CODE>for-each</CODE>.
<A NAME="IDX712"></A>
<A NAME="IDX713"></A>
<A NAME="IDX714"></A>
<A NAME="IDX715"></A>
<A NAME="IDX716"></A>
<A NAME="IDX717"></A>

<LI>A macro facility has been added as an appendix to this report.

</UL>



<H1><A NAME="SEC80" HREF="r4rs_toc.html#SEC80">Example</A></H1>

<P>
<CODE>Integrate-system</CODE> integrates the system
<A NAME="IDX718"></A>

</P>
<P>
<I>y_k' = f_k(y_1, y_2, ..., y_n), ; k = 1, ..., n</I>

</P>
<P>
of differential equations with the method of Runge-Kutta.

</P>
<P>
The parameter <CODE>system-derivative</CODE> is a function that takes a system
state (a vector of values for the state variables y_1, ..., y_n)
and produces a system derivative (the values y_1', ..., y_n').
The parameter <CODE>initial-state</CODE> provides an initial
system state, and <CODE>h</CODE> is an initial guess for the length of the
integration step.

</P>
<P>
The value returned by <CODE>integrate-system</CODE> is an infinite stream of
<A NAME="IDX719"></A>
system states.

</P>

<PRE>
<TT>(define integrate-system
  (lambda (system-derivative initial-state h)
    (let ((next (runge-kutta-4 system-derivative h)))
      (letrec ((states
                (cons initial-state
                      (delay (map-streams next
                                          states)))))
        states))))</TT>
</PRE>

<P>
<CODE>Runge-Kutta-4</CODE> takes a function, <CODE>f</CODE>, that produces a
<A NAME="IDX720"></A>
system derivative from a system state.  <CODE>Runge-Kutta-4</CODE>
<A NAME="IDX721"></A>
produces a function that takes a system state and
produces a new system state.

</P>

<PRE>
<TT>(define runge-kutta-4
  (lambda (f h)
    (let ((*h (scale-vector h))
          (*2 (scale-vector 2))
          (*1/2 (scale-vector (/ 1 2)))
          (*1/6 (scale-vector (/ 1 6))))
      (lambda (y)
        ;; y is a system state
        (let* ((k0 (*h (f y)))
               (k1 (*h (f (add-vectors y (*1/2 k0)))))
               (k2 (*h (f (add-vectors y (*1/2 k1)))))
               (k3 (*h (f (add-vectors y k2)))))
          (add-vectors y
            (*1/6 (add-vectors k0
                               (*2 k1)
                               (*2 k2)
                               k3))))))))

(define elementwise
  (lambda (f)
    (lambda vectors
      (generate-vector
        (vector-length (car vectors))
        (lambda (i)
          (apply f
                 (map (lambda (v) (vector-ref  v i))
                      vectors)))))))

(define generate-vector
  (lambda (size proc)
    (let ((ans (make-vector size)))
      (letrec ((loop
                (lambda (i)
                  (cond ((= i size) ans)
                        (else
                         (vector-set! ans i (proc i))
                         (loop (+ i 1)))))))
        (loop 0)))))

(define add-vectors (elementwise +))

(define scale-vector
  (lambda (s)
    (elementwise (lambda (x) (* x s)))))</TT>
</PRE>

<P>
<CODE>Map-streams</CODE> is analogous to <CODE>map</CODE>: it applies its first
<A NAME="IDX722"></A>
<A NAME="IDX723"></A>
argument (a procedure) to all the elements of its second argument (a
stream).

</P>

<PRE>
<TT>(define map-streams
  (lambda (f s)
    (cons (f (head s))
          (delay (map-streams f (tail s))))))</TT>
</PRE>

<P>
Infinite streams are implemented as pairs whose car holds the first
element of the stream and whose cdr holds a promise to deliver the rest
of the stream.

</P>

<PRE>
<TT>(define head car)
(define tail
  (lambda (stream) (force (cdr stream))))</TT>
</PRE>

<P>
<A NAME="IDX724"></A>
The following illustrates the use of <CODE>integrate-system</CODE> in
integrating the system

</P>

<P>
<I>C (dvC / dt) = -iL - (vC / R)</I>

</P>
<P>
<I>L (diL / dt) = vC</I>

</P>
<P>
which models a damped oscillator.

</P>

<PRE>
<TT>(define damped-oscillator
  (lambda (R L C)
    (lambda (state)
      (let ((Vc (vector-ref state 0))
            (Il (vector-ref state 1)))
        (vector (- 0 (+ (/ Vc (* R C)) (/ Il C)))
                (/ Vc L))))))

(define the-states
  (integrate-system
     (damped-oscillator 10000 1000 .001)
     '#(1 0)
     .01))</TT>
</PRE>



<H1><A NAME="SEC81" HREF="r4rs_toc.html#SEC81">Macros</A></H1>

<P>
This appendix describes an extension to Scheme that allows programs
to define and use new derived expression types.
A derived expression type that has been defined using this extension
is called a <EM>macro</EM>.
<A NAME="IDX725"></A>

</P>
<P>
Derived expression types introduced using this extension have
the syntax

<PRE>
(&#60;keyword&#62; &#60;datum&#62;*)
</PRE>

<P>
where &#60;keyword&#62; is an identifier that uniquely determines the
expression type.  This identifier is called the <EM>syntactic
keyword</EM>, or simply <EM>keyword</EM>,
<A NAME="IDX726"></A>
<A NAME="IDX727"></A>
of the macro.
<A NAME="IDX728"></A>
The number of the &#60;datum&#62;s, and their syntax, depends on the
expression type.

</P>
<P>
Each instance of a macro is called a <EM>use</EM>
<A NAME="IDX729"></A>
of the macro.
The set of rules, or more generally the procedure, that specifies
how a use of a macro is transcribed into a more primitive expression
is called the <EM>transformer</EM>
<A NAME="IDX730"></A>
of the macro.

</P>
<P>
The extension described here consists of three parts:

</P>

<UL>

<LI>A set of expressions used to establish that certain identifiers

are macro keywords, associate them with macro transformers, and control
the scope within which a macro is defined,

<LI>a convenient pattern language that makes it easy to write

transformers for most macros, and

<LI>a compatible low-level macro facility for writing macro

transformers that cannot be expressed by the pattern language.

</UL>

<P>
With this extension, there are no reserved identifiers.  The syntactic
keyword of a macro may shadow variable bindings, and local variable
bindings may shadow keyword bindings.
<A NAME="IDX731"></A>
All macros
defined using the pattern language are "hygienic" and
"referentially transparent":
<A NAME="IDX732"></A>
<A NAME="IDX733"></A>

</P>

<UL>

<LI>If a macro transformer inserts a binding for an identifier

(variable or keyword), the identifier will in effect be renamed
throughout its scope to avoid conflicts with other identifiers.

<LI>If a macro transformer inserts a free reference to an

identifier, the reference refers to the binding that was visible
where the transformer was specified, regardless of any local
bindings that may surround the use of the macro.

</UL>

<P>
This appendix is divided into three major sections.  The first
section describes the expressions and definitions used to
introduce macros, i.e. to bind identifiers to macro
transformers.

</P>
<P>
The second section describes the pattern language.  This pattern
language is sufficient to specify most macro transformers, including
those for all the derived expression types from
section <A HREF="r4rs.html#SEC33">Derived expression types</A>.  The primary limitation of the pattern
language is that it is thoroughly hygienic, and thus cannot express
macros that bind identifiers implicitly.

</P>
<P>
The third section describes a low-level macro facility that could be
used to implement the pattern language described in the second
section.  This low-level facility is also capable of expressing
non-hygienic macros and other macros whose transformers cannot be
described by the pattern language, and is important as an example of a
more powerful facility that can co-exist with the high-level pattern
language.

</P>
<P>
The particular low-level facility described in the third
section is but one of several low-level facilities that have been
designed and implemented to complement the pattern language described
in the second section.  The design of such low-level macro facilities
remains an active area of research, and descriptions of alternative
low-level facilities will be published in subsequent documents.

</P>



<H2><A NAME="SEC82" HREF="r4rs_toc.html#SEC82">Binding syntactic keywords</A></H2>

<P>
<CODE>Define-syntax</CODE>, <CODE>let-syntax</CODE>, and <CODE>letrec-syntax</CODE> are
analogous to <CODE>define</CODE>, <CODE>let</CODE>, and <CODE>letrec</CODE>, but they bind
syntactic keywords to macro transformers instead of binding variables
to locations that contain values.  Furthermore, there is no <CODE>
define-syntax</CODE> analogue of the internal definitions described in
section <A HREF="r4rs.html#SEC44">Internal definitions</A>.

</P>
<P>
<EM>Rationale:</EM>  As discussed below, the syntax and scope rules for definitions
give rise to syntactic ambiguities when syntactic keywords are
not reserved.
Further ambiguities would arise if <CODE>define-syntax</CODE>
were permitted at the beginning of a &#60;body&#62;, with scope
rules analogous to those for internal definitions.

</P>
<P>
These new expression types and the pattern language described in
section <A HREF="r4rs.html#SEC83">Pattern language</A> are added to Scheme by augmenting the
BNF in section <A HREF="r4rs.html#SEC67">Formal syntax</A> with the following new productions.  Note
that the identifier <CODE>...</CODE> used in some of these productions is not
a metasymbol.

</P>

<PRE>
&#60;expression&#62; ==> &#60;macro use&#62;
     | &#60;macro block&#62;

&#60;macro use&#62; ==> (&#60;keyword&#62; &#60;datum&#62;*)
&#60;keyword&#62; ==> &#60;identifier&#62;

&#60;macro block&#62; ==>
      (let-syntax (&#60;syntax spec&#62;*) &#60;body&#62;)
     | (letrec-syntax (&#60;syntax spec&#62;*) &#60;body&#62;)
&#60;syntax spec&#62; ==> (&#60;keyword&#62; &#60;transformer spec&#62;)
&#60;transformer spec&#62; ==>
      (syntax-rules (&#60;identifier&#62;*) &#60;syntax rule&#62;*)
&#60;syntax rule&#62; ==> (&#60;pattern&#62; &#60;template&#62;)
&#60;pattern&#62; ==> &#60;pattern identifier&#62;
     | (&#60;pattern&#62;*)
     | (&#60;pattern&#62;+ . &#60;pattern&#62;)
     | (&#60;pattern&#62;* &#60;pattern&#62; &#60;ellipsis&#62;)
     | &#60;pattern datum&#62;
&#60;pattern datum&#62; ==> &#60;vector&#62;
     | &#60;string&#62;
     | &#60;character&#62;
     | &#60;boolean&#62;
     | &#60;number&#62;
&#60;template&#62; ==> &#60;pattern identifier&#62;
     | (&#60;template element&#62;*)
     | (&#60;template element&#62;+ . &#60;template&#62;)
     | &#60;template datum&#62;
&#60;template element&#62; ==> &#60;template&#62;
     | &#60;template&#62; &#60;ellipsis&#62;
&#60;template datum&#62; ==> &#60;pattern datum&#62;
&#60;pattern identifier&#62; ==> &#60;any identifier except <CODE>...</CODE>&#62;
&#60;ellipsis&#62; ==> &#60;the identifier <CODE>...</CODE>&#62;

&#60;command or definition&#62; ==> &#60;syntax definition&#62;
&#60;syntax definition&#62; ==>
      (define-syntax &#60;keyword&#62; &#60;transformer spec&#62;)
     | (begin &#60;syntax definition&#62;*)
</PRE>

<P>
Although macros may expand into definitions in any context that permits
definitions, it is an error for a definition to shadow a syntactic
keyword whose meaning is needed to determine whether some definition in
the group of top-level or internal definitions that contains the
shadowing definition is in fact a definition, or is needed to determine
the boundary between the group and the expressions that follow the
group.  For example, the following are errors:

</P>

<PRE>
(define define 3)

(begin (define begin list))

(let-syntax
  ((foo (syntax-rules ()
          ((foo (proc args ...) body ...)
           (define proc
             (lambda (args ...)
               body ...))))))
  (let ((x 3))
    (foo (plus x y) (+ x y))
    (define foo x)
    (plus foo x)))
</PRE>

<P>
<U>syntax:</U> <B>syntax</B> <I>{let-syntax} &#60;bindings&#62; &#60;body&#62;</I><P>
<A NAME="IDX734"></A>

</P>
<P>
<EM>Syntax:</EM>  &#60;Bindings&#62; should have the form

<PRE>
((&#60;keyword&#62; &#60;transformer spec&#62;) ...)
</PRE>

<P>
Each &#60;keyword&#62; is an identifier,
each &#60;transformer spec&#62; is an instance of <CODE>syntax-rules</CODE>, and
&#60;body&#62; should be a sequence of one or more expressions.  It is an error
for a &#60;keyword&#62; to appear more than once in the list of keywords
being bound.

</P>
<P>
<EM>Semantics:</EM>  The &#60;body&#62; is expanded in the syntactic environment
obtained by extending the syntactic environment of the
<CODE>let-syntax</CODE> expression with macros whose keywords are
the &#60;keyword&#62;s, bound to the specified transformers.
Each binding of a &#60;keyword&#62; has &#60;body&#62; as its region.

</P>

<PRE>
(let-syntax ((when (syntax-rules ()
                     ((when test stmt1 stmt2 ...)
                      (if test
                          (begin stmt1
                                 stmt2 ...))))))
  (let ((if #t))
    (when if (set! if 'now))
    if))                    =>  now

(let ((x 'outer))
  (let-syntax ((m (syntax-rules () ((m) x))))
    (let ((x 'inner))
      (m))))                =>  outer
</PRE>

<P>

<U>syntax:</U> <B>syntax</B> <I>{letrec-syntax} &#60;bindings&#62; &#60;body&#62;</I><P>
<A NAME="IDX735"></A>

</P>
<P>
<EM>Syntax:</EM>  Same as for <CODE>let-syntax</CODE>.

</P>
<P>
<EM>Semantics:</EM>   The &#60;body&#62; is expanded in the syntactic environment obtained by
extending the syntactic environment of the <CODE>letrec-syntax</CODE>
expression with macros whose keywords are the
&#60;keyword&#62;s, bound to the specified transformers.
Each binding of a &#60;keyword&#62; has the &#60;bindings&#62;
as well as the &#60;body&#62; within its region,
so the transformers can
transcribe expressions into uses of the macros
introduced by the <CODE>letrec-syntax</CODE> expression.

</P>

<PRE>
(letrec-syntax
  ((or (syntax-rules ()
         ((or) #f)
         ((or e) e)
         ((or e1 e2 ...)
          (let ((temp e1))
            (if temp
                temp
                (or e2 ...)))))))
  (let ((x #f)
        (y 7)
        (temp 8)
        (let odd?)
        (if even?))
    (or x
        (let temp)
        (if y)
        y)))                =>  7
</PRE>

<P>

<U>syntax:</U> <B>define-syntax</B> <I>&#60;keyword&#62; &#60;transformer spec&#62;</I><P>
<A NAME="IDX736"></A>

</P>
<P>
<EM>Syntax:</EM>  The &#60;keyword&#62; is an identifier, and the &#60;transformer
spec&#62; should be an instance of <CODE>syntax-rules</CODE>.

</P>
<P>
<EM>Semantics:</EM>  The top-level syntactic environment is extended by binding the
&#60;keyword&#62; to the specified transformer.

</P>

<PRE>
(define-syntax let*
  (syntax-rules ()
    ((let* () body1 body2 ...)
     (let () body1 body2 ...))
    ((let* ((name1 val1) (name2 val2) ...)
       body1 body2 ...)
     (let ((name1 val1))
       (let* ((name2 val2) ...)
         body1 body2 ...)))))
</PRE>

<P>



<H2><A NAME="SEC83" HREF="r4rs_toc.html#SEC83">Pattern language</A></H2>

<P>
<U>syntax:</U> <B>syntax-rules</B> <I>&#60;literals&#62; &#60;syntax rule&#62; ...</I><P>
<A NAME="IDX737"></A>

</P>
<P>
<EM>Syntax:</EM>  &#60;Literals&#62; is a list of identifiers, and each &#60;syntax rule&#62;
should be of the form

<PRE>
(&#60;pattern&#62; &#60;template&#62;)
</PRE>

<P>
where the &#60;pattern&#62; and &#60;template&#62; are as in the grammar
above.

</P>
<P>
<EM>Semantics:</EM>  An instance of <CODE>syntax-rules</CODE> produces a new macro
transformer by specifying a sequence of hygienic rewrite rules.  A use
of a macro whose keyword is associated with a transformer specified by
<CODE>syntax-rules</CODE> is matched against the patterns contained in the
&#60;syntax rule&#62;s, beginning with the leftmost &#60;syntax rule&#62;.
When a match is found, the macro use is transcribed hygienically
according to the template.

</P>
<P>
Each pattern begins with the keyword for the macro.  This keyword
is not involved in the matching and is not considered a pattern
variable or literal identifier.

</P>
<P>
<EM>Rationale:</EM>  The scope of the keyword is determined by the expression or syntax
definition that binds it to the associated macro transformer.
If the keyword were a pattern variable or literal identifier, then
the template that follows the pattern would be within its scope
regardless of whether the keyword were bound by <CODE>let-syntax</CODE>
or by <CODE>letrec-syntax</CODE>.

</P>
<P>
An identifier that appears in the pattern of a &#60;syntax rule&#62; is
a pattern variable, unless it is the keyword that begins the pattern,
is listed in &#60;literals&#62;, or is the identifier "<CODE>...</CODE>".
Pattern variables match arbitrary input elements and
are used to refer to elements of the input in the template.  It is an
error for the same pattern variable to appear more than once in a
&#60;pattern&#62;.

</P>
<P>
Identifiers that appear in &#60;literals&#62; are interpreted as literal
identifiers to be matched against corresponding subforms of the input.
A subform
in the input matches a literal identifier if and only if it is an
identifier
and either both its occurrence in the macro expression and its
occurrence in the macro definition have the same lexical binding, or
the two identifiers are equal and both have no lexical binding.

</P>

<P>
A subpattern followed by <CODE>...</CODE> can match zero or more elements of the
input.  It is an error for <CODE>...</CODE> to appear in &#60;literals&#62;.
Within a pattern the identifier <CODE>...</CODE> must follow the last element of
a nonempty sequence of subpatterns.

</P>
<P>
More formally, an input form <VAR>F</VAR> matches a pattern <VAR>P</VAR> if and only if:

</P>

<UL>
<LI><VAR>P</VAR> is a pattern variable; or

<LI><VAR>P</VAR> is a literal identifier and <VAR>F</VAR> is an identifier with the same

      binding; or

<LI><VAR>P</VAR> is a pattern list <CODE>(<VAR>P1</VAR> ... <VAR>Pn</VAR>)</CODE> and <VAR>F</VAR> is a

      list of <VAR>n</VAR>
      forms that match <VAR>P1</VAR> through <VAR>Pn</VAR>, respectively; or

<LI><VAR>P</VAR> is an improper pattern list

      <CODE>(<VAR>P1</VAR> <VAR>P2</VAR> ... <VAR>Pn</VAR> . <VAR>Q</VAR>)</CODE>
      and <VAR>F</VAR> is a list or
      improper list of <VAR>n</VAR> or more forms that match <VAR>P1</VAR> through <VAR>Pn</VAR>,
      respectively, and whose <VAR>n</VAR>th "cdr" matches <VAR>Q</VAR>; or

<LI><VAR>P</VAR> is

      of the form
      <CODE>(<VAR>P1</VAR> ... <VAR>Pn</VAR> <VAR>Q</VAR> &#60;ellipsis&#62;)</CODE>
      where &#60;ellipsis&#62; is the identifier <CODE>...</CODE>
      and <VAR>F</VAR> is
      a proper list of at least <VAR>n</VAR> elements, the first <VAR>n</VAR> of which match
      <VAR>P1</VAR> through <VAR>Pn</VAR>, respectively, and each remaining element of <VAR>F</VAR>
      matches <VAR>Q</VAR>; or

<LI><VAR>P</VAR> is a pattern datum and <VAR>F</VAR> is equal to <VAR>P</VAR> in the sense of

      the <CODE>equal?</CODE> procedure.
</UL>

<P>
It is an error to use a macro keyword, within the scope of its
binding, in an expression that does not match any of the patterns.

</P>
<P>
When a macro use is transcribed according to the template of the
matching &#60;syntax rule&#62;, pattern variables that occur in the
template are replaced by the subforms they match in the input.
Pattern variables that occur in subpatterns followed by one or more
instances of the identifier
<CODE>...</CODE> are allowed only in subtemplates that are
followed by as many instances of <CODE>...</CODE>.
They are replaced in the
output by all of the subforms they match in the input, distributed as
indicated.  It is an error if the output cannot be built up as
specified.

</P>

<P>
Identifiers that appear in the template but are not pattern variables
or the identifier
<CODE>...</CODE> are inserted into the output as literal identifiers.  If a
literal identifier is inserted as a free identifier then it refers to the
binding of that identifier within whose scope the instance of
<CODE>syntax-rules</CODE> appears.
If a literal identifier is inserted as a bound identifier then it is
in effect renamed to prevent inadvertent captures of free identifiers.

</P>

<PRE>
(define-syntax let
  (syntax-rules ()
    ((let ((name val) ...) body1 body2 ...)
     ((lambda (name ...) body1 body2 ...)
      val ...))
    ((let tag ((name val) ...) body1 body2 ...)
     ((letrec ((tag (lambda (name ...)
                      body1 body2 ...)))
        tag)
      val ...))))

(define-syntax cond
  (syntax-rules (else =&#62;)
    ((cond (else result1 result2 ...))
     (begin result1 result2 ...))
    ((cond (test =&#62; result))
     (let ((temp test))
       (if temp (result temp))))
    ((cond (test =&#62; result) clause1 clause2 ...)
     (let ((temp test))
       (if temp
           (result temp)
           (cond clause1 clause2 ...))))
    ((cond (test)) test)
    ((cond (test) clause1 clause2 ...)
     (or test (cond clause1 clause2 ...)))
    ((cond (test result1 result2 ...))
     (if test (begin result1 result2 ...)))
    ((cond (test result1 result2 ...)
           clause1 clause2 ...)
     (if test
         (begin result1 result2 ...)
         (cond clause1 clause2 ...)))))

(let ((=&#62; #f))
  (cond (#t =&#62; 'ok)))       =>  ok
</PRE>

<P>
The last example is not an error because the local variable <CODE>=&#62;</CODE>
is renamed in effect, so that its use is distinct from uses of the top
level identifier <CODE>=&#62;</CODE> that the transformer for <CODE>cond</CODE> looks
for.  Thus, rather than expanding into

</P>

<PRE>
(let ((=&#62; #f))
  (let ((temp #t))
    (if temp ('ok temp))))
</PRE>

<P>
which would result in an invalid procedure call, it expands instead
into

</P>

<PRE>
(let ((=&#62; #f))
  (if #t (begin =&#62; 'ok)))
</PRE>

<P>



<H2><A NAME="SEC84" HREF="r4rs_toc.html#SEC84">A compatible low-level macro facility</A></H2>

<P>
Although the pattern language provided by <CODE>syntax-rules</CODE> is the
preferred way to specify macro transformers, other low-level
facilities may be provided to specify more complex macro transformers.
In fact, <CODE>syntax-rules</CODE> can itself be defined as a macro using the
low-level facilities described in this section.

</P>
<P>
The low-level macro facility described here introduces <CODE>syntax</CODE>
as a new syntactic keyword analogous to <CODE>quote</CODE>, and allows a
&#60;transformer spec&#62; to be any expression.  This is accomplished by
adding the following two productions to the productions in
section <A HREF="r4rs.html#SEC67">Formal syntax</A> and in section <A HREF="r4rs.html#SEC82">Binding syntactic keywords</A> above.

</P>

<PRE>
&#60;expression&#62; ==> (syntax &#60;datum&#62;)
&#60;transformer spec&#62; ==> &#60;expression&#62;
</PRE>

<P>
The low-level macro system also adds the following procedures:

</P>

<PRE>
unwrap-syntax          identifier-&#62;symbol
identifier?            generate-identifier
free-identifier=?      construct-identifier
bound-identifier=?
</PRE>

<P>
Evaluation of a program proceeds in two logical steps.  First the
program is converted into an intermediate language via macro-expansion,
and then the result of macro expansion is evaluated.  When it is
necessary to distinguish the second stage of this process from the
full evaluation process, it is referred to as "execution."

</P>
<P>
Syntax definitions, either lexical or global, cause an identifier to
be treated as a keyword within the scope of the binding.  The keyword
is associated with a transformer, which may be created implicitly
using the pattern language of <CODE>syntax-rules</CODE> or explicitly using
the low-level facilities described below.

</P>
<P>
Since a transformer spec must be fully evaluated during the
course of expansion, it is necessary to specify the environment in
which this evaluation takes place.  A transformer spec is
expanded in the same environment as that in which the program is being
expanded, but is executed in an environment that is distinct from the
environment in which the program is executed.  This execution
environment distinction is important only for the resolution of global
variable references and assignments.  In what follows, the environment
in which transformers are executed is called the standard transformer
environment and is assumed to be a standard Scheme environment.

</P>
<P>
Since part of the task of hygienic macro expansion is to resolve
identifier references, the fact that transformers are expanded in the
same environment as the program means that identifier bindings in the
program can shadow identifier uses within transformers.  Since
variable bindings in the program are not available at the time the
transformer is executed, it is an error for a transformer to reference
or assign them.  However, since keyword bindings are available during
expansion, lexically visible keyword bindings from the program may be
used in macro uses in a transformer.

</P>
<P>
When a macro use is encountered, the macro transformer associated with
the macro keyword is applied to a representation of the macro
expression.  The result returned by the macro transformer replaces the
original expression and is expanded once again.  Thus macro expansions
may themselves be or contain macro uses.

</P>
<P>
The syntactic representation passed to a macro transformer
encapsulates information about the structure of the represented form
and the bindings of the identifiers it contains.  These syntax objects
can be traversed and examined using the procedures described below.
The output of a transformer may be built up using the usual Scheme
list constructors, combining pieces of the input with new syntactic
structures.

</P>
<P>
<U>syntax:</U> <B>syntax</B> <I>&#60;datum&#62;</I><P>
<A NAME="IDX738"></A>

</P>
<P>
<EM>Syntax:</EM>  The &#60;datum&#62; may be any external representation of a Scheme
object.

</P>
<P>
<EM>Semantics:</EM>  <CODE>Syntax</CODE> is the syntactic analogue of <CODE>quote</CODE>.  It creates a
syntactic representation of &#60;datum&#62; that, like an argument to a
transformer, contains information about the bindings for identifiers
contained in &#60;datum&#62;.  The binding for an identifier introduced
by <CODE>syntax</CODE> is the closest lexically visible binding.  All
variables and keywords introduced by transformers must be created by
<CODE>syntax</CODE>.  It is an error to insert a symbol in the output of a
transformation procedure unless it is to be part of a quoted datum.

</P>

<PRE>
(symbol? (syntax x))        => #f

(let-syntax ((car (lambda (x) (syntax car))))
  ((car) '(0)))             => 0

(let-syntax
  ((quote-quote
    (lambda (x) (list (syntax quote) 'quote))))
  (quote-quote))            => quote

(let-syntax
  ((quote-quote
    (lambda (x) (list 'quote 'quote))))
  (quote-quote))            => <EM>error</EM>
</PRE>

<P>
The second <CODE>quote-quote</CODE> example results in an error because two raw
symbols are being inserted in the output.  The quoted <CODE>quote</CODE> in the
first <CODE>quote-quote</CODE> example does not cause an error because it will
be a quoted datum.

</P>

<PRE>
(let-syntax ((quote-me
              (lambda (x)
                (list (syntax quote) x))))
  (quote-me please))        => (quote-me please)

(let ((x 0))
  (let-syntax ((alpha (lambda (e) (syntax x))))
    (alpha)))               => 0

(let ((x 0))
  (let-syntax ((alpha (lambda (x) (syntax x))))
    (alpha)))               => <EM>error</EM>

(let-syntax ((alpha
              (let-syntax ((beta
                            (syntax-rules ()
                              ((beta) 0))))
                (lambda (x) (syntax (beta))))))
  (alpha))                  => <EM>error</EM>
</PRE>

<P>
The last two examples are errors because in both cases a lexically
bound identifier is placed outside of the scope of its binding.
In the first case, the variable <CODE>x</CODE> is placed outside its scope.
In the second case, the keyword <CODE>beta</CODE> is placed outside its
scope.

</P>

<PRE>
(let-syntax ((alpha (syntax-rules ()
                      ((alpha) 0))))
  (let-syntax ((beta (lambda (x) (alpha))))
    (beta)))                => 0

(let ((list 0))
  (let-syntax ((alpha (lambda (x) (list 0))))
    (alpha)))               => <EM>error</EM>
</PRE>

<P>
The last example is an error because the reference to <CODE>list</CODE> in the
transformer is shadowed by the lexical binding for <CODE>list</CODE>.  Since the
expansion process is distinct from the execution of the program,
transformers cannot reference program variables.  On the other hand,
the previous example is not an error because definitions for keywords
in the program do exist at expansion time.

</P>
<P>
<EM>Note:</EM>  It has been suggested that <CODE>#'&#60;datum&#62;</CODE> and
<CODE>#`&#60;datum&#62;</CODE> would be
felicitous abbreviations for <CODE>(syntax &#60;datum&#62;)</CODE>
and <CODE>(quasisyntax &#60;datum&#62;)</CODE>, respectively,
where <CODE>quasisyntax</CODE>, which is not described in this
appendix, would bear the same relationship to <CODE>syntax</CODE>
that <CODE>quasiquote</CODE> bears to <CODE>quote</CODE>.

</P>
<P>

<U>procedure:</U> <B>identifier?</B> <I>syntax-object</I><P>
<A NAME="IDX739"></A>

</P>
<P>
Returns <CODE>#t</CODE> if <VAR>syntax-object</VAR> represents an identifier,
otherwise returns <CODE>#f</CODE>.

</P>

<PRE>
(identifier? (syntax x))    => #t
(identifier? (quote x))     => #f
(identifier? 3)             => #f
</PRE>

<P>

<U>procedure:</U> <B>unwrap-syntax</B> <I>syntax-object</I><P>
<A NAME="IDX740"></A>

</P>
<P>
If <VAR>syntax-object</VAR> is an identifier, then it is returned unchanged.
Otherwise <CODE>unwrap-syntax</CODE> converts the outermost structure of
<VAR>syntax-object</VAR> into a
data object whose external representation is the same as that of
<VAR>syntax-object</VAR>.  The result is either an identifier, a pair whose
car
and cdr are syntax objects, a vector whose elements are syntax
objects, an empty list, a string, a boolean, a character, or a number.

</P>

<PRE>
(identifier? (unwrap-syntax (syntax x)))
                            => #t
(identifier? (car (unwrap-syntax (syntax (x)))))
                            => #t
(unwrap-syntax (cdr (unwrap-syntax (syntax (x)))))
                            => ()
</PRE>

<P>

<U>procedure:</U> <B>free-identifier=?</B> <I>id1 id2</I><P>
<A NAME="IDX741"></A>

</P>
<P>
Returns <CODE>#t</CODE> if the original occurrences of <VAR>id1</VAR>
and <VAR>id2</VAR> have
the same binding, otherwise returns <CODE>#f</CODE>.
<CODE>free-identifier=?</CODE>
is used to look for a literal identifier in the argument to a
transformer, such as <CODE>else</CODE> in a <CODE>cond</CODE> clause.
A macro
definition for <CODE>syntax-rules</CODE> would use <CODE>free-identifier=?</CODE>
to look for literals in the input.

</P>

<PRE>
(free-identifier=? (syntax x) (syntax x))
                            => #t
(free-identifier=? (syntax x) (syntax y))
                            => r#f

(let ((x (syntax x)))
  (free-identifier=? x (syntax x)))
                            => #f

(let-syntax
  ((alpha
    (lambda (x)
      (free-identifier=? (car (unwrap-syntax x))
                         (syntax alpha)))))
  (alpha))                  => #f

(letrec-syntax
  ((alpha
    (lambda (x)
      (free-identifier=? (car (unwrap-syntax x))
                         (syntax alpha)))))
  (alpha))                  => #t
</PRE>

<P>

<U>procedure:</U> <B>bound-identifier=?</B> <I>id1 id2</I><P>
<A NAME="IDX742"></A>

</P>
<P>
Returns <CODE>#t</CODE> if a binding for one of the two identifiers
<VAR>id1</VAR> and <VAR>id2</VAR> would shadow free references to the other,
otherwise returns <CODE>#f</CODE>.
Two identifiers can be <CODE>free-identifier=?</CODE> without being
<CODE>bound-identifier=?</CODE>  if they were introduced at different
stages in the
expansion process.
<CODE>Bound-identifier=?</CODE> can be used, for example, to
detect duplicate identifiers in bound-variable lists.  A macro
definition of <CODE>syntax-rules</CODE> would use <CODE>bound-identifier=?</CODE>
to look for
pattern variables from the input pattern in the output template.

</P>

<PRE>
(bound-identifier=? (syntax x) (syntax x))
                            => #t

(letrec-syntax
  ((alpha
    (lambda (x)
      (bound-identifier=? (car (unwrap-syntax x))
                          (syntax alpha)))))
  (alpha))                  => #f
</PRE>

<P>

<U>procedure:</U> <B>identifier-&#62;symbol</B> <I>id</I><P>
<A NAME="IDX743"></A>

</P>
<P>
Returns a symbol representing the original name of <VAR>id</VAR>.
<CODE>Identifier-&#62;symbol</CODE> is used to examine identifiers that appear in
literal contexts, i.e., identifiers that will appear in quoted
structures.

</P>

<PRE>
(symbol? (identifier-&#62;symbol (syntax x)))
                            => #t
(identifier-&#62;symbol (syntax x))
                            => x
</PRE>

<P>

<U>procedure:</U> <B>generate-identifier</B><P>
<A NAME="IDX744"></A>
<U>procedure:</U> <B>generate-identifier</B> <I>symbol</I><P>
<A NAME="IDX745"></A>

</P>
<P>
Returns a new identifier.
The optional argument to <CODE>generate-identifier</CODE> specifies the
symbolic name of the resulting identifier.  If no argument is
supplied the name is unspecified.

</P>
<P>
<CODE>Generate-identifier</CODE> is used to introduce bound identifiers into
the output of a transformer.  Since introduced bound identifiers are
automatically renamed, <CODE>generate-identifier</CODE> is necessary only for
distinguishing introduced identifiers when an indefinite number of them
must be generated by a macro.

</P>
<P>
The optional argument to <CODE>generate-identifier</CODE> specifies the
symbolic name of the resulting identifier.  If no argument is
supplied the name is unspecified.  The procedure
<CODE>identifier-&#62;symbol</CODE> reveals the symbolic name of an identifier.

</P>

<PRE>
(identifier-&#62;symbol (generate-identifier 'x))
                            => x

(bound-identifier=? (generate-identifier 'x)
                    (generate-identifier 'x))
                            => #f

(define-syntax set*!
  ; (set*! (&#60;identifier&#62; &#60;expression&#62;) ...)
  (lambda (x)
    (letrec
      ((unwrap-exp
        (lambda (x)
          (let ((x (unwrap-syntax x)))
            (if (pair? x)
                (cons (car x)
                      (unwrap-exp (cdr x)))
                x)))))
      (let ((sets (map unwrap-exp
                       (cdr (unwrap-exp x)))))
        (let ((ids (map car sets))
              (vals (map cadr sets))
              (temps (map (lambda (x)
                            (generate-identifier))
                          sets)))
          `(,(syntax let) ,(map list temps vals)
            ,@(map (lambda (id temp)
                     `(,(syntax set!) ,id ,temp))
                   ids
                   temps)
            #f))))))
</PRE>

<P>

<U>procedure:</U> <B>construct-identifier</B> <I>id symbol</I><P>
<A NAME="IDX746"></A>

</P>
<P>
Creates and returns an identifier named by <VAR>symbol</VAR> that behaves
as if it had been introduced where the identifier <VAR>id</VAR> was
introduced.

</P>
<P>
<CODE>Construct-identifier</CODE> is used to circumvent hygiene by
creating an identifier that behaves as though it had been
implicitly present in some expression.  For example, the
transformer for a structure
definition macro might construct the name of a field accessor
that does not explicitly appear in a use of the macro,
but can be
constructed from the names of the structure and the field.
If a binding for the field accessor were introduced
by a hygienic transformer, then it would be renamed automatically,
so that the introduced binding would fail to capture any
references to the field accessor that were present in the
input and were intended to be
within the scope of the introduced binding.

</P>
<P>
Another example is a macro that implicitly binds <CODE>exit</CODE>:

</P>

<PRE>
(define-syntax loop-until-exit
  (lambda (x)
    (let ((exit (construct-identifier
                 (car (unwrap-syntax x))
                 'exit))
          (body (car (unwrap-syntax
                      (cdr (unwrap-syntax x))))))
      `(,(syntax call-with-current-continuation)
        (,(syntax lambda)
         (,exit)
         (,(syntax letrec)
          ((,(syntax loop)
            (,(syntax lambda) ()
               ,body
               (,(syntax loop)))))
          (,(syntax loop))))))))

(let ((x 0) (y 1000))
  (loop-until-exit
   (if (positive? y)
       (begin (set! x (+ x 3))
              (set! y (- y 1)))
       (exit x))))          => 3000
</PRE>

<P>



<H2><A NAME="SEC85" HREF="r4rs_toc.html#SEC85">Acknowledgements</A></H2>

<P>
The extension described in this appendix is the most
sophisticated macro facility that has ever been proposed
for a block-structured programming language.  The main ideas
come from
Eugene Kohlbecker's PhD thesis on hygienic macro expansion
[KOHLBECKER86], written under the direction of Dan
Friedman [HYGIENIC], and from the work by Alan Bawden
and Jonathan Rees on syntactic closures [BAWDEN88].
Pattern-directed macro facilities were popularized by Kent
Dybvig's non-hygienic implementation of <CODE>extend-syntax</CODE>
[DYBVIG87].

</P>
<P>
At the 1988 meeting of this report's authors at Snowbird,
a macro committee consisting of Bawden, Rees, Dybvig,
and Bob Hieb was charged with developing a hygienic macro
facility akin to <CODE>extend-syntax</CODE> but based on syntactic closures.
Chris Hanson implemented a prototype and wrote a paper on his
experience, pointing out that an implementation based on
syntactic closures must determine the syntactic roles of some
identifiers before macro expansion based on textual pattern
matching can make those roles apparent.  William Clinger
observed that Kohlbecker's algorithm amounts to a technique
for delaying this determination, and proposed a more efficient
version of Kohlbecker's algorithm.  Pavel Curtis spoke up for
referentially transparent local macros.  Rees merged syntactic
environments with the modified Kohlbecker's algorithm and
implemented it all, twice [MACROSTHATWORK].

</P>
<P>
Dybvig and Hieb designed and implemented the low-level
macro facility described above.
Recently Hanson and Bawden have extended syntactic closures
to obtain an alternative low-level macro facility.
The macro committee has not endorsed any particular
low-level facility, but does endorse the general concept of
a low-level facility that is compatible with the
high-level pattern language described in this appendix.

</P>
<P>
Several other people have contributed by working on macros
over the years.  Hal Abelson contributed by holding this
report hostage to the appendix on macros.

</P>



<H1><A NAME="SEC86" HREF="r4rs_toc.html#SEC86">Bibliography</A></H1>

<DL COMPACT>

<DT><A NAME="BIB1">[ABELSON88]</A>
<DD>
<A NAME="IDX747"></A>
Harold Abelson and Gerald Jay Sussman.
Lisp: a langauge for stratified design.
<CITE>BYTE</CITE> 13(2):207--218, February 1988.

<DT><A NAME="BIB2">[SICP]</A>
<DD>
<A NAME="IDX748"></A>
Harold Abelson and Gerald Jay Sussman with Julie Sussman.
<CITE>Structure and Interpretation of Computer Programs.</CITE>
MIT Press, Cambridge, 1985.

<DT><A NAME="BIB3">[ADAMS88]</A>
<DD>
<A NAME="IDX749"></A>
Norman Adams and Jonathan Rees.
Object-oriented programming in Scheme.
In <CITE>Proceedings of the 1988 Conference on Lisp
  and Functional Programming</CITE>, pages 277--288, August 1988.

<DT><A NAME="BIB4">[BARTLEY86]</A>
<DD>
<A NAME="IDX750"></A>
David H. Bartley and John C. Jensen.
The implementation of PC Scheme.
In <CITE>Proceedings of the 1986 ACM Conference on Lisp
  and Functional Programming</CITE>, pages 86--93.

<DT><A NAME="BIB5">[SCHEME81]</A>
<DD>
<A NAME="IDX751"></A>
John Batali, Edmund Goodhue, Chris Hanson, Howie Shrobe, Richard
  M. Stallman, and Gerald Jay Sussman.
The Scheme-81 architecture--system and chip.
In <CITE>Proceedings, Conference on Advanced Research in VLSI</CITE>,
  pages 69--77.
Paul Penfield, Jr., editor.
Artech House, 610 Washington Street, Dedham MA, 1982.

<DT><A NAME="BIB6">[BAWDEN88]</A>
<DD>
<A NAME="IDX752"></A>
Alan Bawden and Jonathan Rees.
Syntactic closures.
In <CITE>Proceedings of the 1988 ACM Symposium on Lisp and
  Functional Programming</CITE>, pages 86--95.

Available as
<A HREF="ftp://ftp-swiss.ai.mit.edu/pub/scheme-reports/synclo.dvi">
synclo.dvi
</A>,
<A HREF="ftp://ftp-swiss.ai.mit.edu/pub/scheme-reports/synclo.ps">
synclo.ps
</A>,
<A HREF="ftp://ftp-swiss.ai.mit.edu/pub/scheme-reports/synclo.tar">
synclo.tar
</A> or
<A HREF="ftp://ftp-swiss.ai.mit.edu/pub/scheme-reports/synclo.tar.Z">
synclo.tar.Z
</A> (LaTeX files).

<DT><A NAME="BIB7">[CLINGER84]</A>
<DD>
<A NAME="IDX753"></A>
William Clinger.
The Scheme 311 compiler: an exercise in denotational semantics.
In <CITE>Conference Record of the 1984 ACM Symposium on Lisp and
  Functional Programming</CITE>, pages 356--364.

<DT><A NAME="BIB8">[RRRS]</A>
<DD>
<A NAME="IDX754"></A>
William Clinger, editor.
The revised revised report on Scheme, or an uncommon Lisp.
MIT Artificial Intelligence Memo 848, August 1985.
Also published as Computer Science Department Technical Report 174,
  Indiana University, June 1985.

<DT><A NAME="BIB9">[CLINGER88]</A>
<DD>
<A NAME="IDX755"></A>
William Clinger.
Semantics of Scheme.
<CITE>BYTE</CITE> 13(2):221--227, February 1988.

<DT><A NAME="BIB10">[HOWTOREAD]</A>
<DD>
<A NAME="IDX756"></A>
William Clinger.
How to read floating point numbers accurately.
In <CITE>Proceedings of the ACM SIGPLAN '90 Conference
  on Programming Language Design and Implementation</CITE>, pages 92--101.
Proceedings published as <CITE>SIGPLAN Notices</CITE> 25(6), June 1990.

<DT><A NAME="BIB11">[CLINGER85]</A>
<DD>
<A NAME="IDX757"></A>
William Clinger, Daniel P. Friedman, and Mitchell Wand.
A scheme for a higher-level semantic algebra.
In <CITE>Algebraic Methods in Semantics</CITE>, pages 237--250.
J. Reynolds, M. Nivat, editor.
Cambridge University Press, 1985.

<DT><A NAME="BIB12">[CLINGER88B]</A>
<DD>
<A NAME="IDX758"></A>
William Clinger, Anne Hartheimer, and Eric Ost.
Implementation strategies for continuations.
In <CITE>Proceedings of the 1988 ACM Conference on Lisp and Functional
  Programming</CITE>, pages 124--131.

<DT><A NAME="BIB13">[MACROSTHATWORK]</A>
<DD>
<A NAME="IDX759"></A>
William Clinger and Jonathan Rees.
Macros that work.
In <CITE>Proceedings of the 1991 ACM Conference on Principles of
  Programming Languages</CITE>, pages 155--162.

<DT><A NAME="BIB14">[CURTIS90]</A>
<DD>
<A NAME="IDX760"></A>
Pavel Curtis and James Rauen.
A module system for Scheme.
In <CITE>Proceedings of the 1990 ACM Conference on Lisp and
  Functional Programming</CITE>, June 1990.

<DT><A NAME="BIB15">[DYBVIG87]</A>
<DD>
<A NAME="IDX761"></A>
R. Kent Dybvig.
<CITE>The Scheme Programming Language.</CITE>
Prentice-Hall, 1987.

<A NAME="IDX762"></A>

<DT><A NAME="BIB16">[DYBVIG86]</A>
<DD>
<A NAME="IDX763"></A>
R. Kent Dybvig and Daniel P. Friedman and Christopher T. Haynes.
Expansion-passing style: a general macro mechanism.
<CITE>Lisp and Symbolic Computation</CITE> 1(1):53--76, June 1988.

<DT><A NAME="BIB17">[DYBVIG88]</A>
<DD>
<A NAME="IDX764"></A>
R. Kent Dybvig and Robert Hieb.
A variable-arity procedural interface.
In <CITE>Proceedings of the 1988 ACM Symposium on Lisp and
  Functional Programming</CITE>, pages 106--115.

<DT><A NAME="BIB18">[DYBVIG88]</A>
<DD>
<A NAME="IDX765"></A>
R. Kent Dybvig and Robert Hieb.
Engines from continuations.
<CITE>Journal of Computer Languages</CITE> 14(2), pages 109--123,
1989.

<DT><A NAME="BIB19">[DYBVIG88]</A>
<DD>
<A NAME="IDX766"></A>
R. Kent Dybvig and Robert Hieb.
Continuations and concurrency.
In <CITE>Proceedings of the Second ACM SIGPLAN Notices
  Symposium on Principles and Practice of Parallel Programming</CITE>,
pages 128--136, March 1990.

<DT><A NAME="BIB20">[EISENBERG85]</A>
<DD>
<A NAME="IDX767"></A>
Michael A. Eisenberg.
Bochser: an integrated Scheme programming system.
MIT Laboratory for Computer Science Technical Report 349,
  October 1985.

<DT><A NAME="BIB21">[EISENBERG88]</A>
<DD>
<A NAME="IDX768"></A>
Michael Eisenberg.
Harold Abelson, editor.
<CITE>Programming In Scheme.</CITE>
Scientific Press, Redwood City, California, 1988.

<DT><A NAME="BIB22">[EISENBERG90]</A>
<DD>
<A NAME="IDX769"></A>
Michael Eisenberg, with William Clinger and Anne Hartheimer.
Harold Abelson, editor.
<CITE>Programming In MacScheme.</CITE>
Scientific Press, San Francisco, 1990.

<DT><A NAME="BIB23">[FEELEY86]</A>
<DD>
<A NAME="IDX770"></A>
Marc Feeley.
Deux approches `{a} l'implantation du language Scheme.
M.Sc. thesis, D'{e}partement d'Informatique et de Recherche
  Op'{e}rationelle, University of Montreal, May 1986.

<DT><A NAME="BIB24">[FEELEY87]</A>
<DD>
<A NAME="IDX771"></A>
Marc Feeley and Guy LaPalme.
Using closures for code generation.
<CITE>Journal of Computer Languages</CITE> 12(1):47--66, 1987.

<DT><A NAME="BIB25">[FEELEY90]</A>
<DD>
<A NAME="IDX772"></A>
Marc Feeley and James Miller.
A parallel virtual machine for efficient Scheme compilation.
In <CITE>Proceedings of the 1990 ACM Conference on Lisp and
  Functional Programming</CITE>, June 1990.

<DT><A NAME="BIB26">[FELLEISEN87B]</A>
<DD>
<A NAME="IDX773"></A>
Matthias Felleisen.
Reflections on Landin's J-Operator: a partly historical note.
<CITE>Journal of Computer Languages</CITE> 12(3/4):197--207, 1987.

<DT><A NAME="BIB27">[FELLEISEN86B]</A>
<DD>
<A NAME="IDX774"></A>
Matthias Felleisen and Daniel P. Friedman.
Control operators, the SECD-machine, and the lambda-calculus.
In <CITE>3rd Working Conference on the Formal Description of
   Programming Concepts</CITE>, pages 193--219, August 1986.

<DT><A NAME="BIB28">[FELLEISEN86C]</A>
<DD>
<A NAME="IDX775"></A>
Matthias Felleisen and Daniel P. Friedman.
A closer look at export and import statements.
<CITE>Journal of Computer Languages</CITE> 11(1):29--37, 1986.

<DT><A NAME="BIB29">[FELLEISEN87]</A>
<DD>
<A NAME="IDX776"></A>
Matthias Felleisen and Daniel P. Friedman.
A calculus for assignments in higher-order languages.
In <CITE>Conference Record of the 14th Annual ACM Symposium
  on Principles of Programming Languages</CITE>, pages 314--345, January 1987.

<DT><A NAME="BIB30">[FELLEISEN87D]</A>
<DD>
<A NAME="IDX777"></A>
Matthias Felleisen and Daniel P. Friedman.
A reduction semantics for imperative higher-order languages.
In <CITE>Lecture Notes in Computer Science</CITE>,
<CITE>Parallel Architectures and Languages Europe</CITE> 259:206--223, 1987.
De Bakker, Nijman and Treleaven, editors.
Springer-Verlag, Berlin.

<DT><A NAME="BIB31">[FELLEISEN86]</A>
<DD>
<A NAME="IDX778"></A>
Matthias Felleisen, Daniel P. Friedman, Eugene Kohlbecker, and Bruce Duba.
Reasoning with continuations.
In <CITE>Proceedings of the Symposium on Logic in Computer Science</CITE>,
  pages 131--141.
IEEE Computer Society Press, Washington DC, 1986.

<DT><A NAME="BIB32">[FELLEISEN87C]</A>
<DD>
<A NAME="IDX779"></A>
Matthias Felleisen, Daniel P. Friedman, Eugene E. Kohlbecker, and Bruce Duba.
A syntactic theory of sequential control.
<CITE>Theoretical Computer Science</CITE> 52:205--237, 1987.

<DT><A NAME="BIB33">[FELLEISEN88]</A>
<DD>
<A NAME="IDX780"></A>
Matthias Felleisen, Mitchell Wand, Daniel P. Friedman, and Bruce Duba.
Abstract continuations: a mathematical semantics for
  handling functional jumps.
In <CITE>Proceedings of the 1988 ACM Symposium on Lisp and
  Functional Programming</CITE>, July 1988.

<DT><A NAME="BIB34">[SCHEME311]</A>
<DD>
<A NAME="IDX781"></A>
Carol Fessenden, William Clinger, Daniel P. Friedman, and Christopher Haynes.
Scheme 311 version 4 reference manual.
Indiana University Computer Science Technical Report 137, February 1983.
Superseded by [SCHEME84].

<DT><A NAME="BIB35">[FRANCO90]</A>
<DD>
<A NAME="IDX782"></A>
John Franco and Daniel P. Friedman.
Towards a facility for lexically scoped, dynamic mutual recursion
  in Scheme.
<CITE>Journal of Computer Languages</CITE> 15(1):55--64, 1990.

<DT><A NAME="BIB36">[LISPER]</A>
<DD>
<A NAME="IDX783"></A>
Daniel P. Friedman and Matthias Felleisen.
<CITE>The Little LISPer.</CITE>
Science Research Associates, second edition 1986.

<DT><A NAME="BIB37">[LITTLELISPER]</A>
<DD>
<A NAME="IDX784"></A>
Daniel P. Friedman and Matthias Felleisen.
<CITE>The Little LISPer.</CITE>
MIT Press, 1987.

<DT><A NAME="BIB38">[FRIEDMAN85]</A>
<DD>
<A NAME="IDX785"></A>
Daniel P. Friedman and Christopher T. Haynes.
Constraining control.
In <CITE>Proceedings of the Twelfth Annual Symposium on Principles of
  Programming Languages</CITE>, pages 245--254.
ACM, January 1985.

<DT><A NAME="BIB39">[FRIEDMAN84]</A>
<DD>
<A NAME="IDX786"></A>
Daniel P. Friedman, Christopher T. Haynes, and Eugene Kohlbecker.
Programming with continuations.
In <CITE>Program Transformation and Programming Environments,</CITE>
  pages 263--274.
P. Pepper, editor.
Springer-Verlag, 1984.

<DT><A NAME="BIB40">[SCHEME84]</A>
<DD>
<A NAME="IDX787"></A>
D. Friedman, C. Haynes, E. Kohlbecker, and M. Wand.
Scheme 84 interim reference manual.
Indiana University Computer Science Technical Report 153, January 1985.

<DT><A NAME="BIB41">[FRIEDMAN84B]</A>
<DD>
<A NAME="IDX788"></A>
Daniel P. Friedman and Mitchell Wand.
Reification: reflection without metaphysics.
In <CITE>Conference Record of the 1984 ACM Symposium on Lisp
  and Functional Programming</CITE>, pages 348--355.

<DT><A NAME="BIB42">[HAYNES86]</A>
<DD>
<A NAME="IDX789"></A>
Christopher T. Haynes.
Logic continuations.
In <CITE>Proceedings of the Third International Conference on
  Logic Programming,</CITE> pages 671--685.
Springer-Verlag, July 1986.

<DT><A NAME="BIB43">[ENGINES]</A>
<DD>
<A NAME="IDX790"></A>
Christopher T. Haynes and Daniel P. Friedman.
Engines build process abstractions.
In <CITE>Conference Record of the 1984 ACM Symposium on Lisp and
  Functional Programming,</CITE> pages 18--24.

<DT><A NAME="BIB44">[HAYNES87B]</A>
<DD>
<A NAME="IDX791"></A>
Christopher T. Haynes and Daniel P. Friedman.
Abstracting timed preemption with engines.
<CITE>Journal of Computer Languages</CITE> 12(2):109--121, 1987.

<DT><A NAME="BIB45">[HAYNES87A]</A>
<DD>
<A NAME="IDX792"></A>
Christopher T. Haynes and Daniel P. Friedman.
Embedding continuations in procedural objects.
<CITE>ACM Transactions on Programming Languages and Systems</CITE> 9(4):582--598,
  October 1987.

<A NAME="IDX793"></A>

<DT><A NAME="BIB46">[HAYNES86]</A>
<DD>
<A NAME="IDX794"></A>
Christopher T. Haynes and Daniel P. Friedman and Mitchell Wand.
Obtaining coroutines with continuations.
<CITE>Journal of Computer Languages</CITE> 11(3/4):143--153, 1986.

<DT><A NAME="BIB47">[HENDERSON82]</A>
<DD>
<A NAME="IDX795"></A>
Peter Henderson.
Functional geometry.
In <CITE>Conference Record of the 1982 ACM Symposium on Lisp and
  Functional Programming</CITE>, pages 179--187.

<DT><A NAME="BIB48">[DYBVIG88]</A>
<DD>
<A NAME="IDX796"></A>
Robert Hieb, R. Kent Dybvig, and Carl Bruggeman.
Representing control in the presence of first-class continuations.
In <CITE>Proceedings of the ACM SIGPLAN '90 Conference on Programming
  Language Design and Implementation</CITE>,
pages 66--77, June 1990.
Proceedings published as <CITE>SIGPLAN Notices</CITE> 25(6), June 1990.

<DT><A NAME="BIB49">[IEEE]</A>
<DD>
<A NAME="IDX797"></A>
<CITE>IEEE Standard 754-1985.  IEEE Standard for Binary Floating-Point
Arithmetic.</CITE>  IEEE, New York, 1985.

<DT><A NAME="BIB50">[IEEESCHEME]</A>
<DD>
<A NAME="IDX798"></A>
<CITE>IEEE Standard 1178-1990.  IEEE Standard for the Scheme
  Programming Language.</CITE>  IEEE, New York, 1991.

<DT><A NAME="BIB51">[KOHLBECKER86]</A>
<DD>
<A NAME="IDX799"></A>
Eugene Edmund Kohlbecker Jr.
<CITE>Syntactic Extensions in the Programming Language Lisp.</CITE>
PhD thesis, Indiana University, August 1986.

<DT><A NAME="BIB52">[HYGIENIC]</A>
<DD>
<A NAME="IDX800"></A>
Eugene E. Kohlbecker, Daniel P. Friedman, Matthias Felleisen, and Bruce Duba.
Hygienic macro expansion.
In <CITE>Proceedings of the 1986 ACM Conference on Lisp
  and Functional Programming</CITE>, pages 151--161.

<DT><A NAME="BIB53">[KRANZ86]</A>
<DD>
<A NAME="IDX801"></A>
David Kranz, Richard Kelsey, Jonathan Rees, Paul Hudak, James Philbin,
  and Norman Adams.
Orbit: An optimizing compiler for Scheme.
In <CITE>Proceedings of the SIGPLAN '86 Symposium on Compiler
  Construction</CITE>, pages 219--233.
ACM, June 1986.
Proceedings published as <CITE>SIGPLAN Notices</CITE> 21(7), July 1986.

<DT><A NAME="BIB54">[KRANZ88]</A>
<DD>
<A NAME="IDX802"></A>
David Kranz.
<CITE>Orbit: An optimizing compiler for Scheme.</CITE>
PhD thesis, Yale University, 1988.

<DT><A NAME="BIB55">[LANDIN65]</A>
<DD>
<A NAME="IDX803"></A>
Peter Landin.
A correspondence between Algol 60 and Church's lambda notation: Part I.
<CITE>Communications of the ACM</CITE> 8(2):89--101, February 1965.

<DT><A NAME="BIB56">[MCDERMOTT80]</A>
<DD>
<A NAME="IDX804"></A>
Drew McDermott.
An efficient environment allocation scheme in an interpreter for a
  lexically-scoped lisp.
In <CITE>Conference Record of the 1980 Lisp Conference,</CITE> pages
  154--162.
Proceedings reprinted by ACM.

<DT><A NAME="BIB57">[MITSCHEME]</A>
<DD>
<A NAME="IDX805"></A>
MIT Department of Electrical Engineering and Computer Science.
Scheme manual, seventh edition.
September 1984.

<DT><A NAME="BIB58">[MUCHNICK80]</A>
<DD>
<A NAME="IDX806"></A>
Steven S. Muchnick and Uwe F. Pleban.
A semantic comparison of Lisp and Scheme.
In <CITE>Conference Record of the 1980 Lisp Conference</CITE>, pages 56--64.
Proceedings reprinted by ACM.

<DT><A NAME="BIB59">[NAUR63]</A>
<DD>
<A NAME="IDX807"></A>
Peter Naur et al.
Revised report on the algorithmic language Algol 60.
<CITE>Communications of the ACM</CITE> 6(1):1--17, January 1963.

<DT><A NAME="BIB60">[PENFIELD81]</A>
<DD>
<A NAME="IDX808"></A>
Paul Penfield, Jr.
Principal values and branch cuts in complex APL.
In <CITE>APL '81 Conference Proceedings,</CITE> pages 248--256.
ACM SIGAPL, San Francisco, September 1981.
Proceedings published as <CITE>APL Quote Quad</CITE> 12(1), ACM, September 1981.

<DT><A NAME="BIB61">[PITMAN85]</A>
<DD>
<A NAME="IDX809"></A>
Kent M. Pitman.
Exceptional situations in Lisp.
MIT Artificial Intelligence Laboratory Working Paper 268, February 1985.

<DT><A NAME="BIB62">[PITMAN83]</A>
<DD>
<A NAME="IDX810"></A>
Kent M. Pitman.
The revised MacLisp manual (Saturday evening edition).
MIT Laboratory for Computer Science Technical Report 295, May 1983.

<DT><A NAME="BIB63">[PITMAN80]</A>
<DD>
<A NAME="IDX811"></A>
Kent M. Pitman.
Special forms in Lisp.
In <CITE>Conference Record of the 1980 Lisp Conference</CITE>, pages 179--187.
Proceedings reprinted by ACM.

<DT><A NAME="BIB64">[PLEBANTHESIS]</A>
<DD>
<A NAME="IDX812"></A>
Uwe F. Pleban.
<CITE>A Denotational Approach to Flow Analysis and Optimization of Scheme,
A Dialect of Lisp.</CITE> PhD thesis, University of Kansas, 1980.

<DT><A NAME="BIB65">[REES89]</A>
<DD>
<A NAME="IDX813"></A>
Jonathan A. Rees.
<CITE>Modular Macros</CITE>.
M.S. thesis, MIT, May 1989.

<DT><A NAME="BIB66">[REES82]</A>
<DD>
<A NAME="IDX814"></A>
Jonathan A. Rees and Norman I. Adams IV.
T: A dialect of Lisp or, lambda: The ultimate software tool.
In <CITE>Conference Record of the 1982 ACM Symposium on Lisp and
  Functional Programming</CITE>, pages 114--122.

<DT><A NAME="BIB67">[REES84]</A>
<DD>
<A NAME="IDX815"></A>
Jonathan A. Rees, Norman I. Adams IV, and James R. Meehan.
The T manual, fourth edition.
Yale University Computer Science Department, January 1984.

<DT><A NAME="BIB68">[R3RS]</A>
<DD>
<A NAME="IDX816"></A>
Jonathan Rees and William Clinger, editors.
The revised(3) report on the algorithmic language Scheme.
In <CITE>ACM SIGPLAN Notices</CITE> 21(12), pages 37--79, December 1986.

Available as
<A HREF="ftp://ftp-swiss.ai.mit.edu/pub/scheme-reports/r3rs.tar">
r3rs.tar
</A> (LaTeX files).

<DT><A NAME="BIB69">[R4RS]</A>
<DD>
<A NAME="IDX817"></A>
William Clinger and Jonathan Rees, Editors.
Revised(4) Report on the Algorithmic Language Scheme.
In <CITE>ACM Lisp Pointers IV</CITE> (July-September 1991).

Available as
<A HREF="ftp://ftp-swiss.ai.mit.edu/pub/scheme-reports/r4rs.dvi">
r4rs.dvi
</A>,
<A HREF="ftp://ftp-swiss.ai.mit.edu/pub/scheme-reports/r4rs.dvi.Z">
r4rs.dvi.Z
</A>,
<A HREF="ftp://ftp-swiss.ai.mit.edu/pub/scheme-reports/r4rs.ps">
r4rs.ps
</A>,
<A HREF="ftp://ftp-swiss.ai.mit.edu/pub/scheme-reports/r4rs.ps.Z">
r4rs.ps.Z
</A>, or
<A HREF="ftp://ftp-swiss.ai.mit.edu/pub/scheme-reports/r4rs.tar">
r4rs.tar
</A> or
<A HREF="ftp://ftp-swiss.ai.mit.edu/pub/scheme-reports/r4rs.tar.Z">
r4rs.tar.Z
</A> (LaTeX files).

<DT><A NAME="BIB70">[REYNOLDS72]</A>
<DD>
<A NAME="IDX818"></A>
John Reynolds.
Definitional interpreters for higher order programming languages.
In <CITE>ACM Conference Proceedings</CITE>, pages 717--740.
ACM,
 1972.

<DT><A NAME="BIB71">[ROZAS84]</A>
<DD>
<A NAME="IDX819"></A>
Guillermo J. Rozas.
Liar, an Algol-like compiler for Scheme.
S. B. thesis, MIT Department of Electrical Engineering and Computer
  Science, January 1984.

<DT><A NAME="BIB72">[SCHFLOW]</A>
<DD>
<A NAME="IDX820"></A>
Olin Shivers.
Control flow analysis in Scheme.
<CITE>Proceedings of the SIGPLAN 1988 Conference on
  Programming Language Design and Implementation</CITE>, pages 164--174.
Proceedings published as <CITE>SIGPLAN Notices</CITE> 23(7), July 1988.

<DT><A NAME="BIB73">[SITARAM90]</A>
<DD>
<A NAME="IDX821"></A>
Dorai Sitaram and Matthias Felleisen.
Control delimiters and their hierarchies.
<CITE>Lisp and Symbolic Computation</CITE> 3(1):67--99, January 1990.

<DT><A NAME="BIB74">[SMITH84]</A>
<DD>
<A NAME="IDX822"></A>
Brian C. Smith.
Reflection and semantics in a procedural language.
MIT Laboratory for Computer Science Technical Report 272, January 1982.

<DT><A NAME="BIB75">[SPRINGER89]</A>
<DD>
<A NAME="IDX823"></A>
George Springer and Daniel P. Friedman.
<CITE>Scheme and the Art of Programming.</CITE>
MIT Press and McGraw-Hill, 1989.

<DT><A NAME="BIB76">[SRIVASTAVA85]</A>
<DD>
<A NAME="IDX824"></A>
Amitabh Srivastava, Don Oxley, and Aditya Srivastava.
An(other) integration of logic and functional programming.
In <CITE>Proceedings of the Symposium on Logic Programming</CITE>, pages 254--260.
IEEE, 1985.

<DT><A NAME="BIB77">[STALLMAN80]</A>
<DD>
<A NAME="IDX825"></A>
Richard M. Stallman.
Phantom stacks--if you look too hard, they aren't there.
MIT Artificial Intelligence Memo 556, July 1980.

<DT><A NAME="BIB78">[DECLARATIVE]</A>
<DD>
<A NAME="IDX826"></A>
Guy Lewis Steele Jr.
Lambda, the ultimate declarative.
MIT Artificial Intelligence Memo 379, November 1976.

<DT><A NAME="BIB79">[DEBUNKING]</A>
<DD>
<A NAME="IDX827"></A>
Guy Lewis Steele Jr.
Debunking the "expensive procedure call" myth, or procedure call
  implementations considered harmful, or lambda, the ultimate GOTO.
In <CITE>ACM Conference Proceedings</CITE>, pages 153--162.
ACM, 1977.

<DT><A NAME="BIB80">[MACARONI]</A>
<DD>
<A NAME="IDX828"></A>
Guy Lewis Steele Jr.
Macaroni is better than spaghetti.
In <CITE>Proceedings of the Symposium on Artificial Intelligence and
  Programming Languages</CITE>, pages 60--66.
These proceedings were published as a special joint issue of
  <CITE>SIGPLAN Notices</CITE> 12(8) and <CITE>SIGART Newsletter</CITE> 64, August
  1977.

<DT><A NAME="BIB81">[RABBIT]</A>
<DD>
<A NAME="IDX829"></A>
Guy Lewis Steele Jr.
Rabbit: a compiler for Scheme.
MIT Artificial Intelligence Laboratory Technical Report 474, May 1978.

<DT><A NAME="BIB82">[RENAMEGOTO]</A>
<DD>
<A NAME="IDX830"></A>
Guy Lewis Steele Jr.
Compiler optimization based on viewing LAMBDA as RENAME + GOTO.
In <CITE>AI: An MIT Perspective.</CITE>
Patrick Henry Winston Richard Henry Brown, editor.
MIT Press, 1980.

<DT><A NAME="BIB83">[CLOVERVIEW]</A>
<DD>
<A NAME="IDX831"></A>
Guy Lewis Steele Jr.
An overview of Common Lisp.
In <CITE>Conference Record of the 1982 ACM Symposium on Lisp and
  Functional Programming</CITE>, pages 98--107.

<DT><A NAME="BIB84">[CLTL]</A>
<DD>
<A NAME="IDX832"></A>
Guy Lewis Steele Jr.
<CITE>Common Lisp: The Language.</CITE>
Digital Press, Burlington MA, 1984.

<DT><A NAME="BIB85">[IMPERATIVE]</A>
<DD>
<A NAME="IDX833"></A>
Guy Lewis Steele Jr. and Gerald Jay Sussman.
Lambda, the ultimate imperative.
MIT Artificial Intelligence Memo 353, March 1976.

<DT><A NAME="BIB86">[SCHEME78]</A>
<DD>
<A NAME="IDX834"></A>
Guy Lewis Steele Jr. and Gerald Jay Sussman.
The revised report on Scheme, a dialect of Lisp.
MIT Artificial Intelligence Memo 452, January 1978.

<DT><A NAME="BIB87">[TAOTI]</A>
<DD>
<A NAME="IDX835"></A>
Guy Lewis Steele Jr. and Gerald Jay Sussman.
The art of the interpreter, or the modularity complex (parts zero, one,
  and two).
MIT Artificial Intelligence Memo 453, May 1978.

<DT><A NAME="BIB88">[DOALBP]</A>
<DD>
<A NAME="IDX836"></A>
Guy Lewis Steele Jr. and Gerald Jay Sussman.
Design of a Lisp-based processor.
<CITE>Communications of the ACM</CITE> 23(11):628--645, November 1980.

<DT><A NAME="BIB89">[DREAM]</A>
<DD>
<A NAME="IDX837"></A>
Guy Lewis Steele Jr. and Gerald Jay Sussman.
The dream of a lifetime: a lazy variable extent mechanism.
In <CITE>Conference Record of the 1980 Lisp Conference</CITE>, pages 163--172.
Proceedings reprinted by ACM.

<DT><A NAME="BIB90">[HOWTOPRINT]</A>
<DD>
<A NAME="IDX838"></A>
Guy Lewis Steele Jr. and Jon L White.
How to print floating point numbers accurately.
In <CITE>Proceedings of the ACM SIGPLAN '90 Conference
  on Programming Language Design and Implementation</CITE>, pages 112--126.
Proceedings published as <CITE>SIGPLAN Notices</CITE> 25(6), June 1990.

<DT><A NAME="BIB91">[SUSSMAN82]</A>
<DD>
<A NAME="IDX839"></A>
Gerald Jay Sussman.
Lisp, programming and implementation.
In <CITE>Functional Programming and its Applications.</CITE>
Darlington, Henderson, Turner, editor.
Cambridge University Press, 1982.

<DT><A NAME="BIB92">[SCHEME75]</A>
<DD>
<A NAME="IDX840"></A>
Gerald Jay Sussman and Guy Lewis Steele Jr.
Scheme: an interpreter for extended lambda calculus.
MIT Artificial Intelligence Memo 349, December 1975.

<DT><A NAME="BIB93">[SCHEME79]</A>
<DD>
<A NAME="IDX841"></A>
Gerald Jay Sussman, Jack Holloway, Guy Lewis Steele Jr., and Alan Bell.
Scheme-79--Lisp on a chip.
<CITE>IEEE Computer</CITE> 14(7):10--21, July 1981.

<DT><A NAME="BIB94">[STOY77]</A>
<DD>
<A NAME="IDX842"></A>
Joseph E. Stoy.
<CITE>Denotational Semantics: The Scott-Strachey Approach to
  Programming Language Theory.</CITE>
MIT Press, Cambridge, 1977.

<DT><A NAME="BIB95">[TI85]</A>
<DD>
<A NAME="IDX843"></A>
Texas Instruments, Inc.
<CITE>TI Scheme Language Reference Manual.</CITE>
Preliminary version 1.0, November 1985.

<DT><A NAME="BIB96">[VEGDAHL89]</A>
<DD>
<A NAME="IDX844"></A>
Steven R. Vegdahl and Uwe F. Pleban.
The runtime environment for Screme, a Scheme implementation on the 88000.
In <CITE>Proceedings of the Third International Conference on Architectural
  Support for Programming Languages and Operating Systems</CITE>,
  pages 172--182, April 1989.

<DT><A NAME="BIB97">[WAND78]</A>
<DD>
<A NAME="IDX845"></A>
Mitchell Wand.
Continuation-based program transformation strategies.
<CITE>Journal of the ACM</CITE> 27(1):174--180, 1978.

<DT><A NAME="BIB98">[WAND80]</A>
<DD>
<A NAME="IDX846"></A>
Mitchell Wand.
Continuation-based multiprocessing.
In <CITE>Conference Record of the 1980 Lisp Conference</CITE>, pages 19--28.
Proceedings available from ACM.

<DT><A NAME="BIB99">[WAND86]</A>
<DD>
<A NAME="IDX847"></A>
Mitchell Wand.
<CITE>Finding the source of type errors.</CITE>
In <CITE>Conference Record of the Thirteenth Annual Symposium on
  Principles of Programming Languages</CITE>, pages 38--43, 1986.

<DT><A NAME="BIB100">[TOWER]</A>
<DD>
<A NAME="IDX848"></A>
Mitchell Wand.
The mystery of the tower revealed: a non-reflective description of the reflective tower.
In <CITE>Proceedings of the 1986 ACM Symposium on LISP and Functional
  Programming</CITE>, pages 298--307, August 1986.

<DT><A NAME="BIB101">[WAND78]</A>
<DD>
<A NAME="IDX849"></A>
Mitchell Wand and Daniel P. Friedman.
Compiling lambda expressions using continuations and factorizations.
<CITE>Journal of Computer Languages</CITE> 3:241--263, 1978.

<DT><A NAME="BIB102">[WAND88]</A>
<DD>
<A NAME="IDX850"></A>
Mitchell Wand and Daniel P. Friedman.
The mystery of the tower revealed: a non-reflective description of the
  reflective tower.
In <CITE>Meta-Level Architectures and Reflection</CITE>, pages 111--134.
P. Maes and D. Nardi, editor.
Elsevier Sci. Publishers B.V. (North Holland), 1988.

</DL>



<H1><A NAME="SEC87" HREF="r4rs_toc.html#SEC87">Alphabetic index of definitions of concepts, keywords, and procedures</A></H1>



<H2><A NAME="SEC88" HREF="r4rs_toc.html#SEC88">Concepts</A></H2>
<P>
<H2>a</H2>
<DIR>
<LI><A HREF="r4rs.html#IDX140">at-sign</A>
</DIR>
<H2>b</H2>
<DIR>
<LI><A HREF="r4rs.html#IDX137">backquote</A>
<LI><A HREF="r4rs.html#IDX30">binding</A>
<LI><A HREF="r4rs.html#IDX31">binding construct</A>
<LI><A HREF="r4rs.html#IDX37">bound</A>
</DIR>
<H2>c</H2>
<DIR>
<LI><A HREF="r4rs.html#IDX66">call</A>
<LI><A HREF="r4rs.html#IDX70">combination</A>
<LI><A HREF="r4rs.html#IDX138">comma</A>
<LI><A HREF="r4rs.html#IDX659">comment</A>
<LI><A HREF="r4rs.html#IDX64">constant</A>
</DIR>
<H2>d</H2>
<DIR>
<LI><A HREF="r4rs.html#IDX148">definition</A>
<LI><A HREF="r4rs.html#IDX558">Delayed evaluation</A>
</DIR>
<H2>e</H2>
<DIR>
<LI><A HREF="r4rs.html#IDX262">empty list</A>
<LI><A HREF="r4rs.html#IDX3">error</A>
<LI><A HREF="r4rs.html#IDX564">escape procedure</A>
<LI><A HREF="r4rs.html#IDX191">exact</A>
<LI><A HREF="r4rs.html#IDX317">exactness</A>
</DIR>
<H2>f</H2>
<DIR>
<LI><A HREF="r4rs.html#IDX175">false</A>
</DIR>
<H2>h</H2>
<DIR>
<LI><A HREF="r4rs.html#IDX732">hygienic</A>
</DIR>
<H2>i</H2>
<DIR>
<LI><A HREF="r4rs.html#IDX658">identifier</A>
<LI><A HREF="r4rs.html#IDX52">immutable</A>
<LI><A HREF="r4rs.html#IDX320">implementation restriction</A>
<LI><A HREF="r4rs.html#IDX192">inexact</A>
<LI><A HREF="r4rs.html#IDX163">initial environment</A>
<LI><A HREF="r4rs.html#IDX159">internal definition</A>
</DIR>
<H2>k</H2>
<DIR>
<LI><A HREF="r4rs.html#IDX731">keyword</A>
</DIR>
<H2>l</H2>
<DIR>
<LI><A HREF="r4rs.html#IDX32">lambda expression</A>
<LI><A HREF="r4rs.html#IDX45">location</A>
</DIR>
<H2>m</H2>
<DIR>
<LI><A HREF="r4rs.html#IDX725">macro</A>
<LI><A HREF="r4rs.html#IDX728">macro keyword</A>
<LI><A HREF="r4rs.html#IDX730">macro transformer</A>
<LI><A HREF="r4rs.html#IDX729">macro use</A>
<LI><A HREF="r4rs.html#IDX51">mutable</A>
</DIR>
<H2>n</H2>
<DIR>
<LI><A HREF="r4rs.html#IDX310">number</A>
<LI><A HREF="r4rs.html#IDX311">numerical types</A>
</DIR>
<H2>o</H2>
<DIR>
<LI><A HREF="r4rs.html#IDX1">object</A>
</DIR>
<H2>p</H2>
<DIR>
<LI><A HREF="r4rs.html#IDX575">port</A>
<LI><A HREF="r4rs.html#IDX67">procedure call</A>
<LI><A HREF="r4rs.html#IDX549">promise</A>
</DIR>
<H2>r</H2>
<DIR>
<LI><A HREF="r4rs.html#IDX733">referentially transparent</A>
<LI><A HREF="r4rs.html#IDX124">region</A>
</DIR>
<H2>s</H2>
<DIR>
<LI><A HREF="r4rs.html#IDX402">simplest rational</A>
<LI><A HREF="r4rs.html#IDX726">syntactic keyword</A>
</DIR>
<H2>t</H2>
<DIR>
<LI><A HREF="r4rs.html#IDX657">token</A>
<LI><A HREF="r4rs.html#IDX164">top level environment</A>
<LI><A HREF="r4rs.html#IDX174">true</A>
<LI><A HREF="r4rs.html#IDX44">type</A>
</DIR>
<H2>u</H2>
<DIR>
<LI><A HREF="r4rs.html#IDX153">unbound</A>
<LI><A HREF="r4rs.html#IDX5">unspecified</A>
</DIR>
<H2>v</H2>
<DIR>
<LI><A HREF="r4rs.html#IDX520">valid indexes</A>
<LI><A HREF="r4rs.html#IDX662">variable</A>
</DIR>

</P>


<H2><A NAME="SEC89" HREF="r4rs_toc.html#SEC89">Keywords</A></H2>
<P>
<H2>!</H2>
<DIR>
<LI><A HREF="r4rs.html#IDX12">!</A>
</DIR>
<H2>#</H2>
<DIR>
<LI><A HREF="r4rs.html#IDX665">#b</A>
<LI><A HREF="r4rs.html#IDX331">#d</A>
<LI><A HREF="r4rs.html#IDX664">#e</A>
<LI><A HREF="r4rs.html#IDX168">#f</A>
<LI><A HREF="r4rs.html#IDX663">#i</A>
<LI><A HREF="r4rs.html#IDX666">#o</A>
<LI><A HREF="r4rs.html#IDX167">#t</A>
<LI><A HREF="r4rs.html#IDX667">#x</A>
</DIR>
<H2>'</H2>
<DIR>
<LI><A HREF="r4rs.html#IDX235">'</A>
</DIR>
<H2>,</H2>
<DIR>
<LI><A HREF="r4rs.html#IDX236">,</A>
<LI><A HREF="r4rs.html#IDX237">,@</A>
</DIR>
<H2>-</H2>
<DIR>
<LI><A HREF="r4rs.html#IDX14">-&#62;</A>
</DIR>
<H2>;</H2>
<DIR>
<LI><A HREF="r4rs.html#IDX25">;</A>
</DIR>
<H2>=</H2>
<DIR>
<LI><A HREF="r4rs.html#IDX84">=&#62;</A>
</DIR>
<H2>?</H2>
<DIR>
<LI><A HREF="r4rs.html#IDX11">?</A>
</DIR>
<H2>`</H2>
<DIR>
<LI><A HREF="r4rs.html#IDX143">`</A>
</DIR>
<H2>d</H2>
<DIR>
<LI><A HREF="r4rs.html#IDX149">define</A>
</DIR>
<H2>e</H2>
<DIR>
<LI><A HREF="r4rs.html#IDX89">else</A>
</DIR>


<H2><A NAME="SEC90" HREF="r4rs_toc.html#SEC90">Procedures</A></H2>
<P>
<H2>'</H2>
<DIR>
<LI><A HREF="r4rs.html#IDX58">'&#38;#60;datum&#38;#62;</A>
</DIR>
<H2>*</H2>
<DIR>
<LI><A HREF="r4rs.html#IDX708">*</A>
</DIR>
<H2>+</H2>
<DIR>
<LI><A HREF="r4rs.html#IDX709">+</A>
</DIR>
<H2>-</H2>
<DIR>
<LI><A HREF="r4rs.html#IDX707">-</A>
</DIR>
<H2>.</H2>
<DIR>
<LI><A HREF="r4rs.html#IDX20">...</A>
</DIR>
<H2>/</H2>
<DIR>
<LI><A HREF="r4rs.html#IDX710">/</A>
</DIR>
<H2>&#60;</H2>
<DIR>
<LI><A HREF="r4rs.html#IDX714">&#60;</A>
<LI><A HREF="r4rs.html#IDX352">&#38;#60;</A>
<LI><A HREF="r4rs.html#IDX475">&#60;=</A>
<LI><A HREF="r4rs.html#IDX354">&#38;#60;=</A>
<LI><A HREF="r4rs.html#IDX59">&#38;#60;constant&#38;#62;</A>
<LI><A HREF="r4rs.html#IDX65">&#38;#60;operator&#38;#62;</A>
<LI><A HREF="r4rs.html#IDX54">&#38;#60;variable&#38;#62;</A>
</DIR>
<H2>=</H2>
<DIR>
<LI><A HREF="r4rs.html#IDX716">=</A>
</DIR>
<H2>&#62;</H2>
<DIR>
<LI><A HREF="r4rs.html#IDX713">&#62;</A>
<LI><A HREF="r4rs.html#IDX353">&#38;#62;</A>
<LI><A HREF="r4rs.html#IDX712">&#62;=</A>
<LI><A HREF="r4rs.html#IDX355">&#38;#62;=</A>
</DIR>
<H2>`</H2>
<DIR>
<LI><A HREF="r4rs.html#IDX136">`</A>
</DIR>
<H2>a</H2>
<DIR>
<LI><A HREF="r4rs.html#IDX433">abs</A>
<LI><A HREF="r4rs.html#IDX414">acos</A>
<LI><A HREF="r4rs.html#IDX704">and</A>
<LI><A HREF="r4rs.html#IDX429">angle</A>
<LI><A HREF="r4rs.html#IDX711">append</A>
<LI><A HREF="r4rs.html#IDX541">apply</A>
<LI><A HREF="r4rs.html#IDX700">approximate</A>
<LI><A HREF="r4rs.html#IDX415">asin</A>
<LI><A HREF="r4rs.html#IDX294">assoc</A>
<LI><A HREF="r4rs.html#IDX290">assq</A>
<LI><A HREF="r4rs.html#IDX291">assv</A>
<LI><A HREF="r4rs.html#IDX416">atan</A>
</DIR>
<H2>b</H2>
<DIR>
<LI><A HREF="r4rs.html#IDX690">begin</A>
<LI><A HREF="r4rs.html#IDX679">boolean?</A>
<LI><A HREF="r4rs.html#IDX742">bound-identifier=?</A>
</DIR>
<H2>c</H2>
<DIR>
<LI><A HREF="r4rs.html#IDX254">caar</A>
<LI><A HREF="r4rs.html#IDX260">caddr</A>
<LI><A HREF="r4rs.html#IDX255">cadr</A>
<LI><A HREF="r4rs.html#IDX580">call-with-current-continuation</A>
<LI><A HREF="r4rs.html#IDX582">call-with-input-file</A>
<LI><A HREF="r4rs.html#IDX581">call-with-output-file</A>
<LI><A HREF="r4rs.html#IDX574">call/cc</A>
<LI><A HREF="r4rs.html#IDX259">car</A>
<LI><A HREF="r4rs.html#IDX705">case</A>
<LI><A HREF="r4rs.html#IDX572">catch</A>
<LI><A HREF="r4rs.html#IDX6"><VAR>category</VAR>}</A>
<LI><A HREF="r4rs.html#IDX256">cdddar</A>
<LI><A HREF="r4rs.html#IDX257">cddddr</A>
<LI><A HREF="r4rs.html#IDX560">cdr</A>
<LI><A HREF="r4rs.html#IDX395">ceiling</A>
<LI><A HREF="r4rs.html#IDX472">char-&#62;integer</A>
<LI><A HREF="r4rs.html#IDX469">char-&#38;#62;integer</A>
<LI><A HREF="r4rs.html#IDX464">char-alphabetic?</A>
<LI><A HREF="r4rs.html#IDX461">char-ci&#38;#60;=?</A>
<LI><A HREF="r4rs.html#IDX459">char-ci&#38;#60;?</A>
<LI><A HREF="r4rs.html#IDX458">char-ci=?</A>
<LI><A HREF="r4rs.html#IDX462">char-ci&#38;#62;=?</A>
<LI><A HREF="r4rs.html#IDX460">char-ci&#38;#62;?</A>
<LI><A HREF="r4rs.html#IDX480">char-downcase</A>
<LI><A HREF="r4rs.html#IDX468">char-lower-case?</A>
<LI><A HREF="r4rs.html#IDX465">char-numeric?</A>
<LI><A HREF="r4rs.html#IDX620">char-ready</A>
<LI><A HREF="r4rs.html#IDX625">char-ready?</A>
<LI><A HREF="r4rs.html#IDX479">char-upcase</A>
<LI><A HREF="r4rs.html#IDX467">char-upper-case?</A>
<LI><A HREF="r4rs.html#IDX466">char-whitespace?</A>
<LI><A HREF="r4rs.html#IDX474">char&#60;=?</A>
<LI><A HREF="r4rs.html#IDX456">char&#38;#60;=?</A>
<LI><A HREF="r4rs.html#IDX505">char&#60;?</A>
<LI><A HREF="r4rs.html#IDX454">char&#38;#60;?</A>
<LI><A HREF="r4rs.html#IDX463">char=?</A>
<LI><A HREF="r4rs.html#IDX457">char&#38;#62;=?</A>
<LI><A HREF="r4rs.html#IDX455">char&#38;#62;?</A>
<LI><A HREF="r4rs.html#IDX683">char?</A>
<LI><A HREF="r4rs.html#IDX597">close-input-port</A>
<LI><A HREF="r4rs.html#IDX598">close-output-port</A>
<LI><A HREF="r4rs.html#IDX346">complex?</A>
<LI><A HREF="r4rs.html#IDX171">cond</A>
<LI><A HREF="r4rs.html#IDX245">cons</A>
<LI><A HREF="r4rs.html#IDX746">construct-identifier</A>
<LI><A HREF="r4rs.html#IDX406">cos</A>
<LI><A HREF="r4rs.html#IDX650">current-input-port</A>
<LI><A HREF="r4rs.html#IDX649">current-output-port</A>
</DIR>
<H2>d</H2>
<DIR>
<LI><A HREF="r4rs.html#IDX338">d</A>
<LI><A HREF="r4rs.html#IDX155">define</A>
<LI><A HREF="r4rs.html#IDX736">define-syntax</A>
<LI><A HREF="r4rs.html#IDX553">delay</A>
<LI><A HREF="r4rs.html#IDX389">denominator</A>
<LI><A HREF="r4rs.html#IDX638">display</A>
<LI><A HREF="r4rs.html#IDX689">do</A>
</DIR>
<H2>e</H2>
<DIR>
<LI><A HREF="r4rs.html#IDX339">e</A>
<LI><A HREF="r4rs.html#IDX616">eof-object?</A>
<LI><A HREF="r4rs.html#IDX286">eq?</A>
<LI><A HREF="r4rs.html#IDX517">equal?</A>
<LI><A HREF="r4rs.html#IDX691">eqv?</A>
<LI><A HREF="r4rs.html#IDX362">even?</A>
<LI><A HREF="r4rs.html#IDX437">exact-&#62;inexact</A>
<LI><A HREF="r4rs.html#IDX435">exact-&#38;#62;inexact</A>
<LI><A HREF="r4rs.html#IDX349">exact?</A>
<LI><A HREF="r4rs.html#IDX403">exp</A>
<LI><A HREF="r4rs.html#IDX418">expt</A>
</DIR>
<H2>f</H2>
<DIR>
<LI><A HREF="r4rs.html#IDX335">f</A>
<LI><A HREF="r4rs.html#IDX394">floor</A>
<LI><A HREF="r4rs.html#IDX16">FOO</A>
<LI><A HREF="r4rs.html#IDX142">foo</A>
<LI><A HREF="r4rs.html#IDX717">for-each</A>
<LI><A HREF="r4rs.html#IDX696">force</A>
<LI><A HREF="r4rs.html#IDX741">free-identifier=?</A>
</DIR>
<H2>g</H2>
<DIR>
<LI><A HREF="r4rs.html#IDX386">gcd</A>
<LI><A HREF="r4rs.html#IDX200">gen-counter</A>
<LI><A HREF="r4rs.html#IDX201">gen-loser</A>
<LI><A HREF="r4rs.html#IDX745">generate-identifier</A>
</DIR>
<H2>i</H2>
<DIR>
<LI><A HREF="r4rs.html#IDX743">identifier-&#38;#62;symbol</A>
<LI><A HREF="r4rs.html#IDX739">identifier?</A>
<LI><A HREF="r4rs.html#IDX669">if</A>
<LI><A HREF="r4rs.html#IDX427">imag-part</A>
<LI><A HREF="r4rs.html#IDX436">inexact-&#38;#62;exact</A>
<LI><A HREF="r4rs.html#IDX438">inexact-&#62;exact</A>
<LI><A HREF="r4rs.html#IDX350">inexact?</A>
<LI><A HREF="r4rs.html#IDX583">input-port?</A>
<LI><A HREF="r4rs.html#IDX695">integer-&#62;char</A>
<LI><A HREF="r4rs.html#IDX470">integer-&#38;#62;char</A>
<LI><A HREF="r4rs.html#IDX344">integer?</A>
<LI><A HREF="r4rs.html#IDX724">integrate-system</A>
</DIR>
<H2>l</H2>
<DIR>
<LI><A HREF="r4rs.html#IDX337">l</A>
<LI><A HREF="r4rs.html#IDX688">lambda</A>
<LI><A HREF="r4rs.html#IDX154">Lambda expressions</A>
<LI><A HREF="r4rs.html#IDX699">last-pair</A>
<LI><A HREF="r4rs.html#IDX387">lcm</A>
<LI><A HREF="r4rs.html#IDX322">length</A>
<LI><A HREF="r4rs.html#IDX686">let</A>
<LI><A HREF="r4rs.html#IDX157">let*</A>
<LI><A HREF="r4rs.html#IDX687">letrec</A>
<LI><A HREF="r4rs.html#IDX525">list</A>
<LI><A HREF="r4rs.html#IDX512">list-&#38;#62;string</A>
<LI><A HREF="r4rs.html#IDX515">list-&#62;string</A>
<LI><A HREF="r4rs.html#IDX535">list-&#62;vector</A>
<LI><A HREF="r4rs.html#IDX533">list-&#38;#62;vector</A>
<LI><A HREF="r4rs.html#IDX271">list-ref</A>
<LI><A HREF="r4rs.html#IDX270">list-tail</A>
<LI><A HREF="r4rs.html#IDX702">list?</A>
<LI><A HREF="r4rs.html#IDX652">load</A>
<LI><A HREF="r4rs.html#IDX412">log</A>
</DIR>
<H2>m</H2>
<DIR>
<LI><A HREF="r4rs.html#IDX434">magnitude</A>
<LI><A HREF="r4rs.html#IDX425">make-polar</A>
<LI><A HREF="r4rs.html#IDX556">make-promise</A>
<LI><A HREF="r4rs.html#IDX426">make-rectangular</A>
<LI><A HREF="r4rs.html#IDX485">make-string</A>
<LI><A HREF="r4rs.html#IDX523">make-vector</A>
<LI><A HREF="r4rs.html#IDX722">map</A>
<LI><A HREF="r4rs.html#IDX723">map-streams</A>
<LI><A HREF="r4rs.html#IDX366">max</A>
<LI><A HREF="r4rs.html#IDX292">member</A>
<LI><A HREF="r4rs.html#IDX295">memq</A>
<LI><A HREF="r4rs.html#IDX672">memv</A>
<LI><A HREF="r4rs.html#IDX365">min</A>
<LI><A HREF="r4rs.html#IDX385">modulo</A>
</DIR>
<H2>n</H2>
<DIR>
<LI><A HREF="r4rs.html#IDX360">negative?</A>
<LI><A HREF="r4rs.html#IDX641">newline</A>
<LI><A HREF="r4rs.html#IDX697">nil</A>
<LI><A HREF="r4rs.html#IDX178">not</A>
<LI><A HREF="r4rs.html#IDX263">null?</A>
<LI><A HREF="r4rs.html#IDX440">number-&#38;#62;string</A>
<LI><A HREF="r4rs.html#IDX694">number-&#62;string</A>
<LI><A HREF="r4rs.html#IDX685">number?</A>
<LI><A HREF="r4rs.html#IDX388">numerator</A>
</DIR>
<H2>o</H2>
<DIR>
<LI><A HREF="r4rs.html#IDX361">odd?</A>
<LI><A HREF="r4rs.html#IDX595">open-input-file</A>
<LI><A HREF="r4rs.html#IDX596">open-output-file</A>
<LI><A HREF="r4rs.html#IDX703">or</A>
<LI><A HREF="r4rs.html#IDX584">output-port?</A>
</DIR>
<H2>p</H2>
<DIR>
<LI><A HREF="r4rs.html#IDX678">pair?</A>
<LI><A HREF="r4rs.html#IDX701">peek-char</A>
<LI><A HREF="r4rs.html#IDX359">positive?</A>
<LI><A HREF="r4rs.html#IDX684">procedure?</A>
</DIR>
<H2>q</H2>
<DIR>
<LI><A HREF="r4rs.html#IDX706">quasiquote</A>
<LI><A HREF="r4rs.html#IDX238">quote</A>
<LI><A HREF="r4rs.html#IDX381">quotient</A>
</DIR>
<H2>r</H2>
<DIR>
<LI><A HREF="r4rs.html#IDX345">rational?</A>
<LI><A HREF="r4rs.html#IDX692">rationalize</A>
<LI><A HREF="r4rs.html#IDX668">read</A>
<LI><A HREF="r4rs.html#IDX621">read-char</A>
<LI><A HREF="r4rs.html#IDX428">real-part</A>
<LI><A HREF="r4rs.html#IDX347">real?</A>
<LI><A HREF="r4rs.html#IDX384">remainder</A>
<LI><A HREF="r4rs.html#IDX570">return</A>
<LI><A HREF="r4rs.html#IDX268">reverse</A>
<LI><A HREF="r4rs.html#IDX398">round</A>
<LI><A HREF="r4rs.html#IDX721">runge-Kutta-4</A>
</DIR>
<H2>s</H2>
<DIR>
<LI><A HREF="r4rs.html#IDX336">s</A>
<LI><A HREF="r4rs.html#IDX119">sequence</A>
<LI><A HREF="r4rs.html#IDX671">set!</A>
<LI><A HREF="r4rs.html#IDX251">set-car!</A>
<LI><A HREF="r4rs.html#IDX253">set-cdr!</A>
<LI><A HREF="r4rs.html#IDX405">sin</A>
<LI><A HREF="r4rs.html#IDX417">sqrt</A>
<LI><A HREF="r4rs.html#IDX486">string</A>
<LI><A HREF="r4rs.html#IDX511">string-&#38;#62;list</A>
<LI><A HREF="r4rs.html#IDX516">string-&#62;list</A>
<LI><A HREF="r4rs.html#IDX444">string-&#38;#62;number</A>
<LI><A HREF="r4rs.html#IDX693">string-&#62;number</A>
<LI><A HREF="r4rs.html#IDX308">string-&#38;#62;symbol</A>
<LI><A HREF="r4rs.html#IDX306">string-&#62;symbol</A>
<LI><A HREF="r4rs.html#IDX510">string-append</A>
<LI><A HREF="r4rs.html#IDX502">string-ci&#38;#60;=?</A>
<LI><A HREF="r4rs.html#IDX500">string-ci&#38;#60;?</A>
<LI><A HREF="r4rs.html#IDX507">string-ci=?</A>
<LI><A HREF="r4rs.html#IDX503">string-ci&#38;#62;=?</A>
<LI><A HREF="r4rs.html#IDX501">string-ci&#38;#62;?</A>
<LI><A HREF="r4rs.html#IDX518">string-copy</A>
<LI><A HREF="r4rs.html#IDX519">string-fill!</A>
<LI><A HREF="r4rs.html#IDX487">string-length</A>
<LI><A HREF="r4rs.html#IDX489">string-ref</A>
<LI><A HREF="r4rs.html#IDX491">string-set!</A>
<LI><A HREF="r4rs.html#IDX498">string&#38;#60;=?</A>
<LI><A HREF="r4rs.html#IDX496">string&#38;#60;?</A>
<LI><A HREF="r4rs.html#IDX504">string&#60;?</A>
<LI><A HREF="r4rs.html#IDX506">string=?</A>
<LI><A HREF="r4rs.html#IDX499">string&#38;#62;=?</A>
<LI><A HREF="r4rs.html#IDX497">string&#38;#62;?</A>
<LI><A HREF="r4rs.html#IDX682">string?</A>
<LI><A HREF="r4rs.html#IDX509">substring</A>
<LI><A HREF="r4rs.html#IDX309">symbol-&#62;string</A>
<LI><A HREF="r4rs.html#IDX303">symbol-&#38;#62;string</A>
<LI><A HREF="r4rs.html#IDX680">symbol?</A>
<LI><A HREF="r4rs.html#IDX738">syntax</A>
<LI><A HREF="r4rs.html#IDX737">syntax-rules</A>
</DIR>
<H2>t</H2>
<DIR>
<LI><A HREF="r4rs.html#IDX698">t</A>
<LI><A HREF="r4rs.html#IDX407">tan</A>
<LI><A HREF="r4rs.html#IDX7">template</A>
<LI><A HREF="r4rs.html#IDX656">transcript-off</A>
<LI><A HREF="r4rs.html#IDX655">transcript-on</A>
<LI><A HREF="r4rs.html#IDX396">truncate</A>
</DIR>
<H2>u</H2>
<DIR>
<LI><A HREF="r4rs.html#IDX240">unquote</A>
<LI><A HREF="r4rs.html#IDX241">unquote-splicing</A>
<LI><A HREF="r4rs.html#IDX740">unwrap-syntax</A>
</DIR>
<H2>v</H2>
<DIR>
<LI><A HREF="r4rs.html#IDX524">vector</A>
<LI><A HREF="r4rs.html#IDX534">vector-&#62;list</A>
<LI><A HREF="r4rs.html#IDX532">vector-&#38;#62;list</A>
<LI><A HREF="r4rs.html#IDX537">vector-fill!</A>
<LI><A HREF="r4rs.html#IDX526">vector-length</A>
<LI><A HREF="r4rs.html#IDX528">vector-ref</A>
<LI><A HREF="r4rs.html#IDX531">vector-set!</A>
<LI><A HREF="r4rs.html#IDX681">vector?</A>
</DIR>
<H2>w</H2>
<DIR>
<LI><A HREF="r4rs.html#IDX594">with-input-from-file</A>
<LI><A HREF="r4rs.html#IDX593">with-output-to-file</A>
<LI><A HREF="r4rs.html#IDX639">write</A>
<LI><A HREF="r4rs.html#IDX644">write-char</A>
</DIR>
<H2>z</H2>
<DIR>
<LI><A HREF="r4rs.html#IDX358">zero?</A>
</DIR>
</BODY>
</HTML>
