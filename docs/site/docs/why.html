<!DOCTYPE html>
<html>
  <head>
    <meta name="generator" content=
	  "HTML Tidy for HTML5 for Linux version 4.9.27">
    <title>Why Should I Use FramerD?</title>
    <link rel="stylesheet" type="text/css" href=
	  "/static/framerd/documentation.css">
  </head>
  <body>
    <h1><img src="fdlogo.png" align="right">Why Should I Use
      FramerD?</h1>
    <h2>FramerD manages descriptions and systems of description</h2>
    <p>FramerD allows the computer to create, access, and manipulate
      descriptions and systems of description. Most computer applications
      work by manipulating descriptions in some systematic way. A system
      of description is the set of conventions, expectations, and
      procedures used to manipulate descriptions in a particular
      application area. For example, in a scheduling application, the
      system of description might specify:</p>
    <ul>
      <li>classes of entities, like events, individuals, locations,
	resources, and times;</li>
      <li>relationships between these entities, like attendance at events
	or reservation of resources</li>
      <li>constraints and inferences about these relationships</li>
    </ul>
    <p>Descriptive systems can be programmed by people or generated by
      machines. In either event, when users or programs add new
      descriptions or extend existing systems, FramerD automatically
      generates consequences from the additions or extensions.</p>
    <h2>FramerD is a database for intelligent systems</h2>
    <p>FramerD was developed to support research in <i>artificial
	intelligence</i> (AI) involving the construction of artifacts which
      demonstrate something like human understanding and intelligence.
      For example, in our current research we use FramerD to encode a
      text database where relations and meanings are used in retrieval
      and matching. Each natural language phrase in the original text
      database is described by a different frame in FramerD; relations
      between these frames descibe both the structure of sentences (e.g.
      "Bush" is the subject of "flew") and possible meanings ("flew"
      might mean "drove the plane" or "rode in the plane"). Taking ideas
      from past work in artificial intelligence, FramerD is built to
      describe conceptual objects and their relationships to one another.
      Unlike this past work, however, FramerD is designed to scale to
      millions or tens of millions of objects.</p>
    <h2>FramerD simplifies development and sharing</h2>
    <p>FramerD was designed to simplify:</p>
    <ul>
      <li>incremental development of systems of description,</li>
      <li>sharing descriptions and systems of description,</li>
      <li>distributing data and computation over a network of clients and
	servers,</li>
      <li>access to descriptions and databases through World Wide
	Web</li>
    </ul>
    <p>If you need to describe complicated and interconnected
      structures and want to be able to store and share these structures,
      it's worthwhile looking at FramerD. In particular, if your work is
      currently (or constitutionally) in "development mode" and
      incremental changes to your database are common, FramerD may be
      what you are looking for.</p>
    <h2>FramerD descriptions can be richly interconnected</h2>
    <p>FramerD is optimized for descriptions consisting primarily of
      relations to other descriptions. Relations between descriptions can
      be either <em>structural relations</em> or <em>semantic
	relations</em>. Structural relations connect elements within a
      particular context, for example</p>
    <ul>
      <li>'this lintel is above that support' or</li>
      <li>'the name "Clinton" (in some context) is the subject of the
	verb "nominated" (in the same context)'.</li>
    </ul>
    <p>Semantic relations, on the other hand, connect a description to
      some "meaning" description elsewhere in the database, for
      example</p>
    <ul>
      <li>`the lintel is a vertical rectangular blob' or</li>
      <li>'the verb "nominated" may denote a kind of selection'.</li>
    </ul>
    <p>Descriptions can also include simple attributes whose values are
      numbers or strings, but FramerD is optimized for the kinds of
      complicated relational structures common in artificial intelligence
      systems. In particular, FramerD has special operations for delayed
      loading and caching of objects which make it inexpensive to load
      objects which refer to other objects.</p>
    <h2>FramerD works on many different kinds of computers</h2>
    <p>The kernel of FramerD functions is quite small and is easily
      ported between platforms and architectures. It has been ported to
      most versions of Unix as well as the major PC operating systems.
      For instance, under Windows, the command line program for accessing
      FramerD services takes less than 125KB (120KB of which is a shared
      library). The entire FramerD script interpreter and libraries are
      under 500KB, including index and object access, inference and
      search facilities, and HTML parsing and generation. For comparison,
      this is substantially smaller than the BASH command shell and its
      associated libraries on the same platform.</p>
    <h2>FramerD databases can be distributed across a network</h2>
    <p>A FramerD database can be maintained on a server, allowing
      clients to access the data without the overhead of a local copy the
      entire database. Likewise, particular functions --- like indexing
      or real-time sensor access --- can be delegated to particular
      servers with particular resources. A FramerD server can also
      locally <i>consolidate</i> or <i>mirror</i> other databases in a
      way which maintains a local cache of references to FramerD
      objects.</p>
    <h2>This manual explains the basic concepts in FramerD</h2>
    <p>Here are pointers to the sections of the document, which you can
      also read linearly. Each section describes a different component of
      FramerD.</p>
    <ul>
      <li><a href="#DTYPES">DTypes</a> are a protocol and external data
	representation used for sharing information between architectures
	and across networks.</li>
      <li><a href="#OBJECTS">OIDs</a> in FramerD can be used to share
	references and changes to DType structures both between different
	programs or among instances of the same program.</li>
      <li><a href="#FRAMES">Frames</a> are an extension of OIDs which
	supports the description of attributes, relations, and inferences
	about attributes and relations.</li>
      <li><a href="#INDICES">Indices</a> support efficiently searching
	for and referring to objects.</li>
      <li><a href="#POOLS">Pools</a> organize the distribution and
	maintenance of databases of FramerD objects.</li>
      <li><a href="#PROGRAMMING">Programming with FramerD</a> is possible
	through many different libraries and environments.</li>
    </ul>
    <hr>
    <h1><a name="DTYPES" id="DTYPES"></a>Dtypes</h1>
    <h2>FramerD uses DTypes as a base representation</h2>
    <p>FramerD is a system and database for describing complicated
      structures and systems to the computer. It is based on a set of
      structures and protocols called DTypes which can represent richly
      interconnected multi-level structures. The basic structures in
      DTypes are directly derived from the Lisp language, but analogs to
      most of them exist (or are easily implemented) in nearly every
      programming language.</p>
    <h2>DTypes are dynamically typed structures</h2>
    <p>DTypes are dynamically typed: when a program refers to a DType
      structure, it does not need to know what kind of structure it is
      referring to. It might be a string, a number, a vector of strings
      and numbers, or a vector of such vectors. This allows programmers
      to write procedures which manipulate data generically without
      regard to its particular representation. Furthermore, because the
      program checks the type of the data it is operating on, it is less
      prone to the accidental or intentional inconsistences of
      improvising or malicous programmers.</p>
    <h2>DTypes are communicable structures</h2>
    <p>DTypes have an external representation which can be easily
      communicated across networks or saved in files. This external
      representation is common to all the software and hardware platforms
      where DTypes are implemented. Memory permitting, a palmtop computer
      running a version of FramerD can transmit a DTYPE structure to a
      multi-processor compute server for processing and receive the
      result of that processing. DTYPEs allow the management of data and
      computation to be divided as technologically or administratively
      appropriate.</p>
    <h2>DTypes are extensible but conservative</h2>
    <p>The external representation of DTypes provides a way for
      applications to package their own internal data types for
      transmission or storage. A transmission or storage facility does
      not need to know the details or purpose of the data's
      implementation in order to receive, store, or transmit it. This
      means that a programmer does not need to change their general tools
      or database format in order to add a new data type to their
      program. It also means that two clients can share data structures
      through a storage or communication facility which need not know the
      data's underlying implementation.</p>
    <hr>
    <h1><a name="OBJECTS" id="OBJECTS"></a>OIDs: Naming Objects</h1>
    <h2>Object identifers provide a simple data store</h2>
    <p>DTypes provide a simple object database which associates numeric
      <b>object identifers</b> (OIDs) with DType structures. DType
      structures can contain these object identifiers so that one DType
      structure can point to the location in the object database where
      another DType structure is stored. A scheme for assigning object
      identifiers ensures (as much as possible) that two structures will
      only use the same object identifier when the are actually referring
      to the same object.</p>
    <h2>Object identifiers allow changes to be shared</h2>
    <p>The chief advantage of using object identifiers to refer to
      structures is that the structures can be changed without having to
      change the references. Because programs operate on these references
      by getting the associated structures, they will always get the
      "latest version" as changed or updated by other programs. For
      example, an object identifier might be used to record some changing
      or accumulating value like the outside temperature or a history of
      such temperatures. More commonly, an object might contain a
      description of attributes and relations where different users or
      processes are modifying and/or updating those attributes or
      relations. Because users (and other objects) go through the object
      reference, these changes are propogated to these users and
      objects.</p>
    <h2>Object identifiers are organized into "pools"</h2>
    <p>Object identifers are 64-bit (8 byte) integers, ranging from
      zero to 18,446,744,073,709,551,616. Needless to say, this allows a
      large number of potential objects. This large range is divided into
      sub-ranges called "pools" used to guarantee that no two users or
      programs use the same object identifer for different purposes. A
      pool is a range of object ids assigned to a particular user,
      project, or program. This entity is responsible for managing the
      identifiers within that pool and no other entity is permitted to
      modify the mapping of the pool's object ids into structures.
      However, the entity (user, project, or program) may choose to
      further subdivide the pool and delegate control over the fragments
      to yet other users or programs.</p>
    <hr>
    <h1><a name="FRAMES" id="FRAMES"></a>Frames</h1>
    <h2>Frames combine attributes and relations</h2>
    <p>A <b>frame</b> is an object identifier whose reference is a set
      of attributes and relations. These attributes and relations are
      implemented as sets of <i>slots</i> and <i>values</i>. Each
      <b>slot</b> is either a symbol (a special kind of string) or
      another frame; for a given frame, the slot is associated with some
      number of particular <b>values</b>, each of which is either a DType
      object or another frame. When the values of a slot point to another
      frame, we say that the slot encodes a <b>relation</b> between the
      frames.</p>
    <p>For example, a biographical database might include frames
      describing particular individuals. The attributes of these frames
      might include literal values like names or dates as well as
      relations to other individuals or more abstract entities (like
      positions or organizations). A fragment of such a database might
      look like this:</p>
    <ul type="disc">
      <li><b><i>Object @55/A3C0</i></b></li>
      <li style="list-style: none; display: inline">
	<ul type="disc">
	  <li><b>name</b>: "George Washington"</li>
	  <li><b>birthdate</b>: February 23</li>
	  <li><b>spouse</b>: @55/55B1"Martha Washington"</li>
	  <li><b>parent</b>: @55/6D35 @55/3331</li>
	</ul>
      </li>
    </ul>
    <p>where the values associated with the spouse and parent slot
      describe the corresponding relations. The cryptic string
      @55/55B1"Martha Washington" refers to an object by both its numeric
      address and its "human name"; many interfaces to FramerD hide the
      numeric identifer (the 55/55b1) from the user, using the human name
      whenever possible.</p>
    <h2>Most operations on frames specify a slot</h2>
    <p>Operations on frames generally also specify a slot to operate
      upon. These operations include:</p>
    <ul>
      <li>getting the value(s) associated with a slot,</li>
      <li>checking whether a particular value is associated with a
	slot,</li>
      <li>associating a new value with a slot (while retaining the
	existing values),</li>
      <li>removing an existing value from the associations of a
	slot.</li>
    </ul>
    <p>For readers familiar with conventional database systems, a frame
      is a kind of record whose fields can contain multiple values,
      including pointers to other frames. Also, because the data language
      is dynamically typed these values need not have a pre-determined
      type. For readers familiar with various diaects of Lisp, frames
      provide (at their basic level) a kind of persistent property list
      facility where object identifiers, rather than symbols, carry the
      associated properties.</p>
    <h2>Slots can easily be added to an object</h2>
    <p>Unlike record structures in conventional languages or databases,
      it is easy to add new slots (fields) to a frame. This allows
      programs and programmers to say something about a particular object
      without having to say something about all similar objects.
      Databases can be constructed incrementally and in pieces, making
      development faster and more flexible. There is a small performance
      penalty for this flexibility, but we have found it more than worth
      the payback in development flexibility. FramerD can be considered
      an "interpreted" database environment, where the structures in the
      database have the same kind of flexibility as functions and
      variables in an interpreted environment.</p>
    <h2>Slots which are objects can have complicated behaviors</h2>
    <p>When a slot is itself a frame, the slot may have a complicated
      behavior. In particular, operations specifying a `slot-frame' may
      trigger <b>attached procedures</b> when values are retrieved,
      examined, or modified. These might compute additional values or
      update other data structures. These attached procedures allow the
      system to automatically make "inferences" based on the data it is
      given; for instance, it might combine the fact that MIT is in
      Cambridge.MA and Cambridge.MA is in the United.States to infer that
      MIT is in the United.States. It would have to be given rules, in
      the form of attached procedures, to infer this fact, but once it
      had received these rules it could make the inference
      automatically.</p>
    <hr>
    <h1><a name="INDICES" id="INDICES"></a>Indices</h1>
    <h2>Indices associate structured "keys" with sets of
      structures</h2>
    <p>An object identifier gives no cues as to the structure
      associated with it. Nonetheless, sometimes we need to identify
      objects based on what their structure actually is. FramerD provides
      <b>indices</b> which associate <b>keys</b> (arbitrary DType
      structures) to sets of other DType structures. For example, an
      index might go from words (represented as strings) to the set of
      descriptions of their possible meanings. Indices can also be used
      to implement relations which are not (for several possible reasons)
      implemented by slots and values. For instance, an index in an email
      system might store a mapping between descriptions of individuals
      and descriptions of the messages you've received from them. It
      might be expensive to update those individual's descriptions
      whenever a new message is received, but indices are designed to
      support small, incremental changes of this sort. Indices can also
      be used for more complicated operations, like pattern matching or
      object retrieval.</p>
    <h2>Indices can be used for searching for frames based on slot
      values</h2>
    <p>Slot indices map slot-value pairs into the objects possessing
      those slot values.</p>
    <hr>
    <h1><a name="POOLS" id="POOLS"></a>Pools</h1>
    <h2>Pools are normally affiliated with files or servers</h2>
    <p>The management of pools is managed through either access to disk
      files (local or remote) or communication with remote FramerD
      servers. Standard operations include allocating a new unique
      identifer, getting the structure associated with an identifer, or
      changing the associated structure. When a file or server manages a
      particular pool, we say that it is the "provider" for the pool. A
      provider may provide only limited or selective access to a pool;
      for instance, some pools may only permit access, not allocation or
      modification, while others may permit allocation or modification
      only in particular ways or to particular clients.</p>
    <h2>Pools can be mirrored and consolidated</h2>
    <p>Pools provided by network servers may actually be copies or
      combinations of other pools. For instance, the official provider
      for the MIT version of WordNet may be a server at MIT; however, a
      site distant from MIT may wish to set up its own server providing a
      copy of the same database. The mirror site cannot be modified, of
      course, but it can provide the information it has gotten as a
      complete or partial snapshot from MIT. (In fact, the server at MIT
      is really a mirror of an internal site and can't be normally
      modified!) Similarly, a server may consolidate several pools into a
      single "point of service". Suppose there were a dozen different
      FramerD servers at site A which are of interest to a remote site.
      That site can set up a single server for processing requests which
      reroutes each request to the appropriate server at site A.
      Mirroring and consolidation become important as networked databases
      become more widely used. Sites with particularly popular databases
      may wish to set up "external mirrors" for the outside world while
      keeping the real "internal" database reserved for their own
      work.</p>
    <h2>Pools are organized into "super pools" administratively</h2>
    <p>Super pools are used to organize the allocation of pools at a
      particular site. A super pool is a pool of roughly 4 billion object
      identifiers sharing the same initial 32 bits of identifier. In the
      64-bit FramerD object identifier address space, there are also
      roughly 4 billion super pools. The first such super pool (the
      "zero" pool) contains objects describing the remaining super pools.
      New pools can be allocated through the "zero pool server"
      (currently at MIT) which can be accessed either directly (through
      DType protocol connections) or through a form on the FramerD web
      page at "http://framerd.www.media.mit.edu/".</p>
    <hr>
    <h1><a name="PROGRAMMING" id="PROGRAMMING">Programming with
	FramerD</a></h1>
    <h2>Programs can use FramerD in many ways</h2>
    <p>FramerD was first designed to allow diverse users at the MIT
      Media Lab to share data, provide lab-wide utilities, etc. As a
      result, access to FramerD was made available from many different
      platforms. Basic libraries allow FramerD data and services to be
      directly accessed from C, Lisp, and Java.</p>
    <p>FramerD includes FDScript, a simple scripting language based on
      <a href="r4rs.html">Scheme</a>. FDScript can be used to write
      command line scripts (it is smaller than many shells), implement
      specialized network servers, or provide World Wide Web (CGI) access
      to FramerD data and services.</p>
    <p>Basic FramerD services are built on the DType protocol and
      libraries for accessing DType services are available in Perl and
      TCL as well as from the command line (with the <a href=
							"commands.html#DTCALL"><tt>dtcall</tt> executable</a>) or from the
      C, Lisp, or Java libraries.</p>
    <h2>C programs can use function libraries to access FramerD</h2>
    <p>C does not natively provide most the datatypes used in FramerD
      structures. Pairs, lists, heterogenous vectors, and interned
      symbols need to be implemented by the C function libraries
      connecting to FramerD. The libraries for accessing FramerD provide
      these data structures, access to th DType protocol, object
      maintenance and caching functions, and the FDScript interpreter.
      Despite this, it is relatively lightweight, as shown in this
      table:</p>
    <center>
      <table border="3">
	<tr>
	  <th rowspan="2">Library</th>
	  <th colspan="4">Binary Library Size</th>
	</tr>
	<tr>
	  <th>WIN32</th>
	  <th>Solaris</th>
	  <th>PowerPC</th>
	  <th>Linux/Alpha</th>
	</tr>
	<tr>
	  <th><font size="+1">dtypes</font><br>
	    <em>data structures, network access</em></th>
	  <td>126K</td>
	  <td></td>
	  <td></td>
	  <td></td>
	</tr>
	<tr>
	  <th><font size="+1">framerd</font><br>
	    <em>object, index, and frame access</em></th>
	  <td>108K</td>
	  <td></td>
	  <td></td>
	  <td></td>
	</tr>
	<tr>
	  <th><font size="+1">fdscript</font><br>
	    <em>R4RS evaluator, inference procedures, etc</em></th>
	  <td>216K</td>
	  <td></td>
	  <td></td>
	  <td></td>
	</tr>
      </table>
    </center>
    The C library is the FramerD reference implementation and is used
    to implement the FramerD server which provides databases or
    functions on the network. Detailed documentation for using the C
    libraries can be found <a href="c-manual.html">here</a>.
    <h2>Lisp or Scheme programs can access FramerD databases</h2>
    <p>LISP already provides most of the native DTYPE structures. The
      FramerD libraries in LISP and Scheme are loaded to provide the same
      level of access as the C libraries, including network access, local
      caching, and FDScript execution.</p>
    <h2>FDScript can be used to write simple FramerD programs</h2>
    <p>FDScript is a lightweight LISP interpreter which incorporates
      the FramerD kernel functions. It is appropriate for casual database
      access, writing command line scripts, and implementing CGI scripts
      for accessing FramerD databases from the World Wide Web. FDScript
      uses a uniform parenthesized syntax for expressions and operations.
      For instance, in the following expression: <tt>(index-get
	"brico@framerd.org" "book")</tt> the operation named
      <tt>INDEX-GET</tt> is being called with two strings as arguments.
      The arguments can also be expressions, so that: <tt>(fget
	(index-get "wn15@wn15" "book") 'senses)</tt> applies the operation
      <tt>FGET</tt> to two arguments: the result of the embedded
      INDEX-GET and the symbol 'senses. (The quote "'" preserves the
      following object from interpretation).</p>
  </body>
</html>
