# ![](fdlogo.png)Why Should I Use Kno?

## Kno manages descriptions and systems of description

Kno allows the computer to create, access, and manipulate descriptions and
systems of description. Most computer applications work by manipulating
descriptions in some systematic way. A system of description is the set of
conventions, expectations, and procedures used to manipulate descriptions in a
particular application area. For example, in a scheduling application, the
system of description might specify:

  * classes of entities, like events, individuals, locations, resources, and times;
  * relationships between these entities, like attendance at events or reservation of resources
  * constraints and inferences about these relationships

Descriptive systems can be programmed by people or generated by machines. In
either event, when users or programs add new descriptions or extend existing
systems, Kno automatically generates consequences from the additions or
extensions.

## Kno is a database for intelligent systems

Kno was developed to support research in _artificial intelligence_ (AI)
involving the construction of artifacts which demonstrate something like human
understanding and intelligence. For example, in our current research we use
Kno to encode a text database where relations and meanings are used in
retrieval and matching. Each natural language phrase in the original text
database is described by a different frame in Kno; relations between these
frames descibe both the structure of sentences (e.g. "Bush" is the subject of
"flew") and possible meanings ("flew" might mean "drove the plane" or "rode in
the plane"). Taking ideas from past work in artificial intelligence, Kno
is built to describe conceptual objects and their relationships to one
another. Unlike this past work, however, Kno is designed to scale to
millions or tens of millions of objects.

## Kno simplifies development and sharing

Kno was designed to simplify:

  * incremental development of systems of description,
  * sharing descriptions and systems of description,
  * distributing data and computation over a network of clients and servers,
  * access to descriptions and databases through World Wide Web

If you need to describe complicated and interconnected structures and want to
be able to store and share these structures, it's worthwhile looking at
Kno. In particular, if your work is currently (or constitutionally) in
"development mode" and incremental changes to your database are common,
Kno may be what you are looking for.

## Kno descriptions can be richly interconnected

Kno is optimized for descriptions consisting primarily of relations to
other descriptions. Relations between descriptions can be either _structural
relations_ or _semantic relations_. Structural relations connect elements
within a particular context, for example

  * 'this lintel is above that support' or
  * 'the name "Clinton" (in some context) is the subject of the verb "nominated" (in the same context)'.

Semantic relations, on the other hand, connect a description to some "meaning"
description elsewhere in the database, for example

  * `the lintel is a vertical rectangular blob' or
  * 'the verb "nominated" may denote a kind of selection'.

Descriptions can also include simple attributes whose values are numbers or
strings, but Kno is optimized for the kinds of complicated relational
structures common in artificial intelligence systems. In particular, Kno
has special operations for delayed loading and caching of objects which make
it inexpensive to load objects which refer to other objects.

## Kno works on many different kinds of computers

The kernel of Kno functions is quite small and is easily ported between
platforms and architectures. It has been ported to most versions of Unix as
well as the major PC operating systems. For instance, under Windows, the
command line program for accessing Kno services takes less than 125KB
(120KB of which is a shared library). The entire Kno script interpreter
and libraries are under 500KB, including index and object access, inference
and search facilities, and HTML parsing and generation. For comparison, this
is substantially smaller than the BASH command shell and its associated
libraries on the same platform.

## Kno databases can be distributed across a network

A Kno database can be maintained on a server, allowing clients to access
the data without the overhead of a local copy the entire database. Likewise,
particular functions --- like indexing or real-time sensor access --- can be
delegated to particular servers with particular resources. A Kno server
can also locally _consolidate_ or _mirror_ other databases in a way which
maintains a local cache of references to Kno objects.

## This manual explains the basic concepts in Kno

Here are pointers to the sections of the document, which you can also read
linearly. Each section describes a different component of Kno.

  * DTypes are a protocol and external data representation used for sharing information between architectures and across networks.
  * OIDs in Kno can be used to share references and changes to DType structures both between different programs or among instances of the same program.
  * Frames are an extension of OIDs which supports the description of attributes, relations, and inferences about attributes and relations.
  * Indices support efficiently searching for and referring to objects.
  * Pools organize the distribution and maintenance of databases of Kno objects.
  * Programming with Kno is possible through many different libraries and environments.

* * *

# Dtypes

## Kno uses DTypes as a base representation

Kno is a system and database for describing complicated structures and
systems to the computer. It is based on a set of structures and protocols
called DTypes which can represent richly interconnected multi-level
structures. The basic structures in DTypes are directly derived from the Lisp
language, but analogs to most of them exist (or are easily implemented) in
nearly every programming language.

## DTypes are dynamically typed structures

DTypes are dynamically typed: when a program refers to a DType structure, it
does not need to know what kind of structure it is referring to. It might be a
string, a number, a vector of strings and numbers, or a vector of such
vectors. This allows programmers to write procedures which manipulate data
generically without regard to its particular representation. Furthermore,
because the program checks the type of the data it is operating on, it is less
prone to the accidental or intentional inconsistences of improvising or
malicous programmers.

## DTypes are communicable structures

DTypes have an external representation which can be easily communicated across
networks or saved in files. This external representation is common to all the
software and hardware platforms where DTypes are implemented. Memory
permitting, a palmtop computer running a version of Kno can transmit a
DTYPE structure to a multi-processor compute server for processing and receive
the result of that processing. DTYPEs allow the management of data and
computation to be divided as technologically or administratively appropriate.

## DTypes are extensible but conservative

The external representation of DTypes provides a way for applications to
package their own internal data types for transmission or storage. A
transmission or storage facility does not need to know the details or purpose
of the data's implementation in order to receive, store, or transmit it. This
means that a programmer does not need to change their general tools or
database format in order to add a new data type to their program. It also
means that two clients can share data structures through a storage or
communication facility which need not know the data's underlying
implementation.

* * *

# OIDs: Naming Objects

## Object identifers provide a simple data store

DTypes provide a simple object database which associates numeric **object
identifers** (OIDs) with DType structures. DType structures can contain these
object identifiers so that one DType structure can point to the location in
the object database where another DType structure is stored. A scheme for
assigning object identifiers ensures (as much as possible) that two structures
will only use the same object identifier when the are actually referring to
the same object.

## Object identifiers allow changes to be shared

The chief advantage of using object identifiers to refer to structures is that
the structures can be changed without having to change the references. Because
programs operate on these references by getting the associated structures,
they will always get the "latest version" as changed or updated by other
programs. For example, an object identifier might be used to record some
changing or accumulating value like the outside temperature or a history of
such temperatures. More commonly, an object might contain a description of
attributes and relations where different users or processes are modifying
and/or updating those attributes or relations. Because users (and other
objects) go through the object reference, these changes are propogated to
these users and objects.

## Object identifiers are organized into "pools"

Object identifers are 64-bit (8 byte) integers, ranging from zero to
18,446,744,073,709,551,616. Needless to say, this allows a large number of
potential objects. This large range is divided into sub-ranges called "pools"
used to guarantee that no two users or programs use the same object identifer
for different purposes. A pool is a range of object ids assigned to a
particular user, project, or program. This entity is responsible for managing
the identifiers within that pool and no other entity is permitted to modify
the mapping of the pool's object ids into structures. However, the entity
(user, project, or program) may choose to further subdivide the pool and
delegate control over the fragments to yet other users or programs.

* * *

# Frames

## Frames combine attributes and relations

A **frame** is an object identifier whose reference is a set of attributes and
relations. These attributes and relations are implemented as sets of _slots_
and _values_. Each **slot** is either a symbol (a special kind of string) or
another frame; for a given frame, the slot is associated with some number of
particular **values** , each of which is either a DType object or another
frame. When the values of a slot point to another frame, we say that the slot
encodes a **relation** between the frames.

For example, a biographical database might include frames describing
particular individuals. The attributes of these frames might include literal
values like names or dates as well as relations to other individuals or more
abstract entities (like positions or organizations). A fragment of such a
database might look like this:

  * **_Object @55/A3C0_**
  *     * **name** : "George Washington"
    * **birthdate** : February 23
    * **spouse** : @55/55B1"Martha Washington"
    * **parent** : @55/6D35 @55/3331

where the values associated with the spouse and parent slot describe the
corresponding relations. The cryptic string @55/55B1"Martha Washington" refers
to an object by both its numeric address and its "human name"; many interfaces
to Kno hide the numeric identifer (the 55/55b1) from the user, using the
human name whenever possible.

## Most operations on frames specify a slot

Operations on frames generally also specify a slot to operate upon. These
operations include:

  * getting the value(s) associated with a slot,
  * checking whether a particular value is associated with a slot,
  * associating a new value with a slot (while retaining the existing values),
  * removing an existing value from the associations of a slot.

For readers familiar with conventional database systems, a frame is a kind of
record whose fields can contain multiple values, including pointers to other
frames. Also, because the data language is dynamically typed these values need
not have a pre-determined type. For readers familiar with various diaects of
Lisp, frames provide (at their basic level) a kind of persistent property list
facility where object identifiers, rather than symbols, carry the associated
properties.

## Slots can easily be added to an object

Unlike record structures in conventional languages or databases, it is easy to
add new slots (fields) to a frame. This allows programs and programmers to say
something about a particular object without having to say something about all
similar objects. Databases can be constructed incrementally and in pieces,
making development faster and more flexible. There is a small performance
penalty for this flexibility, but we have found it more than worth the payback
in development flexibility. Kno can be considered an "interpreted"
database environment, where the structures in the database have the same kind
of flexibility as functions and variables in an interpreted environment.

## Slots which are objects can have complicated behaviors

When a slot is itself a frame, the slot may have a complicated behavior. In
particular, operations specifying a `slot-frame' may trigger **attached
procedures** when values are retrieved, examined, or modified. These might
compute additional values or update other data structures. These attached
procedures allow the system to automatically make "inferences" based on the
data it is given; for instance, it might combine the fact that MIT is in
Cambridge.MA and Cambridge.MA is in the United.States to infer that MIT is in
the United.States. It would have to be given rules, in the form of attached
procedures, to infer this fact, but once it had received these rules it could
make the inference automatically.

* * *

# Indices

## Indices associate structured "keys" with sets of structures

An object identifier gives no cues as to the structure associated with it.
Nonetheless, sometimes we need to identify objects based on what their
structure actually is. Kno provides **indices** which associate **keys**
(arbitrary DType structures) to sets of other DType structures. For example,
an index might go from words (represented as strings) to the set of
descriptions of their possible meanings. Indices can also be used to implement
relations which are not (for several possible reasons) implemented by slots
and values. For instance, an index in an email system might store a mapping
between descriptions of individuals and descriptions of the messages you've
received from them. It might be expensive to update those individual's
descriptions whenever a new message is received, but indices are designed to
support small, incremental changes of this sort. Indices can also be used for
more complicated operations, like pattern matching or object retrieval.

## Indices can be used for searching for frames based on slot values

Slot indices map slot-value pairs into the objects possessing those slot
values.

* * *

# Pools

## Pools are normally affiliated with files or servers

The management of pools is managed through either access to disk files (local
or remote) or communication with remote Kno servers. Standard operations
include allocating a new unique identifer, getting the structure associated
with an identifer, or changing the associated structure. When a file or server
manages a particular pool, we say that it is the "provider" for the pool. A
provider may provide only limited or selective access to a pool; for instance,
some pools may only permit access, not allocation or modification, while
others may permit allocation or modification only in particular ways or to
particular clients.

## Pools can be mirrored and consolidated

Pools provided by network servers may actually be copies or combinations of
other pools. For instance, the official provider for the MIT version of
WordNet may be a server at MIT; however, a site distant from MIT may wish to
set up its own server providing a copy of the same database. The mirror site
cannot be modified, of course, but it can provide the information it has
gotten as a complete or partial snapshot from MIT. (In fact, the server at MIT
is really a mirror of an internal site and can't be normally modified!)
Similarly, a server may consolidate several pools into a single "point of
service". Suppose there were a dozen different Kno servers at site A which
are of interest to a remote site. That site can set up a single server for
processing requests which reroutes each request to the appropriate server at
site A. Mirroring and consolidation become important as networked databases
become more widely used. Sites with particularly popular databases may wish to
set up "external mirrors" for the outside world while keeping the real
"internal" database reserved for their own work.

## Pools are organized into "super pools" administratively

Super pools are used to organize the allocation of pools at a particular site.
A super pool is a pool of roughly 4 billion object identifiers sharing the
same initial 32 bits of identifier. In the 64-bit Kno object identifier
address space, there are also roughly 4 billion super pools. The first such
super pool (the "zero" pool) contains objects describing the remaining super
pools. New pools can be allocated through the "zero pool server" (currently at
MIT) which can be accessed either directly (through DType protocol
connections) or through a form on the Kno web page at
"http://framerd.www.media.mit.edu/".

* * *

# Programming with Kno

## Programs can use Kno in many ways

Kno was first designed to allow diverse users at the MIT Media Lab to
share data, provide lab-wide utilities, etc. As a result, access to Kno
was made available from many different platforms. Basic libraries allow
Kno data and services to be directly accessed from C, Lisp, and Java.

Kno includes FDScript, a simple scripting language based on
[Scheme](r4rs.html). FDScript can be used to write command line scripts (it is
smaller than many shells), implement specialized network servers, or provide
World Wide Web (CGI) access to Kno data and services.

Basic Kno services are built on the DType protocol and libraries for
accessing DType services are available in Perl and TCL as well as from the
command line (with the [`dtcall` executable](commands.html#DTCALL)) or from
the C, Lisp, or Java libraries.

## C programs can use function libraries to access Kno

C does not natively provide most the datatypes used in Kno structures.
Pairs, lists, heterogenous vectors, and interned symbols need to be
implemented by the C function libraries connecting to Kno. The libraries
for accessing Kno provide these data structures, access to th DType
protocol, object maintenance and caching functions, and the FDScript
interpreter. Despite this, it is relatively lightweight, as shown in this
table:

Library | Binary Library Size  
---|---  
WIN32 | Solaris | PowerPC | Linux/Alpha  
dtypes  
_data structures, network access_ |  126K |  |  |  
framerd  
_object, index, and frame access_ |  108K |  |  |  
fdscript  
_R4RS evaluator, inference procedures, etc_ |  216K |  |  |  
The C library is the Kno reference implementation and is used to implement
the Kno server which provides databases or functions on the network.
Detailed documentation for using the C libraries can be found
[here](c-manual.html).

## Lisp or Scheme programs can access Kno databases

LISP already provides most of the native DTYPE structures. The Kno
libraries in LISP and Scheme are loaded to provide the same level of access as
the C libraries, including network access, local caching, and FDScript
execution.

## FDScript can be used to write simple Kno programs

FDScript is a lightweight LISP interpreter which incorporates the Kno
kernel functions. It is appropriate for casual database access, writing
command line scripts, and implementing CGI scripts for accessing Kno
databases from the World Wide Web. FDScript uses a uniform parenthesized
syntax for expressions and operations. For instance, in the following
expression: `(index-get "brico@framerd.org" "book")` the operation named
`INDEX-GET` is being called with two strings as arguments. The arguments can
also be expressions, so that: `(fget (index-get "wn15@wn15" "book") 'senses)`
applies the operation `FGET` to two arguments: the result of the embedded
INDEX-GET and the symbol 'senses. (The quote "'" preserves the following
object from interpretation).

