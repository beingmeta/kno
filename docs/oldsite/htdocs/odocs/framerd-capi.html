<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0//EN">
<HTML><HEAD>
<TITLE>FramerD Kernel APIs</TITLE>
<LINK REL='stylesheet' TYPE='text/css' HREF='framerd.css'>
</HEAD>
<BODY>
<H1>
FramerD Kernel APIs
</H1>
<P>
Automatically Generated by etc/build-api-doc.fdx at 2002-05-29T01:39:11.309450+3:00
</P>
<H2>
Summary
</H2>
<TABLE WIDTH="100%">
<TR>
<TH VALIGN="TOP" ALIGN="LEFT"><A HREF="#hash.c"><TT>src/cons/hash.c</TT></A></TH><TD VALIGN="TOP" ALIGN="LEFT"><A HREF="#_fd_hashset_add_nc"><TT STYLE="font-size: small;">_fd_hashset_add_nc</TT></A> | <A HREF="#_fd_hashtable_set_nolock"><TT STYLE="font-size: small;">_fd_hashtable_set_nolock</TT></A> | <A HREF="#_fd_set_symbol_value_noref"><TT STYLE="font-size: small;">_fd_set_symbol_value_noref</TT></A> | <A HREF="#_fd_symbol_value_noref"><TT STYLE="font-size: small;">_fd_symbol_value_noref</TT></A> | <A HREF="#fd_choice_to_hashset"><TT STYLE="font-size: small;">fd_choice_to_hashset</TT></A> | <A HREF="#fd_cleanup_locked_hashtable"><TT STYLE="font-size: small;">fd_cleanup_locked_hashtable</TT></A> | <A HREF="#fd_final_hashset_elts"><TT STYLE="font-size: small;">fd_final_hashset_elts</TT></A> | <A HREF="#fd_for_all_symbols"><TT STYLE="font-size: small;">fd_for_all_symbols</TT></A> | <A HREF="#fd_free_hashset"><TT STYLE="font-size: small;">fd_free_hashset</TT></A> | <A HREF="#fd_free_hashtable"><TT STYLE="font-size: small;">fd_free_hashtable</TT></A> | <A HREF="#fd_grow_hashset"><TT STYLE="font-size: small;">fd_grow_hashset</TT></A> | <A HREF="#fd_grow_hashtable"><TT STYLE="font-size: small;">fd_grow_hashtable</TT></A> | <A HREF="#fd_hash_lisp"><TT STYLE="font-size: small;">fd_hash_lisp</TT></A> | <A HREF="#fd_hashset_add"><TT STYLE="font-size: small;">fd_hashset_add</TT></A> | <A HREF="#fd_hashset_drop"><TT STYLE="font-size: small;">fd_hashset_drop</TT></A> | <A HREF="#fd_hashset_elts"><TT STYLE="font-size: small;">fd_hashset_elts</TT></A> | <A HREF="#fd_hashset_get"><TT STYLE="font-size: small;">fd_hashset_get</TT></A> | <A HREF="#fd_hashset_intern"><TT STYLE="font-size: small;">fd_hashset_intern</TT></A> | <A HREF="#fd_hashset_probe"><TT STYLE="font-size: small;">fd_hashset_probe</TT></A> | <A HREF="#fd_hashset_strget"><TT STYLE="font-size: small;">fd_hashset_strget</TT></A> | <A HREF="#fd_hashtable_add"><TT STYLE="font-size: small;">fd_hashtable_add</TT></A> | <A HREF="#fd_hashtable_drop"><TT STYLE="font-size: small;">fd_hashtable_drop</TT></A> | <A HREF="#fd_hashtable_get"><TT STYLE="font-size: small;">fd_hashtable_get</TT></A> | <A HREF="#fd_hashtable_increment"><TT STYLE="font-size: small;">fd_hashtable_increment</TT></A> | <A HREF="#fd_hashtable_increment_existing"><TT STYLE="font-size: small;">fd_hashtable_increment_existing</TT></A> | <A HREF="#fd_hashtable_max"><TT STYLE="font-size: small;">fd_hashtable_max</TT></A> | <A HREF="#fd_hashtable_probe"><TT STYLE="font-size: small;">fd_hashtable_probe</TT></A> | <A HREF="#fd_hashtable_set"><TT STYLE="font-size: small;">fd_hashtable_set</TT></A> | <A HREF="#fd_hashtable_skim"><TT STYLE="font-size: small;">fd_hashtable_skim</TT></A> | <A HREF="#fd_hashtable_test"><TT STYLE="font-size: small;">fd_hashtable_test</TT></A> | <A HREF="#fd_hashtable_zap"><TT STYLE="font-size: small;">fd_hashtable_zap</TT></A> | <A HREF="#fd_init_hashset"><TT STYLE="font-size: small;">fd_init_hashset</TT></A> | <A HREF="#fd_init_hashtable"><TT STYLE="font-size: small;">fd_init_hashtable</TT></A> | <A HREF="#fd_intern"><TT STYLE="font-size: small;">fd_intern</TT></A> | <A HREF="#fd_make_hashset"><TT STYLE="font-size: small;">fd_make_hashset</TT></A> | <A HREF="#fd_make_hashtable"><TT STYLE="font-size: small;">fd_make_hashtable</TT></A> | <A HREF="#fd_make_qstring"><TT STYLE="font-size: small;">fd_make_qstring</TT></A> | <A HREF="#fd_make_symbol"><TT STYLE="font-size: small;">fd_make_symbol</TT></A> | <A HREF="#fd_probe_symbol"><TT STYLE="font-size: small;">fd_probe_symbol</TT></A> | <A HREF="#fd_reinit_hashset"><TT STYLE="font-size: small;">fd_reinit_hashset</TT></A> | <A HREF="#fd_reinit_hashtable"><TT STYLE="font-size: small;">fd_reinit_hashtable</TT></A> | <A HREF="#fd_select_table_size"><TT STYLE="font-size: small;">fd_select_table_size</TT></A> | <A HREF="#fd_set_symbol_value"><TT STYLE="font-size: small;">fd_set_symbol_value</TT></A> | <A HREF="#fd_symbol_value"><TT STYLE="font-size: small;">fd_symbol_value</TT></A> | </TD>
</TR>
<TR>
<TH VALIGN="TOP" ALIGN="LEFT"><A HREF="#file-index.c"><TT>src/index/file-index.c</TT></A></TH><TD VALIGN="TOP" ALIGN="LEFT"><A HREF="#fd_dtype_compare"><TT STYLE="font-size: small;">fd_dtype_compare</TT></A> | <A HREF="#fd_file_index_collect_values
"><TT STYLE="font-size: small;">fd_file_index_collect_values
</TT></A> | <A HREF="#fd_index_report_stats"><TT STYLE="font-size: small;">fd_index_report_stats</TT></A> | <A HREF="#fd_preload_file_index"><TT STYLE="font-size: small;">fd_preload_file_index</TT></A> | <A HREF="#fd_register_file_index_opener"><TT STYLE="font-size: small;">fd_register_file_index_opener</TT></A> | <A HREF="#fd_unpreload_file_index"><TT STYLE="font-size: small;">fd_unpreload_file_index</TT></A> | <A HREF="#object"><TT STYLE="font-size: small;">object</TT></A> | </TD>
</TR>
<TR>
<TH VALIGN="TOP" ALIGN="LEFT"><A HREF="#data.c"><TT>src/cons/data.c</TT></A></TH><TD VALIGN="TOP" ALIGN="LEFT"><A HREF="#FD_MAKE_LIST"><TT STYLE="font-size: small;">FD_MAKE_LIST</TT></A> | <A HREF="#_FD_MAKE_LIST1"><TT STYLE="font-size: small;">_FD_MAKE_LIST1</TT></A> | <A HREF="#_FD_MAKE_PAIR"><TT STYLE="font-size: small;">_FD_MAKE_PAIR</TT></A> | <A HREF="#_fd_copy_lisp_proc"><TT STYLE="font-size: small;">_fd_copy_lisp_proc</TT></A> | <A HREF="#_fd_decref_cons"><TT STYLE="font-size: small;">_fd_decref_cons</TT></A> | <A HREF="#_fd_incref_cons"><TT STYLE="font-size: small;">_fd_incref_cons</TT></A> | <A HREF="#fd_copy_string"><TT STYLE="font-size: small;">fd_copy_string</TT></A> | <A HREF="#fd_for_elts"><TT STYLE="font-size: small;">fd_for_elts</TT></A> | <A HREF="#fd_free_proc"><TT STYLE="font-size: small;">fd_free_proc</TT></A> | <A HREF="#fd_get_big_buffer"><TT STYLE="font-size: small;">fd_get_big_buffer</TT></A> | <A HREF="#fd_init_string"><TT STYLE="font-size: small;">fd_init_string</TT></A> | <A HREF="#fd_init_vector"><TT STYLE="font-size: small;">fd_init_vector</TT></A> | <A HREF="#fd_lisp_equal"><TT STYLE="font-size: small;">fd_lisp_equal</TT></A> | <A HREF="#fd_list_length"><TT STYLE="font-size: small;">fd_list_length</TT></A> | <A HREF="#fd_lookup_compound"><TT STYLE="font-size: small;">fd_lookup_compound</TT></A> | <A HREF="#fd_lookup_package_code
"><TT STYLE="font-size: small;">fd_lookup_package_code
</TT></A> | <A HREF="#fd_lookup_record"><TT STYLE="font-size: small;">fd_lookup_record</TT></A> | <A HREF="#fd_lower_string"><TT STYLE="font-size: small;">fd_lower_string</TT></A> | <A HREF="#fd_make_character"><TT STYLE="font-size: small;">fd_make_character</TT></A> | <A HREF="#fd_make_cptr"><TT STYLE="font-size: small;">fd_make_cptr</TT></A> | <A HREF="#fd_make_lrecord"><TT STYLE="font-size: small;">fd_make_lrecord</TT></A> | <A HREF="#fd_make_pair"><TT STYLE="font-size: small;">fd_make_pair</TT></A> | <A HREF="#fd_make_record"><TT STYLE="font-size: small;">fd_make_record</TT></A> | <A HREF="#fd_make_string"><TT STYLE="font-size: small;">fd_make_string</TT></A> | <A HREF="#fd_make_substring"><TT STYLE="font-size: small;">fd_make_substring</TT></A> | <A HREF="#fd_make_vector"><TT STYLE="font-size: small;">fd_make_vector</TT></A> | <A HREF="#fd_memberp"><TT STYLE="font-size: small;">fd_memberp</TT></A> | <A HREF="#fd_register_record"><TT STYLE="font-size: small;">fd_register_record</TT></A> | <A HREF="#fd_register_source_file"><TT STYLE="font-size: small;">fd_register_source_file</TT></A> | <A HREF="#fd_register_typecode"><TT STYLE="font-size: small;">fd_register_typecode</TT></A> | <A HREF="#fd_stream_string"><TT STYLE="font-size: small;">fd_stream_string</TT></A> | <A HREF="#fd_utf8_string_ref"><TT STYLE="font-size: small;">fd_utf8_string_ref</TT></A> | <A HREF="#fd_utf8_strlen"><TT STYLE="font-size: small;">fd_utf8_strlen</TT></A> | <A HREF="#fd_utf8_substring"><TT STYLE="font-size: small;">fd_utf8_substring</TT></A> | </TD>
</TR>
<TR>
<TH VALIGN="TOP" ALIGN="LEFT"><A HREF="#index.c"><TT>src/index/index.c</TT></A></TH><TD VALIGN="TOP" ALIGN="LEFT"><A HREF="#fd_close_index"><TT STYLE="font-size: small;">fd_close_index</TT></A> | <A HREF="#fd_commit_index"><TT STYLE="font-size: small;">fd_commit_index</TT></A> | <A HREF="#fd_find_index"><TT STYLE="font-size: small;">fd_find_index</TT></A> | <A HREF="#fd_for_indices"><TT STYLE="font-size: small;">fd_for_indices</TT></A> | <A HREF="#fd_index_add"><TT STYLE="font-size: small;">fd_index_add</TT></A> | <A HREF="#fd_index_drop"><TT STYLE="font-size: small;">fd_index_drop</TT></A> | <A HREF="#fd_index_get"><TT STYLE="font-size: small;">fd_index_get</TT></A> | <A HREF="#fd_index_get_size"><TT STYLE="font-size: small;">fd_index_get_size</TT></A> | <A HREF="#fd_index_keys"><TT STYLE="font-size: small;">fd_index_keys</TT></A> | <A HREF="#fd_index_prefetch"><TT STYLE="font-size: small;">fd_index_prefetch</TT></A> | <A HREF="#fd_index_set"><TT STYLE="font-size: small;">fd_index_set</TT></A> | <A HREF="#fd_index_set_sizes
"><TT STYLE="font-size: small;">fd_index_set_sizes
</TT></A> | <A HREF="#fd_intern_index_values"><TT STYLE="font-size: small;">fd_intern_index_values</TT></A> | <A HREF="#fd_interpret_index"><TT STYLE="font-size: small;">fd_interpret_index</TT></A> | <A HREF="#fd_revert_index"><TT STYLE="font-size: small;">fd_revert_index</TT></A> | <A HREF="#fd_set_index_zipf_threshold"><TT STYLE="font-size: small;">fd_set_index_zipf_threshold</TT></A> | <A HREF="#fd_swap_out_index"><TT STYLE="font-size: small;">fd_swap_out_index</TT></A> | <A HREF="#fd_use_index"><TT STYLE="font-size: small;">fd_use_index</TT></A> | </TD>
</TR>
<TR>
<TH VALIGN="TOP" ALIGN="LEFT"><A HREF="#fdprintf.c"><TT>src/os/fdprintf.c</TT></A></TH><TD VALIGN="TOP" ALIGN="LEFT"><A HREF="#_fd_grow_string_stream"><TT STYLE="font-size: small;">_fd_grow_string_stream</TT></A> | <A HREF="#_fd_sputc"><TT STYLE="font-size: small;">_fd_sputc</TT></A> | <A HREF="#_fd_sputn"><TT STYLE="font-size: small;">_fd_sputn</TT></A> | <A HREF="#_fd_sputs"><TT STYLE="font-size: small;">_fd_sputs</TT></A> | <A HREF="#fd_default_notifier"><TT STYLE="font-size: small;">fd_default_notifier</TT></A> | <A HREF="#fd_fprintf"><TT STYLE="font-size: small;">fd_fprintf</TT></A> | <A HREF="#fd_notify"><TT STYLE="font-size: small;">fd_notify</TT></A> | <A HREF="#fd_printf"><TT STYLE="font-size: small;">fd_printf</TT></A> | <A HREF="#fd_set_notify_handler"><TT STYLE="font-size: small;">fd_set_notify_handler</TT></A> | <A HREF="#fd_set_warn_handler"><TT STYLE="font-size: small;">fd_set_warn_handler</TT></A> | <A HREF="#fd_warn"><TT STYLE="font-size: small;">fd_warn</TT></A> | <A HREF="#fd_xprintf"><TT STYLE="font-size: small;">fd_xprintf</TT></A> | </TD>
</TR>
<TR>
<TH VALIGN="TOP" ALIGN="LEFT"><A HREF="#network-index.c"><TT>src/index/network-index.c</TT></A></TH><TD VALIGN="TOP" ALIGN="LEFT"><A HREF="#fd_use_network_index"><TT STYLE="font-size: small;">fd_use_network_index</TT></A> | </TD>
</TR>
<TR>
<TH VALIGN="TOP" ALIGN="LEFT"><A HREF="#sandbox.c"><TT>src/eval/sandbox.c</TT></A></TH><TD VALIGN="TOP" ALIGN="LEFT"><A HREF="#fd_add_restricted_cproc"><TT STYLE="font-size: small;">fd_add_restricted_cproc</TT></A> | <A HREF="#fd_add_restricted_lexpr"><TT STYLE="font-size: small;">fd_add_restricted_lexpr</TT></A> | <A HREF="#fd_add_restricted_special_form
"><TT STYLE="font-size: small;">fd_add_restricted_special_form
</TT></A> | </TD>
</TR>
<TR>
<TH VALIGN="TOP" ALIGN="LEFT"><A HREF="#mime.c"><TT>src/text/mime.c</TT></A></TH><TD VALIGN="TOP" ALIGN="LEFT"><A HREF="#fd_parse_mime"><TT STYLE="font-size: small;">fd_parse_mime</TT></A> | </TD>
</TR>
<TR>
<TH VALIGN="TOP" ALIGN="LEFT"><A HREF="#text.c"><TT>src/text/text.c</TT></A></TH><TD VALIGN="TOP" ALIGN="LEFT"><A HREF="#fd_text_subst"><TT STYLE="font-size: small;">fd_text_subst</TT></A> | </TD>
</TR>
<TR>
<TH VALIGN="TOP" ALIGN="LEFT"><A HREF="#htmlgen.c"><TT>src/text/htmlgen.c</TT></A></TH><TD VALIGN="TOP" ALIGN="LEFT"><A HREF="#fd_http_puts"><TT STYLE="font-size: small;">fd_http_puts</TT></A> | <A HREF="#fd_http_write_bytes"><TT STYLE="font-size: small;">fd_http_write_bytes</TT></A> | <A HREF="#fd_set_http_output_methods
"><TT STYLE="font-size: small;">fd_set_http_output_methods
</TT></A> | <A HREF="#fd_start_http"><TT STYLE="font-size: small;">fd_start_http</TT></A> | <A HREF="#fd_start_http_output"><TT STYLE="font-size: small;">fd_start_http_output</TT></A> | <A HREF="#fd_unparse_xml"><TT STYLE="font-size: small;">fd_unparse_xml</TT></A> | </TD>
</TR>
<TR>
<TH VALIGN="TOP" ALIGN="LEFT"><A HREF="#network-pool.c"><TT>src/odb/network-pool.c</TT></A></TH><TD VALIGN="TOP" ALIGN="LEFT"><A HREF="#fd_use_network_pool"><TT STYLE="font-size: small;">fd_use_network_pool</TT></A> | </TD>
</TR>
<TR>
<TH VALIGN="TOP" ALIGN="LEFT"><A HREF="#pools.c"><TT>src/odb/pools.c</TT></A></TH><TD VALIGN="TOP" ALIGN="LEFT"><A HREF="#fd_commit_pool"><TT STYLE="font-size: small;">fd_commit_pool</TT></A> | <A HREF="#fd_find_pool_named"><TT STYLE="font-size: small;">fd_find_pool_named</TT></A> | <A HREF="#fd_for_pools"><TT STYLE="font-size: small;">fd_for_pools</TT></A> | <A HREF="#fd_get_pool"><TT STYLE="font-size: small;">fd_get_pool</TT></A> | <A HREF="#fd_interpret_pool"><TT STYLE="font-size: small;">fd_interpret_pool</TT></A> | <A HREF="#fd_locate_pool"><TT STYLE="font-size: small;">fd_locate_pool</TT></A> | <A HREF="#fd_pool_load"><TT STYLE="font-size: small;">fd_pool_load</TT></A> | <A HREF="#fd_random_oid"><TT STYLE="font-size: small;">fd_random_oid</TT></A> | <A HREF="#fd_register_pool"><TT STYLE="font-size: small;">fd_register_pool</TT></A> | <A HREF="#fd_set_oid_locator"><TT STYLE="font-size: small;">fd_set_oid_locator</TT></A> | <A HREF="#fd_use_pool"><TT STYLE="font-size: small;">fd_use_pool</TT></A> | </TD>
</TR>
<TR>
<TH VALIGN="TOP" ALIGN="LEFT"><A HREF="#stem.c"><TT>src/text/stem.c</TT></A></TH><TD VALIGN="TOP" ALIGN="LEFT"><A HREF="#fd_stem_english_word"><TT STYLE="font-size: small;">fd_stem_english_word</TT></A> | </TD>
</TR>
<TR>
<TH VALIGN="TOP" ALIGN="LEFT"><A HREF="#xdata.c"><TT>src/cons/xdata.c</TT></A></TH><TD VALIGN="TOP" ALIGN="LEFT"><A HREF="#fd_alist_to_hashtable"><TT STYLE="font-size: small;">fd_alist_to_hashtable</TT></A> | <A HREF="#fd_compare_cptrs"><TT STYLE="font-size: small;">fd_compare_cptrs</TT></A> | <A HREF="#fd_cons"><TT STYLE="font-size: small;">fd_cons</TT></A> | <A HREF="#fd_copy_cptr"><TT STYLE="font-size: small;">fd_copy_cptr</TT></A> | <A HREF="#fd_hashtable_to_alist"><TT STYLE="font-size: small;">fd_hashtable_to_alist</TT></A> | <A HREF="#fd_lisp_hashset_elts"><TT STYLE="font-size: small;">fd_lisp_hashset_elts</TT></A> | <A HREF="#fd_make_complex"><TT STYLE="font-size: small;">fd_make_complex</TT></A> | <A HREF="#fd_make_double_vector"><TT STYLE="font-size: small;">fd_make_double_vector</TT></A> | <A HREF="#fd_make_error"><TT STYLE="font-size: small;">fd_make_error</TT></A> | <A HREF="#fd_make_exception"><TT STYLE="font-size: small;">fd_make_exception</TT></A> | <A HREF="#fd_make_float_vector"><TT STYLE="font-size: small;">fd_make_float_vector</TT></A> | <A HREF="#fd_make_flonum"><TT STYLE="font-size: small;">fd_make_flonum</TT></A> | <A HREF="#fd_make_hashset_for_lisp"><TT STYLE="font-size: small;">fd_make_hashset_for_lisp</TT></A> | <A HREF="#fd_make_hashtable_for_lisp"><TT STYLE="font-size: small;">fd_make_hashtable_for_lisp</TT></A> | <A HREF="#fd_make_int_vector"><TT STYLE="font-size: small;">fd_make_int_vector</TT></A> | <A HREF="#fd_make_packet"><TT STYLE="font-size: small;">fd_make_packet</TT></A> | <A HREF="#fd_make_rational"><TT STYLE="font-size: small;">fd_make_rational</TT></A> | <A HREF="#fd_make_short_vector"><TT STYLE="font-size: small;">fd_make_short_vector</TT></A> | <A HREF="#fd_make_timestamp"><TT STYLE="font-size: small;">fd_make_timestamp</TT></A> | <A HREF="#fd_make_xtimestamp"><TT STYLE="font-size: small;">fd_make_xtimestamp</TT></A> | <A HREF="#fd_parse_packet"><TT STYLE="font-size: small;">fd_parse_packet</TT></A> | <A HREF="#fd_quote_lisp"><TT STYLE="font-size: small;">fd_quote_lisp</TT></A> | </TD>
</TR>
<TR>
<TH VALIGN="TOP" ALIGN="LEFT"><A HREF="#timefns.c"><TT>src/os/timefns.c</TT></A></TH><TD VALIGN="TOP" ALIGN="LEFT"><A HREF="#fd_breakup_time"><TT STYLE="font-size: small;">fd_breakup_time</TT></A> | <A HREF="#fd_get_now"><TT STYLE="font-size: small;">fd_get_now</TT></A> | <A HREF="#fd_init_xtime"><TT STYLE="font-size: small;">fd_init_xtime</TT></A> | <A HREF="#fd_iso8601_to_xtime"><TT STYLE="font-size: small;">fd_iso8601_to_xtime</TT></A> | <A HREF="#fd_localtime"><TT STYLE="font-size: small;">fd_localtime</TT></A> | <A HREF="#fd_mktime"><TT STYLE="font-size: small;">fd_mktime</TT></A> | <A HREF="#fd_parse_iso8601"><TT STYLE="font-size: small;">fd_parse_iso8601</TT></A> | <A HREF="#fd_parse_tzspec"><TT STYLE="font-size: small;">fd_parse_tzspec</TT></A> | <A HREF="#fd_sleep"><TT STYLE="font-size: small;">fd_sleep</TT></A> | <A HREF="#fd_timestamp_time"><TT STYLE="font-size: small;">fd_timestamp_time</TT></A> | <A HREF="#fd_timestamp_to_xtime"><TT STYLE="font-size: small;">fd_timestamp_to_xtime</TT></A> | <A HREF="#fd_xtime_to_iso8601"><TT STYLE="font-size: small;">fd_xtime_to_iso8601</TT></A> | <A HREF="#fd_xtime_to_timestamp"><TT STYLE="font-size: small;">fd_xtime_to_timestamp</TT></A> | </TD>
</TR>
<TR>
<TH VALIGN="TOP" ALIGN="LEFT"><A HREF="#consed-oids.c"><TT>src/cons/consed-oids.c</TT></A></TH><TD VALIGN="TOP" ALIGN="LEFT"><A HREF="#_fd_not_an_oid"><TT STYLE="font-size: small;">_fd_not_an_oid</TT></A> | <A HREF="#fd_grow_oid_table"><TT STYLE="font-size: small;">fd_grow_oid_table</TT></A> | <A HREF="#fd_make_oid"><TT STYLE="font-size: small;">fd_make_oid</TT></A> | <A HREF="#fd_probe_oid"><TT STYLE="font-size: small;">fd_probe_oid</TT></A> | </TD>
</TR>
<TR>
<TH VALIGN="TOP" ALIGN="LEFT"><A HREF="#load.c"><TT>src/eval/load.c</TT></A></TH><TD VALIGN="TOP" ALIGN="LEFT"><A HREF="#fd_get_module"><TT STYLE="font-size: small;">fd_get_module</TT></A> | <A HREF="#fd_load_file"><TT STYLE="font-size: small;">fd_load_file</TT></A> | <A HREF="#fd_load_library"><TT STYLE="font-size: small;">fd_load_library</TT></A> | </TD>
</TR>
<TR>
<TH VALIGN="TOP" ALIGN="LEFT"><A HREF="#envfns.c"><TT>src/os/envfns.c</TT></A></TH><TD VALIGN="TOP" ALIGN="LEFT"><A HREF="#fd_exit"><TT STYLE="font-size: small;">fd_exit</TT></A> | <A HREF="#fd_get_gid"><TT STYLE="font-size: small;">fd_get_gid</TT></A> | <A HREF="#fd_get_gname"><TT STYLE="font-size: small;">fd_get_gname</TT></A> | <A HREF="#fd_get_uid"><TT STYLE="font-size: small;">fd_get_uid</TT></A> | <A HREF="#fd_get_uname"><TT STYLE="font-size: small;">fd_get_uname</TT></A> | <A HREF="#fd_get_user_data"><TT STYLE="font-size: small;">fd_get_user_data</TT></A> | <A HREF="#fd_getenv"><TT STYLE="font-size: small;">fd_getenv</TT></A> | <A HREF="#fd_getrusage"><TT STYLE="font-size: small;">fd_getrusage</TT></A> | <A HREF="#fd_inhibit_anti_warranty"><TT STYLE="font-size: small;">fd_inhibit_anti_warranty</TT></A> | <A HREF="#fd_inhibit_herald"><TT STYLE="font-size: small;">fd_inhibit_herald</TT></A> | <A HREF="#fd_int_getenv"><TT STYLE="font-size: small;">fd_int_getenv</TT></A> | <A HREF="#fd_load_config"><TT STYLE="font-size: small;">fd_load_config</TT></A> | <A HREF="#fd_set_build_date"><TT STYLE="font-size: small;">fd_set_build_date</TT></A> | <A HREF="#fd_set_gid"><TT STYLE="font-size: small;">fd_set_gid</TT></A> | <A HREF="#fd_set_random"><TT STYLE="font-size: small;">fd_set_random</TT></A> | <A HREF="#fd_set_session_mnemonic"><TT STYLE="font-size: small;">fd_set_session_mnemonic</TT></A> | <A HREF="#fd_set_uid"><TT STYLE="font-size: small;">fd_set_uid</TT></A> | <A HREF="#fd_string_getenv"><TT STYLE="font-size: small;">fd_string_getenv</TT></A> | </TD>
</TR>
<TR>
<TH VALIGN="TOP" ALIGN="LEFT"><A HREF="#filefns.c"><TT>src/os/filefns.c</TT></A></TH><TD VALIGN="TOP" ALIGN="LEFT"><A HREF="#fd_directoryp"><TT STYLE="font-size: small;">fd_directoryp</TT></A> | <A HREF="#fd_fclose"><TT STYLE="font-size: small;">fd_fclose</TT></A> | <A HREF="#fd_file_existsp"><TT STYLE="font-size: small;">fd_file_existsp</TT></A> | <A HREF="#fd_file_size"><TT STYLE="font-size: small;">fd_file_size</TT></A> | <A HREF="#fd_file_writablep"><TT STYLE="font-size: small;">fd_file_writablep</TT></A> | <A HREF="#fd_find_file"><TT STYLE="font-size: small;">fd_find_file</TT></A> | <A HREF="#fd_fopen"><TT STYLE="font-size: small;">fd_fopen</TT></A> | <A HREF="#fd_fopen_locked"><TT STYLE="font-size: small;">fd_fopen_locked</TT></A> | <A HREF="#fd_get_exec_filename"><TT STYLE="font-size: small;">fd_get_exec_filename</TT></A> | <A HREF="#fd_getpath"><TT STYLE="font-size: small;">fd_getpath</TT></A> | <A HREF="#fd_regular_filep"><TT STYLE="font-size: small;">fd_regular_filep</TT></A> | <A HREF="#fd_symbolic_linkp"><TT STYLE="font-size: small;">fd_symbolic_linkp</TT></A> | </TD>
</TR>
<TR>
<TH VALIGN="TOP" ALIGN="LEFT"><A HREF="#odb.c"><TT>src/odb/odb.c</TT></A></TH><TD VALIGN="TOP" ALIGN="LEFT"><A HREF="#fd_close_pool"><TT STYLE="font-size: small;">fd_close_pool</TT></A> | <A HREF="#fd_commit_oid"><TT STYLE="font-size: small;">fd_commit_oid</TT></A> | <A HREF="#fd_control_frame_printing"><TT STYLE="font-size: small;">fd_control_frame_printing</TT></A> | <A HREF="#fd_get_oid_value"><TT STYLE="font-size: small;">fd_get_oid_value</TT></A> | <A HREF="#fd_mark_modified"><TT STYLE="font-size: small;">fd_mark_modified</TT></A> | <A HREF="#fd_new_oid"><TT STYLE="font-size: small;">fd_new_oid</TT></A> | <A HREF="#fd_oid_modifiedp"><TT STYLE="font-size: small;">fd_oid_modifiedp</TT></A> | <A HREF="#fd_print_oid"><TT STYLE="font-size: small;">fd_print_oid</TT></A> | <A HREF="#fd_revert_oid"><TT STYLE="font-size: small;">fd_revert_oid</TT></A> | <A HREF="#fd_revert_pool"><TT STYLE="font-size: small;">fd_revert_pool</TT></A> | <A HREF="#fd_set_oid_value"><TT STYLE="font-size: small;">fd_set_oid_value</TT></A> | <A HREF="#fd_show_poolids"><TT STYLE="font-size: small;">fd_show_poolids</TT></A> | <A HREF="#fd_swap_out"><TT STYLE="font-size: small;">fd_swap_out</TT></A> | <A HREF="#fd_swap_out_pool"><TT STYLE="font-size: small;">fd_swap_out_pool</TT></A> | <A HREF="#fd_try_oid_value"><TT STYLE="font-size: small;">fd_try_oid_value</TT></A> | </TD>
</TR>
<TR>
<TH VALIGN="TOP" ALIGN="LEFT"><A HREF="#osprims.c"><TT>src/fdscript/osprims.c</TT></A></TH><TD VALIGN="TOP" ALIGN="LEFT"><A HREF="#fd_register_url_protocol"><TT STYLE="font-size: small;">fd_register_url_protocol</TT></A> | <A HREF="#fd_urlget"><TT STYLE="font-size: small;">fd_urlget</TT></A> | </TD>
</TR>
<TR>
<TH VALIGN="TOP" ALIGN="LEFT"><A HREF="#strings.c"><TT>src/scheme/strings.c</TT></A></TH><TD VALIGN="TOP" ALIGN="LEFT"><A HREF="#fd_string_length"><TT STYLE="font-size: small;">fd_string_length</TT></A> | <A HREF="#fd_string_ref"><TT STYLE="font-size: small;">fd_string_ref</TT></A> | <A HREF="#fd_string_set"><TT STYLE="font-size: small;">fd_string_set</TT></A> | </TD>
</TR>
<TR>
<TH VALIGN="TOP" ALIGN="LEFT"><A HREF="#super-pool.c"><TT>src/odb/super-pool.c</TT></A></TH><TD VALIGN="TOP" ALIGN="LEFT"><A HREF="#fd_allocate_pool
"><TT STYLE="font-size: small;">fd_allocate_pool
</TT></A> | <A HREF="#fd_recovered_pool
"><TT STYLE="font-size: small;">fd_recovered_pool
</TT></A> | <A HREF="#fd_super_pool_base"><TT STYLE="font-size: small;">fd_super_pool_base</TT></A> | <A HREF="#fd_super_pool_loading"><TT STYLE="font-size: small;">fd_super_pool_loading</TT></A> | <A HREF="#fd_super_pool_top"><TT STYLE="font-size: small;">fd_super_pool_top</TT></A> | </TD>
</TR>
<TR>
<TH VALIGN="TOP" ALIGN="LEFT"><A HREF="#threads.c"><TT>src/eval/threads.c</TT></A></TH><TD VALIGN="TOP" ALIGN="LEFT"><A HREF="#fd_thread_symbind"><TT STYLE="font-size: small;">fd_thread_symbind</TT></A> | <A HREF="#fd_thread_symeval"><TT STYLE="font-size: small;">fd_thread_symeval</TT></A> | </TD>
</TR>
<TR>
<TH VALIGN="TOP" ALIGN="LEFT"><A HREF="#choices.c"><TT>src/cons/choices.c</TT></A></TH><TD VALIGN="TOP" ALIGN="LEFT"><A HREF="#_fd_add_to_choice"><TT STYLE="font-size: small;">_fd_add_to_choice</TT></A> | <A HREF="#_fd_binary_choice"><TT STYLE="font-size: small;">_fd_binary_choice</TT></A> | <A HREF="#_fd_make_choice_heterogenous"><TT STYLE="font-size: small;">_fd_make_choice_heterogenous</TT></A> | <A HREF="#_fd_make_choice_homogenous"><TT STYLE="font-size: small;">_fd_make_choice_homogenous</TT></A> | <A HREF="#_fd_merge_choices"><TT STYLE="font-size: small;">_fd_merge_choices</TT></A> | <A HREF="#_fd_quote_choice"><TT STYLE="font-size: small;">_fd_quote_choice</TT></A> | <A HREF="#_fd_unquote_choice"><TT STYLE="font-size: small;">_fd_unquote_choice</TT></A> | <A HREF="#fd_choice_containsp"><TT STYLE="font-size: small;">fd_choice_containsp</TT></A> | <A HREF="#fd_choice_overlapsp"><TT STYLE="font-size: small;">fd_choice_overlapsp</TT></A> | <A HREF="#fd_init_choice"><TT STYLE="font-size: small;">fd_init_choice</TT></A> | <A HREF="#fd_init_oid_choice"><TT STYLE="font-size: small;">fd_init_oid_choice</TT></A> | <A HREF="#fd_intersect_choices"><TT STYLE="font-size: small;">fd_intersect_choices</TT></A> | <A HREF="#fd_list_to_choice"><TT STYLE="font-size: small;">fd_list_to_choice</TT></A> | <A HREF="#fd_merge_choices"><TT STYLE="font-size: small;">fd_merge_choices</TT></A> | <A HREF="#fd_proper_choicep"><TT STYLE="font-size: small;">fd_proper_choicep</TT></A> | <A HREF="#fd_remove_from_choice"><TT STYLE="font-size: small;">fd_remove_from_choice</TT></A> | <A HREF="#fd_return_proper_choice"><TT STYLE="font-size: small;">fd_return_proper_choice</TT></A> | <A HREF="#fd_sort_choice"><TT STYLE="font-size: small;">fd_sort_choice</TT></A> | </TD>
</TR>
<TR>
<TH VALIGN="TOP" ALIGN="LEFT"><A HREF="#frames.c"><TT>src/odb/frames.c</TT></A></TH><TD VALIGN="TOP" ALIGN="LEFT"><A HREF="#fd_already_doing_p"><TT STYLE="font-size: small;">fd_already_doing_p</TT></A> | <A HREF="#fd_clear_slot_cache"><TT STYLE="font-size: small;">fd_clear_slot_cache</TT></A> | <A HREF="#fd_copy_frame"><TT STYLE="font-size: small;">fd_copy_frame</TT></A> | <A HREF="#fd_describe_slot"><TT STYLE="font-size: small;">fd_describe_slot</TT></A> | <A HREF="#fd_disable_slot_cache"><TT STYLE="font-size: small;">fd_disable_slot_cache</TT></A> | <A HREF="#fd_enable_slot_cache"><TT STYLE="font-size: small;">fd_enable_slot_cache</TT></A> | <A HREF="#fd_for_slots"><TT STYLE="font-size: small;">fd_for_slots</TT></A> | <A HREF="#fd_frame_add"><TT STYLE="font-size: small;">fd_frame_add</TT></A> | <A HREF="#fd_frame_create"><TT STYLE="font-size: small;">fd_frame_create</TT></A> | <A HREF="#fd_frame_get"><TT STYLE="font-size: small;">fd_frame_get</TT></A> | <A HREF="#fd_frame_get_star"><TT STYLE="font-size: small;">fd_frame_get_star</TT></A> | <A HREF="#fd_frame_remove"><TT STYLE="font-size: small;">fd_frame_remove</TT></A> | <A HREF="#fd_frame_set"><TT STYLE="font-size: small;">fd_frame_set</TT></A> | <A HREF="#fd_frame_slots"><TT STYLE="font-size: small;">fd_frame_slots</TT></A> | <A HREF="#fd_frame_test"><TT STYLE="font-size: small;">fd_frame_test</TT></A> | <A HREF="#fd_get_slotmap"><TT STYLE="font-size: small;">fd_get_slotmap</TT></A> | <A HREF="#fd_inherit_values"><TT STYLE="font-size: small;">fd_inherit_values</TT></A> | <A HREF="#fd_inherits_valuep"><TT STYLE="font-size: small;">fd_inherits_valuep</TT></A> | <A HREF="#fd_overlay_create"><TT STYLE="font-size: small;">fd_overlay_create</TT></A> | <A HREF="#fd_overlay_get"><TT STYLE="font-size: small;">fd_overlay_get</TT></A> | <A HREF="#fd_overlay_test"><TT STYLE="font-size: small;">fd_overlay_test</TT></A> | <A HREF="#fd_pathp"><TT STYLE="font-size: small;">fd_pathp</TT></A> | <A HREF="#fd_prim_add"><TT STYLE="font-size: small;">fd_prim_add</TT></A> | <A HREF="#fd_prim_add_consed"><TT STYLE="font-size: small;">fd_prim_add_consed</TT></A> | <A HREF="#fd_prim_drop"><TT STYLE="font-size: small;">fd_prim_drop</TT></A> | <A HREF="#fd_prim_get"><TT STYLE="font-size: small;">fd_prim_get</TT></A> | <A HREF="#fd_prim_set"><TT STYLE="font-size: small;">fd_prim_set</TT></A> | <A HREF="#fd_prim_set_consed"><TT STYLE="font-size: small;">fd_prim_set_consed</TT></A> | <A HREF="#fd_prim_test"><TT STYLE="font-size: small;">fd_prim_test</TT></A> | <A HREF="#fd_use_autoindex"><TT STYLE="font-size: small;">fd_use_autoindex</TT></A> | </TD>
</TR>
<TR>
<TH VALIGN="TOP" ALIGN="LEFT"><A HREF="#libframerd.c"><TT>src/odb/libframerd.c</TT></A></TH><TD VALIGN="TOP" ALIGN="LEFT"><A HREF="#fd_report_framerd_stats"><TT STYLE="font-size: small;">fd_report_framerd_stats</TT></A> | </TD>
</TR>
<TR>
<TH VALIGN="TOP" ALIGN="LEFT"><A HREF="#xml.c"><TT>src/text/xml.c</TT></A></TH><TD VALIGN="TOP" ALIGN="LEFT"><A HREF="#fd_make_xmltag"><TT STYLE="font-size: small;">fd_make_xmltag</TT></A> | <A HREF="#fd_parse_html"><TT STYLE="font-size: small;">fd_parse_html</TT></A> | <A HREF="#fd_parse_xml"><TT STYLE="font-size: small;">fd_parse_xml</TT></A> | <A HREF="#fd_xml_attributes"><TT STYLE="font-size: small;">fd_xml_attributes</TT></A> | <A HREF="#fd_xml_content"><TT STYLE="font-size: small;">fd_xml_content</TT></A> | <A HREF="#fd_xml_tag"><TT STYLE="font-size: small;">fd_xml_tag</TT></A> | <A HREF="#fd_xmltag_name"><TT STYLE="font-size: small;">fd_xmltag_name</TT></A> | <A HREF="#fd_xmltag_namespace"><TT STYLE="font-size: small;">fd_xmltag_namespace</TT></A> | </TD>
</TR>
<TR>
<TH VALIGN="TOP" ALIGN="LEFT"><A HREF="#slotmaps.c"><TT>src/cons/slotmaps.c</TT></A></TH><TD VALIGN="TOP" ALIGN="LEFT"><A HREF="#_fd_done_with_slotmap_data"><TT STYLE="font-size: small;">_fd_done_with_slotmap_data</TT></A> | <A HREF="#_fd_slotmap_data"><TT STYLE="font-size: small;">_fd_slotmap_data</TT></A> | <A HREF="#fd_make_slotmap"><TT STYLE="font-size: small;">fd_make_slotmap</TT></A> | <A HREF="#fd_slotmap_add"><TT STYLE="font-size: small;">fd_slotmap_add</TT></A> | <A HREF="#fd_slotmap_get"><TT STYLE="font-size: small;">fd_slotmap_get</TT></A> | <A HREF="#fd_slotmap_remove"><TT STYLE="font-size: small;">fd_slotmap_remove</TT></A> | <A HREF="#fd_slotmap_set"><TT STYLE="font-size: small;">fd_slotmap_set</TT></A> | <A HREF="#fd_slotmap_test"><TT STYLE="font-size: small;">fd_slotmap_test</TT></A> | <A HREF="#fd_slotmap_zap"><TT STYLE="font-size: small;">fd_slotmap_zap</TT></A> | </TD>
</TR>
<TR>
<TH VALIGN="TOP" ALIGN="LEFT"><A HREF="#lambda.c"><TT>src/eval/lambda.c</TT></A></TH><TD VALIGN="TOP" ALIGN="LEFT"><A HREF="#fd_bind_value"><TT STYLE="font-size: small;">fd_bind_value</TT></A> | <A HREF="#fd_free_env"><TT STYLE="font-size: small;">fd_free_env</TT></A> | <A HREF="#fd_make_env"><TT STYLE="font-size: small;">fd_make_env</TT></A> | <A HREF="#fd_make_gproc"><TT STYLE="font-size: small;">fd_make_gproc</TT></A> | <A HREF="#fd_make_sproc"><TT STYLE="font-size: small;">fd_make_sproc</TT></A> | <A HREF="#fd_make_ssproc"><TT STYLE="font-size: small;">fd_make_ssproc</TT></A> | <A HREF="#fd_mallocd_env"><TT STYLE="font-size: small;">fd_mallocd_env</TT></A> | <A HREF="#fd_module_export"><TT STYLE="font-size: small;">fd_module_export</TT></A> | <A HREF="#fd_module_uses"><TT STYLE="font-size: small;">fd_module_uses</TT></A> | <A HREF="#fd_register_module"><TT STYLE="font-size: small;">fd_register_module</TT></A> | <A HREF="#fd_register_restricted_module"><TT STYLE="font-size: small;">fd_register_restricted_module</TT></A> | <A HREF="#fd_registered_module"><TT STYLE="font-size: small;">fd_registered_module</TT></A> | <A HREF="#fd_required_symeval"><TT STYLE="font-size: small;">fd_required_symeval</TT></A> | <A HREF="#fd_safe_set_value"><TT STYLE="font-size: small;">fd_safe_set_value</TT></A> | <A HREF="#fd_set_value"><TT STYLE="font-size: small;">fd_set_value</TT></A> | <A HREF="#fd_symeval"><TT STYLE="font-size: small;">fd_symeval</TT></A> | </TD>
</TR>
<TR>
<TH VALIGN="TOP" ALIGN="LEFT"><A HREF="#eval.c"><TT>src/eval/eval.c</TT></A></TH><TD VALIGN="TOP" ALIGN="LEFT"><A HREF="#_fd_finalize_static_tail_call"><TT STYLE="font-size: small;">_fd_finalize_static_tail_call</TT></A> | <A HREF="#fd_add_alias"><TT STYLE="font-size: small;">fd_add_alias</TT></A> | <A HREF="#fd_add_cproc"><TT STYLE="font-size: small;">fd_add_cproc</TT></A> | <A HREF="#fd_add_lexpr
"><TT STYLE="font-size: small;">fd_add_lexpr
</TT></A> | <A HREF="#fd_add_special_form
"><TT STYLE="font-size: small;">fd_add_special_form
</TT></A> | <A HREF="#fd_do_application"><TT STYLE="font-size: small;">fd_do_application</TT></A> | <A HREF="#fd_eval"><TT STYLE="font-size: small;">fd_eval</TT></A> | <A HREF="#fd_eval_elts"><TT STYLE="font-size: small;">fd_eval_elts</TT></A> | <A HREF="#fd_eval_in_env"><TT STYLE="font-size: small;">fd_eval_in_env</TT></A> | <A HREF="#fd_evalstring"><TT STYLE="font-size: small;">fd_evalstring</TT></A> | <A HREF="#fd_finish_value"><TT STYLE="font-size: small;">fd_finish_value</TT></A> | <A HREF="#fd_make_rproc"><TT STYLE="font-size: small;">fd_make_rproc</TT></A> | <A HREF="#fd_mv_arity"><TT STYLE="font-size: small;">fd_mv_arity</TT></A> | <A HREF="#fd_mv_ref"><TT STYLE="font-size: small;">fd_mv_ref</TT></A> | <A HREF="#fd_mv_return"><TT STYLE="font-size: small;">fd_mv_return</TT></A> | <A HREF="#fd_record_typep"><TT STYLE="font-size: small;">fd_record_typep</TT></A> | <A HREF="#fd_set_supertype"><TT STYLE="font-size: small;">fd_set_supertype</TT></A> | <A HREF="#fd_start_eval"><TT STYLE="font-size: small;">fd_start_eval</TT></A> | <A HREF="#fd_streval"><TT STYLE="font-size: small;">fd_streval</TT></A> | </TD>
</TR>
<TR>
<TH VALIGN="TOP" ALIGN="LEFT"><A HREF="#network.c"><TT>src/os/network.c</TT></A></TH><TD VALIGN="TOP" ALIGN="LEFT"><A HREF="#fd_careful_dtcall"><TT STYLE="font-size: small;">fd_careful_dtcall</TT></A> | <A HREF="#fd_careful_dtype_eval"><TT STYLE="font-size: small;">fd_careful_dtype_eval</TT></A> | <A HREF="#fd_close_connection"><TT STYLE="font-size: small;">fd_close_connection</TT></A> | <A HREF="#fd_connect"><TT STYLE="font-size: small;">fd_connect</TT></A> | <A HREF="#fd_dtcall"><TT STYLE="font-size: small;">fd_dtcall</TT></A> | <A HREF="#fd_dtype_eval"><TT STYLE="font-size: small;">fd_dtype_eval</TT></A> | <A HREF="#fd_get_portno"><TT STYLE="font-size: small;">fd_get_portno</TT></A> | <A HREF="#fd_http_get"><TT STYLE="font-size: small;">fd_http_get</TT></A> | <A HREF="#fd_http_head"><TT STYLE="font-size: small;">fd_http_head</TT></A> | <A HREF="#fd_http_string"><TT STYLE="font-size: small;">fd_http_string</TT></A> | <A HREF="#fd_init_connection"><TT STYLE="font-size: small;">fd_init_connection</TT></A> | <A HREF="#fd_open_connection"><TT STYLE="font-size: small;">fd_open_connection</TT></A> | <A HREF="#fd_open_local_socket"><TT STYLE="font-size: small;">fd_open_local_socket</TT></A> | <A HREF="#fd_open_tcp_socket
"><TT STYLE="font-size: small;">fd_open_tcp_socket
</TT></A> | <A HREF="#fd_read_from_socket"><TT STYLE="font-size: small;">fd_read_from_socket</TT></A> | <A HREF="#fd_send_smtp_mail"><TT STYLE="font-size: small;">fd_send_smtp_mail</TT></A> | <A HREF="#fd_sendall"><TT STYLE="font-size: small;">fd_sendall</TT></A> | <A HREF="#fd_timed_recv"><TT STYLE="font-size: small;">fd_timed_recv</TT></A> | <A HREF="#fd_trace_dteval"><TT STYLE="font-size: small;">fd_trace_dteval</TT></A> | <A HREF="#fd_try_to_connect"><TT STYLE="font-size: small;">fd_try_to_connect</TT></A> | </TD>
</TR>
<TR>
<TH VALIGN="TOP" ALIGN="LEFT"><A HREF="#i18n.c"><TT>src/os/i18n.c</TT></A></TH><TD VALIGN="TOP" ALIGN="LEFT"><A HREF="#fd_convert_utf8"><TT STYLE="font-size: small;">fd_convert_utf8</TT></A> | <A HREF="#fd_define_encoding
"><TT STYLE="font-size: small;">fd_define_encoding
</TT></A> | <A HREF="#fd_downcase_string"><TT STYLE="font-size: small;">fd_downcase_string</TT></A> | <A HREF="#fd_fgetc"><TT STYLE="font-size: small;">fd_fgetc</TT></A> | <A HREF="#fd_foreign_filestring"><TT STYLE="font-size: small;">fd_foreign_filestring</TT></A> | <A HREF="#fd_fputc"><TT STYLE="font-size: small;">fd_fputc</TT></A> | <A HREF="#fd_fputs_encoded"><TT STYLE="font-size: small;">fd_fputs_encoded</TT></A> | <A HREF="#fd_fputs_raw"><TT STYLE="font-size: small;">fd_fputs_raw</TT></A> | <A HREF="#fd_free_xfile"><TT STYLE="font-size: small;">fd_free_xfile</TT></A> | <A HREF="#fd_get_encoding"><TT STYLE="font-size: small;">fd_get_encoding</TT></A> | <A HREF="#fd_get_file_encoding"><TT STYLE="font-size: small;">fd_get_file_encoding</TT></A> | <A HREF="#fd_get_xfile"><TT STYLE="font-size: small;">fd_get_xfile</TT></A> | <A HREF="#fd_interpret_unicode_escapes"><TT STYLE="font-size: small;">fd_interpret_unicode_escapes</TT></A> | <A HREF="#fd_load_encoding"><TT STYLE="font-size: small;">fd_load_encoding</TT></A> | <A HREF="#fd_localize_utf8"><TT STYLE="font-size: small;">fd_localize_utf8</TT></A> | <A HREF="#fd_make_utf8"><TT STYLE="font-size: small;">fd_make_utf8</TT></A> | <A HREF="#fd_set_default_encoding"><TT STYLE="font-size: small;">fd_set_default_encoding</TT></A> | <A HREF="#fd_set_file_encoding"><TT STYLE="font-size: small;">fd_set_file_encoding</TT></A> | <A HREF="#fd_set_system_encoding"><TT STYLE="font-size: small;">fd_set_system_encoding</TT></A> | <A HREF="#fd_ungetc"><TT STYLE="font-size: small;">fd_ungetc</TT></A> | <A HREF="#fd_upcase_string"><TT STYLE="font-size: small;">fd_upcase_string</TT></A> | <A HREF="#fd_valid_utf8p"><TT STYLE="font-size: small;">fd_valid_utf8p</TT></A> | <A HREF="#fd_xgetc"><TT STYLE="font-size: small;">fd_xgetc</TT></A> | <A HREF="#fd_xgetc_encoded"><TT STYLE="font-size: small;">fd_xgetc_encoded</TT></A> | <A HREF="#fd_xputc"><TT STYLE="font-size: small;">fd_xputc</TT></A> | <A HREF="#fd_xputc_encoded"><TT STYLE="font-size: small;">fd_xputc_encoded</TT></A> | <A HREF="#fd_xungetc"><TT STYLE="font-size: small;">fd_xungetc</TT></A> | </TD>
</TR>
<TR>
<TH VALIGN="TOP" ALIGN="LEFT"><A HREF="#fdmalloc.c"><TT>src/os/fdmalloc.c</TT></A></TH><TD VALIGN="TOP" ALIGN="LEFT"><A HREF="#_fd_qfree"><TT STYLE="font-size: small;">_fd_qfree</TT></A> | <A HREF="#_fd_qmalloc"><TT STYLE="font-size: small;">_fd_qmalloc</TT></A> | <A HREF="#_fd_qmalloc_cons"><TT STYLE="font-size: small;">_fd_qmalloc_cons</TT></A> | <A HREF="#fd_free"><TT STYLE="font-size: small;">fd_free</TT></A> | <A HREF="#fd_free_int_array"><TT STYLE="font-size: small;">fd_free_int_array</TT></A> | <A HREF="#fd_malloc"><TT STYLE="font-size: small;">fd_malloc</TT></A> | <A HREF="#fd_malloc_adjust"><TT STYLE="font-size: small;">fd_malloc_adjust</TT></A> | <A HREF="#fd_malloc_init"><TT STYLE="font-size: small;">fd_malloc_init</TT></A> | <A HREF="#fd_mallocize"><TT STYLE="font-size: small;">fd_mallocize</TT></A> | <A HREF="#fd_memdup"><TT STYLE="font-size: small;">fd_memdup</TT></A> | <A HREF="#fd_realloc"><TT STYLE="font-size: small;">fd_realloc</TT></A> | <A HREF="#fd_strdup"><TT STYLE="font-size: small;">fd_strdup</TT></A> | <A HREF="#fd_xfree"><TT STYLE="font-size: small;">fd_xfree</TT></A> | <A HREF="#fd_xmalloc"><TT STYLE="font-size: small;">fd_xmalloc</TT></A> | <A HREF="#fd_xmemdup"><TT STYLE="font-size: small;">fd_xmemdup</TT></A> | <A HREF="#fd_xrealloc"><TT STYLE="font-size: small;">fd_xrealloc</TT></A> | </TD>
</TR>
<TR>
<TH VALIGN="TOP" ALIGN="LEFT"><A HREF="#except.c"><TT>src/os/except.c</TT></A></TH><TD VALIGN="TOP" ALIGN="LEFT"><A HREF="#_fd_push_jbr"><TT STYLE="font-size: small;">_fd_push_jbr</TT></A> | <A HREF="#fd_ctype_error"><TT STYLE="font-size: small;">fd_ctype_error</TT></A> | <A HREF="#fd_exception_context"><TT STYLE="font-size: small;">fd_exception_context</TT></A> | <A HREF="#fd_exception_context_push"><TT STYLE="font-size: small;">fd_exception_context_push</TT></A> | <A HREF="#fd_pigs_fly"><TT STYLE="font-size: small;">fd_pigs_fly</TT></A> | <A HREF="#fd_raise_detailed_exception"><TT STYLE="font-size: small;">fd_raise_detailed_exception</TT></A> | <A HREF="#fd_raise_exception"><TT STYLE="font-size: small;">fd_raise_exception</TT></A> | <A HREF="#fd_raise_lisp_exception"><TT STYLE="font-size: small;">fd_raise_lisp_exception</TT></A> | <A HREF="#fd_record_type_error"><TT STYLE="font-size: small;">fd_record_type_error</TT></A> | <A HREF="#fd_set_exception"><TT STYLE="font-size: small;">fd_set_exception</TT></A> | <A HREF="#fd_throw"><TT STYLE="font-size: small;">fd_throw</TT></A> | <A HREF="#fd_type_error"><TT STYLE="font-size: small;">fd_type_error</TT></A> | </TD>
</TR>
<TR>
<TH VALIGN="TOP" ALIGN="LEFT"><A HREF="#io.c"><TT>src/cons/io.c</TT></A></TH><TD VALIGN="TOP" ALIGN="LEFT"><A HREF="#_fd_sgetc"><TT STYLE="font-size: small;">_fd_sgetc</TT></A> | <A HREF="#fd_add_dtype_to_file"><TT STYLE="font-size: small;">fd_add_dtype_to_file</TT></A> | <A HREF="#fd_configure_oid_io
"><TT STYLE="font-size: small;">fd_configure_oid_io
</TT></A> | <A HREF="#fd_default_parse_oid"><TT STYLE="font-size: small;">fd_default_parse_oid</TT></A> | <A HREF="#fd_default_print_oid"><TT STYLE="font-size: small;">fd_default_print_oid</TT></A> | <A HREF="#fd_dtype_size"><TT STYLE="font-size: small;">fd_dtype_size</TT></A> | <A HREF="#fd_object_to_string"><TT STYLE="font-size: small;">fd_object_to_string</TT></A> | <A HREF="#fd_parse_arg"><TT STYLE="font-size: small;">fd_parse_arg</TT></A> | <A HREF="#fd_parse_lisp_from_stream"><TT STYLE="font-size: small;">fd_parse_lisp_from_stream</TT></A> | <A HREF="#fd_parse_number"><TT STYLE="font-size: small;">fd_parse_number</TT></A> | <A HREF="#fd_parse_string"><TT STYLE="font-size: small;">fd_parse_string</TT></A> | <A HREF="#fd_print_lisp"><TT STYLE="font-size: small;">fd_print_lisp</TT></A> | <A HREF="#fd_print_lisp_to_stdout"><TT STYLE="font-size: small;">fd_print_lisp_to_stdout</TT></A> | <A HREF="#fd_print_lisp_to_string"><TT STYLE="font-size: small;">fd_print_lisp_to_string</TT></A> | <A HREF="#fd_read_dtype_from_file"><TT STYLE="font-size: small;">fd_read_dtype_from_file</TT></A> | <A HREF="#fd_read_dtypes_from_file"><TT STYLE="font-size: small;">fd_read_dtypes_from_file</TT></A> | <A HREF="#fd_set_bignum_parser"><TT STYLE="font-size: small;">fd_set_bignum_parser</TT></A> | <A HREF="#fd_set_super_pool_aliasing"><TT STYLE="font-size: small;">fd_set_super_pool_aliasing</TT></A> | <A HREF="#fd_validate_dtype"><TT STYLE="font-size: small;">fd_validate_dtype</TT></A> | <A HREF="#fd_write_dtype_to_file"><TT STYLE="font-size: small;">fd_write_dtype_to_file</TT></A> | </TD>
</TR>
<TR>
<TH VALIGN="TOP" ALIGN="LEFT"><A HREF="#file-pool.c"><TT>src/odb/file-pool.c</TT></A></TH><TD VALIGN="TOP" ALIGN="LEFT"><A HREF="#fd_cache_file_pool"><TT STYLE="font-size: small;">fd_cache_file_pool</TT></A> | <A HREF="#fd_file_pool_capacity"><TT STYLE="font-size: small;">fd_file_pool_capacity</TT></A> | <A HREF="#fd_file_pool_freespace"><TT STYLE="font-size: small;">fd_file_pool_freespace</TT></A> | <A HREF="#fd_file_pool_load"><TT STYLE="font-size: small;">fd_file_pool_load</TT></A> | <A HREF="#fd_label_file_pool"><TT STYLE="font-size: small;">fd_label_file_pool</TT></A> | <A HREF="#fd_lock_file_pool"><TT STYLE="font-size: small;">fd_lock_file_pool</TT></A> | <A HREF="#fd_make_file_pool
"><TT STYLE="font-size: small;">fd_make_file_pool
</TT></A> | <A HREF="#fd_make_new_super_pool"><TT STYLE="font-size: small;">fd_make_new_super_pool</TT></A> | <A HREF="#fd_make_pool_snapshot"><TT STYLE="font-size: small;">fd_make_pool_snapshot</TT></A> | <A HREF="#fd_make_super_pool
"><TT STYLE="font-size: small;">fd_make_super_pool
</TT></A> | <A HREF="#fd_new_file_pool
"><TT STYLE="font-size: small;">fd_new_file_pool
</TT></A> | <A HREF="#fd_read_file_pool_metadata
"><TT STYLE="font-size: small;">fd_read_file_pool_metadata
</TT></A> | <A HREF="#fd_register_file_pool_opener"><TT STYLE="font-size: small;">fd_register_file_pool_opener</TT></A> | <A HREF="#fd_use_file_pool"><TT STYLE="font-size: small;">fd_use_file_pool</TT></A> | </TD>
</TR>
<TR>
<TH VALIGN="TOP" ALIGN="LEFT"><A HREF="#search.c"><TT>src/index/search.c</TT></A></TH><TD VALIGN="TOP" ALIGN="LEFT"><A HREF="#fd_find_frames"><TT STYLE="font-size: small;">fd_find_frames</TT></A> | <A HREF="#fd_find_similar"><TT STYLE="font-size: small;">fd_find_similar</TT></A> | <A HREF="#fd_get_frame_features"><TT STYLE="font-size: small;">fd_get_frame_features</TT></A> | <A HREF="#fd_get_slot_features"><TT STYLE="font-size: small;">fd_get_slot_features</TT></A> | <A HREF="#fd_index_frame"><TT STYLE="font-size: small;">fd_index_frame</TT></A> | <A HREF="#fd_index_notice_slot_values
"><TT STYLE="font-size: small;">fd_index_notice_slot_values
</TT></A> | <A HREF="#fd_index_slot_values
"><TT STYLE="font-size: small;">fd_index_slot_values
</TT></A> | <A HREF="#fd_index_slots"><TT STYLE="font-size: small;">fd_index_slots</TT></A> | <A HREF="#fd_score_from_samples
"><TT STYLE="font-size: small;">fd_score_from_samples
</TT></A> | <A HREF="#fd_score_from_spec"><TT STYLE="font-size: small;">fd_score_from_spec</TT></A> | <A HREF="#fd_strict_search"><TT STYLE="font-size: small;">fd_strict_search</TT></A> | </TD>
</TR>

</TABLE>
<A NAME="envfns.c"><H2>
Functions defined in <TT>src/os/envfns.c</TT>
</H2>
</A><P>
<A HREF="#fd_exit"><TT>fd_exit</TT></A> | <A HREF="#fd_get_gid"><TT>fd_get_gid</TT></A> | <A HREF="#fd_get_gname"><TT>fd_get_gname</TT></A> | <A HREF="#fd_get_uid"><TT>fd_get_uid</TT></A> | <A HREF="#fd_get_uname"><TT>fd_get_uname</TT></A> | <A HREF="#fd_get_user_data"><TT>fd_get_user_data</TT></A> | <A HREF="#fd_getenv"><TT>fd_getenv</TT></A> | <A HREF="#fd_getrusage"><TT>fd_getrusage</TT></A> | <A HREF="#fd_inhibit_anti_warranty"><TT>fd_inhibit_anti_warranty</TT></A> | <A HREF="#fd_inhibit_herald"><TT>fd_inhibit_herald</TT></A> | <A HREF="#fd_int_getenv"><TT>fd_int_getenv</TT></A> | <A HREF="#fd_load_config"><TT>fd_load_config</TT></A> | <A HREF="#fd_set_build_date"><TT>fd_set_build_date</TT></A> | <A HREF="#fd_set_gid"><TT>fd_set_gid</TT></A> | <A HREF="#fd_set_random"><TT>fd_set_random</TT></A> | <A HREF="#fd_set_session_mnemonic"><TT>fd_set_session_mnemonic</TT></A> | <A HREF="#fd_set_uid"><TT>fd_set_uid</TT></A> | <A HREF="#fd_string_getenv"><TT>fd_string_getenv</TT></A> | 
</P>
<TABLE CELLPADDING="5">
<TR>
<TH ALIGN="LEFT">Function</TH><TH ALIGN="LEFT">Arguments</TH><TH ALIGN="LEFT">Returns</TH>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_get_uname">fd_get_uname</A></TD><TD CLASS="ccode">uid_t id</TD><TD CLASS="ccode">char * </TD>
</TR>
<TR>
<TH></TH><TD>a uid</TD><TD>a string</TD>
</TR>
<TR>
<TH></TH><TD><EM>Gets the user name for a particular id</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_set_gid">fd_set_gid</A></TD><TD CLASS="ccode">char *gname</TD><TD CLASS="ccode">int </TD>
</TR>
<TR>
<TH></TH><TD>a gid</TD><TD>changes the current group to be name, return 1 if successful</TD>
</TR>
<TR>
<TH></TH><TD><EM></EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_inhibit_herald">fd_inhibit_herald</A></TD><TD CLASS="ccode">int inhibit</TD><TD CLASS="ccode">void </TD>
</TR>
<TR>
<TH></TH><TD>none</TD><TD>void</TD>
</TR>
<TR>
<TH></TH><TD><EM>Keeps the startup and shutdown heralds from being shown</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_get_uid">fd_get_uid</A></TD><TD CLASS="ccode">char *uname</TD><TD CLASS="ccode">uid_t </TD>
</TR>
<TR>
<TH></TH><TD>a string</TD><TD>gets the user ID for a named user</TD>
</TR>
<TR>
<TH></TH><TD><EM></EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_set_build_date">fd_set_build_date</A></TD><TD CLASS="ccode">char *date</TD><TD CLASS="ccode">void </TD>
</TR>
<TR>
<TH></TH><TD>a string</TD><TD>nothing</TD>
</TR>
<TR>
<TH></TH><TD><EM>Sets the build date to be returned by fd_get_build_date</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_int_getenv">fd_int_getenv</A></TD><TD CLASS="ccode">char *var,int dflt</TD><TD CLASS="ccode">int </TD>
</TR>
<TR>
<TH></TH><TD>a string naming a variable and an int default</TD><TD>an int</TD>
</TR>
<TR>
<TH></TH><TD><EM>Gets a variable from the environment.  It first tries the
 top level LISP environment, then the Windows registry (under WIN32),
 and finally the "POSIX" environment.

  Unlike fd_getenv, this doesn't parse the string.</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_get_gid">fd_get_gid</A></TD><TD CLASS="ccode">char *uname</TD><TD CLASS="ccode">gid_t </TD>
</TR>
<TR>
<TH></TH><TD>a string</TD><TD>gets the group ID for a named group</TD>
</TR>
<TR>
<TH></TH><TD><EM></EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_get_gname">fd_get_gname</A></TD><TD CLASS="ccode">gid_t id</TD><TD CLASS="ccode">char * </TD>
</TR>
<TR>
<TH></TH><TD>a gid</TD><TD>a string</TD>
</TR>
<TR>
<TH></TH><TD><EM>Gets the group name for a particular gid</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_exit">fd_exit</A></TD><TD CLASS="ccode">int status</TD><TD CLASS="ccode">void </TD>
</TR>
<TR>
<TH></TH><TD>a status code (an int)</TD><TD>no.</TD>
</TR>
<TR>
<TH></TH><TD><EM>This sets the variable fd_normal_exit to 1 if the status
 code is zero, which can be read by atexit handlers.</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_load_config">fd_load_config</A></TD><TD CLASS="ccode">char *config_file</TD><TD CLASS="ccode">int </TD>
</TR>
<TR>
<TH></TH><TD>a filename (a string)</TD><TD>nothing</TD>
</TR>
<TR>
<TH></TH><TD><EM>Loads the variable bindings defined in the specified
  configuration file, setting the corresponding symbol values</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_inhibit_anti_warranty">fd_inhibit_anti_warranty</A></TD><TD CLASS="ccode">int inhibit</TD><TD CLASS="ccode">void </TD>
</TR>
<TR>
<TH></TH><TD>none</TD><TD>void</TD>
</TR>
<TR>
<TH></TH><TD><EM>Keeps the startup and shutdown heralds from being shown</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_getenv">fd_getenv</A></TD><TD CLASS="ccode">char *var</TD><TD CLASS="ccode">lisp </TD>
</TR>
<TR>
<TH></TH><TD>a string naming a variable</TD><TD>a lisp object</TD>
</TR>
<TR>
<TH></TH><TD><EM>Gets a variable from the environment.  It first tries the
 top level LISP environment, then the Windows registry (under WIN32),
 and finally the "POSIX" environment used by getenv. When the value comes
 from anywhere besides the lisp environment, it is parsed as a LISP argument,
 so that numbers turn into numbers.</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_getrusage">fd_getrusage</A></TD><TD CLASS="ccode">struct rusage *r</TD><TD CLASS="ccode">void </TD>
</TR>
<TR>
<TH></TH><TD>a pointer to an rusage structure</TD><TD>void</TD>
</TR>
<TR>
<TH></TH><TD><EM>Gets rusage information, covering for holes in various
 implementations (currently just Linux)</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_string_getenv">fd_string_getenv</A></TD><TD CLASS="ccode">char *var</TD><TD CLASS="ccode">fd_u8char * </TD>
</TR>
<TR>
<TH></TH><TD>a string naming a variable</TD><TD>a lisp string</TD>
</TR>
<TR>
<TH></TH><TD><EM>Gets a variable from the environment.  It first tries the
 top level LISP environment, then the Windows registry (under WIN32),
 and finally the "POSIX" environment.

  Unlike fd_getenv, this doesn't parse the string.</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_set_random">fd_set_random</A></TD><TD CLASS="ccode">unsigned int seed</TD><TD CLASS="ccode">void </TD>
</TR>
<TR>
<TH></TH><TD>an unsigned int</TD><TD>void</TD>
</TR>
<TR>
<TH></TH><TD><EM>This sets the random seed.</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_set_uid">fd_set_uid</A></TD><TD CLASS="ccode">char *uname</TD><TD CLASS="ccode">int </TD>
</TR>
<TR>
<TH></TH><TD>a uid</TD><TD>changes the current user to be name, return 1 if successful</TD>
</TR>
<TR>
<TH></TH><TD><EM></EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_set_session_mnemonic">fd_set_session_mnemonic</A></TD><TD CLASS="ccode">char *mnemonic</TD><TD CLASS="ccode">void </TD>
</TR>
<TR>
<TH></TH><TD>a string</TD><TD>nothing</TD>
</TR>
<TR>
<TH></TH><TD><EM>Sets the string used to identify this kind of session (e.g. 'fdscript'
or more usefully, 'mailreader')</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_get_user_data">fd_get_user_data</A></TD><TD CLASS="ccode">uid_t id</TD><TD CLASS="ccode">lisp </TD>
</TR>
<TR>
<TH></TH><TD>a uid</TD><TD>a lisp structure</TD>
</TR>
<TR>
<TH></TH><TD><EM>Gets the user password data for a particular id</EM></TD><TD></TD>
</TR>

</TABLE>
<A NAME="fdprintf.c"><H2>
Functions defined in <TT>src/os/fdprintf.c</TT>
</H2>
</A><P>
<A HREF="#_fd_grow_string_stream"><TT>_fd_grow_string_stream</TT></A> | <A HREF="#_fd_sputc"><TT>_fd_sputc</TT></A> | <A HREF="#_fd_sputn"><TT>_fd_sputn</TT></A> | <A HREF="#_fd_sputs"><TT>_fd_sputs</TT></A> | <A HREF="#fd_default_notifier"><TT>fd_default_notifier</TT></A> | <A HREF="#fd_fprintf"><TT>fd_fprintf</TT></A> | <A HREF="#fd_notify"><TT>fd_notify</TT></A> | <A HREF="#fd_printf"><TT>fd_printf</TT></A> | <A HREF="#fd_set_notify_handler"><TT>fd_set_notify_handler</TT></A> | <A HREF="#fd_set_warn_handler"><TT>fd_set_warn_handler</TT></A> | <A HREF="#fd_warn"><TT>fd_warn</TT></A> | <A HREF="#fd_xprintf"><TT>fd_xprintf</TT></A> | 
</P>
<TABLE CELLPADDING="5">
<TR>
<TH ALIGN="LEFT">Function</TH><TH ALIGN="LEFT">Arguments</TH><TH ALIGN="LEFT">Returns</TH>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_default_notifier">fd_default_notifier</A></TD><TD CLASS="ccode">fd_u8char *message</TD><TD CLASS="ccode">void </TD>
</TR>
<TR>
<TH></TH><TD>a string</TD><TD>void</TD>
</TR>
<TR>
<TH></TH><TD><EM>This is the default notification function, which outputs a bracketed
  time and report.</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="_fd_sputc">_fd_sputc</A></TD><TD CLASS="ccode">fd_string_stream ss,int ch</TD><TD CLASS="ccode">void </TD>
</TR>
<TR>
<TH></TH><TD>a pointer to a string stream and a unicode character</TD><TD>void</TD>
</TR>
<TR>
<TH></TH><TD><EM>Writes the utf8 representation of the character to the string stream.</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_xprintf">fd_xprintf</A></TD><TD CLASS="ccode">char *format_string,...</TD><TD CLASS="ccode">void </TD>
</TR>
<TR>
<TH></TH><TD>a format string, and other args</TD><TD>void</TD>
</TR>
<TR>
<TH></TH><TD><EM>Outputs a string as exceptional I/O generated from the format string and
using the provided arguments.  Much like printf (surprise).</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_fprintf">fd_fprintf</A></TD><TD CLASS="ccode">FILE *f,char *fstring,...</TD><TD CLASS="ccode">void </TD>
</TR>
<TR>
<TH></TH><TD>a FILE * stream, a format string, and other args</TD><TD>void</TD>
</TR>
<TR>
<TH></TH><TD><EM>Outputs a string to a file stream generated from the format string and
using the provided arguments.  Much like printf (surprise).</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="_fd_sputn">_fd_sputn</A></TD><TD CLASS="ccode">fd_string_stream ss,fd_u8char *string,int n</TD><TD CLASS="ccode">void </TD>
</TR>
<TR>
<TH></TH><TD>a pointer to a string stream, a utf8 string, and an int</TD><TD>void</TD>
</TR>
<TR>
<TH></TH><TD><EM>Internal string stream string putn function, used in macro
  ssputn</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_notify">fd_notify</A></TD><TD CLASS="ccode">char *format_string,...</TD><TD CLASS="ccode">void </TD>
</TR>
<TR>
<TH></TH><TD>a FILE * stream, a format string, and other args</TD><TD>void</TD>
</TR>
<TR>
<TH></TH><TD><EM>Outputs a string as a notification, which is generated from the format
string and using the provided arguments.  Much like printf (surprise).</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="_fd_sputs">_fd_sputs</A></TD><TD CLASS="ccode">fd_string_stream ss,fd_u8char *string</TD><TD CLASS="ccode">void </TD>
</TR>
<TR>
<TH></TH><TD>a pointer to a string stream and a utf8 string</TD><TD>void</TD>
</TR>
<TR>
<TH></TH><TD><EM>Internal string stream string put function, used in macro
  ssputs</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_printf">fd_printf</A></TD><TD CLASS="ccode">fd_string_stream s,char *format_string,...</TD><TD CLASS="ccode">void </TD>
</TR>
<TR>
<TH></TH><TD>a string stream, a format string, and other args</TD><TD>void</TD>
</TR>
<TR>
<TH></TH><TD><EM>Outputs a string to string stream generated from the format string and
using the provided arguments.  Much like printf (surprise).</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_set_notify_handler">fd_set_notify_handler</A></TD><TD CLASS="ccode">void (*nf</TD><TD CLASS="ccode">void </TD>
</TR>
<TR>
<TH></TH><TD>a function taking a string arg</TD><TD>void</TD>
</TR>
<TR>
<TH></TH><TD><EM>Sets the function which is called on notification messages</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_warn">fd_warn</A></TD><TD CLASS="ccode">char *format_string,...</TD><TD CLASS="ccode">void </TD>
</TR>
<TR>
<TH></TH><TD>a FILE * stream, a format string, and other args</TD><TD>void</TD>
</TR>
<TR>
<TH></TH><TD><EM>Outputs a string as a warning, which is generated from the format
string and using the provided arguments.  Much like printf (surprise).
Note that notifications can be turned off but warnings cannot.</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="_fd_grow_string_stream">_fd_grow_string_stream</A></TD><TD CLASS="ccode">fd_string_stream ss,int delta</TD><TD CLASS="ccode">void </TD>
</TR>
<TR>
<TH></TH><TD>a pointer to a string stream and a number of bytes</TD><TD>void</TD>
</TR>
<TR>
<TH></TH><TD><EM>Grows the data structures for the string stream to include delta
more bytes</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_set_warn_handler">fd_set_warn_handler</A></TD><TD CLASS="ccode">void (*wf</TD><TD CLASS="ccode">void </TD>
</TR>
<TR>
<TH></TH><TD>a function taking a string arg</TD><TD>void</TD>
</TR>
<TR>
<TH></TH><TD><EM>Sets the function which is called on warning messages</EM></TD><TD></TD>
</TR>

</TABLE>
<A NAME="timefns.c"><H2>
Functions defined in <TT>src/os/timefns.c</TT>
</H2>
</A><P>
<A HREF="#fd_breakup_time"><TT>fd_breakup_time</TT></A> | <A HREF="#fd_get_now"><TT>fd_get_now</TT></A> | <A HREF="#fd_init_xtime"><TT>fd_init_xtime</TT></A> | <A HREF="#fd_iso8601_to_xtime"><TT>fd_iso8601_to_xtime</TT></A> | <A HREF="#fd_localtime"><TT>fd_localtime</TT></A> | <A HREF="#fd_mktime"><TT>fd_mktime</TT></A> | <A HREF="#fd_parse_iso8601"><TT>fd_parse_iso8601</TT></A> | <A HREF="#fd_parse_tzspec"><TT>fd_parse_tzspec</TT></A> | <A HREF="#fd_sleep"><TT>fd_sleep</TT></A> | <A HREF="#fd_timestamp_time"><TT>fd_timestamp_time</TT></A> | <A HREF="#fd_timestamp_to_xtime"><TT>fd_timestamp_to_xtime</TT></A> | <A HREF="#fd_xtime_to_iso8601"><TT>fd_xtime_to_iso8601</TT></A> | <A HREF="#fd_xtime_to_timestamp"><TT>fd_xtime_to_timestamp</TT></A> | 
</P>
<TABLE CELLPADDING="5">
<TR>
<TH ALIGN="LEFT">Function</TH><TH ALIGN="LEFT">Arguments</TH><TH ALIGN="LEFT">Returns</TH>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_init_xtime">fd_init_xtime</A></TD><TD CLASS="ccode">struct FD_XTIME *xtp</TD><TD CLASS="ccode">void </TD>
</TR>
<TR>
<TH></TH><TD>a pointer to an extended timestamp structure</TD><TD>void</TD>
</TR>
<TR>
<TH></TH><TD><EM>This takes a timestamp object and fills out an extended time pointer
structure which includes timezone and precision information.</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_parse_tzspec">fd_parse_tzspec</A></TD><TD CLASS="ccode">char *s,int dflt</TD><TD CLASS="ccode">int </TD>
</TR>
<TR>
<TH></TH><TD>a string and a default offset</TD><TD>an offset from UTC</TD>
</TR>
<TR>
<TH></TH><TD><EM>This uses a built in table but should really use operating system
facilities if they were even remotely standardized.</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_sleep">fd_sleep</A></TD><TD CLASS="ccode">double secs</TD><TD CLASS="ccode">void </TD>
</TR>
<TR>
<TH></TH><TD>an interval in seconds (a double)</TD><TD>nothing</TD>
</TR>
<TR>
<TH></TH><TD><EM>This is a platform abstraction for sleeping that *may*
allow sub-second sleeps.</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_mktime">fd_mktime</A></TD><TD CLASS="ccode">struct tm *tptr,int tzoff</TD><TD CLASS="ccode">time_t </TD>
</TR>
<TR>
<TH></TH><TD>a pointer to a tm struct and a time offset (from UTC) in seconds</TD><TD>a time_t pointer</TD>
</TR>
<TR>
<TH></TH><TD><EM>Returns the UTC time given a filled out tm structure and the offset of the
zone it was filled out in from UTC.</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_breakup_time">fd_breakup_time</A></TD><TD CLASS="ccode">struct tm *tptr,time_t tick,int tzoff</TD><TD CLASS="ccode">int </TD>
</TR>
<TR>
<TH></TH><TD>a pointer to a tm struct, a time_t value, and an offset</TD><TD>an integral timezone offset</TD>
</TR>
<TR>
<TH></TH><TD><EM>Fills the tm struct with the broken down UTC time based on the time_t value.
This is threadsafe, locking the possible shared tptr.</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_timestamp_time">fd_timestamp_time</A></TD><TD CLASS="ccode">lisp timestamp</TD><TD CLASS="ccode">time_t </TD>
</TR>
<TR>
<TH></TH><TD>a lisp pointer to a timestamp</TD><TD>a time_t value</TD>
</TR>
<TR>
<TH></TH><TD><EM></EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_xtime_to_timestamp">fd_xtime_to_timestamp</A></TD><TD CLASS="ccode">struct FD_XTIME *xtp</TD><TD CLASS="ccode">fd_lisp </TD>
</TR>
<TR>
<TH></TH><TD>a string and a pointer to a timestamp structure</TD><TD>-1 on error, the time as a time_t otherwise</TD>
</TR>
<TR>
<TH></TH><TD><EM>This takes an iso8601 string and fills out an extended time pointer which
includes possible timezone and precision information.</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_iso8601_to_xtime">fd_iso8601_to_xtime</A></TD><TD CLASS="ccode">char *s,struct FD_XTIME *xtp</TD><TD CLASS="ccode">time_t </TD>
</TR>
<TR>
<TH></TH><TD>a string and a pointer to a timestamp structure</TD><TD>-1 on error, the time as a time_t otherwise</TD>
</TR>
<TR>
<TH></TH><TD><EM>This takes an iso8601 string and fills out an extended time pointer which
includes possible timezone and precision information.</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_parse_iso8601">fd_parse_iso8601</A></TD><TD CLASS="ccode">char *string</TD><TD CLASS="ccode">time_t </TD>
</TR>
<TR>
<TH></TH><TD>a string</TD><TD>a time_t</TD>
</TR>
<TR>
<TH></TH><TD><EM>Parses an iso8601 format date/time string into a time_t value.</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_timestamp_to_xtime">fd_timestamp_to_xtime</A></TD><TD CLASS="ccode">fd_lisp timestamp,struct FD_XTIME *xtp</TD><TD CLASS="ccode">time_t </TD>
</TR>
<TR>
<TH></TH><TD>a lisp pointer to a timestamp and a pointer to a timestamp structure</TD><TD>-1 on error, the time as a time_t otherwise</TD>
</TR>
<TR>
<TH></TH><TD><EM>This takes a timestamp object and fills out an extended time pointer
structure which includes timezone and precision information.</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_xtime_to_iso8601">fd_xtime_to_iso8601</A></TD><TD CLASS="ccode">struct FD_XTIME *xtp,fd_string_stream ss</TD><TD CLASS="ccode">int </TD>
</TR>
<TR>
<TH></TH><TD>a timestamp and a pointer to a string stream</TD><TD>-1 on error, the time as a time_t otherwise</TD>
</TR>
<TR>
<TH></TH><TD><EM>This takes an iso8601 string and fills out an extended time pointer which
includes possible timezone and precision information.</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_get_now">fd_get_now</A></TD><TD CLASS="ccode">struct FD_XTIME *xtp</TD><TD CLASS="ccode">time_t </TD>
</TR>
<TR>
<TH></TH><TD>a pointer to an extended time pointer</TD><TD>a time_t or -1 if it fails for some reason</TD>
</TR>
<TR>
<TH></TH><TD><EM>This will try and get the finest precision time it can.</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_localtime">fd_localtime</A></TD><TD CLASS="ccode">struct tm *tptr,time_t tick</TD><TD CLASS="ccode">int </TD>
</TR>
<TR>
<TH></TH><TD>a pointer to a tm struct and a time_t value</TD><TD>the time_t value or -1 if it failed</TD>
</TR>
<TR>
<TH></TH><TD><EM>Fills the tm struct with the local time based on the time_t value.
This is threadsafe, since localtime is not.</EM></TD><TD></TD>
</TR>

</TABLE>
<A NAME="except.c"><H2>
Functions defined in <TT>src/os/except.c</TT>
</H2>
</A><P>
<A HREF="#_fd_push_jbr"><TT>_fd_push_jbr</TT></A> | <A HREF="#fd_ctype_error"><TT>fd_ctype_error</TT></A> | <A HREF="#fd_exception_context"><TT>fd_exception_context</TT></A> | <A HREF="#fd_exception_context_push"><TT>fd_exception_context_push</TT></A> | <A HREF="#fd_pigs_fly"><TT>fd_pigs_fly</TT></A> | <A HREF="#fd_raise_detailed_exception"><TT>fd_raise_detailed_exception</TT></A> | <A HREF="#fd_raise_exception"><TT>fd_raise_exception</TT></A> | <A HREF="#fd_raise_lisp_exception"><TT>fd_raise_lisp_exception</TT></A> | <A HREF="#fd_record_type_error"><TT>fd_record_type_error</TT></A> | <A HREF="#fd_set_exception"><TT>fd_set_exception</TT></A> | <A HREF="#fd_throw"><TT>fd_throw</TT></A> | <A HREF="#fd_type_error"><TT>fd_type_error</TT></A> | 
</P>
<TABLE CELLPADDING="5">
<TR>
<TH ALIGN="LEFT">Function</TH><TH ALIGN="LEFT">Arguments</TH><TH ALIGN="LEFT">Returns</TH>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_raise_detailed_exception">fd_raise_detailed_exception</A></TD><TD CLASS="ccode">fd_exception ex,char *details</TD><TD CLASS="ccode">void </TD>
</TR>
<TR>
<TH></TH><TD>an exception (a string) and details (another string)</TD><TD>no.</TD>
</TR>
<TR>
<TH></TH><TD><EM>Raises an exception of a particular kind with particular
details used in generating exception reports
  Unhandled crises cause an exit by calling unhandled_exception.</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_raise_lisp_exception">fd_raise_lisp_exception</A></TD><TD CLASS="ccode">fd_exception ex,char *details,lisp obj</TD><TD CLASS="ccode">void </TD>
</TR>
<TR>
<TH></TH><TD>an exception (a string), details (another string), 
               and a lisp object</TD><TD>no.</TD>
</TR>
<TR>
<TH></TH><TD><EM>Raises an exception of a particular kind with particular
details used in generating exception reports and an associated
lisp object (the irritant)
  Unhandled crises cause an exit by calling unhandled_exception.</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_raise_exception">fd_raise_exception</A></TD><TD CLASS="ccode">fd_exception ex</TD><TD CLASS="ccode">void </TD>
</TR>
<TR>
<TH></TH><TD>an exception (a string)</TD><TD>no.</TD>
</TR>
<TR>
<TH></TH><TD><EM>Raises an exception of a particular kind without providing any
other information.
  Unhandled crises cause an exit by calling unhandled_exception.</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_set_exception">fd_set_exception</A></TD><TD CLASS="ccode">fd_exception ex,fd_u8char *details,lisp object</TD><TD CLASS="ccode">void </TD>
</TR>
<TR>
<TH></TH><TD>an exception (a string), a details string, and a lisp object</TD><TD>nothing</TD>
</TR>
<TR>
<TH></TH><TD><EM>Set's the current threads exception information.</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_exception_context">fd_exception_context</A></TD><TD CLASS="ccode">int force</TD><TD CLASS="ccode">struct FD_EXCEPTION_CONTEXT * </TD>
</TR>
<TR>
<TH></TH><TD>none</TD><TD>a pointer to a FD_EXCEPTION_CONTEXT struct</TD>
</TR>
<TR>
<TH></TH><TD><EM></EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_ctype_error">fd_ctype_error</A></TD><TD CLASS="ccode">char *c_context,fd_u8char *details,lisp obj</TD><TD CLASS="ccode">void </TD>
</TR>
<TR>
<TH></TH><TD>details text (a string), and a lisp object</TD><TD>no.</TD>
</TR>
<TR>
<TH></TH><TD><EM>Raises a type error with particular details and an object.</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_record_type_error">fd_record_type_error</A></TD><TD CLASS="ccode">lisp obj,lisp tag</TD><TD CLASS="ccode">void </TD>
</TR>
<TR>
<TH></TH><TD>details text (a string), and a lisp object</TD><TD>no.</TD>
</TR>
<TR>
<TH></TH><TD><EM>Raises a type error with particular details and an object.</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_pigs_fly">fd_pigs_fly</A></TD><TD CLASS="ccode">fd_u8char *details</TD><TD CLASS="ccode">void </TD>
</TR>
<TR>
<TH></TH><TD>details text (a string)</TD><TD>no.</TD>
</TR>
<TR>
<TH></TH><TD><EM>This is used to signal errors which should never happen.</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="_fd_push_jbr">_fd_push_jbr</A></TD><TD CLASS="ccode">fd_setjmp_rec *jbr</TD><TD CLASS="ccode">void </TD>
</TR>
<TR>
<TH></TH><TD>a setjmp record</TD><TD>void</TD>
</TR>
<TR>
<TH></TH><TD><EM>Adds an entry to the exception handling stack for a particular
  setmp location</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_type_error">fd_type_error</A></TD><TD CLASS="ccode">fd_u8char *details,lisp obj</TD><TD CLASS="ccode">void </TD>
</TR>
<TR>
<TH></TH><TD>details text (a string), and a lisp object</TD><TD>no.</TD>
</TR>
<TR>
<TH></TH><TD><EM>Raises a type error with particular details and an object.</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_exception_context_push">fd_exception_context_push</A></TD><TD CLASS="ccode">lisp sym</TD><TD CLASS="ccode">void </TD>
</TR>
<TR>
<TH></TH><TD>a lisp pointer</TD><TD>void</TD>
</TR>
<TR>
<TH></TH><TD><EM>Adds a value to the current exception context</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_throw">fd_throw</A></TD><TD CLASS="ccode">fd_exception ex,char *details,lisp obj</TD><TD CLASS="ccode">void </TD>
</TR>
<TR>
<TH></TH><TD>an exception (a string), details (another string), 
               and a lisp object</TD><TD>no.</TD>
</TR>
<TR>
<TH></TH><TD><EM>Throws an exception, with particular details and irritant.
   This is used when the exception is expected to be caught, as
   in the use of exceptions to implement continuation.  This is
   identical to fd_raise_lisp_exception but that debuggers may often
   break on fd_raise_lisp_exception and not on fd_throw.</EM></TD><TD></TD>
</TR>

</TABLE>
<A NAME="network.c"><H2>
Functions defined in <TT>src/os/network.c</TT>
</H2>
</A><P>
<A HREF="#fd_careful_dtcall"><TT>fd_careful_dtcall</TT></A> | <A HREF="#fd_careful_dtype_eval"><TT>fd_careful_dtype_eval</TT></A> | <A HREF="#fd_close_connection"><TT>fd_close_connection</TT></A> | <A HREF="#fd_connect"><TT>fd_connect</TT></A> | <A HREF="#fd_dtcall"><TT>fd_dtcall</TT></A> | <A HREF="#fd_dtype_eval"><TT>fd_dtype_eval</TT></A> | <A HREF="#fd_get_portno"><TT>fd_get_portno</TT></A> | <A HREF="#fd_http_get"><TT>fd_http_get</TT></A> | <A HREF="#fd_http_head"><TT>fd_http_head</TT></A> | <A HREF="#fd_http_string"><TT>fd_http_string</TT></A> | <A HREF="#fd_init_connection"><TT>fd_init_connection</TT></A> | <A HREF="#fd_open_connection"><TT>fd_open_connection</TT></A> | <A HREF="#fd_open_local_socket"><TT>fd_open_local_socket</TT></A> | <A HREF="#fd_open_tcp_socket
"><TT>fd_open_tcp_socket
</TT></A> | <A HREF="#fd_read_from_socket"><TT>fd_read_from_socket</TT></A> | <A HREF="#fd_send_smtp_mail"><TT>fd_send_smtp_mail</TT></A> | <A HREF="#fd_sendall"><TT>fd_sendall</TT></A> | <A HREF="#fd_timed_recv"><TT>fd_timed_recv</TT></A> | <A HREF="#fd_trace_dteval"><TT>fd_trace_dteval</TT></A> | <A HREF="#fd_try_to_connect"><TT>fd_try_to_connect</TT></A> | 
</P>
<TABLE CELLPADDING="5">
<TR>
<TH ALIGN="LEFT">Function</TH><TH ALIGN="LEFT">Arguments</TH><TH ALIGN="LEFT">Returns</TH>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_dtype_eval">fd_dtype_eval</A></TD><TD CLASS="ccode">lisp expr,fd_server s</TD><TD CLASS="ccode">lisp </TD>
</TR>
<TR>
<TH></TH><TD>a lisp object and a server</TD><TD>a lisp object</TD>
</TR>
<TR>
<TH></TH><TD><EM>Asks the server to evaluate the lisp object, returning the result
 and trying to restart the connection once if neccessary.</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_sendall">fd_sendall</A></TD><TD CLASS="ccode">int socket,char *buf,int size,int flags</TD><TD CLASS="ccode">int </TD>
</TR>
<TR>
<TH></TH><TD>a socket, a pointer to a block of data, 
                 the length of the block of data, and
		 flags to pass to send()</TD><TD>either zero or -1 (indictating an error)</TD>
</TR>
<TR>
<TH></TH><TD><EM>This sends all of the bytes in a block of data, repeatedly
calling send().  This will return -1, indicating a failure, if
the attempt to write times out.</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_init_connection">fd_init_connection</A></TD><TD CLASS="ccode">fd_server server,char *dest,int port,char *id</TD><TD CLASS="ccode">void </TD>
</TR>
<TR>
<TH></TH><TD>a pointer to an FD_SERVER struct,
               a host (a string), a port (an int),
	       and an id (a string or NULL)</TD><TD>nothing</TD>
</TR>
<TR>
<TH></TH><TD><EM>Initializations a TCP/IP connection structure.</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_dtcall">fd_dtcall</A></TD><TD CLASS="ccode">fd_server s,char *fcn,...</TD><TD CLASS="ccode">lisp </TD>
</TR>
<TR>
<TH></TH><TD>a server, a function name (a string), 
               and a number of args ending with FD_VOID</TD><TD>a lisp object</TD>
</TR>
<TR>
<TH></TH><TD><EM>Asks the server to apply the named function to the args,
 returning the result.  It calls fd_dtype_eval.  The arguments
 are quoted before being passed.</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_try_to_connect">fd_try_to_connect</A></TD><TD CLASS="ccode">char *spec</TD><TD CLASS="ccode">fd_server </TD>
</TR>
<TR>
<TH></TH><TD>a string identifying a server</TD><TD>a server</TD>
</TR>
<TR>
<TH></TH><TD><EM>Tries to make a connection to a particular server, returning NULL
if it fails.
  The server identification has the form port@host, where
port is either a registered service or is 'touch-tone' encoded to
a port number</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_send_smtp_mail">fd_send_smtp_mail</A></TD><TD CLASS="ccode">char *dest,char *text,lisp fields</TD><TD CLASS="ccode">void </TD>
</TR>
<TR>
<TH></TH><TD>a destination (a string), a contents (a string), and
               a set of fields (a lisp object)</TD><TD>nothing</TD>
</TR>
<TR>
<TH></TH><TD><EM>Uses a local SMTP connection to send mail to a particular individual with
 a particular set of fields and a particular contents.</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_open_tcp_socket
">fd_open_tcp_socket
</A></TD><TD CLASS="ccode">char *hostname,int port,char *id,int signal_error,char **fullname</TD><TD CLASS="ccode">int </TD>
</TR>
<TR>
<TH></TH><TD>a hostname (a string) and a port (an int)
                and an id (a string) and an error flag (an int)</TD><TD>an open socket</TD>
</TR>
<TR>
<TH></TH><TD><EM>This utility function gets an open TCP socket for a host and port.</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_close_connection">fd_close_connection</A></TD><TD CLASS="ccode">fd_server s</TD><TD CLASS="ccode">void </TD>
</TR>
<TR>
<TH></TH><TD>a server</TD><TD>nothing</TD>
</TR>
<TR>
<TH></TH><TD><EM>Closes the connection to server.
  This just does a close on the socket and nothing clever to
ensure that pending transactions are completed (though they should
throw out and restart).</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_careful_dtcall">fd_careful_dtcall</A></TD><TD CLASS="ccode">fd_server s,char *fcn,...</TD><TD CLASS="ccode">lisp </TD>
</TR>
<TR>
<TH></TH><TD>a server, a function name (a string), 
               and a number of args ending with FD_VOID</TD><TD>a lisp object</TD>
</TR>
<TR>
<TH></TH><TD><EM>Like fd_dtcall, but signals an error when the remote server
returns an error object.</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_timed_recv">fd_timed_recv</A></TD><TD CLASS="ccode">int secs,int socket_id,char *data,int len,int flags</TD><TD CLASS="ccode">int </TD>
</TR>
<TR>
<TH></TH><TD>an interval in seconds (an int), an open socket,
                 a pointer to a block of data, a number of bytes,
                 and some flags (an int) for recv()</TD><TD>the number of bytes read or -1 on error</TD>
</TR>
<TR>
<TH></TH><TD><EM>Tries to read bytes from a connection, returning -1 if the
   connection times out.</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_connect">fd_connect</A></TD><TD CLASS="ccode">char *spec</TD><TD CLASS="ccode">fd_server </TD>
</TR>
<TR>
<TH></TH><TD>a string identifying a server</TD><TD>a server</TD>
</TR>
<TR>
<TH></TH><TD><EM>Makes a connection to a particular server, signalling an error
if a connection cannot be made.
  The server identification has the form port@host, where
port is either a registered service or is 'touch-tone' encoded to
a port number</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_http_get">fd_http_get</A></TD><TD CLASS="ccode">char *url,int *sizep</TD><TD CLASS="ccode">char * </TD>
</TR>
<TR>
<TH></TH><TD>a string and a pointer to an int</TD><TD>a string (actually a pointer to a byte array)</TD>
</TR>
<TR>
<TH></TH><TD><EM>Gets the contents of a remote URL as a character string, storing the
size in the second argument (if non-NULL)</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_open_local_socket">fd_open_local_socket</A></TD><TD CLASS="ccode">char *filename,char *id,int signal_error</TD><TD CLASS="ccode">int </TD>
</TR>
<TR>
<TH></TH><TD>a filename (a string) and a server id (a string) and an error flag (an int)</TD><TD>an open socket</TD>
</TR>
<TR>
<TH></TH><TD><EM>This utility function gets an open socket for a local filenname.</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_http_head">fd_http_head</A></TD><TD CLASS="ccode">char *url,int *sizep</TD><TD CLASS="ccode">char * </TD>
</TR>
<TR>
<TH></TH><TD>a string and a pointer to an int</TD><TD>a string (actually a pointer to a byte array)</TD>
</TR>
<TR>
<TH></TH><TD><EM>Gets the head of a remote URL as a character string</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_open_connection">fd_open_connection</A></TD><TD CLASS="ccode">char *name,int port,char *id</TD><TD CLASS="ccode">fd_server </TD>
</TR>
<TR>
<TH></TH><TD>a name (a string), a port (an int) and an id (a string)</TD><TD>a server (a pointer to a FD_SERVER struct)</TD>
</TR>
<TR>
<TH></TH><TD><EM>Looks for a current connection to port@hostname and creates one
if it doesn't exist.</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_read_from_socket">fd_read_from_socket</A></TD><TD CLASS="ccode">struct FD_DBUF *buf,int socket</TD><TD CLASS="ccode">void </TD>
</TR>
<TR>
<TH></TH><TD>a pointer to an FD_DBUF struct and a socket</TD><TD>nothing (void)</TD>
</TR>
<TR>
<TH></TH><TD><EM>This fills the expandable FD_DBUF struct with bytes read from
socket, stopping when recv() return 0 or the call to recv times out.</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_careful_dtype_eval">fd_careful_dtype_eval</A></TD><TD CLASS="ccode">lisp expr,fd_server s</TD><TD CLASS="ccode">lisp </TD>
</TR>
<TR>
<TH></TH><TD>a lisp object and a server</TD><TD>a lisp object</TD>
</TR>
<TR>
<TH></TH><TD><EM>Like fd_dtype_eval but signals an error if the remote server
returns an error or exception object.</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_get_portno">fd_get_portno</A></TD><TD CLASS="ccode">char *string</TD><TD CLASS="ccode">int </TD>
</TR>
<TR>
<TH></TH><TD>a string</TD><TD>an integer</TD>
</TR>
<TR>
<TH></TH><TD><EM>Returns the port number identified by a particular string,
starting with the service database and doing touch-tone encoding
if that fails.</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_trace_dteval">fd_trace_dteval</A></TD><TD CLASS="ccode">int flag</TD><TD CLASS="ccode">int </TD>
</TR>
<TR>
<TH></TH><TD>1 or 0</TD><TD>1 or 0</TD>
</TR>
<TR>
<TH></TH><TD><EM>Turns on tracing of all remote DTYPE evaluation activity.</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_http_string">fd_http_string</A></TD><TD CLASS="ccode">char *url</TD><TD CLASS="ccode">char * </TD>
</TR>
<TR>
<TH></TH><TD>a string</TD><TD>a string (actually a pointer to a byte array)</TD>
</TR>
<TR>
<TH></TH><TD><EM>Gets the contents of a remote URL as a character string, storing the
size in the second argument</EM></TD><TD></TD>
</TR>

</TABLE>
<A NAME="filefns.c"><H2>
Functions defined in <TT>src/os/filefns.c</TT>
</H2>
</A><P>
<A HREF="#fd_directoryp"><TT>fd_directoryp</TT></A> | <A HREF="#fd_fclose"><TT>fd_fclose</TT></A> | <A HREF="#fd_file_existsp"><TT>fd_file_existsp</TT></A> | <A HREF="#fd_file_size"><TT>fd_file_size</TT></A> | <A HREF="#fd_file_writablep"><TT>fd_file_writablep</TT></A> | <A HREF="#fd_find_file"><TT>fd_find_file</TT></A> | <A HREF="#fd_fopen"><TT>fd_fopen</TT></A> | <A HREF="#fd_fopen_locked"><TT>fd_fopen_locked</TT></A> | <A HREF="#fd_get_exec_filename"><TT>fd_get_exec_filename</TT></A> | <A HREF="#fd_getpath"><TT>fd_getpath</TT></A> | <A HREF="#fd_regular_filep"><TT>fd_regular_filep</TT></A> | <A HREF="#fd_symbolic_linkp"><TT>fd_symbolic_linkp</TT></A> | 
</P>
<TABLE CELLPADDING="5">
<TR>
<TH ALIGN="LEFT">Function</TH><TH ALIGN="LEFT">Arguments</TH><TH ALIGN="LEFT">Returns</TH>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_file_size">fd_file_size</A></TD><TD CLASS="ccode">fd_u8char *path</TD><TD CLASS="ccode">off_t </TD>
</TR>
<TR>
<TH></TH><TD>a string</TD><TD>a long</TD>
</TR>
<TR>
<TH></TH><TD><EM>Returns the size of a file</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_fclose">fd_fclose</A></TD><TD CLASS="ccode">FILE *stream</TD><TD CLASS="ccode">void </TD>
</TR>
<TR>
<TH></TH><TD>a filename</TD><TD>a FILE * pointer</TD>
</TR>
<TR>
<TH></TH><TD><EM>Closes the stream and cleans up XFILEs associated with it</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_getpath">fd_getpath</A></TD><TD CLASS="ccode">fd_u8char *name</TD><TD CLASS="ccode">lisp </TD>
</TR>
<TR>
<TH></TH><TD>a string naming an extended environment variable</TD><TD>a lisp pointer to a list of directories</TD>
</TR>
<TR>
<TH></TH><TD><EM>Interprets a path variable</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_symbolic_linkp">fd_symbolic_linkp</A></TD><TD CLASS="ccode">fd_u8char *path</TD><TD CLASS="ccode">int </TD>
</TR>
<TR>
<TH></TH><TD>a string</TD><TD>1 or 0</TD>
</TR>
<TR>
<TH></TH><TD><EM>Returns 1 if the file is a symbolic link to another file
     (currently always zero under WIN32).</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_get_exec_filename">fd_get_exec_filename</A></TD><TD CLASS="ccode">char *argv0</TD><TD CLASS="ccode">char * </TD>
</TR>
<TR>
<TH></TH><TD>a string, typicallying argv[0]</TD><TD>a malloc'd absolute filename or NULL</TD>
</TR>
<TR>
<TH></TH><TD><EM>Attempts to figure out the absolute pathname of an
 executable from the argv[0] parameter.  Used to find
 the FramerD configuration file.</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_fopen_locked">fd_fopen_locked</A></TD><TD CLASS="ccode">fd_u8char *filename,char *mode,int allow_readers</TD><TD CLASS="ccode">FILE * </TD>
</TR>
<TR>
<TH></TH><TD>a filename, a mode specifier, and a flag (1 or 0)</TD><TD>a FILE * pointer</TD>
</TR>
<TR>
<TH></TH><TD><EM>Normalizes the filename for the OS and locks the returned stream
  (using fcntl).  If the integer flag is 1, the lock is only a write
  lock.  If it is 0, neither reads nor writes are permitted.</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_find_file">fd_find_file</A></TD><TD CLASS="ccode">fd_u8char *filename,lisp search_path</TD><TD CLASS="ccode">fd_u8char * </TD>
</TR>
<TR>
<TH></TH><TD>a string and a lisp pointer</TD><TD>another string</TD>
</TR>
<TR>
<TH></TH><TD><EM>The lisp pointer is used as a search path to look for files.
  It first checks to see if the string exists as a file as given.
  It then searches along the directories in the search path.
  The search path can be a string (taken as a directory name)
   or a list of strings take as directory names. 
  It allocates a string for a result (but doesn't count it as fd_mallocd).</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_directoryp">fd_directoryp</A></TD><TD CLASS="ccode">fd_u8char *path</TD><TD CLASS="ccode">int </TD>
</TR>
<TR>
<TH></TH><TD>a string</TD><TD>1 or 0</TD>
</TR>
<TR>
<TH></TH><TD><EM>Returns 1 if the file is actually a directory.</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_file_writablep">fd_file_writablep</A></TD><TD CLASS="ccode">fd_u8char *filename</TD><TD CLASS="ccode">int </TD>
</TR>
<TR>
<TH></TH><TD>a string</TD><TD>1 or 0</TD>
</TR>
<TR>
<TH></TH><TD><EM>Returns 1 if the file can be written (whether it exists or not),
      0 otherwise. Actually opens it to try, rather than doing something
       clever with stat.</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_regular_filep">fd_regular_filep</A></TD><TD CLASS="ccode">fd_u8char *path</TD><TD CLASS="ccode">int </TD>
</TR>
<TR>
<TH></TH><TD>a string</TD><TD>1 or 0</TD>
</TR>
<TR>
<TH></TH><TD><EM>Returns 1 if the file is a regular file.</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_file_existsp">fd_file_existsp</A></TD><TD CLASS="ccode">fd_u8char *fname</TD><TD CLASS="ccode">int </TD>
</TR>
<TR>
<TH></TH><TD>a string</TD><TD>1 or 0</TD>
</TR>
<TR>
<TH></TH><TD><EM>Returns 1 if the file exists, 0 otherwise. Uses stat.</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_fopen">fd_fopen</A></TD><TD CLASS="ccode">fd_u8char *filename,char *mode</TD><TD CLASS="ccode">FILE * </TD>
</TR>
<TR>
<TH></TH><TD>a filename and a mode specifier</TD><TD>a FILE * pointer</TD>
</TR>
<TR>
<TH></TH><TD><EM>Normalizes the filename for the OS</EM></TD><TD></TD>
</TR>

</TABLE>
<A NAME="i18n.c"><H2>
Functions defined in <TT>src/os/i18n.c</TT>
</H2>
</A><P>
<A HREF="#fd_convert_utf8"><TT>fd_convert_utf8</TT></A> | <A HREF="#fd_define_encoding
"><TT>fd_define_encoding
</TT></A> | <A HREF="#fd_downcase_string"><TT>fd_downcase_string</TT></A> | <A HREF="#fd_fgetc"><TT>fd_fgetc</TT></A> | <A HREF="#fd_foreign_filestring"><TT>fd_foreign_filestring</TT></A> | <A HREF="#fd_fputc"><TT>fd_fputc</TT></A> | <A HREF="#fd_fputs_encoded"><TT>fd_fputs_encoded</TT></A> | <A HREF="#fd_fputs_raw"><TT>fd_fputs_raw</TT></A> | <A HREF="#fd_free_xfile"><TT>fd_free_xfile</TT></A> | <A HREF="#fd_get_encoding"><TT>fd_get_encoding</TT></A> | <A HREF="#fd_get_file_encoding"><TT>fd_get_file_encoding</TT></A> | <A HREF="#fd_get_xfile"><TT>fd_get_xfile</TT></A> | <A HREF="#fd_interpret_unicode_escapes"><TT>fd_interpret_unicode_escapes</TT></A> | <A HREF="#fd_load_encoding"><TT>fd_load_encoding</TT></A> | <A HREF="#fd_localize_utf8"><TT>fd_localize_utf8</TT></A> | <A HREF="#fd_make_utf8"><TT>fd_make_utf8</TT></A> | <A HREF="#fd_set_default_encoding"><TT>fd_set_default_encoding</TT></A> | <A HREF="#fd_set_file_encoding"><TT>fd_set_file_encoding</TT></A> | <A HREF="#fd_set_system_encoding"><TT>fd_set_system_encoding</TT></A> | <A HREF="#fd_ungetc"><TT>fd_ungetc</TT></A> | <A HREF="#fd_upcase_string"><TT>fd_upcase_string</TT></A> | <A HREF="#fd_valid_utf8p"><TT>fd_valid_utf8p</TT></A> | <A HREF="#fd_xgetc"><TT>fd_xgetc</TT></A> | <A HREF="#fd_xgetc_encoded"><TT>fd_xgetc_encoded</TT></A> | <A HREF="#fd_xputc"><TT>fd_xputc</TT></A> | <A HREF="#fd_xputc_encoded"><TT>fd_xputc_encoded</TT></A> | <A HREF="#fd_xungetc"><TT>fd_xungetc</TT></A> | 
</P>
<TABLE CELLPADDING="5">
<TR>
<TH ALIGN="LEFT">Function</TH><TH ALIGN="LEFT">Arguments</TH><TH ALIGN="LEFT">Returns</TH>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_foreign_filestring">fd_foreign_filestring</A></TD><TD CLASS="ccode">char *filename,struct FD_TEXT_ENCODING *e</TD><TD CLASS="ccode">lisp </TD>
</TR>
<TR>
<TH></TH><TD>a filename (a localized string) and a text encoding</TD><TD>a utf-8 string</TD>
</TR>
<TR>
<TH></TH><TD><EM>Interprets the contents of the file according to the encoding and
 returns a UTF-8 encoded unicode string.</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_upcase_string">fd_upcase_string</A></TD><TD CLASS="ccode">fd_u8char *string,int len</TD><TD CLASS="ccode">fd_u8char * </TD>
</TR>
<TR>
<TH></TH><TD>a utf8 string</TD><TD>a copy of the argument converted to upper case</TD>
</TR>
<TR>
<TH></TH><TD><EM></EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_get_file_encoding">fd_get_file_encoding</A></TD><TD CLASS="ccode">FILE *f</TD><TD CLASS="ccode">struct FD_TEXT_ENCODING * </TD>
</TR>
<TR>
<TH></TH><TD>a FILE pointer</TD><TD>a pointer to an encoding struct or NULL</TD>
</TR>
<TR>
<TH></TH><TD><EM>Returns the encoding associated with a particular file stream.</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_valid_utf8p">fd_valid_utf8p</A></TD><TD CLASS="ccode">fd_u8char *s</TD><TD CLASS="ccode">int </TD>
</TR>
<TR>
<TH></TH><TD>a possible utf8 string</TD><TD>1 if the string is valid, 0 otherwise.</TD>
</TR>
<TR>
<TH></TH><TD><EM></EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_fputs_encoded">fd_fputs_encoded</A></TD><TD CLASS="ccode">fd_u8char *s,int len,FILE *f</TD><TD CLASS="ccode">void </TD>
</TR>
<TR>
<TH></TH><TD>a utf8 string and a FILE pointer</TD><TD>nothing</TD>
</TR>
<TR>
<TH></TH><TD><EM>Writes the contents of the string to the XFILE, writing
unhandled characters with unicode (\u and \U escapes).</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_fputc">fd_fputc</A></TD><TD CLASS="ccode">xchar c,FILE *f</TD><TD CLASS="ccode">void </TD>
</TR>
<TR>
<TH></TH><TD>a wide char and a FILE pointer</TD><TD>void</TD>
</TR>
<TR>
<TH></TH><TD><EM>Writes the character to the FILE stream</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_set_system_encoding">fd_set_system_encoding</A></TD><TD CLASS="ccode">char *name</TD><TD CLASS="ccode">void </TD>
</TR>
<TR>
<TH></TH><TD>an encoding name</TD><TD>void</TD>
</TR>
<TR>
<TH></TH><TD><EM>Sets the encoding used by the operating system
   (e.g. for system calls, filenames, etc)</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_ungetc">fd_ungetc</A></TD><TD CLASS="ccode">int c,FILE *f</TD><TD CLASS="ccode">void </TD>
</TR>
<TR>
<TH></TH><TD>a wide character and a FILE pointer</TD><TD>nothing</TD>
</TR>
<TR>
<TH></TH><TD><EM>Ungets the character on the stream, using its XFILE
structure if possible.</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_set_default_encoding">fd_set_default_encoding</A></TD><TD CLASS="ccode">char *name</TD><TD CLASS="ccode">void </TD>
</TR>
<TR>
<TH></TH><TD>an encoding name</TD><TD>void</TD>
</TR>
<TR>
<TH></TH><TD><EM>Sets the default encoding used for XFILES</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_set_file_encoding">fd_set_file_encoding</A></TD><TD CLASS="ccode">FILE *f,char *name</TD><TD CLASS="ccode">void </TD>
</TR>
<TR>
<TH></TH><TD>a FILE pointer and an ASCII string naming an encoding</TD><TD>void</TD>
</TR>
<TR>
<TH></TH><TD><EM>Sets the encoding for a particular FILE pointer to the encoding
with the specified name.</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_fgetc">fd_fgetc</A></TD><TD CLASS="ccode">FILE *f</TD><TD CLASS="ccode">int </TD>
</TR>
<TR>
<TH></TH><TD>a FILE pointer</TD><TD>a wide character</TD>
</TR>
<TR>
<TH></TH><TD><EM>Returns a wide character from a stream according to its encoding.</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_get_xfile">fd_get_xfile</A></TD><TD CLASS="ccode">FILE *f</TD><TD CLASS="ccode">struct FD_XFILE * </TD>
</TR>
<TR>
<TH></TH><TD>a FILE pointer</TD><TD>an XFILE pointer (or NULL)</TD>
</TR>
<TR>
<TH></TH><TD><EM>Gets the XFILE struct associated with a particular file pointer.</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_fputs_raw">fd_fputs_raw</A></TD><TD CLASS="ccode">fd_u8char *s,int len,FILE *f</TD><TD CLASS="ccode">void </TD>
</TR>
<TR>
<TH></TH><TD>a utf8 string and an XFILE pointer</TD><TD>nothing</TD>
</TR>
<TR>
<TH></TH><TD><EM>Writes the contents of the string to the XFILE, signalling
an error if the stream does not accept any of the characters
in the XFILE.</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_localize_utf8">fd_localize_utf8</A></TD><TD CLASS="ccode">fd_u8char *string,struct FD_TEXT_ENCODING *e</TD><TD CLASS="ccode">unsigned char * </TD>
</TR>
<TR>
<TH></TH><TD>a utf8 encoded string and a text encoding</TD><TD>a regular string</TD>
</TR>
<TR>
<TH></TH><TD><EM>Returns an 8BIT string encoded using the text encoding.</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_xgetc_encoded">fd_xgetc_encoded</A></TD><TD CLASS="ccode">struct FD_XFILE *f</TD><TD CLASS="ccode">int </TD>
</TR>
<TR>
<TH></TH><TD>an XFILE pointer</TD><TD>a wide character</TD>
</TR>
<TR>
<TH></TH><TD><EM>Returns a wide character from a stream according to its encoding.
This will interpret \u and \U escapes in the file.</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_convert_utf8">fd_convert_utf8</A></TD><TD CLASS="ccode">fd_u8char *string,int slen,struct FD_TEXT_ENCODING *e,int *size_loc</TD><TD CLASS="ccode">unsigned char * </TD>
</TR>
<TR>
<TH></TH><TD>a utf8 encoded string and a text encoding</TD><TD>a regular string</TD>
</TR>
<TR>
<TH></TH><TD><EM>Returns an 8BIT string encoded using the text encoding.</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_interpret_unicode_escapes">fd_interpret_unicode_escapes</A></TD><TD CLASS="ccode">fd_u8char *string</TD><TD CLASS="ccode">fd_u8char * </TD>
</TR>
<TR>
<TH></TH><TD>a utf8 string with (potentially) embedded unicode escapes</TD><TD>a utf8 string where those escapes have been expanded</TD>
</TR>
<TR>
<TH></TH><TD><EM></EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_free_xfile">fd_free_xfile</A></TD><TD CLASS="ccode">FILE *f</TD><TD CLASS="ccode">void </TD>
</TR>
<TR>
<TH></TH><TD>an FILE pointer</TD><TD>nothing</TD>
</TR>
<TR>
<TH></TH><TD><EM>Frees the XFILE entry from the linked list of FILE association pointers.</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_load_encoding">fd_load_encoding</A></TD><TD CLASS="ccode">char *name,char *file</TD><TD CLASS="ccode">void </TD>
</TR>
<TR>
<TH></TH><TD>a name and a filename</TD><TD>void</TD>
</TR>
<TR>
<TH></TH><TD><EM>Defines a text encoding based on a text file of byte sequence to
unicode mappings.  This interprets the standard mappings files provided
by the Unicode consortium at ftp://ftp.unicode.org/Public/MAPPINGS/.</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_get_encoding">fd_get_encoding</A></TD><TD CLASS="ccode">char *name</TD><TD CLASS="ccode">struct FD_TEXT_ENCODING * </TD>
</TR>
<TR>
<TH></TH><TD>an ASCII string</TD><TD>a pointer to an FD_TEXT_ENCODING struct</TD>
</TR>
<TR>
<TH></TH><TD><EM>This gets the structure describing a particular encoding given
its ASCII name.</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_xputc">fd_xputc</A></TD><TD CLASS="ccode">xchar c,struct FD_XFILE *f</TD><TD CLASS="ccode">void </TD>
</TR>
<TR>
<TH></TH><TD>a wide char and an XFILE pointer</TD><TD>void</TD>
</TR>
<TR>
<TH></TH><TD><EM>Writes the character to XFILE stream, signalling
an error if the stream cannot handle the character.</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_make_utf8">fd_make_utf8</A></TD><TD CLASS="ccode">uchar *start,uchar *end,struct FD_TEXT_ENCODING *e</TD><TD CLASS="ccode">fd_u8char * </TD>
</TR>
<TR>
<TH></TH><TD>a 8BIT string representation and a text encoding</TD><TD>a utf8 encoded string</TD>
</TR>
<TR>
<TH></TH><TD><EM></EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_xputc_encoded">fd_xputc_encoded</A></TD><TD CLASS="ccode">xchar c,struct FD_XFILE *f</TD><TD CLASS="ccode">void </TD>
</TR>
<TR>
<TH></TH><TD>a wide char and an XFILE pointer</TD><TD>void</TD>
</TR>
<TR>
<TH></TH><TD><EM>Writes the character to XFILE stream, using unicode
escapes if the stream cannot handle the character.</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_downcase_string">fd_downcase_string</A></TD><TD CLASS="ccode">fd_u8char *string,int len</TD><TD CLASS="ccode">fd_u8char * </TD>
</TR>
<TR>
<TH></TH><TD>a utf8 string</TD><TD>a copy of the argument converted to lower case</TD>
</TR>
<TR>
<TH></TH><TD><EM></EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_xungetc">fd_xungetc</A></TD><TD CLASS="ccode">int c,struct FD_XFILE *e</TD><TD CLASS="ccode">void </TD>
</TR>
<TR>
<TH></TH><TD>a wide character and an XFILE pointer</TD><TD>nothing</TD>
</TR>
<TR>
<TH></TH><TD><EM>Ungets the character on an XFILE stream.</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_define_encoding
">fd_define_encoding
</A></TD><TD CLASS="ccode">char *name,struct FD_MB_MAP *charset,int size,
   wc2mb_fn wc2mb,mb2wc_fn mb2wc,int flags</TD><TD CLASS="ccode">int </TD>
</TR>
<TR>
<TH></TH><TD>a name, a pointer to a charset, 
        a wide-char to multi-byte conversion function,
        a multi-byte to wide-char conversion function,
        and a set of flags.</TD><TD>1 if the map was used, zero if it wasn't (mapping was already defined)</TD>
</TR>
<TR>
<TH></TH><TD><EM>Defines an encoding with a name and the associated properties.  If an
encoding with the give properties already exists, the name is added to
that encoding structure.</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_xgetc">fd_xgetc</A></TD><TD CLASS="ccode">struct FD_XFILE *f</TD><TD CLASS="ccode">int </TD>
</TR>
<TR>
<TH></TH><TD>an XFILE pointer</TD><TD>a wide character</TD>
</TR>
<TR>
<TH></TH><TD><EM>Returns a wide character from a stream according to its encoding.
This will *not* interpret \u and \U escapes in the file.</EM></TD><TD></TD>
</TR>

</TABLE>
<A NAME="fdmalloc.c"><H2>
Functions defined in <TT>src/os/fdmalloc.c</TT>
</H2>
</A><P>
<A HREF="#_fd_qfree"><TT>_fd_qfree</TT></A> | <A HREF="#_fd_qmalloc"><TT>_fd_qmalloc</TT></A> | <A HREF="#_fd_qmalloc_cons"><TT>_fd_qmalloc_cons</TT></A> | <A HREF="#fd_free"><TT>fd_free</TT></A> | <A HREF="#fd_free_int_array"><TT>fd_free_int_array</TT></A> | <A HREF="#fd_malloc"><TT>fd_malloc</TT></A> | <A HREF="#fd_malloc_adjust"><TT>fd_malloc_adjust</TT></A> | <A HREF="#fd_malloc_init"><TT>fd_malloc_init</TT></A> | <A HREF="#fd_mallocize"><TT>fd_mallocize</TT></A> | <A HREF="#fd_memdup"><TT>fd_memdup</TT></A> | <A HREF="#fd_realloc"><TT>fd_realloc</TT></A> | <A HREF="#fd_strdup"><TT>fd_strdup</TT></A> | <A HREF="#fd_xfree"><TT>fd_xfree</TT></A> | <A HREF="#fd_xmalloc"><TT>fd_xmalloc</TT></A> | <A HREF="#fd_xmemdup"><TT>fd_xmemdup</TT></A> | <A HREF="#fd_xrealloc"><TT>fd_xrealloc</TT></A> | 
</P>
<TABLE CELLPADDING="5">
<TR>
<TH ALIGN="LEFT">Function</TH><TH ALIGN="LEFT">Arguments</TH><TH ALIGN="LEFT">Returns</TH>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="_fd_qmalloc_cons">_fd_qmalloc_cons</A></TD><TD CLASS="ccode">size_t bytes</TD><TD CLASS="ccode">void * </TD>
</TR>
<TR>
<TH></TH><TD>number of bytes</TD><TD>allocated memory</TD>
</TR>
<TR>
<TH></TH><TD><EM>This also initializes the reference count, assuming
that the result will be a struct whose first int field
is the reference count.</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_xrealloc">fd_xrealloc</A></TD><TD CLASS="ccode">void *oldptr,size_t bytes</TD><TD CLASS="ccode">void * </TD>
</TR>
<TR>
<TH></TH><TD>a pointer and a size</TD><TD>returns a pointer to a memory chunk with at least size bytes</TD>
</TR>
<TR>
<TH></TH><TD><EM>which includes the data of the argument passed in

  This signals an exception if malloc fails.
  It doesn't count the malloc'd bytes</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="_fd_qmalloc">_fd_qmalloc</A></TD><TD CLASS="ccode">size_t bytes</TD><TD CLASS="ccode">void * </TD>
</TR>
<TR>
<TH></TH><TD>number of bytes</TD><TD>allocated memory</TD>
</TR>
<TR>
<TH></TH><TD><EM>This maintains a free list for certain memory sizes and
   allocates them blocks at a time.</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_malloc">fd_malloc</A></TD><TD CLASS="ccode">size_t bytes</TD><TD CLASS="ccode">void * </TD>
</TR>
<TR>
<TH></TH><TD>number of bytes</TD><TD>allocated memory to at least that many bytes</TD>
</TR>
<TR>
<TH></TH><TD><EM>This signals an exception if malloc fails.</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_memdup">fd_memdup</A></TD><TD CLASS="ccode">const char *data,size_t sz</TD><TD CLASS="ccode">char * </TD>
</TR>
<TR>
<TH></TH><TD>a pointer to a chunk of memory and a size</TD><TD>a string</TD>
</TR>
<TR>
<TH></TH><TD><EM>Allocates a new string which is a copy of its argument
 and has the corresponding size.  This will work with
 strings that contain NULLs.
 This will count towards global memory counts and use huge_malloc
  if neccessary.</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_malloc_init">fd_malloc_init</A></TD><TD CLASS="ccode">size_t sz,int chunk_size</TD><TD CLASS="ccode">void </TD>
</TR>
<TR>
<TH></TH><TD>two size_t pointers, struct_size and block_size</TD><TD>void</TD>
</TR>
<TR>
<TH></TH><TD><EM>Arranges for malloc tables to keep a free list of structs
with *struct_size* bytes and to allocate these structs
in blocks of *block_size* to reduce malloc overhead.

This will signal an error if any thread has already copied
the malloc data table.  This isn't neccessary, but just easy
to code right now.</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_xmalloc">fd_xmalloc</A></TD><TD CLASS="ccode">size_t bytes</TD><TD CLASS="ccode">void * </TD>
</TR>
<TR>
<TH></TH><TD>number of bytes</TD><TD>allocated memory to at least that many bytes</TD>
</TR>
<TR>
<TH></TH><TD><EM>This signals an exception if malloc fails.
  It doesn't count the malloc'd bytes, though...</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_xfree">fd_xfree</A></TD><TD CLASS="ccode">void *ptr</TD><TD CLASS="ccode">void </TD>
</TR>
<TR>
<TH></TH><TD>a pointer</TD><TD>void</TD>
</TR>
<TR>
<TH></TH><TD><EM>Doesn't signal an error of pointer is NULL</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_free_int_array">fd_free_int_array</A></TD><TD CLASS="ccode">unsigned int *ptr,size_t size</TD><TD CLASS="ccode">void </TD>
</TR>
<TR>
<TH></TH><TD>a pointer and number of bytes</TD><TD>void</TD>
</TR>
<TR>
<TH></TH><TD><EM>This frees the pointer and bumps the malloc pointer down
   by a number rounded up to the size to FD_STRING_CHUNK.</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_mallocize">fd_mallocize</A></TD><TD CLASS="ccode">char *data,size_t sz</TD><TD CLASS="ccode">char * </TD>
</TR>
<TR>
<TH></TH><TD>a pointer to a chunk of memory and a size</TD><TD>a pointer</TD>
</TR>
<TR>
<TH></TH><TD><EM>Returns a pointer which can be used with the fd_malloc/realloc/free
functions.  This does two things: if the size is large enough to for
calling huge_malloc, it is called, the strings contents is copied, and
the original chunk is freed; in addition, in either the case of a copy or a
pass-through fd_malloc_adjust is called to record the memory take up
by the chunk of memory.</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_xmemdup">fd_xmemdup</A></TD><TD CLASS="ccode">const char *data,size_t sz</TD><TD CLASS="ccode">char * </TD>
</TR>
<TR>
<TH></TH><TD>a pointer to a chunk of data and a size</TD><TD>a string</TD>
</TR>
<TR>
<TH></TH><TD><EM>Allocates a new string which is a copy of its argument
 and has the corresponding size.  This will work with
 strings that contain NULLs.
 This does not count towards the global memory counts.</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_realloc">fd_realloc</A></TD><TD CLASS="ccode">void *ptr,size_t new_size,size_t old_size</TD><TD CLASS="ccode">void * </TD>
</TR>
<TR>
<TH></TH><TD>a pointer and a number of bytes</TD><TD>void</TD>
</TR>
<TR>
<TH></TH><TD><EM>Frees the pointer and updates the memory usage count</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_strdup">fd_strdup</A></TD><TD CLASS="ccode">const char *string</TD><TD CLASS="ccode">char * </TD>
</TR>
<TR>
<TH></TH><TD>a null terminated string</TD><TD>a null terminated string</TD>
</TR>
<TR>
<TH></TH><TD><EM>Allocates a new string which is a copy of its argument.
 This does not count towards the global memory counts.</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_malloc_adjust">fd_malloc_adjust</A></TD><TD CLASS="ccode">int delta</TD><TD CLASS="ccode">void </TD>
</TR>
<TR>
<TH></TH><TD>an int</TD><TD>void</TD>
</TR>
<TR>
<TH></TH><TD><EM>Bumps up the malloc count but doesn't really malloc anything</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="_fd_qfree">_fd_qfree</A></TD><TD CLASS="ccode">void *p,size_t bytes</TD><TD CLASS="ccode">void </TD>
</TR>
<TR>
<TH></TH><TD>a pointer and a number of bytes</TD><TD>void</TD>
</TR>
<TR>
<TH></TH><TD><EM>This frees a cons allocated by fd_qmalloc which tries to
do free list maintainance.</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_free">fd_free</A></TD><TD CLASS="ccode">void *ptr,size_t bytes</TD><TD CLASS="ccode">void </TD>
</TR>
<TR>
<TH></TH><TD>a pointer and a number of bytes</TD><TD>void</TD>
</TR>
<TR>
<TH></TH><TD><EM>Frees the pointer and updates the memory usage count</EM></TD><TD></TD>
</TR>

</TABLE>
{}<A NAME="oids.c"><H2>
Functions defined in <TT>src/cons/oids.c</TT>
</H2>
</A><P>

</P>
<TABLE CELLPADDING="5">
<TR>
<TH ALIGN="LEFT">Function</TH><TH ALIGN="LEFT">Arguments</TH><TH ALIGN="LEFT">Returns</TH>
</TR>

</TABLE>
<A NAME="slotmaps.c"><H2>
Functions defined in <TT>src/cons/slotmaps.c</TT>
</H2>
</A><P>
<A HREF="#_fd_done_with_slotmap_data"><TT>_fd_done_with_slotmap_data</TT></A> | <A HREF="#_fd_slotmap_data"><TT>_fd_slotmap_data</TT></A> | <A HREF="#fd_make_slotmap"><TT>fd_make_slotmap</TT></A> | <A HREF="#fd_slotmap_add"><TT>fd_slotmap_add</TT></A> | <A HREF="#fd_slotmap_get"><TT>fd_slotmap_get</TT></A> | <A HREF="#fd_slotmap_remove"><TT>fd_slotmap_remove</TT></A> | <A HREF="#fd_slotmap_set"><TT>fd_slotmap_set</TT></A> | <A HREF="#fd_slotmap_test"><TT>fd_slotmap_test</TT></A> | <A HREF="#fd_slotmap_zap"><TT>fd_slotmap_zap</TT></A> | 
</P>
<TABLE CELLPADDING="5">
<TR>
<TH ALIGN="LEFT">Function</TH><TH ALIGN="LEFT">Arguments</TH><TH ALIGN="LEFT">Returns</TH>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_slotmap_add">fd_slotmap_add</A></TD><TD CLASS="ccode">fd_slotmap sm,lisp key,lisp value</TD><TD CLASS="ccode">void </TD>
</TR>
<TR>
<TH></TH><TD>a slotmap, a lisp key, and a lisp value</TD><TD>makes the value be associated with the key</TD>
</TR>
<TR>
<TH></TH><TD><EM>in the slotmap, making the value  non deterministic if
     neccessary. 
  Refcounts (if it's not a set) or copies (if it is) the value given it.</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="_fd_slotmap_data">_fd_slotmap_data</A></TD><TD CLASS="ccode">lisp x,void **velts</TD><TD CLASS="ccode">int </TD>
</TR>
<TR>
<TH></TH><TD>a lisp pointer (to a slotmap) and
                a pointer to a pointer to a vector of lisp pointers</TD><TD>an int (the number of lisp pointers in the vector assigned</TD>
</TR>
<TR>
<TH></TH><TD><EM>Returns the data of the slotmap to use in producing a packaged
   DTYPE from it.</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_slotmap_test">fd_slotmap_test</A></TD><TD CLASS="ccode">fd_slotmap sm,lisp key,lisp value</TD><TD CLASS="ccode">int </TD>
</TR>
<TR>
<TH></TH><TD>a slotmap, a lisp key, and a lisp value</TD><TD>1 or 0</TD>
</TR>
<TR>
<TH></TH><TD><EM>Returns 1 if the value can be found on the *key* slot of
the slotmap.</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_slotmap_get">fd_slotmap_get</A></TD><TD CLASS="ccode">fd_slotmap sm,lisp key,lisp dflt</TD><TD CLASS="ccode">lisp </TD>
</TR>
<TR>
<TH></TH><TD>a slotmap, a lisp key, and a default value</TD><TD>the value associated with the key in the slotmap</TD>
</TR>
<TR>
<TH></TH><TD><EM>or the default value otherwise.</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_make_slotmap">fd_make_slotmap</A></TD><TD CLASS="ccode">int size</TD><TD CLASS="ccode">lisp </TD>
</TR>
<TR>
<TH></TH><TD>a size (int)</TD><TD>a slotmap with capacity for <size> slots</TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="_fd_done_with_slotmap_data">_fd_done_with_slotmap_data</A></TD><TD CLASS="ccode">fd_lisp *elts,int size</TD><TD CLASS="ccode">void </TD>
</TR>
<TR>
<TH></TH><TD>a pointer to a vector of LISP pointers and a size</TD><TD>nothing</TD>
</TR>
<TR>
<TH></TH><TD><EM>Frees a slotmap data vector.</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_slotmap_set">fd_slotmap_set</A></TD><TD CLASS="ccode">fd_slotmap sm,lisp key,lisp value</TD><TD CLASS="ccode">void </TD>
</TR>
<TR>
<TH></TH><TD>a slotmap, a lisp key, and a lisp value</TD><TD>makes the value be associated with the key</TD>
</TR>
<TR>
<TH></TH><TD><EM>in the slotmap 
  Refcounts (if it's not a set) or copies (if it is) the value given it.</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_slotmap_remove">fd_slotmap_remove</A></TD><TD CLASS="ccode">fd_slotmap sm,lisp key,lisp value</TD><TD CLASS="ccode">void </TD>
</TR>
<TR>
<TH></TH><TD>a slotmap, a lisp key, and a lisp value</TD><TD>removes the value from the values associated with</TD>
</TR>
<TR>
<TH></TH><TD><EM>a particular key in the slotmap
  The value on the slotmap is freed.</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_slotmap_zap">fd_slotmap_zap</A></TD><TD CLASS="ccode">fd_slotmap sm,lisp key</TD><TD CLASS="ccode">void </TD>
</TR>
<TR>
<TH></TH><TD>a pointer to a slotmap and a key</TD><TD>nothing</TD>
</TR>
<TR>
<TH></TH><TD><EM>Removes all values associated with the key in the slotmap.</EM></TD><TD></TD>
</TR>

</TABLE>
<A NAME="io.c"><H2>
Functions defined in <TT>src/cons/io.c</TT>
</H2>
</A><P>
<A HREF="#_fd_sgetc"><TT>_fd_sgetc</TT></A> | <A HREF="#fd_add_dtype_to_file"><TT>fd_add_dtype_to_file</TT></A> | <A HREF="#fd_configure_oid_io
"><TT>fd_configure_oid_io
</TT></A> | <A HREF="#fd_default_parse_oid"><TT>fd_default_parse_oid</TT></A> | <A HREF="#fd_default_print_oid"><TT>fd_default_print_oid</TT></A> | <A HREF="#fd_dtype_size"><TT>fd_dtype_size</TT></A> | <A HREF="#fd_object_to_string"><TT>fd_object_to_string</TT></A> | <A HREF="#fd_parse_arg"><TT>fd_parse_arg</TT></A> | <A HREF="#fd_parse_lisp_from_stream"><TT>fd_parse_lisp_from_stream</TT></A> | <A HREF="#fd_parse_number"><TT>fd_parse_number</TT></A> | <A HREF="#fd_parse_string"><TT>fd_parse_string</TT></A> | <A HREF="#fd_print_lisp"><TT>fd_print_lisp</TT></A> | <A HREF="#fd_print_lisp_to_stdout"><TT>fd_print_lisp_to_stdout</TT></A> | <A HREF="#fd_print_lisp_to_string"><TT>fd_print_lisp_to_string</TT></A> | <A HREF="#fd_read_dtype_from_file"><TT>fd_read_dtype_from_file</TT></A> | <A HREF="#fd_read_dtypes_from_file"><TT>fd_read_dtypes_from_file</TT></A> | <A HREF="#fd_set_bignum_parser"><TT>fd_set_bignum_parser</TT></A> | <A HREF="#fd_set_super_pool_aliasing"><TT>fd_set_super_pool_aliasing</TT></A> | <A HREF="#fd_validate_dtype"><TT>fd_validate_dtype</TT></A> | <A HREF="#fd_write_dtype_to_file"><TT>fd_write_dtype_to_file</TT></A> | 
</P>
<TABLE CELLPADDING="5">
<TR>
<TH ALIGN="LEFT">Function</TH><TH ALIGN="LEFT">Arguments</TH><TH ALIGN="LEFT">Returns</TH>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_parse_arg">fd_parse_arg</A></TD><TD CLASS="ccode">char *xstring</TD><TD CLASS="ccode">lisp </TD>
</TR>
<TR>
<TH></TH><TD>a localized string</TD><TD>a lisp object</TD>
</TR>
<TR>
<TH></TH><TD><EM>Returns the lisp object described by the printed representation
in its argument.</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_print_lisp">fd_print_lisp</A></TD><TD CLASS="ccode">lisp x, FILE * stream</TD><TD CLASS="ccode">void </TD>
</TR>
<TR>
<TH></TH><TD>a lisp object and a standard output stream</TD><TD>nothing</TD>
</TR>
<TR>
<TH></TH><TD><EM>Outputs an ascii representation of the object to the output stream</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_configure_oid_io
">fd_configure_oid_io
</A></TD><TD CLASS="ccode">void ((*print_fcn</TD><TD CLASS="ccode">void </TD>
</TR>
<TR>
<TH></TH><TD>a pointer to two C functions; the first outputs OIDs to
       string streams and the second parses utf8 strings into OIDs</TD><TD>nothing</TD>
</TR>
<TR>
<TH></TH><TD><EM>Changes the default printer and parser for OIDs.</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_write_dtype_to_file">fd_write_dtype_to_file</A></TD><TD CLASS="ccode">lisp v,char *filename</TD><TD CLASS="ccode">void </TD>
</TR>
<TR>
<TH></TH><TD>a lisp object, a filename (a string)</TD><TD>nothing</TD>
</TR>
<TR>
<TH></TH><TD><EM>Outputs a dtype representation of the object to the
   specified file.</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_default_parse_oid">fd_default_parse_oid</A></TD><TD CLASS="ccode">fd_u8char *string</TD><TD CLASS="ccode">lisp </TD>
</TR>
<TR>
<TH></TH><TD>a pointer to a UTF-8 string</TD><TD>a lisp pointer to an FD_OID</TD>
</TR>
<TR>
<TH></TH><TD><EM>Outputs the most primitive ASCII representation of the object
  to the string stream.</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="_fd_sgetc">_fd_sgetc</A></TD><TD CLASS="ccode">fd_u8char **ss</TD><TD CLASS="ccode">int </TD>
</TR>
<TR>
<TH></TH><TD>a pointer to a pointer to a UTF-8 string</TD><TD>an int (representing a unicode character)</TD>
</TR>
<TR>
<TH></TH><TD><EM>Reads a single unicode character from a utf-8 string, advancing the
string past the character.</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_read_dtype_from_file">fd_read_dtype_from_file</A></TD><TD CLASS="ccode">char *filename</TD><TD CLASS="ccode">lisp </TD>
</TR>
<TR>
<TH></TH><TD>a localized string (a filename)</TD><TD>a lisp object</TD>
</TR>
<TR>
<TH></TH><TD><EM>Returns the lisp object described by the first DTYPE
 in filename.</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_parse_number">fd_parse_number</A></TD><TD CLASS="ccode">fd_u8char *string,int base</TD><TD CLASS="ccode">lisp </TD>
</TR>
<TR>
<TH></TH><TD>a utf8 string and an integral base</TD><TD>a lisp object</TD>
</TR>
<TR>
<TH></TH><TD><EM>Parses the number assuming the specified base.</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_default_print_oid">fd_default_print_oid</A></TD><TD CLASS="ccode">lisp obj,fd_string_stream ss</TD><TD CLASS="ccode">void </TD>
</TR>
<TR>
<TH></TH><TD>a pointer to a LISP OID pointer
                and a pointer to a "string stream"</TD><TD>nothing</TD>
</TR>
<TR>
<TH></TH><TD><EM>Outputs the most primitive ASCII representation of the object
  to the string stream.</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_read_dtypes_from_file">fd_read_dtypes_from_file</A></TD><TD CLASS="ccode">char *filename</TD><TD CLASS="ccode">lisp </TD>
</TR>
<TR>
<TH></TH><TD>a localized string (a filename)</TD><TD>a lisp object</TD>
</TR>
<TR>
<TH></TH><TD><EM>Returns the lisp objects described by the DTYPES
 in filename.</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_validate_dtype">fd_validate_dtype</A></TD><TD CLASS="ccode">unsigned char *buf,unsigned char *end</TD><TD CLASS="ccode">int </TD>
</TR>
<TR>
<TH></TH><TD>two pointers into an array of bytes</TD><TD>1 if the range contains a valid dtype representation</TD>
</TR>
<TR>
<TH></TH><TD><EM></EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_set_bignum_parser">fd_set_bignum_parser</A></TD><TD CLASS="ccode">lisp (*fcn</TD><TD CLASS="ccode">void </TD>
</TR>
<TR>
<TH></TH><TD>a function for parsing bignums from strings and returning
     lisp objects</TD><TD>void</TD>
</TR>
<TR>
<TH></TH><TD><EM>Defines the function used for parsing large integers into lisp objects.
The function takes a string and an integral radix and returns a 
lisp object representing the number described by the string.</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_dtype_size">fd_dtype_size</A></TD><TD CLASS="ccode">lisp x</TD><TD CLASS="ccode">unsigned int </TD>
</TR>
<TR>
<TH></TH><TD>a lis pointer</TD><TD>an integer</TD>
</TR>
<TR>
<TH></TH><TD><EM>Returns the number of bytes which will be used by the DType representation
 of its argument.</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_parse_lisp_from_stream">fd_parse_lisp_from_stream</A></TD><TD CLASS="ccode">FILE *f</TD><TD CLASS="ccode">lisp </TD>
</TR>
<TR>
<TH></TH><TD>a FILE pointer</TD><TD>a lisp object</TD>
</TR>
<TR>
<TH></TH><TD><EM>Parses the printed representation of an object from
  a stdio file stream</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_object_to_string">fd_object_to_string</A></TD><TD CLASS="ccode">lisp object</TD><TD CLASS="ccode">fd_u8char * </TD>
</TR>
<TR>
<TH></TH><TD>a lisp object</TD><TD>a string</TD>
</TR>
<TR>
<TH></TH><TD><EM>Returns a string containing a UTF-8 representation of the object.</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_parse_string">fd_parse_string</A></TD><TD CLASS="ccode">fd_u8char *string</TD><TD CLASS="ccode">lisp </TD>
</TR>
<TR>
<TH></TH><TD>a utf8 string</TD><TD>a lisp object</TD>
</TR>
<TR>
<TH></TH><TD><EM>Returns the lisp object described by the printed representation
in its argument.</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_set_super_pool_aliasing">fd_set_super_pool_aliasing</A></TD><TD CLASS="ccode">FD_OID from,FD_OID to</TD><TD CLASS="ccode">void </TD>
</TR>
<TR>
<TH></TH><TD>two OIDs</TD><TD>nothing</TD>
</TR>
<TR>
<TH></TH><TD><EM>Sets up the DType reader to translate OIDs in the super pool of
*from* into OIDs in the super pool for *to*.</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_add_dtype_to_file">fd_add_dtype_to_file</A></TD><TD CLASS="ccode">lisp v,char *filename</TD><TD CLASS="ccode">void </TD>
</TR>
<TR>
<TH></TH><TD>a lisp object, a filename (a string)</TD><TD>nothing</TD>
</TR>
<TR>
<TH></TH><TD><EM>Outputs a dtype representation of the object to the
   end of the specified file (creating it if neccessary).</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_print_lisp_to_stdout">fd_print_lisp_to_stdout</A></TD><TD CLASS="ccode">lisp dtype</TD><TD CLASS="ccode">void </TD>
</TR>
<TR>
<TH></TH><TD>a lisp object</TD><TD>nothing</TD>
</TR>
<TR>
<TH></TH><TD><EM>Outputs an ascii representation of the object to the standard output</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_print_lisp_to_string">fd_print_lisp_to_string</A></TD><TD CLASS="ccode">lisp x,fd_string_stream s</TD><TD CLASS="ccode">void </TD>
</TR>
<TR>
<TH></TH><TD>a lisp object and a pointer to a "string stream"</TD><TD>nothing</TD>
</TR>
<TR>
<TH></TH><TD><EM>Outputs an ASCII representation of the object to the string stream.</EM></TD><TD></TD>
</TR>

</TABLE>
<A NAME="choices.c"><H2>
Functions defined in <TT>src/cons/choices.c</TT>
</H2>
</A><P>
<A HREF="#_fd_add_to_choice"><TT>_fd_add_to_choice</TT></A> | <A HREF="#_fd_binary_choice"><TT>_fd_binary_choice</TT></A> | <A HREF="#_fd_make_choice_heterogenous"><TT>_fd_make_choice_heterogenous</TT></A> | <A HREF="#_fd_make_choice_homogenous"><TT>_fd_make_choice_homogenous</TT></A> | <A HREF="#_fd_merge_choices"><TT>_fd_merge_choices</TT></A> | <A HREF="#_fd_quote_choice"><TT>_fd_quote_choice</TT></A> | <A HREF="#_fd_unquote_choice"><TT>_fd_unquote_choice</TT></A> | <A HREF="#fd_choice_containsp"><TT>fd_choice_containsp</TT></A> | <A HREF="#fd_choice_overlapsp"><TT>fd_choice_overlapsp</TT></A> | <A HREF="#fd_init_choice"><TT>fd_init_choice</TT></A> | <A HREF="#fd_init_oid_choice"><TT>fd_init_oid_choice</TT></A> | <A HREF="#fd_intersect_choices"><TT>fd_intersect_choices</TT></A> | <A HREF="#fd_list_to_choice"><TT>fd_list_to_choice</TT></A> | <A HREF="#fd_merge_choices"><TT>fd_merge_choices</TT></A> | <A HREF="#fd_proper_choicep"><TT>fd_proper_choicep</TT></A> | <A HREF="#fd_remove_from_choice"><TT>fd_remove_from_choice</TT></A> | <A HREF="#fd_return_proper_choice"><TT>fd_return_proper_choice</TT></A> | <A HREF="#fd_sort_choice"><TT>fd_sort_choice</TT></A> | 
</P>
<TABLE CELLPADDING="5">
<TR>
<TH ALIGN="LEFT">Function</TH><TH ALIGN="LEFT">Arguments</TH><TH ALIGN="LEFT">Returns</TH>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_init_oid_choice">fd_init_oid_choice</A></TD><TD CLASS="ccode">int n</TD><TD CLASS="ccode">lisp </TD>
</TR>
<TR>
<TH></TH><TD>a size</TD><TD>An empty non-deterministic set with a homogenous type of OID</TD>
</TR>
<TR>
<TH></TH><TD><EM>This returns an empty set with reserved space for a certain number
    of elements.  The set is initialized as a homogenous choice of OIDS.</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="_fd_make_choice_heterogenous">_fd_make_choice_heterogenous</A></TD><TD CLASS="ccode">fd_choice ch</TD><TD CLASS="ccode">void </TD>
</TR>
<TR>
<TH></TH><TD>a pointer to a choice</TD><TD>nothing</TD>
</TR>
<TR>
<TH></TH><TD><EM>Makes a homogenous choice into a heterogenous one</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="_fd_binary_choice">_fd_binary_choice</A></TD><TD CLASS="ccode">lisp x,lisp y</TD><TD CLASS="ccode">lisp </TD>
</TR>
<TR>
<TH></TH><TD>two lisp objects</TD><TD>a non-deterministic set containing copies of them</TD>
</TR>
<TR>
<TH></TH><TD><EM>This is useful because the transition from simple value to nd-value
    usually starts with a set of two elements.</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_sort_choice">fd_sort_choice</A></TD><TD CLASS="ccode">fd_lisp arg</TD><TD CLASS="ccode">int </TD>
</TR>
<TR>
<TH></TH><TD>a pointer to a choice</TD><TD>1/0</TD>
</TR>
<TR>
<TH></TH><TD><EM>Sorts the elements of a heterogenous choice, returns 1 if
the choice was successfully sorted, 0 otherwise</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_list_to_choice">fd_list_to_choice</A></TD><TD CLASS="ccode">lisp lst</TD><TD CLASS="ccode">lisp </TD>
</TR>
<TR>
<TH></TH><TD>a lisp list</TD><TD>an non-deterministic set whose elements are the elements of</TD>
</TR>
<TR>
<TH></TH><TD><EM>the list it is given
  This copies (rather than just crefs) the elements it is given</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_init_choice">fd_init_choice</A></TD><TD CLASS="ccode">int n</TD><TD CLASS="ccode">lisp </TD>
</TR>
<TR>
<TH></TH><TD>a size</TD><TD>An empty non-deterministic set</TD>
</TR>
<TR>
<TH></TH><TD><EM>This returns an empty set with reserved space for a certain number
    of elements.</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_remove_from_choice">fd_remove_from_choice</A></TD><TD CLASS="ccode">lisp x,lisp choice</TD><TD CLASS="ccode">lisp </TD>
</TR>
<TR>
<TH></TH><TD>a lisp object and a lisp non-deterministic set</TD><TD>a non-deterministic set without any occurences of the object</TD>
</TR>
<TR>
<TH></TH><TD><EM></EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="_fd_make_choice_homogenous">_fd_make_choice_homogenous</A></TD><TD CLASS="ccode">fd_choice ch</TD><TD CLASS="ccode">void </TD>
</TR>
<TR>
<TH></TH><TD>a pointer to a choice</TD><TD>nothing</TD>
</TR>
<TR>
<TH></TH><TD><EM>Makes a heterogenous choice into a homogenous one</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_choice_containsp">fd_choice_containsp</A></TD><TD CLASS="ccode">lisp sub,lisp super</TD><TD CLASS="ccode">int </TD>
</TR>
<TR>
<TH></TH><TD>two lisp objects</TD><TD>1 or 0</TD>
</TR>
<TR>
<TH></TH><TD><EM>Returns 1 if the first argument is a subset of the second.
of the choice which is the second argument.</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="_fd_unquote_choice">_fd_unquote_choice</A></TD><TD CLASS="ccode">fd_lisp x</TD><TD CLASS="ccode">fd_lisp </TD>
</TR>
<TR>
<TH></TH><TD>a lisp object (possibly a choice)</TD><TD>a lisp object</TD>
</TR>
<TR>
<TH></TH><TD><EM>Returns a lisp object will be a quoted choice if appropriate</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="_fd_merge_choices">_fd_merge_choices</A></TD><TD CLASS="ccode">lisp x,lisp y</TD><TD CLASS="ccode">lisp </TD>
</TR>
<TR>
<TH></TH><TD>two objects</TD><TD>a non-deterministic set which contains the elements of both</TD>
</TR>
<TR>
<TH></TH><TD><EM>This implicitly frees y (its second argument), while adding its elements
to x.</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_merge_choices">fd_merge_choices</A></TD><TD CLASS="ccode">lisp x,lisp y</TD><TD CLASS="ccode">lisp </TD>
</TR>
<TR>
<TH></TH><TD>two objects</TD><TD>a non-deterministic set which contains the elements of both</TD>
</TR>
<TR>
<TH></TH><TD><EM>Merges two choices, being smart about sorted choices.  This may side
effect the first argument.</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_proper_choicep">fd_proper_choicep</A></TD><TD CLASS="ccode">lisp value</TD><TD CLASS="ccode">int </TD>
</TR>
<TR>
<TH></TH><TD>a lisp pointer</TD><TD>1 if the argument is a proper choice, 0 otherwise</TD>
</TR>
<TR>
<TH></TH><TD><EM>A proper choice has no duplicated elements. Note that
 a non-choice lisp pointer is always "proper" since it has
 only one element.</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_return_proper_choice">fd_return_proper_choice</A></TD><TD CLASS="ccode">lisp values</TD><TD CLASS="ccode">lisp </TD>
</TR>
<TR>
<TH></TH><TD>a lisp pointer</TD><TD>another lisp pointer</TD>
</TR>
<TR>
<TH></TH><TD><EM>If the argument is a non-deterministic set, this returns a "proper set"
which contains no duplicate elements.</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_choice_overlapsp">fd_choice_overlapsp</A></TD><TD CLASS="ccode">lisp ch1,lisp ch2</TD><TD CLASS="ccode">int </TD>
</TR>
<TR>
<TH></TH><TD>two lisp objects</TD><TD>1 or 0</TD>
</TR>
<TR>
<TH></TH><TD><EM>Returns 1 if any elements of the first argument overlap elements of the second.</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_intersect_choices">fd_intersect_choices</A></TD><TD CLASS="ccode">lisp *choices,int size</TD><TD CLASS="ccode">lisp </TD>
</TR>
<TR>
<TH></TH><TD>a C array of LISP pointers and a size</TD><TD>a lisp object</TD>
</TR>
<TR>
<TH></TH><TD><EM>Returns the intersection of all the choices in the array.  This
 is optimized to take advantage of sorted choices.</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="_fd_add_to_choice">_fd_add_to_choice</A></TD><TD CLASS="ccode">lisp x,lisp set</TD><TD CLASS="ccode">void </TD>
</TR>
<TR>
<TH></TH><TD>a lisp object and a lisp non-deterministic set</TD><TD>nothing</TD>
</TR>
<TR>
<TH></TH><TD><EM>Adds the object (not a copy!) to the non-deterministic set.</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="_fd_quote_choice">_fd_quote_choice</A></TD><TD CLASS="ccode">fd_lisp x</TD><TD CLASS="ccode">fd_lisp </TD>
</TR>
<TR>
<TH></TH><TD>a lisp object (possibly a choice)</TD><TD>a lisp object</TD>
</TR>
<TR>
<TH></TH><TD><EM>Returns a lisp object will be a quoted choice if appropriate</EM></TD><TD></TD>
</TR>

</TABLE>
<A NAME="xdata.c"><H2>
Functions defined in <TT>src/cons/xdata.c</TT>
</H2>
</A><P>
<A HREF="#fd_alist_to_hashtable"><TT>fd_alist_to_hashtable</TT></A> | <A HREF="#fd_compare_cptrs"><TT>fd_compare_cptrs</TT></A> | <A HREF="#fd_cons"><TT>fd_cons</TT></A> | <A HREF="#fd_copy_cptr"><TT>fd_copy_cptr</TT></A> | <A HREF="#fd_hashtable_to_alist"><TT>fd_hashtable_to_alist</TT></A> | <A HREF="#fd_lisp_hashset_elts"><TT>fd_lisp_hashset_elts</TT></A> | <A HREF="#fd_make_complex"><TT>fd_make_complex</TT></A> | <A HREF="#fd_make_double_vector"><TT>fd_make_double_vector</TT></A> | <A HREF="#fd_make_error"><TT>fd_make_error</TT></A> | <A HREF="#fd_make_exception"><TT>fd_make_exception</TT></A> | <A HREF="#fd_make_float_vector"><TT>fd_make_float_vector</TT></A> | <A HREF="#fd_make_flonum"><TT>fd_make_flonum</TT></A> | <A HREF="#fd_make_hashset_for_lisp"><TT>fd_make_hashset_for_lisp</TT></A> | <A HREF="#fd_make_hashtable_for_lisp"><TT>fd_make_hashtable_for_lisp</TT></A> | <A HREF="#fd_make_int_vector"><TT>fd_make_int_vector</TT></A> | <A HREF="#fd_make_packet"><TT>fd_make_packet</TT></A> | <A HREF="#fd_make_rational"><TT>fd_make_rational</TT></A> | <A HREF="#fd_make_short_vector"><TT>fd_make_short_vector</TT></A> | <A HREF="#fd_make_timestamp"><TT>fd_make_timestamp</TT></A> | <A HREF="#fd_make_xtimestamp"><TT>fd_make_xtimestamp</TT></A> | <A HREF="#fd_parse_packet"><TT>fd_parse_packet</TT></A> | <A HREF="#fd_quote_lisp"><TT>fd_quote_lisp</TT></A> | 
</P>
<TABLE CELLPADDING="5">
<TR>
<TH ALIGN="LEFT">Function</TH><TH ALIGN="LEFT">Arguments</TH><TH ALIGN="LEFT">Returns</TH>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_make_rational">fd_make_rational</A></TD><TD CLASS="ccode">lisp num,lisp denom</TD><TD CLASS="ccode">lisp </TD>
</TR>
<TR>
<TH></TH><TD>two lisp numbers</TD><TD>a lisp rational</TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_lisp_hashset_elts">fd_lisp_hashset_elts</A></TD><TD CLASS="ccode">lisp table</TD><TD CLASS="ccode">lisp </TD>
</TR>
<TR>
<TH></TH><TD>a lisp pointer to a hashset</TD><TD>a lisp pointer</TD>
</TR>
<TR>
<TH></TH><TD><EM>Returns all the elements of a hashset as a choice.</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_quote_lisp">fd_quote_lisp</A></TD><TD CLASS="ccode">lisp x</TD><TD CLASS="ccode">lisp </TD>
</TR>
<TR>
<TH></TH><TD>a lisp object</TD><TD>another object, which when evaluated, returns the first</TD>
</TR>
<TR>
<TH></TH><TD><EM>This also copies any structure copied to it.</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_make_complex">fd_make_complex</A></TD><TD CLASS="ccode">lisp real,lisp imag</TD><TD CLASS="ccode">lisp </TD>
</TR>
<TR>
<TH></TH><TD>two numbers</TD><TD>a lisp complex</TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_cons">fd_cons</A></TD><TD CLASS="ccode">char *format,...</TD><TD CLASS="ccode">fd_lisp </TD>
</TR>
<TR>
<TH></TH><TD>a format string and a number of args</TD><TD>a lisp object</TD>
</TR>
<TR>
<TH></TH><TD><EM>Geneates a lisp object based on the format string.  Codes in
the format string are interpreted as follows:
   i  integer
   f  long
   q  lisp pointer (will be incref'd)
   Q  lisp pointer (won't be incref'd)
   s  locally encoded string
   S  locally encoded symbol
   u  utf8 encoded string
   U  utf8 encoded symbol
   (xxx)  list with elements
   {xxx}  choice with elements
   #(xxx) vector with elements</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_make_short_vector">fd_make_short_vector</A></TD><TD CLASS="ccode">int len,short *data</TD><TD CLASS="ccode">lisp </TD>
</TR>
<TR>
<TH></TH><TD>a float</TD><TD>a LISP floating point number</TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_make_hashtable_for_lisp">fd_make_hashtable_for_lisp</A></TD><TD CLASS="ccode">int size</TD><TD CLASS="ccode">lisp </TD>
</TR>
<TR>
<TH></TH><TD>an integer</TD><TD>a lisp pointer to a hashtable</TD>
</TR>
<TR>
<TH></TH><TD><EM></EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_make_double_vector">fd_make_double_vector</A></TD><TD CLASS="ccode">int len,double *data</TD><TD CLASS="ccode">lisp </TD>
</TR>
<TR>
<TH></TH><TD>a int length and a pointer to an array of doubles</TD><TD>a homongenous double floating point vector</TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_make_hashset_for_lisp">fd_make_hashset_for_lisp</A></TD><TD CLASS="ccode">int size</TD><TD CLASS="ccode">lisp </TD>
</TR>
<TR>
<TH></TH><TD>an integer</TD><TD>a lisp pointer to a hashtable</TD>
</TR>
<TR>
<TH></TH><TD><EM></EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_make_float_vector">fd_make_float_vector</A></TD><TD CLASS="ccode">int len,float *data</TD><TD CLASS="ccode">lisp </TD>
</TR>
<TR>
<TH></TH><TD>a int length and a pointer to an array of floats</TD><TD>a homongenous floating point vector</TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_make_flonum">fd_make_flonum</A></TD><TD CLASS="ccode">double f</TD><TD CLASS="ccode">lisp </TD>
</TR>
<TR>
<TH></TH><TD>a float</TD><TD>a LISP floating point number</TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_make_int_vector">fd_make_int_vector</A></TD><TD CLASS="ccode">int len,int *data</TD><TD CLASS="ccode">lisp </TD>
</TR>
<TR>
<TH></TH><TD>an int length and a pointer to an array of ints</TD><TD>a homongenous lisp vector of ints</TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_compare_cptrs">fd_compare_cptrs</A></TD><TD CLASS="ccode">lisp x,lisp y</TD><TD CLASS="ccode">unsigned int </TD>
</TR>
<TR>
<TH></TH><TD>two cptr objects</TD><TD>an unsigned int</TD>
</TR>
<TR>
<TH></TH><TD><EM>Compares the pointers underlying two cptrs.
Returns 1 if they are the same.</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_hashtable_to_alist">fd_hashtable_to_alist</A></TD><TD CLASS="ccode">lisp table</TD><TD CLASS="ccode">lisp </TD>
</TR>
<TR>
<TH></TH><TD>a lisp pointer to a hashtable</TD><TD>a lisp association list</TD>
</TR>
<TR>
<TH></TH><TD><EM>Converts a hashtable to an association list</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_make_timestamp">fd_make_timestamp</A></TD><TD CLASS="ccode">time_t moment</TD><TD CLASS="ccode">lisp </TD>
</TR>
<TR>
<TH></TH><TD>a time_t value</TD><TD>a lisp record whose tag is the symbol timestamp</TD>
</TR>
<TR>
<TH></TH><TD><EM></EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_alist_to_hashtable">fd_alist_to_hashtable</A></TD><TD CLASS="ccode">lisp alist</TD><TD CLASS="ccode">lisp </TD>
</TR>
<TR>
<TH></TH><TD>a lisp association list</TD><TD>a lisp pointer to a hashtable</TD>
</TR>
<TR>
<TH></TH><TD><EM>Converts an association list to a hashtable</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_make_xtimestamp">fd_make_xtimestamp</A></TD><TD CLASS="ccode">time_t moment,int nsecs,fd_tmprec prec,int tzoff</TD><TD CLASS="ccode">lisp </TD>
</TR>
<TR>
<TH></TH><TD>a time_t value, a nanoseconds value, a precision, and a timezone string</TD><TD>a lisp record whose tag is the symbol timestamp</TD>
</TR>
<TR>
<TH></TH><TD><EM></EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_copy_cptr">fd_copy_cptr</A></TD><TD CLASS="ccode">lisp x</TD><TD CLASS="ccode">lisp </TD>
</TR>
<TR>
<TH></TH><TD>a cptr object</TD><TD>another cptr object</TD>
</TR>
<TR>
<TH></TH><TD><EM>Makes a new reference counting CONS for a wrapped cptr.</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_parse_packet">fd_parse_packet</A></TD><TD CLASS="ccode">fd_u8char *string</TD><TD CLASS="ccode">lisp </TD>
</TR>
<TR>
<TH></TH><TD>a utf8 string</TD><TD>a lisp pointer to a packet structure</TD>
</TR>
<TR>
<TH></TH><TD><EM>Takes a long hex string and turns it into a packet</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_make_error">fd_make_error</A></TD><TD CLASS="ccode">lisp data</TD><TD CLASS="ccode">lisp </TD>
</TR>
<TR>
<TH></TH><TD>another lisp object describing some error</TD><TD>an error object whose *details* are the given arguments</TD>
</TR>
<TR>
<TH></TH><TD><EM>Note: the details are not copied</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_make_packet">fd_make_packet</A></TD><TD CLASS="ccode">int len,unsigned char *data</TD><TD CLASS="ccode">lisp </TD>
</TR>
<TR>
<TH></TH><TD>an integer and a pointer to an array of bytes</TD><TD>a "packet object" containing the array of bytes</TD>
</TR>
<TR>
<TH></TH><TD><EM>Note: the details are not copied</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_make_exception">fd_make_exception</A></TD><TD CLASS="ccode">lisp data</TD><TD CLASS="ccode">lisp </TD>
</TR>
<TR>
<TH></TH><TD>another lisp object describing some exception</TD><TD>an exception object whose *details* are the given arguments</TD>
</TR>
<TR>
<TH></TH><TD><EM>Note: the details are not copied</EM></TD><TD></TD>
</TR>

</TABLE>
<A NAME="consed-oids.c"><H2>
Functions defined in <TT>src/cons/consed-oids.c</TT>
</H2>
</A><P>
<A HREF="#_fd_not_an_oid"><TT>_fd_not_an_oid</TT></A> | <A HREF="#fd_grow_oid_table"><TT>fd_grow_oid_table</TT></A> | <A HREF="#fd_make_oid"><TT>fd_make_oid</TT></A> | <A HREF="#fd_probe_oid"><TT>fd_probe_oid</TT></A> | 
</P>
<TABLE CELLPADDING="5">
<TR>
<TH ALIGN="LEFT">Function</TH><TH ALIGN="LEFT">Arguments</TH><TH ALIGN="LEFT">Returns</TH>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_probe_oid">fd_probe_oid</A></TD><TD CLASS="ccode">FD_OID id</TD><TD CLASS="ccode">lisp </TD>
</TR>
<TR>
<TH></TH><TD>an OID</TD><TD>a lisp pointer to the OID object or the empty set</TD>
</TR>
<TR>
<TH></TH><TD><EM>This is like fd_make_oid but doesn't make the oid, only
returns it if it exists.</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="_fd_not_an_oid">_fd_not_an_oid</A></TD><TD CLASS="ccode">lisp x</TD><TD CLASS="ccode">struct FD_CONSOID * </TD>
</TR>
<TR>
<TH></TH><TD>a lisp pointer</TD><TD>never, but pretends to return an FD_OID pointer</TD>
</TR>
<TR>
<TH></TH><TD><EM></EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_grow_oid_table">fd_grow_oid_table</A></TD><TD CLASS="ccode">unsigned int size</TD><TD CLASS="ccode">void </TD>
</TR>
<TR>
<TH></TH><TD>an unsigned int size</TD><TD>nothing</TD>
</TR>
<TR>
<TH></TH><TD><EM>Grows the oid table to at least a specified size.  This is provided
   because if you know there will be a lot of object references, you can
   grow the oid table at first and avoid having to take the time to
   grow it along the way.</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_make_oid">fd_make_oid</A></TD><TD CLASS="ccode">FD_OID id</TD><TD CLASS="ccode">lisp </TD>
</TR>
<TR>
<TH></TH><TD>an OID address structure</TD><TD>a lisp pointer to a OID object with the corresponding address</TD>
</TR>
<TR>
<TH></TH><TD><EM>This is basically the same loop as above with a substitution of
   FD_COMPARE_OIDS for ==.</EM></TD><TD></TD>
</TR>

</TABLE>
<A NAME="lightweight-oids.c"><H2>
Functions defined in <TT>src/cons/lightweight-oids.c</TT>
</H2>
</A><P>

</P>
<TABLE CELLPADDING="5">
<TR>
<TH ALIGN="LEFT">Function</TH><TH ALIGN="LEFT">Arguments</TH><TH ALIGN="LEFT">Returns</TH>
</TR>

</TABLE>
<A NAME="libdtypes.c"><H2>
Functions defined in <TT>src/cons/libdtypes.c</TT>
</H2>
</A><P>

</P>
<TABLE CELLPADDING="5">
<TR>
<TH ALIGN="LEFT">Function</TH><TH ALIGN="LEFT">Arguments</TH><TH ALIGN="LEFT">Returns</TH>
</TR>

</TABLE>
<A NAME="data.c"><H2>
Functions defined in <TT>src/cons/data.c</TT>
</H2>
</A><P>
<A HREF="#FD_MAKE_LIST"><TT>FD_MAKE_LIST</TT></A> | <A HREF="#_FD_MAKE_LIST1"><TT>_FD_MAKE_LIST1</TT></A> | <A HREF="#_FD_MAKE_PAIR"><TT>_FD_MAKE_PAIR</TT></A> | <A HREF="#_fd_copy_lisp_proc"><TT>_fd_copy_lisp_proc</TT></A> | <A HREF="#_fd_decref_cons"><TT>_fd_decref_cons</TT></A> | <A HREF="#_fd_incref_cons"><TT>_fd_incref_cons</TT></A> | <A HREF="#fd_copy_string"><TT>fd_copy_string</TT></A> | <A HREF="#fd_for_elts"><TT>fd_for_elts</TT></A> | <A HREF="#fd_free_proc"><TT>fd_free_proc</TT></A> | <A HREF="#fd_get_big_buffer"><TT>fd_get_big_buffer</TT></A> | <A HREF="#fd_init_string"><TT>fd_init_string</TT></A> | <A HREF="#fd_init_vector"><TT>fd_init_vector</TT></A> | <A HREF="#fd_lisp_equal"><TT>fd_lisp_equal</TT></A> | <A HREF="#fd_list_length"><TT>fd_list_length</TT></A> | <A HREF="#fd_lookup_compound"><TT>fd_lookup_compound</TT></A> | <A HREF="#fd_lookup_package_code
"><TT>fd_lookup_package_code
</TT></A> | <A HREF="#fd_lookup_record"><TT>fd_lookup_record</TT></A> | <A HREF="#fd_lower_string"><TT>fd_lower_string</TT></A> | <A HREF="#fd_make_character"><TT>fd_make_character</TT></A> | <A HREF="#fd_make_cptr"><TT>fd_make_cptr</TT></A> | <A HREF="#fd_make_lrecord"><TT>fd_make_lrecord</TT></A> | <A HREF="#fd_make_pair"><TT>fd_make_pair</TT></A> | <A HREF="#fd_make_record"><TT>fd_make_record</TT></A> | <A HREF="#fd_make_string"><TT>fd_make_string</TT></A> | <A HREF="#fd_make_substring"><TT>fd_make_substring</TT></A> | <A HREF="#fd_make_vector"><TT>fd_make_vector</TT></A> | <A HREF="#fd_memberp"><TT>fd_memberp</TT></A> | <A HREF="#fd_register_record"><TT>fd_register_record</TT></A> | <A HREF="#fd_register_source_file"><TT>fd_register_source_file</TT></A> | <A HREF="#fd_register_typecode"><TT>fd_register_typecode</TT></A> | <A HREF="#fd_stream_string"><TT>fd_stream_string</TT></A> | <A HREF="#fd_utf8_string_ref"><TT>fd_utf8_string_ref</TT></A> | <A HREF="#fd_utf8_strlen"><TT>fd_utf8_strlen</TT></A> | <A HREF="#fd_utf8_substring"><TT>fd_utf8_substring</TT></A> | 
</P>
<TABLE CELLPADDING="5">
<TR>
<TH ALIGN="LEFT">Function</TH><TH ALIGN="LEFT">Arguments</TH><TH ALIGN="LEFT">Returns</TH>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="_fd_decref_cons">_fd_decref_cons</A></TD><TD CLASS="ccode">lisp x</TD><TD CLASS="ccode">void </TD>
</TR>
<TR>
<TH></TH><TD>a lisp object</TD><TD>void</TD>
</TR>
<TR>
<TH></TH><TD><EM>Increments the GC count for x and reclaims it if appropriate.</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="_fd_copy_lisp_proc">_fd_copy_lisp_proc</A></TD><TD CLASS="ccode">lisp x</TD><TD CLASS="ccode">lisp </TD>
</TR>
<TR>
<TH></TH><TD>a lisp object</TD><TD>a copy of the object</TD>
</TR>
<TR>
<TH></TH><TD><EM>This doesn't bother copying fixnums, symbols, objects, or immediates.
   The macro fd_incref is the identify for such objects and calls
   _fd_copy_lisp_proc for everything else.</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_lisp_equal">fd_lisp_equal</A></TD><TD CLASS="ccode">lisp key0, lisp key1</TD><TD CLASS="ccode">int </TD>
</TR>
<TR>
<TH></TH><TD>two lisp objects</TD><TD>the integer 1 if they're EQUAL, 0 if they're not.</TD>
</TR>
<TR>
<TH></TH><TD><EM></EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="_fd_incref_cons">_fd_incref_cons</A></TD><TD CLASS="ccode">lisp x</TD><TD CLASS="ccode">lisp </TD>
</TR>
<TR>
<TH></TH><TD>a lisp pointer</TD><TD>its argument</TD>
</TR>
<TR>
<TH></TH><TD><EM>Increments the reference count associated with a cons</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_make_vector">fd_make_vector</A></TD><TD CLASS="ccode">int size</TD><TD CLASS="ccode">lisp </TD>
</TR>
<TR>
<TH></TH><TD>a C integer</TD><TD>a vector of a fixed size, initialized to FD_EMPTY_CHOICE</TD>
</TR>
<TR>
<TH></TH><TD><EM>Makes a vector of the given size.  A vector is implemented as a record
     with the tag VECTOR_TAG and a pointer to an array of size and elements.</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_make_cptr">fd_make_cptr</A></TD><TD CLASS="ccode">fd_lisp_type tp,void *data</TD><TD CLASS="ccode">fd_lisp </TD>
</TR>
<TR>
<TH></TH><TD>a lisp type and a data pointer</TD><TD>a lisp pointer with the type and an allocated refcounter for</TD>
</TR>
<TR>
<TH></TH><TD><EM>the cpointer</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_copy_string">fd_copy_string</A></TD><TD CLASS="ccode">fd_u8char *string</TD><TD CLASS="ccode">lisp </TD>
</TR>
<TR>
<TH></TH><TD>a null-terminated utf8 string</TD><TD>a lisp object describing the string</TD>
</TR>
<TR>
<TH></TH><TD><EM>This copies the string argument and also determines
if it is UTF-8 or not.</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_make_substring">fd_make_substring</A></TD><TD CLASS="ccode">fd_u8char *start,fd_u8char *end</TD><TD CLASS="ccode">lisp </TD>
</TR>
<TR>
<TH></TH><TD>two pointers into the same utf-8 string</TD><TD>a lisp object describing the substring between them</TD>
</TR>
<TR>
<TH></TH><TD><EM></EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_make_pair">fd_make_pair</A></TD><TD CLASS="ccode">lisp x, lisp y</TD><TD CLASS="ccode">lisp </TD>
</TR>
<TR>
<TH></TH><TD>two lisp objects</TD><TD>a cons pair whose CAR and CDR are the arguments</TD>
</TR>
<TR>
<TH></TH><TD><EM>the arguments *are* incref'd</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_lower_string">fd_lower_string</A></TD><TD CLASS="ccode">fd_u8char *string</TD><TD CLASS="ccode">lisp </TD>
</TR>
<TR>
<TH></TH><TD>a null-terminated utf-8 C string</TD><TD>a lisp object describing the lower-cased version of the string</TD>
</TR>
<TR>
<TH></TH><TD><EM>This is useful for canonicalizing strings to look things up in hashtables,
etc.</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_init_string">fd_init_string</A></TD><TD CLASS="ccode">fd_u8char *string,int size</TD><TD CLASS="ccode">lisp </TD>
</TR>
<TR>
<TH></TH><TD>a null-terminated utf8 string</TD><TD>a lisp object describing the string</TD>
</TR>
<TR>
<TH></TH><TD><EM>This uses the actual string argument (so it shouldn't be
stack consed or subsequently freed by the caller).</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_make_character">fd_make_character</A></TD><TD CLASS="ccode">unsigned int c</TD><TD CLASS="ccode">lisp </TD>
</TR>
<TR>
<TH></TH><TD>a character</TD><TD>the LISP version of the character</TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_utf8_string_ref">fd_utf8_string_ref</A></TD><TD CLASS="ccode">fd_u8char *str</TD><TD CLASS="ccode">int </TD>
</TR>
<TR>
<TH></TH><TD>a pointer to a UTF-encoded string</TD><TD>returns the first unicode character in the string</TD>
</TR>
<TR>
<TH></TH><TD><EM></EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_memberp">fd_memberp</A></TD><TD CLASS="ccode">lisp x,lisp list</TD><TD CLASS="ccode">int </TD>
</TR>
<TR>
<TH></TH><TD>a lisp object and a list of such objects</TD><TD>1 if the object is in the list and 0 otherwise</TD>
</TR>
<TR>
<TH></TH><TD><EM></EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_make_string">fd_make_string</A></TD><TD CLASS="ccode">char *string</TD><TD CLASS="ccode">lisp </TD>
</TR>
<TR>
<TH></TH><TD>a null-terminated localized C string</TD><TD>a lisp object describing the string</TD>
</TR>
<TR>
<TH></TH><TD><EM>This does UTF-8 conversion and doesn't use the direct
pointer to string.</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="FD_MAKE_LIST">FD_MAKE_LIST</A></TD><TD CLASS="ccode">int length,...</TD><TD CLASS="ccode">lisp </TD>
</TR>
<TR>
<TH></TH><TD>an integer followed by several elements</TD><TD>a list of <length> elements in order</TD>
</TR>
<TR>
<TH></TH><TD><EM></EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_utf8_strlen">fd_utf8_strlen</A></TD><TD CLASS="ccode">fd_u8char *str,int slen</TD><TD CLASS="ccode">int </TD>
</TR>
<TR>
<TH></TH><TD>a pointer to a UTF-encoded string and a length</TD><TD>an integer indicating the number of unicode characters</TD>
</TR>
<TR>
<TH></TH><TD><EM>in the string it represents</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_list_length">fd_list_length</A></TD><TD CLASS="ccode">lisp x</TD><TD CLASS="ccode">unsigned int </TD>
</TR>
<TR>
<TH></TH><TD>a lisp object</TD><TD>the number of elements in the object, if it is a list,</TD>
</TR>
<TR>
<TH></TH><TD><EM>or 1 otherwise.</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_lookup_compound">fd_lookup_compound</A></TD><TD CLASS="ccode">lisp tag</TD><TD CLASS="ccode">struct FD_TYPE_REGISTRY * </TD>
</TR>
<TR>
<TH></TH><TD>a lisp tag</TD><TD>a pointer to a record entry or NULL</TD>
</TR>
<TR>
<TH></TH><TD><EM>Returns the record entry for types with the specified compound tag</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_make_record">fd_make_record</A></TD><TD CLASS="ccode">lisp type_name, void *data</TD><TD CLASS="ccode">lisp </TD>
</TR>
<TR>
<TH></TH><TD>a type specifier (a lisp object), and a pointer to some data</TD><TD>a lisp record</TD>
</TR>
<TR>
<TH></TH><TD><EM></EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_free_proc">fd_free_proc</A></TD><TD CLASS="ccode">lisp x</TD><TD CLASS="ccode">void </TD>
</TR>
<TR>
<TH></TH><TD>a lisp object</TD><TD>nothing</TD>
</TR>
<TR>
<TH></TH><TD><EM>If x is reclaimable (e.g. not a symbol, object, integer, etc), reclaim
      the storage used by x for future objects.
   This is used by the inline fd_decref which doesn't bother invoking
    it on non-reclaimable objects.</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="_FD_MAKE_PAIR">_FD_MAKE_PAIR</A></TD><TD CLASS="ccode">lisp x, lisp y</TD><TD CLASS="ccode">lisp </TD>
</TR>
<TR>
<TH></TH><TD>two lisp objects</TD><TD>a cons pair whose CAR and CDR are the arguments</TD>
</TR>
<TR>
<TH></TH><TD><EM>the arguments are not incref'd</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_lookup_package_code
">fd_lookup_package_code
</A></TD><TD CLASS="ccode">unsigned char package_code,unsigned char subcode</TD><TD CLASS="ccode">struct FD_TYPE_REGISTRY * </TD>
</TR>
<TR>
<TH></TH><TD>a package code and subcode</TD><TD>a pointer to a record entry or NULL</TD>
</TR>
<TR>
<TH></TH><TD><EM>Returns the record entry for types with the specified
   package code and subcode.  Note that this looks up the
   subcode for the "short" version of the packaged data.</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_register_typecode">fd_register_typecode</A></TD><TD CLASS="ccode">fd_lisp_type tp</TD><TD CLASS="ccode">struct FD_TYPE_REGISTRY * </TD>
</TR>
<TR>
<TH></TH><TD>a lisp typecode</TD><TD>a pointer to a record entry</TD>
</TR>
<TR>
<TH></TH><TD><EM>Returns a record entry for types with a particular typecode.
    This creates an entry if one does not already exist.  Also, if
    the tag is FD_VOID, it always creates a new entry.  (This is
    useful for types which don't have tags but need special methods
    like non-deterministic sets.</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="_FD_MAKE_LIST1">_FD_MAKE_LIST1</A></TD><TD CLASS="ccode">lisp x</TD><TD CLASS="ccode">lisp </TD>
</TR>
<TR>
<TH></TH><TD>a lisp object</TD><TD>a list whose first and only element is the argument</TD>
</TR>
<TR>
<TH></TH><TD><EM></EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_for_elts">fd_for_elts</A></TD><TD CLASS="ccode">void (*fcn</TD><TD CLASS="ccode">void </TD>
</TR>
<TR>
<TH></TH><TD>a function which returns void from a lisp object and
               a list of lisp objects</TD><TD>nothing</TD>
</TR>
<TR>
<TH></TH><TD><EM>This applies the function to all the elements of the list.</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_stream_string">fd_stream_string</A></TD><TD CLASS="ccode">struct FD_STRING_STREAM *s</TD><TD CLASS="ccode">lisp </TD>
</TR>
<TR>
<TH></TH><TD>a pointer to a string stream</TD><TD>a lisp string containing the contents of the stream</TD>
</TR>
<TR>
<TH></TH><TD><EM>This sets the string stream's pointer to NULL and size to zero, so that
subsequent modifications signal errors.</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_register_source_file">fd_register_source_file</A></TD><TD CLASS="ccode">char *name,char *date,char *details</TD><TD CLASS="ccode">void </TD>
</TR>
<TR>
<TH></TH><TD>three strings -- name, date, and details</TD><TD>void</TD>
</TR>
<TR>
<TH></TH><TD><EM>Registers a module.  Name is the filename (basename), date is the
 compilation date for the file, and details is typically the RCSID tag.</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_init_vector">fd_init_vector</A></TD><TD CLASS="ccode">int size,lisp *elts</TD><TD CLASS="ccode">lisp </TD>
</TR>
<TR>
<TH></TH><TD>a C integer and a pointer to a vector of LISP objects</TD><TD>a vector of a fixed size with the given elements</TD>
</TR>
<TR>
<TH></TH><TD><EM>Makes a vector of the given size with particular elements.  Called
     by dtio.c to make vectors when reading dtypes.</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_make_lrecord">fd_make_lrecord</A></TD><TD CLASS="ccode">lisp type_name, lisp data</TD><TD CLASS="ccode">lisp </TD>
</TR>
<TR>
<TH></TH><TD>a type specifier (a lisp object), and another lisp object</TD><TD>a lisp record</TD>
</TR>
<TR>
<TH></TH><TD><EM></EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_lookup_record">fd_lookup_record</A></TD><TD CLASS="ccode">lisp tag</TD><TD CLASS="ccode">struct FD_TYPE_REGISTRY * </TD>
</TR>
<TR>
<TH></TH><TD>a lisp pointer</TD><TD>a pointer to a record entry or NULL</TD>
</TR>
<TR>
<TH></TH><TD><EM>Returns the record entry for types whose record tags
     are the argument given to the function.</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_utf8_substring">fd_utf8_substring</A></TD><TD CLASS="ccode">fd_u8char *str,int index</TD><TD CLASS="ccode">char * </TD>
</TR>
<TR>
<TH></TH><TD>a pointer to a UTF-encoded string and an integer</TD><TD>the substring starting at the interger-th character</TD>
</TR>
<TR>
<TH></TH><TD><EM></EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_register_record">fd_register_record</A></TD><TD CLASS="ccode">lisp tag</TD><TD CLASS="ccode">struct FD_TYPE_REGISTRY * </TD>
</TR>
<TR>
<TH></TH><TD>a lisp pointer</TD><TD>a pointer to a record entry</TD>
</TR>
<TR>
<TH></TH><TD><EM>Returns a record entry for types with a particular record tag.
    This creates an entry if one does not already exist.  Also, if
    the tag is FD_VOID, it always creates a new entry.  (This is
    useful for types which don't have tags but need special methods
    like non-deterministic sets.</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_get_big_buffer">fd_get_big_buffer</A></TD><TD CLASS="ccode">unsigned int *bufsize</TD><TD CLASS="ccode">char * </TD>
</TR>
<TR>
<TH></TH><TD>a pointer to an int</TD><TD>a pointer to a large char array</TD>
</TR>
<TR>
<TH></TH><TD><EM>Allocates a big buffer, with the size determined by
the environment variable FD_BUFFER_SIZE or the runtime
define FD_BIGBUFF_DEFAULT.  This value is stored in the int
pointed to by the argument.</EM></TD><TD></TD>
</TR>

</TABLE>
<A NAME="hash.c"><H2>
Functions defined in <TT>src/cons/hash.c</TT>
</H2>
</A><P>
<A HREF="#_fd_hashset_add_nc"><TT>_fd_hashset_add_nc</TT></A> | <A HREF="#_fd_hashtable_set_nolock"><TT>_fd_hashtable_set_nolock</TT></A> | <A HREF="#_fd_set_symbol_value_noref"><TT>_fd_set_symbol_value_noref</TT></A> | <A HREF="#_fd_symbol_value_noref"><TT>_fd_symbol_value_noref</TT></A> | <A HREF="#fd_choice_to_hashset"><TT>fd_choice_to_hashset</TT></A> | <A HREF="#fd_cleanup_locked_hashtable"><TT>fd_cleanup_locked_hashtable</TT></A> | <A HREF="#fd_final_hashset_elts"><TT>fd_final_hashset_elts</TT></A> | <A HREF="#fd_for_all_symbols"><TT>fd_for_all_symbols</TT></A> | <A HREF="#fd_free_hashset"><TT>fd_free_hashset</TT></A> | <A HREF="#fd_free_hashtable"><TT>fd_free_hashtable</TT></A> | <A HREF="#fd_grow_hashset"><TT>fd_grow_hashset</TT></A> | <A HREF="#fd_grow_hashtable"><TT>fd_grow_hashtable</TT></A> | <A HREF="#fd_hash_lisp"><TT>fd_hash_lisp</TT></A> | <A HREF="#fd_hashset_add"><TT>fd_hashset_add</TT></A> | <A HREF="#fd_hashset_drop"><TT>fd_hashset_drop</TT></A> | <A HREF="#fd_hashset_elts"><TT>fd_hashset_elts</TT></A> | <A HREF="#fd_hashset_get"><TT>fd_hashset_get</TT></A> | <A HREF="#fd_hashset_intern"><TT>fd_hashset_intern</TT></A> | <A HREF="#fd_hashset_probe"><TT>fd_hashset_probe</TT></A> | <A HREF="#fd_hashset_strget"><TT>fd_hashset_strget</TT></A> | <A HREF="#fd_hashtable_add"><TT>fd_hashtable_add</TT></A> | <A HREF="#fd_hashtable_drop"><TT>fd_hashtable_drop</TT></A> | <A HREF="#fd_hashtable_get"><TT>fd_hashtable_get</TT></A> | <A HREF="#fd_hashtable_increment"><TT>fd_hashtable_increment</TT></A> | <A HREF="#fd_hashtable_increment_existing"><TT>fd_hashtable_increment_existing</TT></A> | <A HREF="#fd_hashtable_max"><TT>fd_hashtable_max</TT></A> | <A HREF="#fd_hashtable_probe"><TT>fd_hashtable_probe</TT></A> | <A HREF="#fd_hashtable_set"><TT>fd_hashtable_set</TT></A> | <A HREF="#fd_hashtable_skim"><TT>fd_hashtable_skim</TT></A> | <A HREF="#fd_hashtable_test"><TT>fd_hashtable_test</TT></A> | <A HREF="#fd_hashtable_zap"><TT>fd_hashtable_zap</TT></A> | <A HREF="#fd_init_hashset"><TT>fd_init_hashset</TT></A> | <A HREF="#fd_init_hashtable"><TT>fd_init_hashtable</TT></A> | <A HREF="#fd_intern"><TT>fd_intern</TT></A> | <A HREF="#fd_make_hashset"><TT>fd_make_hashset</TT></A> | <A HREF="#fd_make_hashtable"><TT>fd_make_hashtable</TT></A> | <A HREF="#fd_make_qstring"><TT>fd_make_qstring</TT></A> | <A HREF="#fd_make_symbol"><TT>fd_make_symbol</TT></A> | <A HREF="#fd_probe_symbol"><TT>fd_probe_symbol</TT></A> | <A HREF="#fd_reinit_hashset"><TT>fd_reinit_hashset</TT></A> | <A HREF="#fd_reinit_hashtable"><TT>fd_reinit_hashtable</TT></A> | <A HREF="#fd_select_table_size"><TT>fd_select_table_size</TT></A> | <A HREF="#fd_set_symbol_value"><TT>fd_set_symbol_value</TT></A> | <A HREF="#fd_symbol_value"><TT>fd_symbol_value</TT></A> | 
</P>
<TABLE CELLPADDING="5">
<TR>
<TH ALIGN="LEFT">Function</TH><TH ALIGN="LEFT">Arguments</TH><TH ALIGN="LEFT">Returns</TH>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_reinit_hashtable">fd_reinit_hashtable</A></TD><TD CLASS="ccode">fd_hashtable h,int minsize,int locked</TD><TD CLASS="ccode">void </TD>
</TR>
<TR>
<TH></TH><TD>a pointer to a hashtable and an int minsize</TD><TD>nothing</TD>
</TR>
<TR>
<TH></TH><TD><EM>Reinitializes the table for use with at least minsize slots.
  This leaves the tables mutex untouched, since someone may be
   waiting on it.</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_final_hashset_elts">fd_final_hashset_elts</A></TD><TD CLASS="ccode">fd_hashset h</TD><TD CLASS="ccode">lisp </TD>
</TR>
<TR>
<TH></TH><TD>a pointer to a hashset</TD><TD>a lisp object (possibly a non-deterministic set)</TD>
</TR>
<TR>
<TH></TH><TD><EM>This returns all the values in the hashset and frees the hashset.</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_init_hashtable">fd_init_hashtable</A></TD><TD CLASS="ccode">fd_hashtable h,int minsize</TD><TD CLASS="ccode">void </TD>
</TR>
<TR>
<TH></TH><TD>a pointer to a hashtable and an int minsize</TD><TD>nothing</TD>
</TR>
<TR>
<TH></TH><TD><EM>Initializes the table for use with at least minsize slots.
  This can be used for either a malloc'd hashtable or a hashtable
  on the stack.</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_make_symbol">fd_make_symbol</A></TD><TD CLASS="ccode">const fd_u8char *pname</TD><TD CLASS="ccode">lisp </TD>
</TR>
<TR>
<TH></TH><TD>a string</TD><TD>a lisp pointer to a symbol with that name</TD>
</TR>
<TR>
<TH></TH><TD><EM>This is basically the same loop as above with a substitution of
   a strcmp for the == test.</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_hashtable_get">fd_hashtable_get</A></TD><TD CLASS="ccode">fd_hashtable h,lisp key,lisp dflt</TD><TD CLASS="ccode">lisp </TD>
</TR>
<TR>
<TH></TH><TD>a pointer to a hashtable, a lisp key, and a default</TD><TD>a lisp object</TD>
</TR>
<TR>
<TH></TH><TD><EM>Returns the value associated with the key in the hashtable or the
    given default value if there is no such assocation.  Note that
    this does *not* copy the value returned from the table.</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_hashtable_skim">fd_hashtable_skim</A></TD><TD CLASS="ccode">fd_hashtable h,int threshold</TD><TD CLASS="ccode">lisp </TD>
</TR>
<TR>
<TH></TH><TD>a hashtable and an integral threshold</TD><TD>a lisp pointer</TD>
</TR>
<TR>
<TH></TH><TD><EM>Returns (as a choice) all the keys in the hashtable whose
values are greater than the numeric threshold.</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_free_hashset">fd_free_hashset</A></TD><TD CLASS="ccode">struct FD_HASHSET *h</TD><TD CLASS="ccode">void </TD>
</TR>
<TR>
<TH></TH><TD>a pointer to a hashset</TD><TD>nothing</TD>
</TR>
<TR>
<TH></TH><TD><EM>Frees the memory taken by a hashset and its elements.  Note that
this does not free the hashtable itself, since it might be on the stack.</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_hash_lisp">fd_hash_lisp</A></TD><TD CLASS="ccode">lisp x</TD><TD CLASS="ccode">unsigned int </TD>
</TR>
<TR>
<TH></TH><TD>a lisp pointer</TD><TD>an unsigned int</TD>
</TR>
<TR>
<TH></TH><TD><EM>Returns the hash for a lisp object.  This hash is *not*
  portable across sessions.</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_make_hashset">fd_make_hashset</A></TD><TD CLASS="ccode">int minsize</TD><TD CLASS="ccode">struct FD_HASHSET * </TD>
</TR>
<TR>
<TH></TH><TD>an int minsize</TD><TD>a pointer to a hashtable</TD>
</TR>
<TR>
<TH></TH><TD><EM>This mallocs a new hashset and initializes it to have at least minsize
   elements.</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_cleanup_locked_hashtable">fd_cleanup_locked_hashtable</A></TD><TD CLASS="ccode">fd_hashtable h</TD><TD CLASS="ccode">void </TD>
</TR>
<TR>
<TH></TH><TD>a pointer to a hashtable</TD><TD>nothing</TD>
</TR>
<TR>
<TH></TH><TD><EM>Removes empty elements from the hashtable.</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_hashtable_increment_existing">fd_hashtable_increment_existing</A></TD><TD CLASS="ccode">fd_hashtable h,lisp key,int increment</TD><TD CLASS="ccode">void </TD>
</TR>
<TR>
<TH></TH><TD>a pointer to a hashtable, a lisp key, and an int</TD><TD>nothing</TD>
</TR>
<TR>
<TH></TH><TD><EM>Increments the value associated with the key by a number, doing
nothing if the key does not exist.</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_grow_hashset">fd_grow_hashset</A></TD><TD CLASS="ccode">fd_hashset h,int minsize</TD><TD CLASS="ccode">void </TD>
</TR>
<TR>
<TH></TH><TD>a pointer to a hashset and an int minsize</TD><TD>nothing</TD>
</TR>
<TR>
<TH></TH><TD><EM>Grows the hashset to have at least minsize slots</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_grow_hashtable">fd_grow_hashtable</A></TD><TD CLASS="ccode">struct FD_HASHTABLE *h,int minsize</TD><TD CLASS="ccode">void </TD>
</TR>
<TR>
<TH></TH><TD>a pointer to a hashtable and an int minsize</TD><TD>nothing</TD>
</TR>
<TR>
<TH></TH><TD><EM>Grows hashtable to have at least minsize slots</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_reinit_hashset">fd_reinit_hashset</A></TD><TD CLASS="ccode">fd_hashset h,int minsize,int locked</TD><TD CLASS="ccode">void </TD>
</TR>
<TR>
<TH></TH><TD>a pointer to a hashtable and an int minsize</TD><TD>nothing</TD>
</TR>
<TR>
<TH></TH><TD><EM>Reinitializes the table for use with at least minsize slots.
  This leaves the tables mutex untouched, since someone may be
   waiting on it.</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="_fd_set_symbol_value_noref">_fd_set_symbol_value_noref</A></TD><TD CLASS="ccode">lisp x,lisp v</TD><TD CLASS="ccode">void </TD>
</TR>
<TR>
<TH></TH><TD>a LISP symbol, another LISP pointer</TD><TD>nothing</TD>
</TR>
<TR>
<TH></TH><TD><EM>Threadsafe modifier for the value slot of a symbol
which does not do any refcounting or uncounting.</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_probe_symbol">fd_probe_symbol</A></TD><TD CLASS="ccode">const fd_u8char *pname</TD><TD CLASS="ccode">lisp </TD>
</TR>
<TR>
<TH></TH><TD>a string</TD><TD>a lisp pointer to a symbol with that name</TD>
</TR>
<TR>
<TH></TH><TD><EM>This is like fd_make_symbol but doesn't make the symbol, only
returning it if it exists.</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_make_qstring">fd_make_qstring</A></TD><TD CLASS="ccode">fd_u8char *string_data,int len</TD><TD CLASS="ccode">lisp </TD>
</TR>
<TR>
<TH></TH><TD>a string and a length</TD><TD>a lisp pointer to a qstring that is EQUAL to the string</TD>
</TR>
<TR>
<TH></TH><TD><EM>If the length is negative, it is computed.</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="_fd_symbol_value_noref">_fd_symbol_value_noref</A></TD><TD CLASS="ccode">lisp x</TD><TD CLASS="ccode">lisp </TD>
</TR>
<TR>
<TH></TH><TD>a LISP symbol</TD><TD>the symbol's value</TD>
</TR>
<TR>
<TH></TH><TD><EM>Threadsafe accessor for the value slot which doesn't incref the value it returns</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_init_hashset">fd_init_hashset</A></TD><TD CLASS="ccode">fd_hashset h,int minsize</TD><TD CLASS="ccode">void </TD>
</TR>
<TR>
<TH></TH><TD>a pointer to a hashset and an int minsize</TD><TD>nothing</TD>
</TR>
<TR>
<TH></TH><TD><EM>Initializes the table for use with at least minsize slots.
  This can be used for either a malloc'd hashtable or a hashtable
  on the stack.</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_hashtable_zap">fd_hashtable_zap</A></TD><TD CLASS="ccode">fd_hashtable h,lisp key</TD><TD CLASS="ccode">void </TD>
</TR>
<TR>
<TH></TH><TD>a pointer to a hashtable and a lisp key</TD><TD>nothing</TD>
</TR>
<TR>
<TH></TH><TD><EM>Removes all values associated key in the hashtable.</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_set_symbol_value">fd_set_symbol_value</A></TD><TD CLASS="ccode">lisp x,lisp v</TD><TD CLASS="ccode">void </TD>
</TR>
<TR>
<TH></TH><TD>a LISP symbol, another LISP pointer</TD><TD>nothing</TD>
</TR>
<TR>
<TH></TH><TD><EM>Threadsafe modifier for the value slot of a symbol.</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_hashtable_increment">fd_hashtable_increment</A></TD><TD CLASS="ccode">fd_hashtable h,lisp key,int increment</TD><TD CLASS="ccode">void </TD>
</TR>
<TR>
<TH></TH><TD>a pointer to a hashtable, a lisp key, and an int</TD><TD>nothing</TD>
</TR>
<TR>
<TH></TH><TD><EM>Increments the value associated with the key by a number, simply
    storing the number if no value is currently associated.</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_hashtable_test">fd_hashtable_test</A></TD><TD CLASS="ccode">fd_hashtable h,lisp key,lisp value</TD><TD CLASS="ccode">int </TD>
</TR>
<TR>
<TH></TH><TD>a pointer to a hashtable, a lisp key, and a lisp value</TD><TD>1 or 0</TD>
</TR>
<TR>
<TH></TH><TD><EM>Returns 1 if the value is one of the values associated with the key</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_hashset_get">fd_hashset_get</A></TD><TD CLASS="ccode">fd_hashset h,lisp key</TD><TD CLASS="ccode">int </TD>
</TR>
<TR>
<TH></TH><TD>a pointer to a hashtable and a lisp key</TD><TD>1 or 0</TD>
</TR>
<TR>
<TH></TH><TD><EM>Returns 1 if the given key is in the hashset.</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_free_hashtable">fd_free_hashtable</A></TD><TD CLASS="ccode">struct FD_HASHTABLE *h</TD><TD CLASS="ccode">void </TD>
</TR>
<TR>
<TH></TH><TD>a pointer to a hashtable</TD><TD>nothing</TD>
</TR>
<TR>
<TH></TH><TD><EM>Frees the memory taken by a hashtable and its elements.  Note that
this does not free the hashtable itself, since it might be on the stack.</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_symbol_value">fd_symbol_value</A></TD><TD CLASS="ccode">lisp x</TD><TD CLASS="ccode">lisp </TD>
</TR>
<TR>
<TH></TH><TD>a LISP symbol</TD><TD>the symbol's value</TD>
</TR>
<TR>
<TH></TH><TD><EM>Threadsafe accessor for the value slot which increfs the value it returns</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_hashtable_drop">fd_hashtable_drop</A></TD><TD CLASS="ccode">fd_hashtable h,lisp key,lisp value</TD><TD CLASS="ccode">void </TD>
</TR>
<TR>
<TH></TH><TD>a pointer to a hashtable, a lisp key, and a value</TD><TD>nothing</TD>
</TR>
<TR>
<TH></TH><TD><EM>Removes a value from the values associated with key in the hashtable.</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_hashtable_add">fd_hashtable_add</A></TD><TD CLASS="ccode">fd_hashtable h,lisp key,lisp value</TD><TD CLASS="ccode">void </TD>
</TR>
<TR>
<TH></TH><TD>a pointer to a hashtable, a lisp key, and a value</TD><TD>nothing</TD>
</TR>
<TR>
<TH></TH><TD><EM>Adds a value to the values associated with key in the hashtable.  If the
    key is already associated with multiple values, a copy of the new value
    is added to it.  If there is one association, a new non-deterministic
    set is created.  And if there is not association, this is just the
    same as fd_hashtable_set.</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_for_all_symbols">fd_for_all_symbols</A></TD><TD CLASS="ccode">void (*fcn</TD><TD CLASS="ccode">void </TD>
</TR>
<TR>
<TH></TH><TD>a function on lisp pointers which returns void</TD><TD>nothing</TD>
</TR>
<TR>
<TH></TH><TD><EM>Applies the function to every symbol in the symbol table.</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_hashtable_probe">fd_hashtable_probe</A></TD><TD CLASS="ccode">fd_hashtable h,lisp key</TD><TD CLASS="ccode">int </TD>
</TR>
<TR>
<TH></TH><TD>a pointer to a hashtable, a lisp key</TD><TD>1 or 0</TD>
</TR>
<TR>
<TH></TH><TD><EM>Returns 1 if the key is associated with some value in the table.</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_select_table_size">fd_select_table_size</A></TD><TD CLASS="ccode">unsigned int min</TD><TD CLASS="ccode">unsigned int </TD>
</TR>
<TR>
<TH></TH><TD>an unsigned int (min)</TD><TD>an unsigned int greater than min</TD>
</TR>
<TR>
<TH></TH><TD><EM>Selects a hashtable/index size greater than min.</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_hashset_probe">fd_hashset_probe</A></TD><TD CLASS="ccode">fd_hashset h,lisp key</TD><TD CLASS="ccode">lisp </TD>
</TR>
<TR>
<TH></TH><TD>a pointer to a hashset and a lisp key</TD><TD>a value EQUAL to the key in the hashset</TD>
</TR>
<TR>
<TH></TH><TD><EM>Adds a cref of a key to the hashset (if it doesn't already contain it),
otherwise returns the pointer already there</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_hashtable_set">fd_hashtable_set</A></TD><TD CLASS="ccode">fd_hashtable h,lisp key,lisp value</TD><TD CLASS="ccode">void </TD>
</TR>
<TR>
<TH></TH><TD>a pointer to a hashtable, a lisp key, and a value</TD><TD>nothing</TD>
</TR>
<TR>
<TH></TH><TD><EM>Associates the value with the key in the hashtable.  If the key is new
   it copies both key and value; if the key already had an association, that
   value is freed and a copy of the new value replaces it.</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_hashset_strget">fd_hashset_strget</A></TD><TD CLASS="ccode">fd_hashset h,fd_u8char *keystring,int len</TD><TD CLASS="ccode">int </TD>
</TR>
<TR>
<TH></TH><TD>a pointer to a hashtable and a string</TD><TD>1 or 0</TD>
</TR>
<TR>
<TH></TH><TD><EM>Returns 1 if the a LISP copy of string is in the hashset.</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_intern">fd_intern</A></TD><TD CLASS="ccode">const fd_u8char *name,int len</TD><TD CLASS="ccode">fd_lisp </TD>
</TR>
<TR>
<TH></TH><TD>a pointer to a string and a int length</TD><TD>a lisp pointer to a symbol whose name is the string capitalized</TD>
</TR>
<TR>
<TH></TH><TD><EM>Returns an interned symbol whose name is a capitalized version of name.</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="_fd_hashset_add_nc">_fd_hashset_add_nc</A></TD><TD CLASS="ccode">fd_hashset h,lisp key</TD><TD CLASS="ccode">int </TD>
</TR>
<TR>
<TH></TH><TD>a pointer to a hashset and a lisp key</TD><TD>1 if the value wasn't already there</TD>
</TR>
<TR>
<TH></TH><TD><EM>Adds a key (not a copy!) to the hashset.</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_hashset_elts">fd_hashset_elts</A></TD><TD CLASS="ccode">fd_hashset h</TD><TD CLASS="ccode">lisp </TD>
</TR>
<TR>
<TH></TH><TD>a pointer to a hashset</TD><TD>a lisp object (possibly a non-deterministic set)</TD>
</TR>
<TR>
<TH></TH><TD><EM>This returns all the values in the hashset.</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="_fd_hashtable_set_nolock">_fd_hashtable_set_nolock</A></TD><TD CLASS="ccode">fd_hashtable h,lisp key,lisp value</TD><TD CLASS="ccode">void </TD>
</TR>
<TR>
<TH></TH><TD>a pointer to a hashtable, a lisp key, and a value</TD><TD>nothing</TD>
</TR>
<TR>
<TH></TH><TD><EM>Associates the value with the key in the hashtable.  If the key is new
   it copies both key and value; if the key already had an association, that
   value is freed and a copy of the new value replaces it.</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_hashset_add">fd_hashset_add</A></TD><TD CLASS="ccode">fd_hashset h,lisp key</TD><TD CLASS="ccode">int </TD>
</TR>
<TR>
<TH></TH><TD>a pointer to a hashset and a lisp key</TD><TD>1 if the value wasn't already there</TD>
</TR>
<TR>
<TH></TH><TD><EM>Adds a cref of a key to the hashset (if it doesn't already contain it).</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_hashset_intern">fd_hashset_intern</A></TD><TD CLASS="ccode">fd_hashset h,lisp key</TD><TD CLASS="ccode">lisp </TD>
</TR>
<TR>
<TH></TH><TD>a pointer to a hashset and a lisp key</TD><TD>a value EQUAL to the key in the hashset</TD>
</TR>
<TR>
<TH></TH><TD><EM>Adds a cref of a key to the hashset (if it doesn't already contain it),
otherwise returns the pointer already there</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_make_hashtable">fd_make_hashtable</A></TD><TD CLASS="ccode">int minsize</TD><TD CLASS="ccode">struct FD_HASHTABLE * </TD>
</TR>
<TR>
<TH></TH><TD>an int minsize</TD><TD>a pointer to a hashtable</TD>
</TR>
<TR>
<TH></TH><TD><EM>This mallocs a new hashtable and initializes it to have at least minsize
   elements.</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_hashset_drop">fd_hashset_drop</A></TD><TD CLASS="ccode">fd_hashset h,lisp key</TD><TD CLASS="ccode">void </TD>
</TR>
<TR>
<TH></TH><TD>a pointer to a hashtable and a lisp key</TD><TD>nothing</TD>
</TR>
<TR>
<TH></TH><TD><EM>"Removes" the key from the hashset by replacing it with FD_VOID.
   Note that this doesn't save any space, but the search algorithm will
   just skip over it rather than returning it.</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_hashtable_max">fd_hashtable_max</A></TD><TD CLASS="ccode">fd_hashtable h</TD><TD CLASS="ccode">lisp </TD>
</TR>
<TR>
<TH></TH><TD>a hashtable</TD><TD>a lisp pointer</TD>
</TR>
<TR>
<TH></TH><TD><EM>Returns the keys in the hashtable whose values are numerically
maximum.</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_choice_to_hashset">fd_choice_to_hashset</A></TD><TD CLASS="ccode">lisp values</TD><TD CLASS="ccode">fd_hashset </TD>
</TR>
<TR>
<TH></TH><TD>a pointer to a hashset</TD><TD>a lisp object (possibly a non-deterministic set)</TD>
</TR>
<TR>
<TH></TH><TD><EM>This returns all the values in the hashset.</EM></TD><TD></TD>
</TR>

</TABLE>
{}<A NAME="file-pool.c"><H2>
Functions defined in <TT>src/odb/file-pool.c</TT>
</H2>
</A><P>
<A HREF="#fd_cache_file_pool"><TT>fd_cache_file_pool</TT></A> | <A HREF="#fd_file_pool_capacity"><TT>fd_file_pool_capacity</TT></A> | <A HREF="#fd_file_pool_freespace"><TT>fd_file_pool_freespace</TT></A> | <A HREF="#fd_file_pool_load"><TT>fd_file_pool_load</TT></A> | <A HREF="#fd_label_file_pool"><TT>fd_label_file_pool</TT></A> | <A HREF="#fd_lock_file_pool"><TT>fd_lock_file_pool</TT></A> | <A HREF="#fd_make_file_pool
"><TT>fd_make_file_pool
</TT></A> | <A HREF="#fd_make_new_super_pool"><TT>fd_make_new_super_pool</TT></A> | <A HREF="#fd_make_pool_snapshot"><TT>fd_make_pool_snapshot</TT></A> | <A HREF="#fd_make_super_pool
"><TT>fd_make_super_pool
</TT></A> | <A HREF="#fd_new_file_pool
"><TT>fd_new_file_pool
</TT></A> | <A HREF="#fd_read_file_pool_metadata
"><TT>fd_read_file_pool_metadata
</TT></A> | <A HREF="#fd_register_file_pool_opener"><TT>fd_register_file_pool_opener</TT></A> | <A HREF="#fd_use_file_pool"><TT>fd_use_file_pool</TT></A> | 
</P>
<TABLE CELLPADDING="5">
<TR>
<TH ALIGN="LEFT">Function</TH><TH ALIGN="LEFT">Arguments</TH><TH ALIGN="LEFT">Returns</TH>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_make_file_pool
">fd_make_file_pool
</A></TD><TD CLASS="ccode">char *filename,FD_OID base, unsigned int capacity,
   int major_version,fd_lisp metadata</TD><TD CLASS="ccode">void </TD>
</TR>
<TR>
<TH></TH><TD>pointer to an object ID (oid)
                 capacity (unsigned int)
                 filename (string pointer)</TD><TD>void</TD>
</TR>
<TR>
<TH></TH><TD><EM>Creates an empty file pool on disk which can be subsequently
    opened or added.</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_make_super_pool
">fd_make_super_pool
</A></TD><TD CLASS="ccode">char *filename,unsigned int base,unsigned int load</TD><TD CLASS="ccode">unsigned int </TD>
</TR>
<TR>
<TH></TH><TD>a filename, a base id, and a load</TD><TD>the base id</TD>
</TR>
<TR>
<TH></TH><TD><EM>Creates a new super pool file.  The base id is specifies
the high half of the base of the super pool and the load declares
how many OIDs are already "pre allocated" from the super pool.</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_read_file_pool_metadata
">fd_read_file_pool_metadata
</A></TD><TD CLASS="ccode">FILE *f,int *revnum,int *size,time_t *make,time_t *repack,time_t *change</TD><TD CLASS="ccode">fd_lisp </TD>
</TR>
<TR>
<TH></TH><TD>an open file stream to a file pool and pointers to two ints</TD><TD>a lisp object (or the empty choice)</TD>
</TR>
<TR>
<TH></TH><TD><EM>Returns metadata and version information for a file pool.
     The version information, consisting of a serial repack ID and
  a file length, are written into the two integer  pointers.
     Since modifications always write at the end of the file,
  the repack serial number and the length of the file uniquely
  identify a moment in time for the file.</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_file_pool_freespace">fd_file_pool_freespace</A></TD><TD CLASS="ccode">fd_u8char *filename</TD><TD CLASS="ccode">unsigned int </TD>
</TR>
<TR>
<TH></TH><TD>a pathname (a string)</TD><TD>an unsigned int</TD>
</TR>
<TR>
<TH></TH><TD><EM>Returns the number of unallocated OIDs in the specified file pool.
This operates without actually "using the pool".</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_make_pool_snapshot">fd_make_pool_snapshot</A></TD><TD CLASS="ccode">char *filename,char *snapshot</TD><TD CLASS="ccode">void </TD>
</TR>
<TR>
<TH></TH><TD>two filenames</TD><TD>the base id</TD>
</TR>
<TR>
<TH></TH><TD><EM>Creates a "snapshot" of a specified file pool.  This is basically
a copy of the pools offset table and load information, which can be used
to reconstitute the state of the pool.  This takes advantage of the fact
that pools don't write over values until they are repacked.</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_lock_file_pool">fd_lock_file_pool</A></TD><TD CLASS="ccode">fd_file_pool p</TD><TD CLASS="ccode">int </TD>
</TR>
<TR>
<TH></TH><TD>a pointer to a file pool</TD><TD>1 on success</TD>
</TR>
<TR>
<TH></TH><TD><EM>Attempts to lock the file storing pool.</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_new_file_pool
">fd_new_file_pool
</A></TD><TD CLASS="ccode">char *filename,unsigned int capacity,char *super_pool</TD><TD CLASS="ccode">void </TD>
</TR>
<TR>
<TH></TH><TD>a filename (localized string), a capacity (unsigned int),
                and a super pool id (localized string)</TD><TD>void</TD>
</TR>
<TR>
<TH></TH><TD><EM>Creates a new, empty, file pool with a particular capacity from a
specified super pool.</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_label_file_pool">fd_label_file_pool</A></TD><TD CLASS="ccode">char *filename,lisp label</TD><TD CLASS="ccode">void </TD>
</TR>
<TR>
<TH></TH><TD>a string, and a lisp object</TD><TD>void</TD>
</TR>
<TR>
<TH></TH><TD><EM>Modifies a file pool to have a given label.</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_make_new_super_pool">fd_make_new_super_pool</A></TD><TD CLASS="ccode">char *filename</TD><TD CLASS="ccode">unsigned int </TD>
</TR>
<TR>
<TH></TH><TD>a filename</TD><TD>the base id</TD>
</TR>
<TR>
<TH></TH><TD><EM>Creates a new super pool file with a random base id (based
on the time and process id).  This will not allocated in the first
thousand super pools.</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_register_file_pool_opener">fd_register_file_pool_opener</A></TD><TD CLASS="ccode">int magic_no,fd_pool (*opener</TD><TD CLASS="ccode">void </TD>
</TR>
<TR>
<TH></TH><TD>a magic number and an opening function</TD><TD>void</TD>
</TR>
<TR>
<TH></TH><TD><EM>This associates an opening function with a number which
  is the first word of the file to use this opener.</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_use_file_pool">fd_use_file_pool</A></TD><TD CLASS="ccode">fd_u8char *fname</TD><TD CLASS="ccode">fd_pool </TD>
</TR>
<TR>
<TH></TH><TD>a string naming a file</TD><TD>a pointer to a file pool structure</TD>
</TR>
<TR>
<TH></TH><TD><EM>Errors:
    Cannot open pool (signalled by fd_open_file_pool)

   Side effects:
    Creates a file pool structure for the named file
    Adds a pointer to the pool structure to _fd_pool_table</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_file_pool_load">fd_file_pool_load</A></TD><TD CLASS="ccode">fd_u8char *filename</TD><TD CLASS="ccode">unsigned int </TD>
</TR>
<TR>
<TH></TH><TD>a pathname (a string)</TD><TD>an unsigned int</TD>
</TR>
<TR>
<TH></TH><TD><EM>Returns the number of allocated OIDs in the specified file pool.
This operates without actually "using the pool".</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_file_pool_capacity">fd_file_pool_capacity</A></TD><TD CLASS="ccode">fd_u8char *filename</TD><TD CLASS="ccode">unsigned int </TD>
</TR>
<TR>
<TH></TH><TD>a pathname (a string)</TD><TD>an unsigned int</TD>
</TR>
<TR>
<TH></TH><TD><EM>Returns the total number of possible OIDs in the specified file pool.
This operates without actually "using the pool".</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_cache_file_pool">fd_cache_file_pool</A></TD><TD CLASS="ccode">fd_pool p</TD><TD CLASS="ccode">void </TD>
</TR>
<TR>
<TH></TH><TD>pointer to a file pool structure</TD><TD>void</TD>
</TR>
<TR>
<TH></TH><TD><EM>Initializes a cache for the file pool, reducing the
    need for disk access and repositioning.</EM></TD><TD></TD>
</TR>

</TABLE>
<A NAME="portahash.c"><H2>
Functions defined in <TT>src/index/portahash.c</TT>
</H2>
</A><P>

</P>
<TABLE CELLPADDING="5">
<TR>
<TH ALIGN="LEFT">Function</TH><TH ALIGN="LEFT">Arguments</TH><TH ALIGN="LEFT">Returns</TH>
</TR>

</TABLE>
<A NAME="file-index.c"><H2>
Functions defined in <TT>src/index/file-index.c</TT>
</H2>
</A><P>
<A HREF="#fd_dtype_compare"><TT>fd_dtype_compare</TT></A> | <A HREF="#fd_file_index_collect_values
"><TT>fd_file_index_collect_values
</TT></A> | <A HREF="#fd_index_report_stats"><TT>fd_index_report_stats</TT></A> | <A HREF="#fd_preload_file_index"><TT>fd_preload_file_index</TT></A> | <A HREF="#fd_register_file_index_opener"><TT>fd_register_file_index_opener</TT></A> | <A HREF="#fd_unpreload_file_index"><TT>fd_unpreload_file_index</TT></A> | <A HREF="#object"><TT>object</TT></A> | 
</P>
<TABLE CELLPADDING="5">
<TR>
<TH ALIGN="LEFT">Function</TH><TH ALIGN="LEFT">Arguments</TH><TH ALIGN="LEFT">Returns</TH>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_file_index_collect_values
">fd_file_index_collect_values
</A></TD><TD CLASS="ccode">fd_file_index ix,unsigned int loc,unsigned int size</TD><TD CLASS="ccode">lisp </TD>
</TR>
<TR>
<TH></TH><TD>a file stream</TD><TD>a "result set"</TD>
</TR>
<TR>
<TH></TH><TD><EM>This reads a linked list stored in a binary file and generates a
     lisp list from its elements.  It returns a "result set" which
     consists of a size and a list of elements.</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_index_report_stats">fd_index_report_stats</A></TD><TD CLASS="ccode">FILE *stream</TD><TD CLASS="ccode">void </TD>
</TR>
<TR>
<TH></TH><TD>none</TD><TD>void</TD>
</TR>
<TR>
<TH></TH><TD><EM>Prints a report on hash table chaining behavior.</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_register_file_index_opener">fd_register_file_index_opener</A></TD><TD CLASS="ccode">int magic_no,fd_index (*opener</TD><TD CLASS="ccode">void </TD>
</TR>
<TR>
<TH></TH><TD>a magic number and an opening function</TD><TD>void</TD>
</TR>
<TR>
<TH></TH><TD><EM>This associates an opening function with a number which
  is the first word of the file to use this opener.</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="object">object</A></TD><TD CLASS="ccode">or the empty choice</TD><TD CLASS="ccode">FRAMERD_EXPORT
/* fd_read_file_index_metadata:
 Arguments: an open file stream to a file index and pointers to two ints
 Returns: a lisp </TD>
</TR>
<TR>
<TH></TH><TD>an open file stream to a file index, and pointers to two ints</TD><TD>a lisp object (or the empty choice)</TD>
</TR>
<TR>
<TH></TH><TD><EM>Returns metadata and version information for a file index.
     The version information, consisting of a serial repack ID and
  a file length, are written into the two int pointers.
     Since modifications always write at the end of the file,
  the repack serial number and the length of the file uniquely
  identify a moment in time for the file.</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_dtype_compare">fd_dtype_compare</A></TD><TD CLASS="ccode">lisp key,FILE *stream</TD><TD CLASS="ccode">int </TD>
</TR>
<TR>
<TH></TH><TD>a lisp object and a file stream</TD><TD>boolean (int)</TD>
</TR>
<TR>
<TH></TH><TD><EM>This returns true if the dtype representation on the file stream
    is equal to the lisp object it is handed.  If it returns true (1),
    the file is positioned at the end of the dtype representation.</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_unpreload_file_index">fd_unpreload_file_index</A></TD><TD CLASS="ccode">fd_index idx_arg</TD><TD CLASS="ccode">void </TD>
</TR>
<TR>
<TH></TH><TD>a pointer to an index</TD><TD>void</TD>
</TR>
<TR>
<TH></TH><TD><EM>Reinits the size cache and basically undoes the effects of
  fd_preload_file_index.</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_preload_file_index">fd_preload_file_index</A></TD><TD CLASS="ccode">fd_index idx_arg</TD><TD CLASS="ccode">void </TD>
</TR>
<TR>
<TH></TH><TD>a pointer to an index</TD><TD>void</TD>
</TR>
<TR>
<TH></TH><TD><EM>This loads up the file indices size cache with all of the keys in the
   table.  In addition to providing a fast cache of frequency information,
   this allows fetching to determine if there is a value without actually
   going to disk.</EM></TD><TD></TD>
</TR>

</TABLE>
<A NAME="frames.c"><H2>
Functions defined in <TT>src/odb/frames.c</TT>
</H2>
</A><P>
<A HREF="#fd_already_doing_p"><TT>fd_already_doing_p</TT></A> | <A HREF="#fd_clear_slot_cache"><TT>fd_clear_slot_cache</TT></A> | <A HREF="#fd_copy_frame"><TT>fd_copy_frame</TT></A> | <A HREF="#fd_describe_slot"><TT>fd_describe_slot</TT></A> | <A HREF="#fd_disable_slot_cache"><TT>fd_disable_slot_cache</TT></A> | <A HREF="#fd_enable_slot_cache"><TT>fd_enable_slot_cache</TT></A> | <A HREF="#fd_for_slots"><TT>fd_for_slots</TT></A> | <A HREF="#fd_frame_add"><TT>fd_frame_add</TT></A> | <A HREF="#fd_frame_create"><TT>fd_frame_create</TT></A> | <A HREF="#fd_frame_get"><TT>fd_frame_get</TT></A> | <A HREF="#fd_frame_get_star"><TT>fd_frame_get_star</TT></A> | <A HREF="#fd_frame_remove"><TT>fd_frame_remove</TT></A> | <A HREF="#fd_frame_set"><TT>fd_frame_set</TT></A> | <A HREF="#fd_frame_slots"><TT>fd_frame_slots</TT></A> | <A HREF="#fd_frame_test"><TT>fd_frame_test</TT></A> | <A HREF="#fd_get_slotmap"><TT>fd_get_slotmap</TT></A> | <A HREF="#fd_inherit_values"><TT>fd_inherit_values</TT></A> | <A HREF="#fd_inherits_valuep"><TT>fd_inherits_valuep</TT></A> | <A HREF="#fd_overlay_create"><TT>fd_overlay_create</TT></A> | <A HREF="#fd_overlay_get"><TT>fd_overlay_get</TT></A> | <A HREF="#fd_overlay_test"><TT>fd_overlay_test</TT></A> | <A HREF="#fd_pathp"><TT>fd_pathp</TT></A> | <A HREF="#fd_prim_add"><TT>fd_prim_add</TT></A> | <A HREF="#fd_prim_add_consed"><TT>fd_prim_add_consed</TT></A> | <A HREF="#fd_prim_drop"><TT>fd_prim_drop</TT></A> | <A HREF="#fd_prim_get"><TT>fd_prim_get</TT></A> | <A HREF="#fd_prim_set"><TT>fd_prim_set</TT></A> | <A HREF="#fd_prim_set_consed"><TT>fd_prim_set_consed</TT></A> | <A HREF="#fd_prim_test"><TT>fd_prim_test</TT></A> | <A HREF="#fd_use_autoindex"><TT>fd_use_autoindex</TT></A> | 
</P>
<TABLE CELLPADDING="5">
<TR>
<TH ALIGN="LEFT">Function</TH><TH ALIGN="LEFT">Arguments</TH><TH ALIGN="LEFT">Returns</TH>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_for_slots">fd_for_slots</A></TD><TD CLASS="ccode">void (*fcn</TD><TD CLASS="ccode">void </TD>
</TR>
<TR>
<TH></TH><TD>a function on three lisp objects and a lisp object</TD><TD>void</TD>
</TR>
<TR>
<TH></TH><TD><EM>Applies the function to the frame and each of its attributes and values.</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_get_slotmap">fd_get_slotmap</A></TD><TD CLASS="ccode">lisp arg</TD><TD CLASS="ccode">lisp </TD>
</TR>
<TR>
<TH></TH><TD>a lisp pointer</TD><TD>a lisp pointer</TD>
</TR>
<TR>
<TH></TH><TD><EM>If arg is a slotmap, it is cref'd and returned;
  if arg is an OID whose value is a slotmap, that slotmap is returned
  if arg is an OID whose value is a choice, one of which is a slotmap,
     that slotmap is returned</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_inherit_values">fd_inherit_values</A></TD><TD CLASS="ccode">lisp root,lisp slotid,lisp through</TD><TD CLASS="ccode">lisp </TD>
</TR>
<TR>
<TH></TH><TD>a frame and two slotids</TD><TD>a lisp pointer</TD>
</TR>
<TR>
<TH></TH><TD><EM>Searches for a value for the first slotid through the lattice
  defined by the second slotid.</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_frame_set">fd_frame_set</A></TD><TD CLASS="ccode">lisp frame,lisp slotid,lisp value</TD><TD CLASS="ccode">void </TD>
</TR>
<TR>
<TH></TH><TD>a frame, an attribute name (a lisp pointer),
       and a value (a lisp pointer)</TD><TD>void</TD>
</TR>
<TR>
<TH></TH><TD><EM>Modifies the given attribute (slotid) of frame so that it has values,
    removing and adding values as neccessary.</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_prim_drop">fd_prim_drop</A></TD><TD CLASS="ccode">lisp frame,lisp slotid,lisp value</TD><TD CLASS="ccode">void </TD>
</TR>
<TR>
<TH></TH><TD>a frame, an attribute name (a lisp pointer),
       and a value (a lisp pointer)</TD><TD>void</TD>
</TR>
<TR>
<TH></TH><TD><EM>Removes the designated value from the designated attribute of a frame

   Note: the attribute name is compared with ==, meaning that
    it can be a symbol, fixnum, ascii or unicode character, boolean,
       or an object</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_prim_set_consed">fd_prim_set_consed</A></TD><TD CLASS="ccode">lisp frame,lisp slotid,lisp value</TD><TD CLASS="ccode">void </TD>
</TR>
<TR>
<TH></TH><TD>a frame, an attribute name (a lisp pointer),
       and a value (a lisp pointer)</TD><TD>void</TD>
</TR>
<TR>
<TH></TH><TD><EM>Just like fd_prim_set, but frees the value it was passed (the
 frame still keeps its pointer.  This is a convenience function
 for passing consed values as arguments.</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_overlay_get">fd_overlay_get</A></TD><TD CLASS="ccode">lisp frame,lisp slotid</TD><TD CLASS="ccode">lisp </TD>
</TR>
<TR>
<TH></TH><TD>a frame (slotmap or OID evaluating to one) and a slotid</TD><TD>a lisp pointer</TD>
</TR>
<TR>
<TH></TH><TD><EM>Does inheritance through OID values on annotated frames.</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_frame_remove">fd_frame_remove</A></TD><TD CLASS="ccode">lisp frame,lisp slotid,lisp value</TD><TD CLASS="ccode">void </TD>
</TR>
<TR>
<TH></TH><TD>a frame, an attribute name (a lisp pointer),
       and a value (a lisp pointer)</TD><TD>void</TD>
</TR>
<TR>
<TH></TH><TD><EM>If a frame already possesses the named attribute whose value contains
     the given value, it is removed.  If that would make the attribute value
     empty, it is replaced with FD_EMPTY_CHOICE; if that would make the attribute
     value a singleton, it is replaced with just that value.
   If the slot is itself an oid and the value removed is actually present,
     then the remove-effects demons of the slot are evaluated.</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_frame_add">fd_frame_add</A></TD><TD CLASS="ccode">lisp frame,lisp slotid,lisp value</TD><TD CLASS="ccode">void </TD>
</TR>
<TR>
<TH></TH><TD>a frame, an attribute name (a lisp pointer),
       and a value (a lisp pointer)</TD><TD>void</TD>
</TR>
<TR>
<TH></TH><TD><EM>If a frame already possesses the named attribute, the value is added to
     its set of values (if it's value isn't a set, it is made one).
   If the slot is itself an oid and the value stored is new (not currently
          in the attribute's set of values),
     then the add-effects demons of the slot are evaluated.

   Side effects:
     May replace the slot/value vector of a slotmap to add an attribute
     Refcounts or copies the value given it (sets are copied)

   Note: the attribute name is compared with ==, meaning that
    it can be a symbol, fixnum, ascii or unicode character, boolean,
       or an oid</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_use_autoindex">fd_use_autoindex</A></TD><TD CLASS="ccode">fd_index ix</TD><TD CLASS="ccode">void </TD>
</TR>
<TR>
<TH></TH><TD>a pointer to an index</TD><TD>void</TD>
</TR>
<TR>
<TH></TH><TD><EM>Sets up a particular index for automatically recording
  changed and new slot values.</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_copy_frame">fd_copy_frame</A></TD><TD CLASS="ccode">lisp original,fd_pool x</TD><TD CLASS="ccode">lisp </TD>
</TR>
<TR>
<TH></TH><TD>a frame and a pool</TD><TD>a pointer to a new frame (oid)</TD>
</TR>
<TR>
<TH></TH><TD><EM>This creates a new object in the pool and initializes
    its value to be a slotmap copying another object's stotmap,
    thus making it a frame.</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_prim_add_consed">fd_prim_add_consed</A></TD><TD CLASS="ccode">lisp frame,lisp slotid,lisp value</TD><TD CLASS="ccode">void </TD>
</TR>
<TR>
<TH></TH><TD>a frame, an attribute name (a lisp pointer),
       and a value (a lisp pointer)</TD><TD>void</TD>
</TR>
<TR>
<TH></TH><TD><EM>Just like fd_prim_add, but frees the value it was passed (the
 frame still keeps its pointer.  This is for passing consed values
 as arguments.</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_describe_slot">fd_describe_slot</A></TD><TD CLASS="ccode">FILE *stream,lisp slotid,lisp value</TD><TD CLASS="ccode">void </TD>
</TR>
<TR>
<TH></TH><TD>an attribute name and a value</TD><TD>void</TD>
</TR>
<TR>
<TH></TH><TD><EM>Describes a slot and its value to a stream.</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_frame_test">fd_frame_test</A></TD><TD CLASS="ccode">lisp frame,lisp slotid,lisp value</TD><TD CLASS="ccode">int </TD>
</TR>
<TR>
<TH></TH><TD>a frame, a slotid, and a value</TD><TD>1 if the value is on the slot, 0 otherwise</TD>
</TR>
<TR>
<TH></TH><TD><EM>If the slot is an oid, this may use the TEST-METHODS and 
    GET-METHODS of the slot.  Otherwise, it just checks for membership
    in the corresponding value.

   Note: the attribute name is compared with ==, meaning that
    it can be a symbol, fixnum, ascii or unicode character, boolean,
       or an oid pointer</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_clear_slot_cache">fd_clear_slot_cache</A></TD><TD CLASS="ccode">lisp slotid,lisp frame</TD><TD CLASS="ccode">void </TD>
</TR>
<TR>
<TH></TH><TD>slotid, frame</TD><TD>void</TD>
</TR>
<TR>
<TH></TH><TD><EM>Clears cached entries for slotid and frame, clearing
  all entries if frame is FD_VOID</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_frame_slots">fd_frame_slots</A></TD><TD CLASS="ccode">lisp frames</TD><TD CLASS="ccode">fd_lisp </TD>
</TR>
<TR>
<TH></TH><TD>a frame</TD><TD>a set of slot ids</TD>
</TR>
<TR>
<TH></TH><TD><EM>Returns the current slot ids with associations on the frame</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_prim_get">fd_prim_get</A></TD><TD CLASS="ccode">lisp frame,lisp slotid</TD><TD CLASS="ccode">lisp </TD>
</TR>
<TR>
<TH></TH><TD>a frame and an attribute name (a lisp pointer)</TD><TD>a lisp pointer</TD>
</TR>
<TR>
<TH></TH><TD><EM>Returns either the value associated with the attribute
 or FD_EMPTY_CHOICE if no such attribute exists; this value is
 computed from the attribute value if the slot is an object identifier.

   Note: the attribute name is compared with ==, meaning that
    it can be a symbol, fixnum, ascii or unicode character, boolean,
       or an object pointer</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_prim_test">fd_prim_test</A></TD><TD CLASS="ccode">lisp frame,lisp slotid,lisp value</TD><TD CLASS="ccode">int </TD>
</TR>
<TR>
<TH></TH><TD>a frame, an attribute name (a lisp pointer),
       and a value (a lisp pointer)</TD><TD>1 or 0</TD>
</TR>
<TR>
<TH></TH><TD><EM>Returns 1 if the named attribute of the frame contains a value</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_pathp">fd_pathp</A></TD><TD CLASS="ccode">lisp root,lisp slotid,lisp to</TD><TD CLASS="ccode">int </TD>
</TR>
<TR>
<TH></TH><TD>a frame, a slotid, and a frame</TD><TD>1 or 0</TD>
</TR>
<TR>
<TH></TH><TD><EM>Returns 1 if there is a path through slotid between the two frames</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_overlay_test">fd_overlay_test</A></TD><TD CLASS="ccode">lisp frame,lisp slotid,lisp value</TD><TD CLASS="ccode">int </TD>
</TR>
<TR>
<TH></TH><TD>a frame (slotmap or OID evaluating to one), a slotid,
                 and a value</TD><TD>1 or 0</TD>
</TR>
<TR>
<TH></TH><TD><EM>Does inheritance through OID values on annotated frames, determining
if a slotid is associated with a particular value.</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_enable_slot_cache">fd_enable_slot_cache</A></TD><TD CLASS="ccode">lisp slotid</TD><TD CLASS="ccode">void </TD>
</TR>
<TR>
<TH></TH><TD>slotid</TD><TD>void</TD>
</TR>
<TR>
<TH></TH><TD><EM>Enables caching on the slot SLOTID</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_prim_add">fd_prim_add</A></TD><TD CLASS="ccode">lisp frame,lisp slotid,lisp value</TD><TD CLASS="ccode">void </TD>
</TR>
<TR>
<TH></TH><TD>a frame, an attribute name (a lisp pointer),
       and a value (a lisp pointer)</TD><TD>void</TD>
</TR>
<TR>
<TH></TH><TD><EM>If the frame already possess the named attribute, the specified
    value is added to the current one; otherwise, the attribute is
    added to the frame with the corresponding value.

   Side effects:
     May replace the slot/value vector of a slotmap to add an attribute
     Refcounts or copies the value given it (sets are copied)

   Note: the attribute name is compared with ==, meaning that
    it can be a symbol, fixnum, ascii or unicode character, boolean,
       or an object</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_overlay_create">fd_overlay_create</A></TD><TD CLASS="ccode">fd_pool x,lisp value</TD><TD CLASS="ccode">lisp </TD>
</TR>
<TR>
<TH></TH><TD>a pool and a frame</TD><TD>a pointer to a frame (oid)</TD>
</TR>
<TR>
<TH></TH><TD><EM>This creates a new oid in the pool and initializes
    its value to be both a slotmap and a pointer to a frame</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_frame_create">fd_frame_create</A></TD><TD CLASS="ccode">fd_pool x</TD><TD CLASS="ccode">lisp </TD>
</TR>
<TR>
<TH></TH><TD>a pool</TD><TD>a pointer to a frame (oid)</TD>
</TR>
<TR>
<TH></TH><TD><EM>This creates a new oid in the pool and initializes
    its value to be a slotmap, thus making it a frame.</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_frame_get">fd_frame_get</A></TD><TD CLASS="ccode">lisp frame,lisp slotid</TD><TD CLASS="ccode">lisp </TD>
</TR>
<TR>
<TH></TH><TD>a frame and an attribute name (a lisp pointer)</TD><TD>either the value associated with the attribute</TD>
</TR>
<TR>
<TH></TH><TD><EM>or FD_EMPTY_CHOICE if no such attribute exists
       (The return value is a copy which may need to be freed).

   Note: the attribute name is compared with ==, meaning that
    it can be a symbol, fixnum, ascii or unicode character, boolean,
       or an oid pointer</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_prim_set">fd_prim_set</A></TD><TD CLASS="ccode">lisp frame,lisp slotid,lisp value</TD><TD CLASS="ccode">void </TD>
</TR>
<TR>
<TH></TH><TD>a frame, a slotid (a lisp pointer),
       and a value (a lisp pointer)</TD><TD>void</TD>
</TR>
<TR>
<TH></TH><TD><EM>If the frame already possess the named attribute, its value is replaced
    with the new one; otherwise, the attribute is added to the frame
    with the corresponding value.

   Side effects:
     May replace the slot/value vector of a slotmap to add an attribute
     Frees the previous value of the attribute (if it exists)
     Refcounts or copies the value given it (sets are copied)

   Note: the attribute name is compared with ==, meaning that
    it can be a symbol, fixnum, ascii or unicode character, boolean,
       or an object</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_disable_slot_cache">fd_disable_slot_cache</A></TD><TD CLASS="ccode">lisp slotid</TD><TD CLASS="ccode">void </TD>
</TR>
<TR>
<TH></TH><TD>slotid</TD><TD>void</TD>
</TR>
<TR>
<TH></TH><TD><EM>Disables caching on the slot SLOTID</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_frame_get_star">fd_frame_get_star</A></TD><TD CLASS="ccode">fd_lisp frames,fd_lisp slotids</TD><TD CLASS="ccode">fd_lisp </TD>
</TR>
<TR>
<TH></TH><TD>a choice of frames and a choice of slotids</TD><TD>the kleene star of the slotids on the frames</TD>
</TR>
<TR>
<TH></TH><TD><EM></EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_inherits_valuep">fd_inherits_valuep</A></TD><TD CLASS="ccode">lisp root,lisp slotid,lisp through,lisp value</TD><TD CLASS="ccode">int </TD>
</TR>
<TR>
<TH></TH><TD>a frame, two slotids, and a value</TD><TD>1 or 0</TD>
</TR>
<TR>
<TH></TH><TD><EM>Returns 1 if the value can be inherited for the first slotid
  going through the lattice defined by the second slotid.</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_already_doing_p">fd_already_doing_p</A></TD><TD CLASS="ccode">slot_op op,lisp frame,lisp slotid,lisp value</TD><TD CLASS="ccode">int </TD>
</TR>
<TR>
<TH></TH><TD>a slot operation, a frame, slot, and value</TD><TD>1 or 0</TD>
</TR>
<TR>
<TH></TH><TD><EM>Returns 1 if the frame system is already doing a slot operation.
(This causes most slot operations to return the empty choice).</EM></TD><TD></TD>
</TR>

</TABLE>
<A NAME="search.c"><H2>
Functions defined in <TT>src/index/search.c</TT>
</H2>
</A><P>
<A HREF="#fd_find_frames"><TT>fd_find_frames</TT></A> | <A HREF="#fd_find_similar"><TT>fd_find_similar</TT></A> | <A HREF="#fd_get_frame_features"><TT>fd_get_frame_features</TT></A> | <A HREF="#fd_get_slot_features"><TT>fd_get_slot_features</TT></A> | <A HREF="#fd_index_frame"><TT>fd_index_frame</TT></A> | <A HREF="#fd_index_notice_slot_values
"><TT>fd_index_notice_slot_values
</TT></A> | <A HREF="#fd_index_slot_values
"><TT>fd_index_slot_values
</TT></A> | <A HREF="#fd_index_slots"><TT>fd_index_slots</TT></A> | <A HREF="#fd_score_from_samples
"><TT>fd_score_from_samples
</TT></A> | <A HREF="#fd_score_from_spec"><TT>fd_score_from_spec</TT></A> | <A HREF="#fd_strict_search"><TT>fd_strict_search</TT></A> | 
</P>
<TABLE CELLPADDING="5">
<TR>
<TH ALIGN="LEFT">Function</TH><TH ALIGN="LEFT">Arguments</TH><TH ALIGN="LEFT">Returns</TH>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_score_from_spec">fd_score_from_spec</A></TD><TD CLASS="ccode">lisp indices,lisp frames,lisp spec</TD><TD CLASS="ccode">fd_hashtable </TD>
</TR>
<TR>
<TH></TH><TD>an index, a set of frames, and a list of feature sets</TD><TD>a hashtable of frames and scores</TD>
</TR>
<TR>
<TH></TH><TD><EM>Computes similarity scores to <samples> based on the feature sets
 If the set of frames argument is void, all candidates are scored;
  otherwise, only the specified frames are scored.</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_find_similar">fd_find_similar</A></TD><TD CLASS="ccode">lisp indices,lisp frames,lisp slots</TD><TD CLASS="ccode">lisp </TD>
</TR>
<TR>
<TH></TH><TD>an index, a set of frames, and a set of slots</TD><TD>a set of frames</TD>
</TR>
<TR>
<TH></TH><TD><EM>Finds all frames in <index> that have some <slots> in common with <frames></EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_get_frame_features">fd_get_frame_features</A></TD><TD CLASS="ccode">lisp frames</TD><TD CLASS="ccode">lisp </TD>
</TR>
<TR>
<TH></TH><TD>a frame (or set of frames)</TD><TD>a set of features based on those on the slots of FRAMES</TD>
</TR>
<TR>
<TH></TH><TD><EM>Gets the features of FRAME based on all of its slots.</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_score_from_samples
">fd_score_from_samples
</A></TD><TD CLASS="ccode">lisp indices,lisp frames,lisp samples,lisp slots</TD><TD CLASS="ccode">fd_hashtable </TD>
</TR>
<TR>
<TH></TH><TD>an index, a set of frames, a set of samples, and a set
                 of slotids</TD><TD>a hashtable of frames and scores</TD>
</TR>
<TR>
<TH></TH><TD><EM>Computes similarity scores to <samples> based on slotids and index.
 If the set of frames argument is void, all candidates are scored;
  otherwise, only the specified frames are scored.</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_find_frames">fd_find_frames</A></TD><TD CLASS="ccode">lisp indices,...</TD><TD CLASS="ccode">lisp </TD>
</TR>
<TR>
<TH></TH><TD>a set of indices and a series of slot and value sets 
               terminated by a FD_VOID</TD><TD>a set of frames</TD>
</TR>
<TR>
<TH></TH><TD><EM>This is a C version of the FDSCRIPT strict searching function
  It returns those frames indexed as having each of the slots with
   at least of the subsequent values</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_index_frame">fd_index_frame</A></TD><TD CLASS="ccode">fd_index idx,lisp frame</TD><TD CLASS="ccode">void </TD>
</TR>
<TR>
<TH></TH><TD>a frame and an index</TD><TD>nothing</TD>
</TR>
<TR>
<TH></TH><TD><EM>Indexes an object based on its slot values.</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_index_slots">fd_index_slots</A></TD><TD CLASS="ccode">fd_index idx,lisp frame,lisp slots</TD><TD CLASS="ccode">void </TD>
</TR>
<TR>
<TH></TH><TD>a frame (or set of frames), an index, and a set of slots</TD><TD>nothing</TD>
</TR>
<TR>
<TH></TH><TD><EM>Indexes the frame (or set of frames) based on the specified slots</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_index_notice_slot_values
">fd_index_notice_slot_values
</A></TD><TD CLASS="ccode">fd_index idx,lisp frames,lisp slots,lisp values</TD><TD CLASS="ccode">void </TD>
</TR>
<TR>
<TH></TH><TD>a frame (or set of frames), an index, 
                 a set of slots, and a set of values</TD><TD>nothing</TD>
</TR>
<TR>
<TH></TH><TD><EM>Indexes the frame (or set of frames) based on the specified slots
  This doesn't force slots to be indexed, so stop-features works.</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_get_slot_features">fd_get_slot_features</A></TD><TD CLASS="ccode">lisp frames,lisp slots</TD><TD CLASS="ccode">lisp </TD>
</TR>
<TR>
<TH></TH><TD>a frame (or set of frames) and a slot (or set of slots)</TD><TD>a set of features based on those slots of those frames</TD>
</TR>
<TR>
<TH></TH><TD><EM>Gets the features of FRAME on SLOTS.</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_index_slot_values
">fd_index_slot_values
</A></TD><TD CLASS="ccode">fd_index idx,lisp frames,lisp slotids,lisp values</TD><TD CLASS="ccode">void </TD>
</TR>
<TR>
<TH></TH><TD>a frame (or set of frames), an index, 
                 a set of slots, and a set of values</TD><TD>nothing</TD>
</TR>
<TR>
<TH></TH><TD><EM>Indexes the frame (or set of frames) based on the specified slots</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_strict_search">fd_strict_search</A></TD><TD CLASS="ccode">lisp indices,lisp spec</TD><TD CLASS="ccode">lisp </TD>
</TR>
<TR>
<TH></TH><TD>an index (or set/choice of indices) and 
                a list of sets/choices of features</TD><TD>a set of objects</TD>
</TR>
<TR>
<TH></TH><TD><EM>Returns all objects recorded in indices which have
one of each set of features in the provided list</EM></TD><TD></TD>
</TR>

</TABLE>
<A NAME="index.c"><H2>
Functions defined in <TT>src/index/index.c</TT>
</H2>
</A><P>
<A HREF="#fd_close_index"><TT>fd_close_index</TT></A> | <A HREF="#fd_commit_index"><TT>fd_commit_index</TT></A> | <A HREF="#fd_find_index"><TT>fd_find_index</TT></A> | <A HREF="#fd_for_indices"><TT>fd_for_indices</TT></A> | <A HREF="#fd_index_add"><TT>fd_index_add</TT></A> | <A HREF="#fd_index_drop"><TT>fd_index_drop</TT></A> | <A HREF="#fd_index_get"><TT>fd_index_get</TT></A> | <A HREF="#fd_index_get_size"><TT>fd_index_get_size</TT></A> | <A HREF="#fd_index_keys"><TT>fd_index_keys</TT></A> | <A HREF="#fd_index_prefetch"><TT>fd_index_prefetch</TT></A> | <A HREF="#fd_index_set"><TT>fd_index_set</TT></A> | <A HREF="#fd_index_set_sizes
"><TT>fd_index_set_sizes
</TT></A> | <A HREF="#fd_intern_index_values"><TT>fd_intern_index_values</TT></A> | <A HREF="#fd_interpret_index"><TT>fd_interpret_index</TT></A> | <A HREF="#fd_revert_index"><TT>fd_revert_index</TT></A> | <A HREF="#fd_set_index_zipf_threshold"><TT>fd_set_index_zipf_threshold</TT></A> | <A HREF="#fd_swap_out_index"><TT>fd_swap_out_index</TT></A> | <A HREF="#fd_use_index"><TT>fd_use_index</TT></A> | 
</P>
<TABLE CELLPADDING="5">
<TR>
<TH ALIGN="LEFT">Function</TH><TH ALIGN="LEFT">Arguments</TH><TH ALIGN="LEFT">Returns</TH>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_find_index">fd_find_index</A></TD><TD CLASS="ccode">fd_u8char *id</TD><TD CLASS="ccode">fd_index </TD>
</TR>
<TR>
<TH></TH><TD>a string</TD><TD>a pointer to an index or NULL</TD>
</TR>
<TR>
<TH></TH><TD><EM>Returns the index whose id matches the given string.</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_index_drop">fd_index_drop</A></TD><TD CLASS="ccode">fd_index x,lisp key,lisp value</TD><TD CLASS="ccode">void </TD>
</TR>
<TR>
<TH></TH><TD>an index pointer, a lisp key, a lisp value</TD><TD>an index</TD>
</TR>
<TR>
<TH></TH><TD><EM>Removes the values from the values associated with the key in the index.</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_index_get_size">fd_index_get_size</A></TD><TD CLASS="ccode">fd_index x,lisp key</TD><TD CLASS="ccode">unsigned int </TD>
</TR>
<TR>
<TH></TH><TD>an index pointer, a lisp key</TD><TD>the number of values associated with the key in the index</TD>
</TR>
<TR>
<TH></TH><TD><EM>Returns the number of values associated with the key in the index</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_revert_index">fd_revert_index</A></TD><TD CLASS="ccode">fd_index x</TD><TD CLASS="ccode">void </TD>
</TR>
<TR>
<TH></TH><TD>a pointer to an index</TD><TD>nothing</TD>
</TR>
<TR>
<TH></TH><TD><EM>Erases all of the changes made to the specified index.</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_set_index_zipf_threshold">fd_set_index_zipf_threshold</A></TD><TD CLASS="ccode">fd_index ix,int threshold</TD><TD CLASS="ccode">void </TD>
</TR>
<TR>
<TH></TH><TD>an index, an integer</TD><TD>nothing</TD>
</TR>
<TR>
<TH></TH><TD><EM>Sets the save threshold for an index, so that keys with fewer
than threshold values will not be written to disk or server</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_intern_index_values">fd_intern_index_values</A></TD><TD CLASS="ccode">fd_index x</TD><TD CLASS="ccode">void </TD>
</TR>
<TR>
<TH></TH><TD>an index pointer</TD><TD>void</TD>
</TR>
<TR>
<TH></TH><TD><EM>Arranges for an index to intern the values it stores</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_index_prefetch">fd_index_prefetch</A></TD><TD CLASS="ccode">fd_index x,lisp keys</TD><TD CLASS="ccode">void </TD>
</TR>
<TR>
<TH></TH><TD>an index pointer, and a choice of keys</TD><TD>an index</TD>
</TR>
<TR>
<TH></TH><TD><EM>Prefetches the values for particular keys.</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_commit_index">fd_commit_index</A></TD><TD CLASS="ccode">fd_index x</TD><TD CLASS="ccode">void </TD>
</TR>
<TR>
<TH></TH><TD>a pointer to an index</TD><TD>nothing</TD>
</TR>
<TR>
<TH></TH><TD><EM>Saves the changes made to the specified index.</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_interpret_index">fd_interpret_index</A></TD><TD CLASS="ccode">lisp spec</TD><TD CLASS="ccode">fd_index </TD>
</TR>
<TR>
<TH></TH><TD>an expression and an environment</TD><TD>a pointer to an index</TD>
</TR>
<TR>
<TH></TH><TD><EM>Evaluates the expression in the environment and tries to produce an
index object from the result.</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_index_set_sizes
">fd_index_set_sizes
</A></TD><TD CLASS="ccode">fd_index x,int cache_size,int adds_size,int drops_size,int sizes_size</TD><TD CLASS="ccode">void </TD>
</TR>
<TR>
<TH></TH><TD>a pointer to an index</TD><TD>nothing</TD>
</TR>
<TR>
<TH></TH><TD><EM>Grows the internal tables for an index to accomodate n keys and n mods</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_index_keys">fd_index_keys</A></TD><TD CLASS="ccode">fd_index idx</TD><TD CLASS="ccode">lisp </TD>
</TR>
<TR>
<TH></TH><TD>a pointer to an index</TD><TD>nothing</TD>
</TR>
<TR>
<TH></TH><TD><EM>Non-deterministically returns all the keys in an index.</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_for_indices">fd_for_indices</A></TD><TD CLASS="ccode">void (*fcn</TD><TD CLASS="ccode">void </TD>
</TR>
<TR>
<TH></TH><TD>a function on pointers to indices</TD><TD>nothing</TD>
</TR>
<TR>
<TH></TH><TD><EM>Calls the function on all registered indices.</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_use_index">fd_use_index</A></TD><TD CLASS="ccode">fd_u8char *spec</TD><TD CLASS="ccode">fd_index </TD>
</TR>
<TR>
<TH></TH><TD>a string</TD><TD>an index</TD>
</TR>
<TR>
<TH></TH><TD><EM>Returns an index object based on the string argument.  If the string
    has the form "port@host" it is taken to be a network index; otherwise,
    it is taken to be a file index which is opened.</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_index_add">fd_index_add</A></TD><TD CLASS="ccode">fd_index x,lisp key,lisp value</TD><TD CLASS="ccode">void </TD>
</TR>
<TR>
<TH></TH><TD>an index pointer, a lisp key, a lisp value</TD><TD>an index</TD>
</TR>
<TR>
<TH></TH><TD><EM>Adds the value to the values associated with the key in the index.</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_close_index">fd_close_index</A></TD><TD CLASS="ccode">fd_index idx</TD><TD CLASS="ccode">void </TD>
</TR>
<TR>
<TH></TH><TD>a pointer to an index</TD><TD>nothing</TD>
</TR>
<TR>
<TH></TH><TD><EM>Closes an index</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_index_get">fd_index_get</A></TD><TD CLASS="ccode">fd_index x,lisp key,lisp dflt</TD><TD CLASS="ccode">lisp </TD>
</TR>
<TR>
<TH></TH><TD>an index pointer, a lisp key, and a default value</TD><TD>the values associated with the key in the index</TD>
</TR>
<TR>
<TH></TH><TD><EM>Returns the values associated with the key in the index or the default
   value if there are none.</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_swap_out_index">fd_swap_out_index</A></TD><TD CLASS="ccode">fd_index x</TD><TD CLASS="ccode">void </TD>
</TR>
<TR>
<TH></TH><TD>a pointer to an index</TD><TD>nothing</TD>
</TR>
<TR>
<TH></TH><TD><EM>Frees most of the space used by the cached values of an index.</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_index_set">fd_index_set</A></TD><TD CLASS="ccode">fd_index x,lisp key,lisp value</TD><TD CLASS="ccode">void </TD>
</TR>
<TR>
<TH></TH><TD>an index pointer, a lisp key, a lisp value</TD><TD>an index</TD>
</TR>
<TR>
<TH></TH><TD><EM>Sets the values associated with the key in the index.</EM></TD><TD></TD>
</TR>

</TABLE>
<A NAME="super-pool.c"><H2>
Functions defined in <TT>src/odb/super-pool.c</TT>
</H2>
</A><P>
<A HREF="#fd_allocate_pool
"><TT>fd_allocate_pool
</TT></A> | <A HREF="#fd_recovered_pool
"><TT>fd_recovered_pool
</TT></A> | <A HREF="#fd_super_pool_base"><TT>fd_super_pool_base</TT></A> | <A HREF="#fd_super_pool_loading"><TT>fd_super_pool_loading</TT></A> | <A HREF="#fd_super_pool_top"><TT>fd_super_pool_top</TT></A> | 
</P>
<TABLE CELLPADDING="5">
<TR>
<TH ALIGN="LEFT">Function</TH><TH ALIGN="LEFT">Arguments</TH><TH ALIGN="LEFT">Returns</TH>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_allocate_pool
">fd_allocate_pool
</A></TD><TD CLASS="ccode">char *super_pool,unsigned int capacity,char *label</TD><TD CLASS="ccode">FD_OID </TD>
</TR>
<TR>
<TH></TH><TD>a super pool id, a capacity, and a string label</TD><TD>an FD_OID</TD>
</TR>
<TR>
<TH></TH><TD><EM>Allocates a new pool from a designated super pool with a particular
 capacity, returning the base of the new pool.</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_recovered_pool
">fd_recovered_pool
</A></TD><TD CLASS="ccode">char *super_pool,FD_OID base,unsigned int capacity,lisp sp_label</TD><TD CLASS="ccode">FD_OID </TD>
</TR>
<TR>
<TH></TH><TD>a super pool id, a base, a capacity, and a lisp pointer label</TD><TD>an FD_OID</TD>
</TR>
<TR>
<TH></TH><TD><EM>Asserts lost information about a pool in a super pool.</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_super_pool_top">fd_super_pool_top</A></TD><TD CLASS="ccode">char *id</TD><TD CLASS="ccode">FD_OID </TD>
</TR>
<TR>
<TH></TH><TD>a super pool id</TD><TD>an FD_OID</TD>
</TR>
<TR>
<TH></TH><TD><EM>Returns the highest allocated FD_OID in a super pool</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_super_pool_loading">fd_super_pool_loading</A></TD><TD CLASS="ccode">char *id</TD><TD CLASS="ccode">float </TD>
</TR>
<TR>
<TH></TH><TD>a super pool id</TD><TD>a float</TD>
</TR>
<TR>
<TH></TH><TD><EM>Returns the fraction of the super pool which is allocated</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_super_pool_base">fd_super_pool_base</A></TD><TD CLASS="ccode">char *id</TD><TD CLASS="ccode">FD_OID </TD>
</TR>
<TR>
<TH></TH><TD>a super pool id</TD><TD>an FD_OID</TD>
</TR>
<TR>
<TH></TH><TD><EM>Returns the base of a super pool (e.g. @sp_id/0)</EM></TD><TD></TD>
</TR>

</TABLE>
<A NAME="network-pool.c"><H2>
Functions defined in <TT>src/odb/network-pool.c</TT>
</H2>
</A><P>
<A HREF="#fd_use_network_pool"><TT>fd_use_network_pool</TT></A> | 
</P>
<TABLE CELLPADDING="5">
<TR>
<TH ALIGN="LEFT">Function</TH><TH ALIGN="LEFT">Arguments</TH><TH ALIGN="LEFT">Returns</TH>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_use_network_pool">fd_use_network_pool</A></TD><TD CLASS="ccode">char *servername,int port,fd_u8char *id</TD><TD CLASS="ccode">fd_network_pool </TD>
</TR>
<TR>
<TH></TH><TD>a port number, a host name, and an id string</TD><TD>a pointer to a networked pool structure</TD>
</TR>
<TR>
<TH></TH><TD><EM>Errors:
    Cannot connect to server

   Side effects:
    Creates a networked pool structure for the server
    Adds a pointer to the pool structure to fd_all_pools</EM></TD><TD></TD>
</TR>

</TABLE>
<A NAME="odb.c"><H2>
Functions defined in <TT>src/odb/odb.c</TT>
</H2>
</A><P>
<A HREF="#fd_close_pool"><TT>fd_close_pool</TT></A> | <A HREF="#fd_commit_oid"><TT>fd_commit_oid</TT></A> | <A HREF="#fd_control_frame_printing"><TT>fd_control_frame_printing</TT></A> | <A HREF="#fd_get_oid_value"><TT>fd_get_oid_value</TT></A> | <A HREF="#fd_mark_modified"><TT>fd_mark_modified</TT></A> | <A HREF="#fd_new_oid"><TT>fd_new_oid</TT></A> | <A HREF="#fd_oid_modifiedp"><TT>fd_oid_modifiedp</TT></A> | <A HREF="#fd_print_oid"><TT>fd_print_oid</TT></A> | <A HREF="#fd_revert_oid"><TT>fd_revert_oid</TT></A> | <A HREF="#fd_revert_pool"><TT>fd_revert_pool</TT></A> | <A HREF="#fd_set_oid_value"><TT>fd_set_oid_value</TT></A> | <A HREF="#fd_show_poolids"><TT>fd_show_poolids</TT></A> | <A HREF="#fd_swap_out"><TT>fd_swap_out</TT></A> | <A HREF="#fd_swap_out_pool"><TT>fd_swap_out_pool</TT></A> | <A HREF="#fd_try_oid_value"><TT>fd_try_oid_value</TT></A> | 
</P>
<TABLE CELLPADDING="5">
<TR>
<TH ALIGN="LEFT">Function</TH><TH ALIGN="LEFT">Arguments</TH><TH ALIGN="LEFT">Returns</TH>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_close_pool">fd_close_pool</A></TD><TD CLASS="ccode">fd_pool p</TD><TD CLASS="ccode">void </TD>
</TR>
<TR>
<TH></TH><TD>a pointer to a pool</TD><TD>void</TD>
</TR>
<TR>
<TH></TH><TD><EM>Closes open file pointers or network connections underlying
the pool.</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_control_frame_printing">fd_control_frame_printing</A></TD><TD CLASS="ccode">int level</TD><TD CLASS="ccode">void </TD>
</TR>
<TR>
<TH></TH><TD>an integral print level</TD><TD>void</TD>
</TR>
<TR>
<TH></TH><TD><EM>Controls the printing of oids
   If print level is 0, names are never printed
   If print level is 1, names are printed for loaded oids
   If print level is 2, names are always printed and
     oids are loaded when printed</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_get_oid_value">fd_get_oid_value</A></TD><TD CLASS="ccode">lisp oid</TD><TD CLASS="ccode">lisp </TD>
</TR>
<TR>
<TH></TH><TD>a lisp pointer to an oid</TD><TD>a lisp pointer</TD>
</TR>
<TR>
<TH></TH><TD><EM>Gets the value of an OID, doing fetching from files or network as
neccessary.</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_set_oid_value">fd_set_oid_value</A></TD><TD CLASS="ccode">lisp oid,lisp value</TD><TD CLASS="ccode">void </TD>
</TR>
<TR>
<TH></TH><TD>a lisp pointer to an oid and a lisp pointer to a value</TD><TD>none</TD>
</TR>
<TR>
<TH></TH><TD><EM>This sets the value of an oid (its first argument) 
       to a new value (its second argument).
    fd_set_oid_value refcounts or copies the second argument (if it's a choice)

   Errors:
     Cannot modify oid

   Side effects:
     Frees the old value of the oid
     Changes the value field of the oid
     Adds the oid to its pools "modified objects"</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_mark_modified">fd_mark_modified</A></TD><TD CLASS="ccode">lisp oid</TD><TD CLASS="ccode">void </TD>
</TR>
<TR>
<TH></TH><TD>a lisp pointer to an oid</TD><TD>void</TD>
</TR>
<TR>
<TH></TH><TD><EM>Marks the designated OID as modified and signals an error if it cannot
be modified.</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_show_poolids">fd_show_poolids</A></TD><TD CLASS="ccode">int use_ids</TD><TD CLASS="ccode">void </TD>
</TR>
<TR>
<TH></TH><TD>1 or 0</TD><TD>void</TD>
</TR>
<TR>
<TH></TH><TD><EM>Determines if pool ids are used to print OIDs.</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_swap_out_pool">fd_swap_out_pool</A></TD><TD CLASS="ccode">fd_pool p</TD><TD CLASS="ccode">void </TD>
</TR>
<TR>
<TH></TH><TD>a pointer to a pool</TD><TD>void</TD>
</TR>
<TR>
<TH></TH><TD><EM>Frees any space being used for the values of unmodified OIDs
in pool.  It doesn't do anything about committing changes.</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_try_oid_value">fd_try_oid_value</A></TD><TD CLASS="ccode">lisp oid</TD><TD CLASS="ccode">lisp </TD>
</TR>
<TR>
<TH></TH><TD>a lisp pointer to an oid</TD><TD>a lisp pointer</TD>
</TR>
<TR>
<TH></TH><TD><EM>Gets the value of an OID, doing fetching from files or network as
neccessary.  If an error occurs, this will return FD_VOID rather
than signalling the error.</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_commit_oid">fd_commit_oid</A></TD><TD CLASS="ccode">lisp oid</TD><TD CLASS="ccode">int </TD>
</TR>
<TR>
<TH></TH><TD>a lisp pointer to an oid</TD><TD>1 if successful, 0 otherwise</TD>
</TR>
<TR>
<TH></TH><TD><EM>Commits any changes to an oid using pool specific methods, as appropriate.</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_print_oid">fd_print_oid</A></TD><TD CLASS="ccode">lisp frame,fd_string_stream ss</TD><TD CLASS="ccode">void </TD>
</TR>
<TR>
<TH></TH><TD>a lisp pointer (to an `oid') and a string stream</TD><TD>nothing</TD>
</TR>
<TR>
<TH></TH><TD><EM>Outputs an external representation of the oid, consisting of
     its ID followed by its OBJ-NAME slot (if it exists).</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_swap_out">fd_swap_out</A></TD><TD CLASS="ccode">lisp oid</TD><TD CLASS="ccode">void </TD>
</TR>
<TR>
<TH></TH><TD>a lisp pointer to an oid</TD><TD>none</TD>
</TR>
<TR>
<TH></TH><TD><EM>If this oid's value has not been modified, it is freed
    and the oid declared "non present", allowing it to be
    reloaded later if its value is needed.</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_oid_modifiedp">fd_oid_modifiedp</A></TD><TD CLASS="ccode">lisp oid</TD><TD CLASS="ccode">int </TD>
</TR>
<TR>
<TH></TH><TD>a lisp pointer to an oid</TD><TD>1 or 0</TD>
</TR>
<TR>
<TH></TH><TD><EM>Returns 1 if the oid has usaved modifications.</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_revert_oid">fd_revert_oid</A></TD><TD CLASS="ccode">lisp oid</TD><TD CLASS="ccode">int </TD>
</TR>
<TR>
<TH></TH><TD>a lisp pointer to an oid</TD><TD>1 if successful, 0 otherwise</TD>
</TR>
<TR>
<TH></TH><TD><EM>Erases any uncommited changes to the designated oid.</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_new_oid">fd_new_oid</A></TD><TD CLASS="ccode">fd_pool p</TD><TD CLASS="ccode">lisp </TD>
</TR>
<TR>
<TH></TH><TD>a pointer to a pool structure</TD><TD>a new oid in the pool</TD>
</TR>
<TR>
<TH></TH><TD><EM>Errors:
    Pool is used up

   Side effects:
    Increments the load of a file pool
     or
    Updates the load on a remote server</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_revert_pool">fd_revert_pool</A></TD><TD CLASS="ccode">fd_pool p</TD><TD CLASS="ccode">void </TD>
</TR>
<TR>
<TH></TH><TD>a pointer to a pool</TD><TD>void</TD>
</TR>
<TR>
<TH></TH><TD><EM>Erases any uncommited changes to the oids in the pool.</EM></TD><TD></TD>
</TR>

</TABLE>
<A NAME="pools.c"><H2>
Functions defined in <TT>src/odb/pools.c</TT>
</H2>
</A><P>
<A HREF="#fd_commit_pool"><TT>fd_commit_pool</TT></A> | <A HREF="#fd_find_pool_named"><TT>fd_find_pool_named</TT></A> | <A HREF="#fd_for_pools"><TT>fd_for_pools</TT></A> | <A HREF="#fd_get_pool"><TT>fd_get_pool</TT></A> | <A HREF="#fd_interpret_pool"><TT>fd_interpret_pool</TT></A> | <A HREF="#fd_locate_pool"><TT>fd_locate_pool</TT></A> | <A HREF="#fd_pool_load"><TT>fd_pool_load</TT></A> | <A HREF="#fd_random_oid"><TT>fd_random_oid</TT></A> | <A HREF="#fd_register_pool"><TT>fd_register_pool</TT></A> | <A HREF="#fd_set_oid_locator"><TT>fd_set_oid_locator</TT></A> | <A HREF="#fd_use_pool"><TT>fd_use_pool</TT></A> | 
</P>
<TABLE CELLPADDING="5">
<TR>
<TH ALIGN="LEFT">Function</TH><TH ALIGN="LEFT">Arguments</TH><TH ALIGN="LEFT">Returns</TH>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_get_pool">fd_get_pool</A></TD><TD CLASS="ccode">lisp id</TD><TD CLASS="ccode">fd_pool </TD>
</TR>
<TR>
<TH></TH><TD>a lisp pointer to an OID</TD><TD>a pointer to a pool</TD>
</TR>
<TR>
<TH></TH><TD><EM>Finds the pool containing an oid.</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_random_oid">fd_random_oid</A></TD><TD CLASS="ccode">fd_pool p</TD><TD CLASS="ccode">lisp </TD>
</TR>
<TR>
<TH></TH><TD>a pointer to a pool</TD><TD>an lisp pointer to an oid (or the empty choice)</TD>
</TR>
<TR>
<TH></TH><TD><EM>Returns a random allocated OID in pool, or the empty
choice if the pool is empty.</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_for_pools">fd_for_pools</A></TD><TD CLASS="ccode">void (*fcn</TD><TD CLASS="ccode">void </TD>
</TR>
<TR>
<TH></TH><TD>a function on a pool pointer and a void pointer
               and a void data pointer</TD><TD>void</TD>
</TR>
<TR>
<TH></TH><TD><EM>Applies the function to each known pool and the data pointer
      passed to the call (got that?).</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_interpret_pool">fd_interpret_pool</A></TD><TD CLASS="ccode">lisp spec</TD><TD CLASS="ccode">fd_pool </TD>
</TR>
<TR>
<TH></TH><TD>an expression and an environment</TD><TD>a pointer to a pool</TD>
</TR>
<TR>
<TH></TH><TD><EM>Evaluates the expression in the environment and tries to produce an
index object from the result.</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_commit_pool">fd_commit_pool</A></TD><TD CLASS="ccode">fd_pool p</TD><TD CLASS="ccode">void </TD>
</TR>
<TR>
<TH></TH><TD>a pool</TD><TD>nothing</TD>
</TR>
<TR>
<TH></TH><TD><EM></EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_find_pool_named">fd_find_pool_named</A></TD><TD CLASS="ccode">fd_u8char *name</TD><TD CLASS="ccode">fd_pool </TD>
</TR>
<TR>
<TH></TH><TD>a utf-8 string</TD><TD>a pointer to a pool or NULL</TD>
</TR>
<TR>
<TH></TH><TD><EM>Returns the pool which has been assigned the designated name.</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_register_pool">fd_register_pool</A></TD><TD CLASS="ccode">fd_pool p</TD><TD CLASS="ccode">int </TD>
</TR>
<TR>
<TH></TH><TD>a pointer to a pool</TD><TD>void</TD>
</TR>
<TR>
<TH></TH><TD><EM>Adds an entry for the pool to the pool table, doing nothing if
it is already there and signalling an error if the pool overlaps
with a currently registered pool.</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_set_oid_locator">fd_set_oid_locator</A></TD><TD CLASS="ccode">fd_pool (*ol</TD><TD CLASS="ccode">void </TD>
</TR>
<TR>
<TH></TH><TD>a function which maps OIDs to pools</TD><TD>nothing</TD>
</TR>
<TR>
<TH></TH><TD><EM>Sets the OID locator function for this session, which takes
an OID and returns its pool.  This function is only called if the
pool is not already known, so the purpose of the oid locator
is to find otherwise undeclared pools.</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_pool_load">fd_pool_load</A></TD><TD CLASS="ccode">fd_pool p</TD><TD CLASS="ccode">int </TD>
</TR>
<TR>
<TH></TH><TD>a pointer to a pool</TD><TD>an int</TD>
</TR>
<TR>
<TH></TH><TD><EM>Returns the number of OIDs allocated in pool.</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_locate_pool">fd_locate_pool</A></TD><TD CLASS="ccode">lisp loid</TD><TD CLASS="ccode">fd_pool </TD>
</TR>
<TR>
<TH></TH><TD>a lisp pointer (to an OID)</TD><TD>a pointer to a pool or NULL</TD>
</TR>
<TR>
<TH></TH><TD><EM>This is just like fd_get_pool, but will try harder, calling
locator functions to try pools which haven't been explicitly
registered.</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_use_pool">fd_use_pool</A></TD><TD CLASS="ccode">fd_u8char *c</TD><TD CLASS="ccode">fd_pool </TD>
</TR>
<TR>
<TH></TH><TD>a pool specification</TD><TD>a pool</TD>
</TR>
<TR>
<TH></TH><TD><EM>Returns a pool based on a specification.  The specification either has
    the form port@host indicating a server or a filename indicating
    a file pool.</EM></TD><TD></TD>
</TR>

</TABLE>
<A NAME="libframerd.c"><H2>
Functions defined in <TT>src/odb/libframerd.c</TT>
</H2>
</A><P>
<A HREF="#fd_report_framerd_stats"><TT>fd_report_framerd_stats</TT></A> | 
</P>
<TABLE CELLPADDING="5">
<TR>
<TH ALIGN="LEFT">Function</TH><TH ALIGN="LEFT">Arguments</TH><TH ALIGN="LEFT">Returns</TH>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_report_framerd_stats">fd_report_framerd_stats</A></TD><TD CLASS="ccode">FILE *to</TD><TD CLASS="ccode">void </TD>
</TR>
<TR>
<TH></TH><TD>none</TD><TD>void</TD>
</TR>
<TR>
<TH></TH><TD><EM>Reports framerd stats to the standard error.</EM></TD><TD></TD>
</TR>

</TABLE>
<A NAME="network-index.c"><H2>
Functions defined in <TT>src/index/network-index.c</TT>
</H2>
</A><P>
<A HREF="#fd_use_network_index"><TT>fd_use_network_index</TT></A> | 
</P>
<TABLE CELLPADDING="5">
<TR>
<TH ALIGN="LEFT">Function</TH><TH ALIGN="LEFT">Arguments</TH><TH ALIGN="LEFT">Returns</TH>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_use_network_index">fd_use_network_index</A></TD><TD CLASS="ccode">char *servname,int port_no,fd_u8char *id</TD><TD CLASS="ccode">fd_network_index </TD>
</TR>
<TR>
<TH></TH><TD>servername (a string), port_no (an int), and id (a utf8 string)</TD><TD>a pointer to a network index struct</TD>
</TR>
<TR>
<TH></TH><TD><EM>Finds or creates (if neccessary) a network index served by the specified
    servername and port.</EM></TD><TD></TD>
</TR>

</TABLE>
{}<A NAME="load.c"><H2>
Functions defined in <TT>src/eval/load.c</TT>
</H2>
</A><P>
<A HREF="#fd_get_module"><TT>fd_get_module</TT></A> | <A HREF="#fd_load_file"><TT>fd_load_file</TT></A> | <A HREF="#fd_load_library"><TT>fd_load_library</TT></A> | 
</P>
<TABLE CELLPADDING="5">
<TR>
<TH ALIGN="LEFT">Function</TH><TH ALIGN="LEFT">Arguments</TH><TH ALIGN="LEFT">Returns</TH>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_load_file">fd_load_file</A></TD><TD CLASS="ccode">char *filename,char *enc,fd_lispenv env</TD><TD CLASS="ccode">lisp </TD>
</TR>
<TR>
<TH></TH><TD>a filename string, an encoding string, an environment</TD><TD>a lisp pointer</TD>
</TR>
<TR>
<TH></TH><TD><EM>Loads a file into a particular environment with a particular encoding.</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_get_module">fd_get_module</A></TD><TD CLASS="ccode">fd_u8char *name,fd_u8char *filename,int all</TD><TD CLASS="ccode">fd_lispenv </TD>
</TR>
<TR>
<TH></TH><TD>a module name, a filename, and an int flag</TD><TD>a pointer to a lispenv or NULL</TD>
</TR>
<TR>
<TH></TH><TD><EM>Returns the module with the given name, loading it from filename
if needed.  If filename is non-NULL, it is used to load the module's
definition.  The final flag argument determines whether the search
includes modules which have restricted access.</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_load_library">fd_load_library</A></TD><TD CLASS="ccode">char *filename,char *enc,fd_lispenv env</TD><TD CLASS="ccode">lisp </TD>
</TR>
<TR>
<TH></TH><TD>a filename string, an encoding string, an environment</TD><TD>a lisp pointer</TD>
</TR>
<TR>
<TH></TH><TD><EM>Loads a file into a particular environment with a particular encoding.
This searches for the file along FDMYPATH and FDPATH.</EM></TD><TD></TD>
</TR>

</TABLE>
<A NAME="libfdeval.c"><H2>
Functions defined in <TT>src/eval/libfdeval.c</TT>
</H2>
</A><P>

</P>
<TABLE CELLPADDING="5">
<TR>
<TH ALIGN="LEFT">Function</TH><TH ALIGN="LEFT">Arguments</TH><TH ALIGN="LEFT">Returns</TH>
</TR>

</TABLE>
<A NAME="threads.c"><H2>
Functions defined in <TT>src/eval/threads.c</TT>
</H2>
</A><P>
<A HREF="#fd_thread_symbind"><TT>fd_thread_symbind</TT></A> | <A HREF="#fd_thread_symeval"><TT>fd_thread_symeval</TT></A> | 
</P>
<TABLE CELLPADDING="5">
<TR>
<TH ALIGN="LEFT">Function</TH><TH ALIGN="LEFT">Arguments</TH><TH ALIGN="LEFT">Returns</TH>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_thread_symeval">fd_thread_symeval</A></TD><TD CLASS="ccode">lisp sym</TD><TD CLASS="ccode">lisp </TD>
</TR>
<TR>
<TH></TH><TD>a lisp symbol</TD><TD>a lisp value</TD>
</TR>
<TR>
<TH></TH><TD><EM>Returns the thread-local value assigned to a symbol.  This
increfs the value it returns.</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_thread_symbind">fd_thread_symbind</A></TD><TD CLASS="ccode">lisp sym,lisp value</TD><TD CLASS="ccode">void </TD>
</TR>
<TR>
<TH></TH><TD>a lisp symbol and a lisp value</TD><TD>void</TD>
</TR>
<TR>
<TH></TH><TD><EM>Assigns a thread-local value to a symbol.  The
value is `used up' in the assignment.</EM></TD><TD></TD>
</TR>

</TABLE>
<A NAME="sandbox.c"><H2>
Functions defined in <TT>src/eval/sandbox.c</TT>
</H2>
</A><P>
<A HREF="#fd_add_restricted_cproc"><TT>fd_add_restricted_cproc</TT></A> | <A HREF="#fd_add_restricted_lexpr"><TT>fd_add_restricted_lexpr</TT></A> | <A HREF="#fd_add_restricted_special_form
"><TT>fd_add_restricted_special_form
</TT></A> | 
</P>
<TABLE CELLPADDING="5">
<TR>
<TH ALIGN="LEFT">Function</TH><TH ALIGN="LEFT">Arguments</TH><TH ALIGN="LEFT">Returns</TH>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_add_restricted_cproc">fd_add_restricted_cproc</A></TD><TD CLASS="ccode">char *name,int n_args,lisp (*proc</TD><TD CLASS="ccode">void </TD>
</TR>
<TR>
<TH></TH><TD>a string, an int, and a function pointer</TD><TD>void</TD>
</TR>
<TR>
<TH></TH><TD><EM>Defines a primitive procedure in the standard restricted environment.</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_add_restricted_special_form
">fd_add_restricted_special_form
</A></TD><TD CLASS="ccode">char *name,lisp (*proc</TD><TD CLASS="ccode">void </TD>
</TR>
<TR>
<TH></TH><TD>a string, an int, and a function pointer</TD><TD>void</TD>
</TR>
<TR>
<TH></TH><TD><EM>Defines a primitive special form in the standard restricted environment.</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_add_restricted_lexpr">fd_add_restricted_lexpr</A></TD><TD CLASS="ccode">char *name,int argcode,lisp (*proc</TD><TD CLASS="ccode">void </TD>
</TR>
<TR>
<TH></TH><TD>a string, an int, and a function pointer</TD><TD>void</TD>
</TR>
<TR>
<TH></TH><TD><EM>Defines a primitive lexpr in the standard restricted environment.</EM></TD><TD></TD>
</TR>

</TABLE>
<A NAME="lambda.c"><H2>
Functions defined in <TT>src/eval/lambda.c</TT>
</H2>
</A><P>
<A HREF="#fd_bind_value"><TT>fd_bind_value</TT></A> | <A HREF="#fd_free_env"><TT>fd_free_env</TT></A> | <A HREF="#fd_make_env"><TT>fd_make_env</TT></A> | <A HREF="#fd_make_gproc"><TT>fd_make_gproc</TT></A> | <A HREF="#fd_make_sproc"><TT>fd_make_sproc</TT></A> | <A HREF="#fd_make_ssproc"><TT>fd_make_ssproc</TT></A> | <A HREF="#fd_mallocd_env"><TT>fd_mallocd_env</TT></A> | <A HREF="#fd_module_export"><TT>fd_module_export</TT></A> | <A HREF="#fd_module_uses"><TT>fd_module_uses</TT></A> | <A HREF="#fd_register_module"><TT>fd_register_module</TT></A> | <A HREF="#fd_register_restricted_module"><TT>fd_register_restricted_module</TT></A> | <A HREF="#fd_registered_module"><TT>fd_registered_module</TT></A> | <A HREF="#fd_required_symeval"><TT>fd_required_symeval</TT></A> | <A HREF="#fd_safe_set_value"><TT>fd_safe_set_value</TT></A> | <A HREF="#fd_set_value"><TT>fd_set_value</TT></A> | <A HREF="#fd_symeval"><TT>fd_symeval</TT></A> | 
</P>
<TABLE CELLPADDING="5">
<TR>
<TH ALIGN="LEFT">Function</TH><TH ALIGN="LEFT">Arguments</TH><TH ALIGN="LEFT">Returns</TH>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_set_value">fd_set_value</A></TD><TD CLASS="ccode">lisp sym,lisp val,lispenv env</TD><TD CLASS="ccode">void </TD>
</TR>
<TR>
<TH></TH><TD>a symbol, a value, and an environment</TD><TD>void</TD>
</TR>
<TR>
<TH></TH><TD><EM>Sets the binding for symbol in an environment chain, setting
it in the innermost module or the global environment if the variable
is not directly bound.</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_free_env">fd_free_env</A></TD><TD CLASS="ccode">fd_lispenv env</TD><TD CLASS="ccode">void </TD>
</TR>
<TR>
<TH></TH><TD>an environment</TD><TD>void</TD>
</TR>
<TR>
<TH></TH><TD><EM>Frees a dynamically allocated environment</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_mallocd_env">fd_mallocd_env</A></TD><TD CLASS="ccode">fd_lispenv env</TD><TD CLASS="ccode">fd_lispenv </TD>
</TR>
<TR>
<TH></TH><TD>an environment</TD><TD>a dynamically allocated environment</TD>
</TR>
<TR>
<TH></TH><TD><EM>Returns the existing dynamic copy of an environment or
makes one if one doesn't exist.</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_registered_module">fd_registered_module</A></TD><TD CLASS="ccode">fd_u8char *name,int risky</TD><TD CLASS="ccode">fd_lispenv </TD>
</TR>
<TR>
<TH></TH><TD>a string</TD><TD>a lisp environment</TD>
</TR>
<TR>
<TH></TH><TD><EM>Returns a module environment, register</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_required_symeval">fd_required_symeval</A></TD><TD CLASS="ccode">fd_lisp sym,lispenv env</TD><TD CLASS="ccode">fd_lisp </TD>
</TR>
<TR>
<TH></TH><TD>a lisp symbol and an environment (possibly NULL)</TD><TD>a lisp object (cref'd)</TD>
</TR>
<TR>
<TH></TH><TD><EM>Does an environment lookup (using fd_symeval) but signals
an error if it fails</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_module_uses">fd_module_uses</A></TD><TD CLASS="ccode">fd_lispenv env,fd_lispenv use</TD><TD CLASS="ccode">void </TD>
</TR>
<TR>
<TH></TH><TD>two pointers to modules</TD><TD>void</TD>
</TR>
<TR>
<TH></TH><TD><EM>Adds the second argument to the uses for the first argument,
if it is not already included.</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_make_gproc">fd_make_gproc</A></TD><TD CLASS="ccode">lisp lambda,lispenv env</TD><TD CLASS="ccode">lisp </TD>
</TR>
<TR>
<TH></TH><TD>a lisp lambda expression and an environment</TD><TD>a procedure object closing the expression in the environment</TD>
</TR>
<TR>
<TH></TH><TD><EM></EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_make_sproc">fd_make_sproc</A></TD><TD CLASS="ccode">lisp lambda,lispenv env</TD><TD CLASS="ccode">lisp </TD>
</TR>
<TR>
<TH></TH><TD>a lisp lambda expression and an environment</TD><TD>a procedure object closing the expression in the environment</TD>
</TR>
<TR>
<TH></TH><TD><EM></EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_register_module">fd_register_module</A></TD><TD CLASS="ccode">fd_u8char *name,fd_lispenv menv</TD><TD CLASS="ccode">void </TD>
</TR>
<TR>
<TH></TH><TD>a string and an environment</TD><TD>void</TD>
</TR>
<TR>
<TH></TH><TD><EM>Binds the named symbol to the environment in the global environment.
 This will signal an error if the global binding is not VOID.</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_safe_set_value">fd_safe_set_value</A></TD><TD CLASS="ccode">lisp sym,lisp val,lispenv env</TD><TD CLASS="ccode">void </TD>
</TR>
<TR>
<TH></TH><TD>a symbol, a value, and an environment</TD><TD>void</TD>
</TR>
<TR>
<TH></TH><TD><EM>Sets the value for a variable, but never effecting the
global environment.</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_make_env">fd_make_env</A></TD><TD CLASS="ccode">fd_lispenv env</TD><TD CLASS="ccode">fd_lispenv </TD>
</TR>
<TR>
<TH></TH><TD>a parent environment</TD><TD>a new environment</TD>
</TR>
<TR>
<TH></TH><TD><EM>This dynamically allocates a new environment
with a specified parent.</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_symeval">fd_symeval</A></TD><TD CLASS="ccode">fd_lisp sym,lispenv env</TD><TD CLASS="ccode">fd_lisp </TD>
</TR>
<TR>
<TH></TH><TD>a lisp symbol and an environment (possibly NULL)</TD><TD>a lisp object (not cref'd)</TD>
</TR>
<TR>
<TH></TH><TD><EM>This looks up a symbol, handling both lexical references, module references,
and global references.</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_make_ssproc">fd_make_ssproc</A></TD><TD CLASS="ccode">lisp lambda,lispenv env</TD><TD CLASS="ccode">lisp </TD>
</TR>
<TR>
<TH></TH><TD>a lisp lambda expression and an environment</TD><TD>a procedure object closing the expression in the environment</TD>
</TR>
<TR>
<TH></TH><TD><EM>with a lock for synchronizing application.</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_bind_value">fd_bind_value</A></TD><TD CLASS="ccode">lisp sym,lisp val,lispenv env</TD><TD CLASS="ccode">void </TD>
</TR>
<TR>
<TH></TH><TD>a symbol, a value, and an environment</TD><TD>1 on success, 0 on failure</TD>
</TR>
<TR>
<TH></TH><TD><EM>Sets the binding for symbol in the first frame of environment
 or creates a new one if one does not exist.  Returns 1 if a new
 binding had to be created.</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_register_restricted_module">fd_register_restricted_module</A></TD><TD CLASS="ccode">fd_u8char *name,fd_lispenv menv</TD><TD CLASS="ccode">void </TD>
</TR>
<TR>
<TH></TH><TD>a string and an environment</TD><TD>void</TD>
</TR>
<TR>
<TH></TH><TD><EM>Binds the named symbol to the environment in the restricted environment.
 This will signal an error if the global binding is not VOID.</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_module_export">fd_module_export</A></TD><TD CLASS="ccode">fd_lispenv modenv,lisp symbol</TD><TD CLASS="ccode">void </TD>
</TR>
<TR>
<TH></TH><TD>a pointer to a module and a lisp symbol</TD><TD>void</TD>
</TR>
<TR>
<TH></TH><TD><EM>Arranges for the module to export the specified symbol.</EM></TD><TD></TD>
</TR>

</TABLE>
<A NAME="mini.c"><H2>
Functions defined in <TT>src/eval/mini.c</TT>
</H2>
</A><P>

</P>
<TABLE CELLPADDING="5">
<TR>
<TH ALIGN="LEFT">Function</TH><TH ALIGN="LEFT">Arguments</TH><TH ALIGN="LEFT">Returns</TH>
</TR>

</TABLE>
<A NAME="ndeval.c"><H2>
Functions defined in <TT>src/eval/ndeval.c</TT>
</H2>
</A><P>

</P>
<TABLE CELLPADDING="5">
<TR>
<TH ALIGN="LEFT">Function</TH><TH ALIGN="LEFT">Arguments</TH><TH ALIGN="LEFT">Returns</TH>
</TR>

</TABLE>
<A NAME="eval.c"><H2>
Functions defined in <TT>src/eval/eval.c</TT>
</H2>
</A><P>
<A HREF="#_fd_finalize_static_tail_call"><TT>_fd_finalize_static_tail_call</TT></A> | <A HREF="#fd_add_alias"><TT>fd_add_alias</TT></A> | <A HREF="#fd_add_cproc"><TT>fd_add_cproc</TT></A> | <A HREF="#fd_add_lexpr
"><TT>fd_add_lexpr
</TT></A> | <A HREF="#fd_add_special_form
"><TT>fd_add_special_form
</TT></A> | <A HREF="#fd_do_application"><TT>fd_do_application</TT></A> | <A HREF="#fd_eval"><TT>fd_eval</TT></A> | <A HREF="#fd_eval_elts"><TT>fd_eval_elts</TT></A> | <A HREF="#fd_eval_in_env"><TT>fd_eval_in_env</TT></A> | <A HREF="#fd_evalstring"><TT>fd_evalstring</TT></A> | <A HREF="#fd_finish_value"><TT>fd_finish_value</TT></A> | <A HREF="#fd_make_rproc"><TT>fd_make_rproc</TT></A> | <A HREF="#fd_mv_arity"><TT>fd_mv_arity</TT></A> | <A HREF="#fd_mv_ref"><TT>fd_mv_ref</TT></A> | <A HREF="#fd_mv_return"><TT>fd_mv_return</TT></A> | <A HREF="#fd_record_typep"><TT>fd_record_typep</TT></A> | <A HREF="#fd_set_supertype"><TT>fd_set_supertype</TT></A> | <A HREF="#fd_start_eval"><TT>fd_start_eval</TT></A> | <A HREF="#fd_streval"><TT>fd_streval</TT></A> | 
</P>
<TABLE CELLPADDING="5">
<TR>
<TH ALIGN="LEFT">Function</TH><TH ALIGN="LEFT">Arguments</TH><TH ALIGN="LEFT">Returns</TH>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_make_rproc">fd_make_rproc</A></TD><TD CLASS="ccode">fd_server s,lisp op</TD><TD CLASS="ccode">lisp </TD>
</TR>
<TR>
<TH></TH><TD>a server id and a remote op name, both lisp pointers</TD><TD>an rproc to invoke the op name on the named server</TD>
</TR>
<TR>
<TH></TH><TD><EM></EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_do_application">fd_do_application</A></TD><TD CLASS="ccode">lisp fcn,lisp argvalues</TD><TD CLASS="ccode">lisp </TD>
</TR>
<TR>
<TH></TH><TD>two lisp values, a procedure and a list of arguments</TD><TD>a value or a tail call resulting from applying the</TD>
</TR>
<TR>
<TH></TH><TD><EM>procedure to the arguments.</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_eval_elts">fd_eval_elts</A></TD><TD CLASS="ccode">lisp lst,lispenv env</TD><TD CLASS="ccode">lisp </TD>
</TR>
<TR>
<TH></TH><TD>a list of expressions</TD><TD>a list of objects</TD>
</TR>
<TR>
<TH></TH><TD><EM>Returns the result of evaluating each element of a list in an
 environment.  Actual implementation is above.</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_mv_return">fd_mv_return</A></TD><TD CLASS="ccode">lisp *x,int len</TD><TD CLASS="ccode">fd_lisp </TD>
</TR>
<TR>
<TH></TH><TD>a pointer to an array of lisp pointers and a int length</TD><TD>a multiple value object whose elements are the elements</TD>
</TR>
<TR>
<TH></TH><TD><EM>of the array (copied into a new array)</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_eval">fd_eval</A></TD><TD CLASS="ccode">lisp expr</TD><TD CLASS="ccode">lisp </TD>
</TR>
<TR>
<TH></TH><TD>an expression</TD><TD>a lisp pointer</TD>
</TR>
<TR>
<TH></TH><TD><EM>Evaluates an expression in the top level environment.
  It's argument is not gc'd.</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_add_alias">fd_add_alias</A></TD><TD CLASS="ccode">fd_lispenv env,char *alias,char *name</TD><TD CLASS="ccode">void </TD>
</TR>
<TR>
<TH></TH><TD>a null terminated string, an argument count,
               and a pointer to a C function</TD><TD>nothing (void)</TD>
</TR>
<TR>
<TH></TH><TD><EM>Defines a new FDScript primitive which is the same as another
existing primitive.  This saves a little consing in that it simply
keeps a pointer to the primitive struct rather than making a new one.
It inherits the safety information of the procedure it is aliasing.</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_add_lexpr
">fd_add_lexpr
</A></TD><TD CLASS="ccode">fd_lispenv env,char *name,int argcode,lisp (*proc</TD><TD CLASS="ccode">void </TD>
</TR>
<TR>
<TH></TH><TD>a null terminated string and a pointer to a C function</TD><TD>nothing (void)</TD>
</TR>
<TR>
<TH></TH><TD><EM>Defines a new FDScript primitive which accepts any number of arguments.
  The C function is called on a single lisp object, pointing to a list of
  arguments.  Note that any non-deterministic arguments are represented as
  sets.
  fd_add_lexpr also declares the symbol to be "safe" for
   evaluation.</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_streval">fd_streval</A></TD><TD CLASS="ccode">char *input</TD><TD CLASS="ccode">char * </TD>
</TR>
<TR>
<TH></TH><TD>a string</TD><TD>a string</TD>
</TR>
<TR>
<TH></TH><TD><EM>Evaluates an expression in the top level environment.</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_evalstring">fd_evalstring</A></TD><TD CLASS="ccode">char *input,lispenv env</TD><TD CLASS="ccode">char * </TD>
</TR>
<TR>
<TH></TH><TD>a string</TD><TD>a string</TD>
</TR>
<TR>
<TH></TH><TD><EM>Evaluates an expression in the top level environment.</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_add_cproc">fd_add_cproc</A></TD><TD CLASS="ccode">fd_lispenv env,char *name,int n_args,lisp (*proc</TD><TD CLASS="ccode">void </TD>
</TR>
<TR>
<TH></TH><TD>a null terminated string, an argument count,
               and a pointer to a C function</TD><TD>nothing (void)</TD>
</TR>
<TR>
<TH></TH><TD><EM>Defines a new FDScript primitive with a name, a number of
   arguments and a C implementation.  Note that if the number
   of arguments is negative, it is taken to be a lexpr or special form,
   thought fd_add_special_form is the preferred way to declare such
   primitives.  A special form's implementation function is
   called on the expression being evaluated and its environment,
   without any further processing of the expression.
  fd_add_cproc also declares the symbol to be "safe" for
   evaluation.</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_record_typep">fd_record_typep</A></TD><TD CLASS="ccode">lisp x,lisp tag</TD><TD CLASS="ccode">int </TD>
</TR>
<TR>
<TH></TH><TD>a lisp record and a tag</TD><TD>1 or 0</TD>
</TR>
<TR>
<TH></TH><TD><EM>Returns 1 if the record's tag is the specified
pointer or one of its `supertypes'.  Returns 0 otherwise
or if the record is not really a record</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_start_eval">fd_start_eval</A></TD><TD CLASS="ccode">lisp expr,lispenv env</TD><TD CLASS="ccode">lisp </TD>
</TR>
<TR>
<TH></TH><TD>a lisp expression and a lisp environment</TD><TD>a lisp value, possibly a tail call</TD>
</TR>
<TR>
<TH></TH><TD><EM>This starts the evaluation process which can be finished
 with fd_finish_value</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="_fd_finalize_static_tail_call">_fd_finalize_static_tail_call</A></TD><TD CLASS="ccode">lisp tc,fd_lispenv env</TD><TD CLASS="ccode">lisp </TD>
</TR>
<TR>
<TH></TH><TD>a tail call object and an environment</TD><TD>the results of evaluating the tail call until it no</TD>
</TR>
<TR>
<TH></TH><TD><EM>longer depends on the given environment</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_finish_value">fd_finish_value</A></TD><TD CLASS="ccode">lisp value</TD><TD CLASS="ccode">lisp </TD>
</TR>
<TR>
<TH></TH><TD>a lisp pointer</TD><TD>a lisp pointer which isn't a tail call</TD>
</TR>
<TR>
<TH></TH><TD><EM>This will force any tail call to evaluate to a real value.</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_eval_in_env">fd_eval_in_env</A></TD><TD CLASS="ccode">lisp expr,lispenv env</TD><TD CLASS="ccode">lisp </TD>
</TR>
<TR>
<TH></TH><TD>a lisp expression and a lisp environment</TD><TD>a lisp value, never a tail call</TD>
</TR>
<TR>
<TH></TH><TD><EM>This starts and finishes the evaluation process.
 It returns a value which may need to be freed but does
  not use up the value it is passed.</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_mv_ref">fd_mv_ref</A></TD><TD CLASS="ccode">lisp x,unsigned int i</TD><TD CLASS="ccode">fd_lisp </TD>
</TR>
<TR>
<TH></TH><TD>a lisp pointer and an int</TD><TD>the ith value represented by the pointer or FD_VOID otherwise</TD>
</TR>
<TR>
<TH></TH><TD><EM></EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_add_special_form
">fd_add_special_form
</A></TD><TD CLASS="ccode">fd_lispenv env,char *name,lisp (*proc</TD><TD CLASS="ccode">void </TD>
</TR>
<TR>
<TH></TH><TD>a null terminated string and a pointer to a C function</TD><TD>nothing (void)</TD>
</TR>
<TR>
<TH></TH><TD><EM>Defines a new FDScript special form.  Whenever a form whose head is
   the specified symbol is evaluated, the declared function is called
   on the form and the environment of evaluation.
  fd_add_special_form also declares the symbol to be "safe" for
   evaluation.</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_set_supertype">fd_set_supertype</A></TD><TD CLASS="ccode">lisp tag,lisp super_tag</TD><TD CLASS="ccode">void </TD>
</TR>
<TR>
<TH></TH><TD>two lisp tags</TD><TD>nothing (void)</TD>
</TR>
<TR>
<TH></TH><TD><EM>Records a super type relationship between two tags</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_mv_arity">fd_mv_arity</A></TD><TD CLASS="ccode">lisp x</TD><TD CLASS="ccode">int </TD>
</TR>
<TR>
<TH></TH><TD>a lisp pointer</TD><TD>the number of values represented by the pointer</TD>
</TR>
<TR>
<TH></TH><TD><EM></EM></TD><TD></TD>
</TR>

</TABLE>
{}<A NAME="cxr.c"><H2>
Functions defined in <TT>src/scheme/cxr.c</TT>
</H2>
</A><P>

</P>
<TABLE CELLPADDING="5">
<TR>
<TH ALIGN="LEFT">Function</TH><TH ALIGN="LEFT">Arguments</TH><TH ALIGN="LEFT">Returns</TH>
</TR>

</TABLE>
<A NAME="reflect.c"><H2>
Functions defined in <TT>src/scheme/reflect.c</TT>
</H2>
</A><P>

</P>
<TABLE CELLPADDING="5">
<TR>
<TH ALIGN="LEFT">Function</TH><TH ALIGN="LEFT">Arguments</TH><TH ALIGN="LEFT">Returns</TH>
</TR>

</TABLE>
<A NAME="pairs.c"><H2>
Functions defined in <TT>src/scheme/pairs.c</TT>
</H2>
</A><P>

</P>
<TABLE CELLPADDING="5">
<TR>
<TH ALIGN="LEFT">Function</TH><TH ALIGN="LEFT">Arguments</TH><TH ALIGN="LEFT">Returns</TH>
</TR>

</TABLE>
<A NAME="characters.c"><H2>
Functions defined in <TT>src/scheme/characters.c</TT>
</H2>
</A><P>

</P>
<TABLE CELLPADDING="5">
<TR>
<TH ALIGN="LEFT">Function</TH><TH ALIGN="LEFT">Arguments</TH><TH ALIGN="LEFT">Returns</TH>
</TR>

</TABLE>
<A NAME="bignum.c"><H2>
Functions defined in <TT>src/scheme/bignum.c</TT>
</H2>
</A><P>

</P>
<TABLE CELLPADDING="5">
<TR>
<TH ALIGN="LEFT">Function</TH><TH ALIGN="LEFT">Arguments</TH><TH ALIGN="LEFT">Returns</TH>
</TR>

</TABLE>
<A NAME="ioprims.c"><H2>
Functions defined in <TT>src/scheme/ioprims.c</TT>
</H2>
</A><P>

</P>
<TABLE CELLPADDING="5">
<TR>
<TH ALIGN="LEFT">Function</TH><TH ALIGN="LEFT">Arguments</TH><TH ALIGN="LEFT">Returns</TH>
</TR>

</TABLE>
<A NAME="arith.c"><H2>
Functions defined in <TT>src/scheme/arith.c</TT>
</H2>
</A><P>

</P>
<TABLE CELLPADDING="5">
<TR>
<TH ALIGN="LEFT">Function</TH><TH ALIGN="LEFT">Arguments</TH><TH ALIGN="LEFT">Returns</TH>
</TR>

</TABLE>
<A NAME="special.c"><H2>
Functions defined in <TT>src/scheme/special.c</TT>
</H2>
</A><P>

</P>
<TABLE CELLPADDING="5">
<TR>
<TH ALIGN="LEFT">Function</TH><TH ALIGN="LEFT">Arguments</TH><TH ALIGN="LEFT">Returns</TH>
</TR>

</TABLE>
<A NAME="libfdscheme.c"><H2>
Functions defined in <TT>src/scheme/libfdscheme.c</TT>
</H2>
</A><P>

</P>
<TABLE CELLPADDING="5">
<TR>
<TH ALIGN="LEFT">Function</TH><TH ALIGN="LEFT">Arguments</TH><TH ALIGN="LEFT">Returns</TH>
</TR>

</TABLE>
<A NAME="strings.c"><H2>
Functions defined in <TT>src/scheme/strings.c</TT>
</H2>
</A><P>
<A HREF="#fd_string_length"><TT>fd_string_length</TT></A> | <A HREF="#fd_string_ref"><TT>fd_string_ref</TT></A> | <A HREF="#fd_string_set"><TT>fd_string_set</TT></A> | 
</P>
<TABLE CELLPADDING="5">
<TR>
<TH ALIGN="LEFT">Function</TH><TH ALIGN="LEFT">Arguments</TH><TH ALIGN="LEFT">Returns</TH>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_string_set">fd_string_set</A></TD><TD CLASS="ccode">fd_lisp str,int index,unichar_t ch</TD><TD CLASS="ccode">void </TD>
</TR>
<TR>
<TH></TH><TD>a lisp pointer to a string, an int, and a unicode character</TD><TD>void</TD>
</TR>
<TR>
<TH></TH><TD><EM>Modifies the string so that a particular character is changed.</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_string_length">fd_string_length</A></TD><TD CLASS="ccode">lisp str</TD><TD CLASS="ccode">int </TD>
</TR>
<TR>
<TH></TH><TD>a lisp pointer to a string</TD><TD>the length (in unicode characters) of a string</TD>
</TR>
<TR>
<TH></TH><TD><EM></EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_string_ref">fd_string_ref</A></TD><TD CLASS="ccode">lisp string,int index</TD><TD CLASS="ccode">unichar_t </TD>
</TR>
<TR>
<TH></TH><TD>a lisp pointer to a string and an int</TD><TD>an unsigned int encoding a unicode character</TD>
</TR>
<TR>
<TH></TH><TD><EM></EM></TD><TD></TD>
</TR>

</TABLE>
<A NAME="records.c"><H2>
Functions defined in <TT>src/scheme/records.c</TT>
</H2>
</A><P>

</P>
<TABLE CELLPADDING="5">
<TR>
<TH ALIGN="LEFT">Function</TH><TH ALIGN="LEFT">Arguments</TH><TH ALIGN="LEFT">Returns</TH>
</TR>

</TABLE>
{}<A NAME="framerd.c"><H2>
Functions defined in <TT>src/fdscript/framerd.c</TT>
</H2>
</A><P>

</P>
<TABLE CELLPADDING="5">
<TR>
<TH ALIGN="LEFT">Function</TH><TH ALIGN="LEFT">Arguments</TH><TH ALIGN="LEFT">Returns</TH>
</TR>

</TABLE>
<A NAME="osprims.c"><H2>
Functions defined in <TT>src/fdscript/osprims.c</TT>
</H2>
</A><P>
<A HREF="#fd_register_url_protocol"><TT>fd_register_url_protocol</TT></A> | <A HREF="#fd_urlget"><TT>fd_urlget</TT></A> | 
</P>
<TABLE CELLPADDING="5">
<TR>
<TH ALIGN="LEFT">Function</TH><TH ALIGN="LEFT">Arguments</TH><TH ALIGN="LEFT">Returns</TH>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_register_url_protocol">fd_register_url_protocol</A></TD><TD CLASS="ccode">char *protocol,fd_lisp (*getter</TD><TD CLASS="ccode">void </TD>
</TR>
<TR>
<TH></TH><TD>a string and a pointer to an URL handler</TD><TD>void</TD>
</TR>
<TR>
<TH></TH><TD><EM>Registers the handler for a particular protocol name.</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_urlget">fd_urlget</A></TD><TD CLASS="ccode">char *url</TD><TD CLASS="ccode">fd_lisp </TD>
</TR>
<TR>
<TH></TH><TD>a string and a pointer to an int</TD><TD>a string (actually a pointer to a byte array)</TD>
</TR>
<TR>
<TH></TH><TD><EM>Gets the contents of a remote URL as a character string, storing the
size in the second argument (if non-NULL)</EM></TD><TD></TD>
</TR>

</TABLE>
<A NAME="libfdscript.c"><H2>
Functions defined in <TT>src/fdscript/libfdscript.c</TT>
</H2>
</A><P>

</P>
<TABLE CELLPADDING="5">
<TR>
<TH ALIGN="LEFT">Function</TH><TH ALIGN="LEFT">Arguments</TH><TH ALIGN="LEFT">Returns</TH>
</TR>

</TABLE>
<A NAME="prims.c"><H2>
Functions defined in <TT>src/fdscript/prims.c</TT>
</H2>
</A><P>

</P>
<TABLE CELLPADDING="5">
<TR>
<TH ALIGN="LEFT">Function</TH><TH ALIGN="LEFT">Arguments</TH><TH ALIGN="LEFT">Returns</TH>
</TR>

</TABLE>
<A NAME="seq.c"><H2>
Functions defined in <TT>src/fdscript/seq.c</TT>
</H2>
</A><P>

</P>
<TABLE CELLPADDING="5">
<TR>
<TH ALIGN="LEFT">Function</TH><TH ALIGN="LEFT">Arguments</TH><TH ALIGN="LEFT">Returns</TH>
</TR>

</TABLE>
<A NAME="printout.c"><H2>
Functions defined in <TT>src/fdscript/printout.c</TT>
</H2>
</A><P>

</P>
<TABLE CELLPADDING="5">
<TR>
<TH ALIGN="LEFT">Function</TH><TH ALIGN="LEFT">Arguments</TH><TH ALIGN="LEFT">Returns</TH>
</TR>

</TABLE>
<A NAME="hashprims.c"><H2>
Functions defined in <TT>src/fdscript/hashprims.c</TT>
</H2>
</A><P>

</P>
<TABLE CELLPADDING="5">
<TR>
<TH ALIGN="LEFT">Function</TH><TH ALIGN="LEFT">Arguments</TH><TH ALIGN="LEFT">Returns</TH>
</TR>

</TABLE>
<A NAME="maint.c"><H2>
Functions defined in <TT>src/fdscript/maint.c</TT>
</H2>
</A><P>

</P>
<TABLE CELLPADDING="5">
<TR>
<TH ALIGN="LEFT">Function</TH><TH ALIGN="LEFT">Arguments</TH><TH ALIGN="LEFT">Returns</TH>
</TR>

</TABLE>
{}<A NAME="match.c"><H2>
Functions defined in <TT>src/text/match.c</TT>
</H2>
</A><P>

</P>
<TABLE CELLPADDING="5">
<TR>
<TH ALIGN="LEFT">Function</TH><TH ALIGN="LEFT">Arguments</TH><TH ALIGN="LEFT">Returns</TH>
</TR>

</TABLE>
<A NAME="mime.c"><H2>
Functions defined in <TT>src/text/mime.c</TT>
</H2>
</A><P>
<A HREF="#fd_parse_mime"><TT>fd_parse_mime</TT></A> | 
</P>
<TABLE CELLPADDING="5">
<TR>
<TH ALIGN="LEFT">Function</TH><TH ALIGN="LEFT">Arguments</TH><TH ALIGN="LEFT">Returns</TH>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_parse_mime">fd_parse_mime</A></TD><TD CLASS="ccode">char *packet,int len</TD><TD CLASS="ccode">fd_lisp </TD>
</TR>
<TR>
<TH></TH><TD>a C string and an integer length</TD><TD>a slotmap</TD>
</TR>
<TR>
<TH></TH><TD><EM>The slotmap is derived from MIME-parsing the string;
  the CONTENT slot of the returned slotmap is either a string
  or a list of slotmaps (for multipart mime messages).</EM></TD><TD></TD>
</TR>

</TABLE>
<A NAME="text.c"><H2>
Functions defined in <TT>src/text/text.c</TT>
</H2>
</A><P>
<A HREF="#fd_text_subst"><TT>fd_text_subst</TT></A> | 
</P>
<TABLE CELLPADDING="5">
<TR>
<TH ALIGN="LEFT">Function</TH><TH ALIGN="LEFT">Arguments</TH><TH ALIGN="LEFT">Returns</TH>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_text_subst">fd_text_subst</A></TD><TD CLASS="ccode">fd_lisp pat,fd_lisp string</TD><TD CLASS="ccode">fd_lisp </TD>
</TR>
<TR>
<TH></TH><TD>a pattern (a lisp pointer) and a string (also a lisp pointer)</TD><TD>another lisp string</TD>
</TR>
<TR>
<TH></TH><TD><EM>Applies the substitutions specified in the pattern to the string,
returning the result.</EM></TD><TD></TD>
</TR>

</TABLE>
<A NAME="xml.c"><H2>
Functions defined in <TT>src/text/xml.c</TT>
</H2>
</A><P>
<A HREF="#fd_make_xmltag"><TT>fd_make_xmltag</TT></A> | <A HREF="#fd_parse_html"><TT>fd_parse_html</TT></A> | <A HREF="#fd_parse_xml"><TT>fd_parse_xml</TT></A> | <A HREF="#fd_xml_attributes"><TT>fd_xml_attributes</TT></A> | <A HREF="#fd_xml_content"><TT>fd_xml_content</TT></A> | <A HREF="#fd_xml_tag"><TT>fd_xml_tag</TT></A> | <A HREF="#fd_xmltag_name"><TT>fd_xmltag_name</TT></A> | <A HREF="#fd_xmltag_namespace"><TT>fd_xmltag_namespace</TT></A> | 
</P>
<TABLE CELLPADDING="5">
<TR>
<TH ALIGN="LEFT">Function</TH><TH ALIGN="LEFT">Arguments</TH><TH ALIGN="LEFT">Returns</TH>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_xmltag_namespace">fd_xmltag_namespace</A></TD><TD CLASS="ccode">fd_lisp tag</TD><TD CLASS="ccode">fd_lisp </TD>
</TR>
<TR>
<TH></TH><TD>a lisp object (symbol or xml tag)</TD><TD>the tag's namespace (possibly #f)</TD>
</TR>
<TR>
<TH></TH><TD><EM>For symbols, this just returns #F; for tags,
 it returns the tag's namespace.</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_xml_attributes">fd_xml_attributes</A></TD><TD CLASS="ccode">fd_lisp x</TD><TD CLASS="ccode">fd_lisp </TD>
</TR>
<TR>
<TH></TH><TD>a lisp pointer</TD><TD>a lisp pointer</TD>
</TR>
<TR>
<TH></TH><TD><EM>Gets the attributes of a pair or OID describing
an XML element.  Note that the attributes are a property list of
 lists.</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_xmltag_name">fd_xmltag_name</A></TD><TD CLASS="ccode">fd_lisp tag</TD><TD CLASS="ccode">fd_lisp </TD>
</TR>
<TR>
<TH></TH><TD>a lisp object (symbol or xml tag)</TD><TD>the tag's name</TD>
</TR>
<TR>
<TH></TH><TD><EM>For symbols, this is just the identity; for tags,
 it returns whatever the base of the xmltag is.</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_xml_tag">fd_xml_tag</A></TD><TD CLASS="ccode">fd_lisp x</TD><TD CLASS="ccode">fd_lisp </TD>
</TR>
<TR>
<TH></TH><TD>a lisp pointer</TD><TD>a lisp pointer</TD>
</TR>
<TR>
<TH></TH><TD><EM>Gets the tag (or element type) of an pair or OID describing
an XML element.</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_parse_html">fd_parse_html</A></TD><TD CLASS="ccode">fd_u8char *string</TD><TD CLASS="ccode">fd_lisp </TD>
</TR>
<TR>
<TH></TH><TD>a UTF8-string</TD><TD>A nested pair structure based on the HTML structure of the given string</TD>
</TR>
<TR>
<TH></TH><TD><EM>This knows about the empty HTML tags and will handle them appropriately.  It also automatically
terminates paragraphs and list items.</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_parse_xml">fd_parse_xml</A></TD><TD CLASS="ccode">fd_u8char *string,int err_level,fd_lisp ns</TD><TD CLASS="ccode">fd_lisp </TD>
</TR>
<TR>
<TH></TH><TD>a UTF8-string, an error level, and a namespace (a lisp pointer)</TD><TD>A nested pair structure based on the XML structure of the given string</TD>
</TR>
<TR>
<TH></TH><TD><EM>Unqualified element and attribute names will be created in the given namespace,
unless it is false (#f,FD_FALSE), in which case they will just be created as symbols.
The error level is an int in the range [0,2]:
	0	XML_LAX		Try and fix XML mismatches and other syntax errors
	1	XML_ATTENTIVE	Warn about XML mismatches and other syntax errors (and try to fix them)
	2	XML_PARANOID	Raise an exception for XML mismatches and other syntax errors</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_make_xmltag">fd_make_xmltag</A></TD><TD CLASS="ccode">fd_lisp ns,fd_lisp base</TD><TD CLASS="ccode">fd_lisp </TD>
</TR>
<TR>
<TH></TH><TD>a namespace (a string or symbol), and a type (a symbol)</TD><TD>an lisp object describing a qualified xmltag</TD>
</TR>
<TR>
<TH></TH><TD><EM>If the namespace is false (#f), this just returns the type.  Otherwise,
 it conses a lisp record.</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_xml_content">fd_xml_content</A></TD><TD CLASS="ccode">fd_lisp x</TD><TD CLASS="ccode">fd_lisp </TD>
</TR>
<TR>
<TH></TH><TD>a lisp pointer</TD><TD>a lisp pointer</TD>
</TR>
<TR>
<TH></TH><TD><EM>Gets the content of a pair or OID describing
an XML element. Note that this should always be a list of
either strings or other elements.</EM></TD><TD></TD>
</TR>

</TABLE>
<A NAME="md5c.c"><H2>
Functions defined in <TT>src/text/md5c.c</TT>
</H2>
</A><P>

</P>
<TABLE CELLPADDING="5">
<TR>
<TH ALIGN="LEFT">Function</TH><TH ALIGN="LEFT">Arguments</TH><TH ALIGN="LEFT">Returns</TH>
</TR>

</TABLE>
<A NAME="htmlgen.c"><H2>
Functions defined in <TT>src/text/htmlgen.c</TT>
</H2>
</A><P>
<A HREF="#fd_http_puts"><TT>fd_http_puts</TT></A> | <A HREF="#fd_http_write_bytes"><TT>fd_http_write_bytes</TT></A> | <A HREF="#fd_set_http_output_methods
"><TT>fd_set_http_output_methods
</TT></A> | <A HREF="#fd_start_http"><TT>fd_start_http</TT></A> | <A HREF="#fd_start_http_output"><TT>fd_start_http_output</TT></A> | <A HREF="#fd_unparse_xml"><TT>fd_unparse_xml</TT></A> | 
</P>
<TABLE CELLPADDING="5">
<TR>
<TH ALIGN="LEFT">Function</TH><TH ALIGN="LEFT">Arguments</TH><TH ALIGN="LEFT">Returns</TH>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_unparse_xml">fd_unparse_xml</A></TD><TD CLASS="ccode">fd_lisp expr,fd_lispenv env,fd_htstream *hs</TD><TD CLASS="ccode">void </TD>
</TR>
<TR>
<TH></TH><TD>an xml element rep, an environment, and an http stream</TD><TD>void</TD>
</TR>
<TR>
<TH></TH><TD><EM>Outputs a text representation of the xml/html structure represented by the first
  argument.  Any tags which have bindings in the environment are interpreted as function
  calls.  If the html flag is true, the generation process will try and generate
  HTML rather than XML.</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_start_http_output">fd_start_http_output</A></TD><TD CLASS="ccode">fd_htstream *s</TD><TD CLASS="ccode">void </TD>
</TR>
<TR>
<TH></TH><TD>a pointer to an fd_htstream</TD><TD>void</TD>
</TR>
<TR>
<TH></TH><TD><EM>Begins output to the designated htstream, setting it
as the thread-local HTTP output stream and setting the initial
phasse of the HTTP output process.</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_set_http_output_methods
">fd_set_http_output_methods
</A></TD><TD CLASS="ccode">void (*_puts</TD><TD CLASS="ccode">void </TD>
</TR>
<TR>
<TH></TH><TD>three functions</TD><TD>void</TD>
</TR>
<TR>
<TH></TH><TD><EM>Sets the methods used for HTTP output.  The first function
is for outputting null-terminated strings in their entirety; the
second function is for outputing single characters; and the third function
is for outputing substrings given a start and a length.</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_start_http">fd_start_http</A></TD><TD CLASS="ccode">char *mime</TD><TD CLASS="ccode">void </TD>
</TR>
<TR>
<TH></TH><TD>a string containing a mime type specification</TD><TD>void</TD>
</TR>
<TR>
<TH></TH><TD><EM>Outputs a content-type header field, including a charset specifier
which refers to the current default character encoding.</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_http_puts">fd_http_puts</A></TD><TD CLASS="ccode">char *s,fd_htstream *stream</TD><TD CLASS="ccode">void </TD>
</TR>
<TR>
<TH></TH><TD>a pointer to a null-terminated string and an FD_HTTP_STREAM struct</TD><TD>void</TD>
</TR>
<TR>
<TH></TH><TD><EM>Writes the string to the stream.</EM></TD><TD></TD>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_http_write_bytes">fd_http_write_bytes</A></TD><TD CLASS="ccode">char *s,int n,fd_htstream *stream</TD><TD CLASS="ccode">void </TD>
</TR>
<TR>
<TH></TH><TD>a pointer to a null-terminated string and an FD_HTTP_STREAM struct</TD><TD>void</TD>
</TR>
<TR>
<TH></TH><TD><EM>Writes the string to the stream.</EM></TD><TD></TD>
</TR>

</TABLE>
<A NAME="getnames.c"><H2>
Functions defined in <TT>src/text/getnames.c</TT>
</H2>
</A><P>

</P>
<TABLE CELLPADDING="5">
<TR>
<TH ALIGN="LEFT">Function</TH><TH ALIGN="LEFT">Arguments</TH><TH ALIGN="LEFT">Returns</TH>
</TR>

</TABLE>
<A NAME="stem.c"><H2>
Functions defined in <TT>src/text/stem.c</TT>
</H2>
</A><P>
<A HREF="#fd_stem_english_word"><TT>fd_stem_english_word</TT></A> | 
</P>
<TABLE CELLPADDING="5">
<TR>
<TH ALIGN="LEFT">Function</TH><TH ALIGN="LEFT">Arguments</TH><TH ALIGN="LEFT">Returns</TH>
</TR>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" CLASS="ccode"><A NAME="fd_stem_english_word">fd_stem_english_word</A></TD><TD CLASS="ccode">fd_u8char *original</TD><TD CLASS="ccode">char * </TD>
</TR>
<TR>
<TH></TH><TD>an ASCII string</TD><TD>a stemmed string (malloc'd)</TD>
</TR>
<TR>
<TH></TH><TD><EM>Applies all the Porter rules for stemming a word.  If the word
    is too long (more than 200 characters) it just gives up.  This
    returns a malloc'd string containing the porter stem.   Note that
    the porter stem is usually not itself a word you would recognize.</EM></TD><TD></TD>
</TR>

</TABLE>
{}<A NAME="console.c"><H2>
Functions defined in <TT>src/misc/console.c</TT>
</H2>
</A><P>

</P>
<TABLE CELLPADDING="5">
<TR>
<TH ALIGN="LEFT">Function</TH><TH ALIGN="LEFT">Arguments</TH><TH ALIGN="LEFT">Returns</TH>
</TR>

</TABLE>
<A NAME="cgiparse.c"><H2>
Functions defined in <TT>src/misc/cgiparse.c</TT>
</H2>
</A><P>

</P>
<TABLE CELLPADDING="5">
<TR>
<TH ALIGN="LEFT">Function</TH><TH ALIGN="LEFT">Arguments</TH><TH ALIGN="LEFT">Returns</TH>
</TR>

</TABLE>
<A NAME="indextools.c"><H2>
Functions defined in <TT>src/misc/indextools.c</TT>
</H2>
</A><P>

</P>
<TABLE CELLPADDING="5">
<TR>
<TH ALIGN="LEFT">Function</TH><TH ALIGN="LEFT">Arguments</TH><TH ALIGN="LEFT">Returns</TH>
</TR>

</TABLE>
<A NAME="server.c"><H2>
Functions defined in <TT>src/misc/server.c</TT>
</H2>
</A><P>

</P>
<TABLE CELLPADDING="5">
<TR>
<TH ALIGN="LEFT">Function</TH><TH ALIGN="LEFT">Arguments</TH><TH ALIGN="LEFT">Returns</TH>
</TR>

</TABLE>
{}
</BODY></HTML>
