directory @source_dir@/framerd:@source_dir@/libu8:@source_dir@/lingo:@extra_sources@
set env UNDERGDB=yes
set env STDLOG=yes
set env FD_FOREGROUND=yes
set env FD_IGNORELEFTOVERS=yes
set env FD_STEALSOCKETS=yes
set env DUMA_ALIGNMENT=4
set env PPROF_PATH=/usr/bin/gpprof
set env MSAN_SYMBOLIZER_PATH=/usr/bin/llvm-symbolizer
set env ASAN_OPTIONS=abort_on_error=1:malloc_context_size=30:print_cmdline=true
set env LSAN_OPTIONS=detect_leaks=0
set env TCMALLOC_DEBUG=3
#set env PERFTOOLS_VERBOSE=2
#set env MALLOCSTATS=2
#set env HEAPPROFILE=/tmp/heap.profiles/heapprof
#set env HEAPCHECK=normal # strict|draconian
#set CPUPROFILE=/tmp/cpu-profile
set print elements 64

define vg
  target remote | vgdb
end
define vgx
  target remote | vgdb $arg0
end
define w5
  if ($argc > 0)
    thread $arg0
  end
  where 5
end
define w10
  if ($argc > 0)
    thread $arg0
  end
  where 10
end
define w15
  if ($argc > 0)
    thread $arg0
  end
  where 15
end
define w20
  if ($argc > 0)
    thread $arg0
  end
  where 20
end
define ww
  if ($argc > 0)
    thread $arg0
  end
  where 25
end
define wh
  if ($argc > 1)
    thread $arg1
  end
  where $arg0
end
define x64
  x/64xb $arg0
end
define x32
  x/32xb $arg0
end
define x16
  x/16xb $arg0
end
define xx
  x/16xb $arg0
end
define freeze
  set scheduler on
end
define unfreeze
  set scheduler off
end

define heapcheck
  set env HEAPPROFILE=/tmp/heap.profiles/heapprof
  set env HEAPCHECK=normal # strict|draconian
end
define leakcheck
  set env HEAPCHECK=normal # strict|draconian
  set LSAN_OPTIONS=detect_leaks=1:report_objects=1:malloc_context_size=30
end
define libinfo
  info sharedlib
end
define locals
  info args
  info locals
end

define pp
  if ($argc == 0)
    print/x $
    print/x *$
  else
     if ($argc == 1)
      print/x $arg0
      print/x *$arg0
    else
      print/x (($arg1)($arg0))
      print/x *(($arg1)($arg0))
    end
  end
end
define xp
  print/x $arg0
end

define lisp
  printf "%s\n",fd_lisp2string($arg0)
end
define lispval
  printf "%s\n",fd_lisp2string($arg0)
end

define showtype
  printf "type of 0x%llx is 0x%x: %s\n",((lispval)$arg0),(((($arg0)&0x03)==2)?(fd_fixnum_type):((($arg0)&0x3)==3)?(fd_oid_type):((($arg0)&0x3)==0)?((enum FD_PTR_TYPE)(((((struct FD_CONS *)($arg0))->conshead)&0x7F)+0x84)):((enum FD_PTR_TYPE)(((($arg0)>>25)&0x7f)+0x04))),fd_type_names[(((($arg0)&0x03)==2)?(fd_fixnum_type):((($arg0)&0x3)==3)?(fd_oid_type):((($arg0)&0x3)==0)?((enum FD_PTR_TYPE)(((((struct FD_CONS *)($arg0))->conshead)&0x7F)+0x84)):((enum FD_PTR_TYPE)(((($arg0)>>25)&0x7f)+0x04)))]
end
define showtypename
  printf "object type is 0x%x: %s\n",_fd_ptr_type($arg0),fd_type_names[_fd_ptr_type($arg0)]
end
define lispout
  call _fd_lisp2stderr($arg0)
end
define unparse
  call _fd_lisp2stderr($arg0)
end
define refcount
  if (((lispval)$arg0)&3)
  print "not a cons" 
  else
  printf "object refcount=%d\n",((((struct FD_CONS *)$arg0)->conshead)>>7)
  print ((struct FD_CONS *)($arg0))
  end
end
define watchcons
  watch -l ((struct FD_CONS *)($arg0))->conshead
end
define showstruct 
  print/x *((struct $arg1 *)($arg0))
end
define showcons
  print/x ((struct FD_CONS *)($arg0))
end
define showfield
  print/x ((struct $arg1 *)($arg0))->$arg2
end
define showstring
  set print elements 0
  print ((struct FD_STRING *)($arg0))->str_bytes
  set print elements 16
end
define showsymbol
  printf "%s\n",((struct FD_STRING *)(fd_symbol_names[((($arg0)>>2)&(0x7FFFFF))]))->str_bytes
end
define showoid
  print/x (fd_base_oids[(($arg0>>2)&(_FD_OID_BUCKET_MASK)]+($arg0>>(_FD_OID_BUCKET_WIDTH+2)))
end
define oid
  printf "  @%x/%x\n",((fd_base_oids[(($arg0>>2)&(_FD_OID_BUCKET_MASK))])>>32),(((fd_base_oids[(($arg0>>2)&(_FD_OID_BUCKET_MASK))])&0xFFFFFFFF)|(($arg0&(0x7FFFFF))>>(_FD_OID_BUCKET_WIDTH+2)))
end
define showcar
  print/x (((struct FD_PAIR *)$arg0)->car)
  showtype $
end
define showcdr
  print/x (((struct FD_PAIR *)$arg0)->cdr)
  showtype $
end
define showvelt
   print/x ((((struct FD_VECTOR *)$arg0)->vec_elts)[$arg1])
   showtype $
end
define showcelt
  print/x ((&((struct FD_CHOICE *)$arg0)->choice_0)[$arg1])
  showtype $  
end
define celt
  printf "%s\n",fd_lisp2string(((&((struct FD_CHOICE *)$arg0)->choice_0)[$arg1]))
  print/x ((&((struct FD_CHOICE *)$arg0)->choice_0)[$arg1])
  showtype $
define oidinfo
  printf "oidinfo: %s\n", (_fd_oid_info($arg0))
end
define showchoice
  printf "data=%d\n",(&(((struct FD_CHOICE *)$arg0)->choice_0))
  printf "size=%d\n",((((struct FD_CHOICE *)$arg0)->choice_size)&(0x7FFFFFFF))
  print (*((struct FD_CHOICE *)$arg0))
end
define showvec
  printf "data=%d\n",(&(((struct FD_VECTOR *)$arg0)->vec_elts))
  printf "size=%d\n",(((struct FD_VECTOR *)$arg0)->vec_length)
  print (*((struct FD_VECTOR *)$arg0))
end
define showvelt
  printf "data=%d\n",(&(((struct FD_CHOICE *)$arg0)->vec_elts))
  printf "size=%d\n",((((struct FD_CHOICE *)$arg0)->vec_length)&(0x7FFFFFFF))
  print ((((struct FD_VECTOR *)$arg0)->vec_elts)[$arg1])
  showtype $
end
define velt
  printf "%s\n",fd_lisp2string(((((struct FD_VECTOR *)$arg0)->vec_elts)[$arg1]))
  print ((((struct FD_VECTOR *)$arg0)->vec_elts)[$arg1])
  showtype $
end
define showflo
  print (((struct FD_FLONUM *)($arg0))->floval)
end
define schemap
  printf "schema=%d\n",(&(((struct FD_SCHEMAP *)$arg0)->table_schema))
  printf "values=%d\n",(&(((struct FD_SCHEMAP *)$arg0)->schema_values))
  printf "size=%d\n",(((struct FD_SCHEMAP *)$arg0)->schema_length)
  print (*((struct FD_SCHEMAP *)$arg0))
end
define showschemapk
  print (((struct FD_SCHEMAP *)$arg0)->table_schema)[$arg1]
  showtype $
end
define showschemapv
  print (((struct FD_SCHEMAP *)$arg0)->schema_values)[$arg1]
  showtype $
end
define slotmap
  printf "keyvals=%d\n",(&(((struct FD_SLOTMAP *)$arg0)->sm_keyvals))
  printf "size=%d\n",((((struct FD_SLOTMAP *)$arg0)->n_slots)&0x3FFFFFFF)
  printf "space=%d\n",((((struct FD_SLOTMAP *)$arg0)->n_allocd)&0x3FFFFFFF)
  print (*((struct FD_SLOTMAP *)$arg0))
end
define slotmapkv
  print &((((fd_slotmap)($arg0))->sm_keyvals)[($arg1)])
  showtype ((((fd_slotmap)($arg0))->sm_keyvals)[($arg1)].kv_key)
  showtype ((((fd_slotmap)($arg0))->sm_keyvals)[($arg1)].kv_val)
end
define showslotmapv
  print ((((fd_slotmap)$arg0)->sm_keyvals)[($arg1)].kv_val)
  showtype $
end
define findelt
  print _fd_find_elt($arg0,$arg1,$arg2)
  showtype $
end
define inchoicep
  print _fd_find_elt($arg0,&(((struct FD_CHOICE *)$arg1)->choice_0),(((struct FD_CHOICE *)$arg1)->choice_size))
  showtype $
end
define rawpos
  print u8_rawpos($arg0)
end

define fullstring
  call (void)puts($arg0)
end

set breakpoint pending on
#set disable-randomization off
set overload-resolution off

break u8_log_break
break u8_new_exception
break _fd_debug
break _u8_dbg
break u8_raise
break TCMalloc_Printer::printf
break __msan_warning
break __msan_warning_noreturn
break __asan_report_error
break abort
#break exit


# For LIBC
set env MALLOC_CHECK_=2

# For OS X
#set env MallocHelp=1 
set env MallocGuardEdges=1
set env MallocScribble=1
set env MallocBadFreeAbort=1
set env MallocCheckHeapAbort=1
set env MallocCorruptionAbort=1

define osx_check_heap
  set env MallocCheckHeapStart=0
  set env MallocCheckHeapEach=$arg0
  break malloc_error_break
end

define osx_trace_heap
  set env MallocStackLogging YES
end

# Init Framer print limits (init done through the config interface)
define set_fdmaxelts
  set env FD_DISPLAYMAXELTS=36
  set env FD_DISPLAYMAXCHARS=1024
end

define reset_fdmaxelts
  unset env FD_DISPLAYMAXELTS
  unset env FD_DISPLAYMAXCHARS
end

define trace_server
  set env FD_U8LOGLISTEN=yes
  set env FD_U8LOGCONNECT=yes
  set env FD_U8LOGTRANSACT=yes
  set env FD_LOGTRANSFER=yes
  set env FD_LOGLEVEL=8
end

define debug_tempsrv
  set args tempsrv.fdz
end

define trace_tempsrv
  set args tempsrv.fdz
  set env FD_U8LOGLISTEN=yes
  set env FD_U8LOGCONNECT=yes
  set env FD_U8LOGTRANSACT=yes
  set env FD_U8LOGTRANSFER=yes
  set env FD_LOGLEVEL=8
end

define useinstalledmodules
  unset environment FD_INIT_LOADPATH
  unset environment FD_INIT_DLOADPATH
  unset environment FD_INIT_SAFELOADPATH
end

define staticweb
    set args /var/run/fdserv/static.sock
end

define dotload
  unset environment FD_SKIP_DOTLOAD
end

define dontload
  set env FD_SKIP_DOTLOAD yes
end

define cast
  print (($arg1)($arg0))
end

define pcast
  print *(($arg1)($arg0))
end

define pfield
  print *(($arg0)->$arg1)
end

define sfield
  print *(($arg0).$arg1)
end

# Commands for the new stack
define stackframe
  if ($argc == 1)
    call _fdbg_show_stack_frame($arg0)
  else
   call _fdbg_show_stack_frame((void *)0)
  end
end

define showstack
  if ($argc == 0)
   call _fdbg_show_stack((void *)0,-1)
  end
  if ($argc == 1)
    call _fdbg_show_stack_frame($arg0)
  end
  if ($argc == 2)
   call _fdbg_show_stack($arg1,$arg0)
  end
end

define stackarg
  print/x _fdbg_get_stack_arg($arg0,$arg1)
  printf "type of 0x%llx is 0x%x: %s\n",((lispval)$),(((($)&0x03)==2)?(fd_fixnum_type):((($)&0x3)==3)?(fd_oid_type):((($)&0x3)==0)?((enum FD_PTR_TYPE)(((((struct FD_CONS *)($))->conshead)&0x7F)+0x84)):((enum FD_PTR_TYPE)(((($)>>25)&0x7f)+0x04))),fd_type_names[(((($)&0x03)==2)?(fd_fixnum_type):((($)&0x3)==3)?(fd_oid_type):((($)&0x3)==0)?((enum FD_PTR_TYPE)(((((struct FD_CONS *)($))->conshead)&0x7F)+0x84)):((enum FD_PTR_TYPE)(((($)>>25)&0x7f)+0x04)))]
end

define stackvar
  print/x _fdbg_get_stack_var($arg0,"$arg1")
  printf "type of 0x%llx is 0x%x: %s\n",((lispval)$),(((($)&0x03)==2)?(fd_fixnum_type):((($)&0x3)==3)?(fd_oid_type):((($)&0x3)==0)?((enum FD_PTR_TYPE)(((((struct FD_CONS *)($))->conshead)&0x7F)+0x84)):((enum FD_PTR_TYPE)(((($)>>25)&0x7f)+0x04))),fd_type_names[(((($)&0x03)==2)?(fd_fixnum_type):((($)&0x3)==3)?(fd_oid_type):((($)&0x3)==0)?((enum FD_PTR_TYPE)(((((struct FD_CONS *)($))->conshead)&0x7F)+0x84)):((enum FD_PTR_TYPE)(((($)>>25)&0x7f)+0x04)))]
end


define lexenv
  call _fdbg_show_env($arg0,20)
end
define lexvals
  call _fdbg_show_env($arg0,-1)
end

define stackenv
  call _fdbg_show_stack_env($arg0,20)
end

# Init some tracing configurations
set env FD_DLOAD:TRACE=yes
# This is for OS X > Sierra
set startup-with-shell off
