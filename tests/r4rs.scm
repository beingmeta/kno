;; Copyright (C) 1991, 1992, 1993, 1994, 1995 Free Software Foundation, Inc.
;;
;; This program is free software; you can redistribute it and/or modify it
;; under the terms of the GNU General Public License as published by the
;; Free Software Foundation; either version 2, or (at your option) any
;; later version.
;;
;; This program is distributed in the hope that it will be useful,
;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;; GNU General Public License for more details.
;;
;; To receive a copy of the GNU General Public License, write to the
;; Free Software Foundation, Inc., 59 Temple Place - Suite 330,
;; Boston, MA 02111-1307, USA; or view
;; http://www-swiss.ai.mit.edu/~jaffer/GPL.html

;;;; "r4rstest.scm" Test correctness of scheme implementations.
;;; Author: Aubrey Jaffer

;;; This includes examples from
;;; William Clinger and Jonathan Rees, editors.
;;; Revised^4 Report on the Algorithmic Language Scheme
;;; and the IEEE specification.

;;; The input tests read this file expecting it to be named "r4rstest.scm".
;;; Files `tmp1', `tmp2' and `tmp3' will be created in the course of running
;;; these tests.  You may need to delete them in order to run
;;; "r4rstest.scm" more than once.

;;;   There are three optional tests:
;;; (TEST-CONT) tests multiple returns from call-with-current-continuation
;;;
;;; (TEST-SC4) tests procedures required by R4RS but not by IEEE
;;;
;;; (TEST-DELAY) tests DELAY and FORCE, which are not required by
;;;   either standard.

;;; If you are testing a R3RS version which does not have `list?' do:
;;; (define list? #f)

;;; send corrections or additions to jaffer@ai.mit.edu

(load-component "common.scm")

(optimization-leaks)

(define cur-section '())(define errs '())
(define SECTION (lambda args
		  (display "SECTION") (write args) (newline)
		  (set! cur-section args) #t))

(SECTION 2 1);; test that all symbol characters are supported.
'(+ - ... !.. $.+ %.- &.! *.: /:. :+. <-. =. >. ?. ~. _. ^.)

(SECTION 3 4)
(define disjoint-type-functions
  (list boolean? char? null? number? pair? procedure? string? symbol? vector? compound?))
(define type-examples
  (list
   #t #f #\a '() 9739 '(applytest) SECTION "test" "" 'test '#() '#(a b c) #%(RECORD 1 2 c)))
(define i 1)
(for-each (lambda (x) (display (make-string i #\ ))
		  (set! i (+ 3 i))
		  (write x)
		  (newline))
	  disjoint-type-functions)
(define type-matrix
  (map (lambda (x)
	 (let ((t (map (lambda (f) (f x)) disjoint-type-functions)))
	   (write t)
	   (write x)
	   (newline)
	   t))
       type-examples))
(set! i 0)
(define j 0)
(for-each (lambda (x y)
	    (set! j (+ 1 j))
	    (set! i 0)
	    (for-each (lambda (f)
			(set! i (+ 1 i))
			(cond ((and (= i j))
			       (cond ((not (f x))) (applytester #t f x)))
			      ((f x) (applytester #f f x)))
			(cond ((and (= i j))
			       (cond ((not (f y))) (applytester #t f y)))
			      ((f y) (applytester #f f y))))
		      disjoint-type-functions))
	  (list #t #\a '() 9739 '(applytest) SECTION "test" 'car '#(a b c))
	  (list #f #\newline '() -3252 '(t . t) car "" 'nil '#()))
(SECTION 4 1 2)
(applytester #t equal? '(quote a) (quote 'a))
(applytester #t equal? '(quote a) ''a)
(SECTION 4 1 3)
(applytester 12 (if #f + *) 3 4)
(SECTION 4 1 4)
(applytester 8 (lambda (x) (+ x x)) 4)
(define reverse-subtract
  (lambda (x y) (- y x)))
(applytester 3 reverse-subtract 7 10)
(define add4
  (let ((x 4))
    (lambda (y) (+ x y))))
(applytester 10 add4 6) ; ??
(applytester '(3 4 5 6) (lambda x x) 3 4 5 6)
(applytester '(5 6) (lambda (x y . z) z) 3 4 5 6)
(SECTION 4 1 5)
(evaltester 'yes (if (> 3 2) 'yes 'no))
(evaltester 'no (if (> 2 3) 'yes 'no))
(evaltester 1 (if (> 3 2) (- 3 2) (+ 3 2)))
(SECTION 4 1 6)
(define x 2)
(evaltest 'void (define x (+ x 1)) 'define)
(evaltester 3 x 'define)
(set! x 4)
(evaltester 'void (set! x (+ x 1)) 'set!)
(evaltester 5 x set!)
(evaltester 6 (begin (set! x (+ x 1)) x) 'begin+set!)
(SECTION 4 2 1)
(evaltester 'greater (cond ((> 3 2) 'greater)
			   ((< 3 2) 'less))
	    'cond)
(evaltester 'equal (cond ((> 3 3) 'greater)
			 ((< 3 3) 'less)
			 (else 'equal))
	    'cond)
(evaltester 2 (cond ((assv 'b '((a 1) (b 2))) => cadr)
		     (else #f))
	    'cond)
(evaltester 'composite (case (* 2 3)
			 ((2 3 5 7) 'prime)
			 ((1 4 6 8 9) 'composite))
	    'case)
(evaltester 'consonant (case (car '(c d))
			 ((a e i o u) 'vowel)
			 ((w y) 'semivowel)
			 (else 'consonant))
	    'case)
(evaltester #t (and (= 2 2) (> 2 1))
	    'and)
(evaltester #f (and (= 2 2) (< 2 1))
	    'and)
(evaltester '(f g) (and 1 2 'c '(f g))
	    'and)
(evaltester #t (and)
	    'and)
(evaltester #t (or (= 2 2) (> 2 1))
	    'or)
(evaltester #t (or (= 2 2) (< 2 1))
	    'or)
(evaltester #f (or #f #f #f)
	    'or)
(evaltester #f (or)
	    'or)
(evaltester '(b c) (or (memq 'b '(a b c)) (+ 3 0))
	    'or)
(SECTION 4 2 2)
(evaltester 6 (let ((x 2) (y 3)) (* x y))
	    'let)
(evaltester 35 (let ((x 2) (y 3)) (let ((x 7) (z (+ x y))) (* z x)))
	    'let)
(evaltester 70 (let ((x 2) (y 3)) (let* ((x 7) (z (+ x y))) (* z x)))
	    'let*)
(evaltester 70 (let ((x 2) (y 3)) (let* ((x (+ x 5)) (z (+ x y))) (* z x)))
	    'let*)
; (applytester #t 'letrec (letrec ((even?
; 			   (lambda (n) (if (zero? n) #t (odd? (- n 1)))))
; 			  (odd?
; 			   (lambda (n) (if (zero? n) #f (even? (- n 1))))))
; 		   (even? 88)))
(define x 34)
; (applytester 5 'let (let ((x 3)) (define x 5) x))
; (applytester 34 'let x)
; (applytester 6 'let (let () (define x 6) x))
; (applytester 34 'let x)
; (applytester 7 'let* (let* ((x 3)) (define x 7) x))
; (applytester 34 'let* x)
; (applytester 8 'let* (let* () (define x 8) x))
; (applytester 34 'let* x)
;(applytester 9 'letrec (letrec () (define x 9) x))
;(applytester 34 'letrec x)
;(applytester 10 'letrec (letrec ((x 3)) (define x 10) x))
;(applytester 34 'letrec x)
(SECTION 4 2 3)
(define x 0)
(evaltester 6 (begin (set! x 5) (+ x 1))
	    'begin)
(SECTION 4 2 4)
; (applytester '#(0 1 2 3 4) 'do (do ((vec (make-vector 5))
; 			    (i 0 (+ i 1)))
; 			   ((= i 5) vec)
; 			 (vector-set! vec i i)))
(evaltester 25 (let ((x '(1 3 5 7 9)))
		 (do ((x x (cdr x))
		      (sum 0 (+ sum (car x))))
		     ((null? x) sum)))
	    'do)
;(applytester 1 'let (let foo () 1))
; (applytester '((6 1 3) (-5 -2)) 'let
;       (let loop ((numbers '(3 -2 1 6 -5))
; 		 (nonneg '())
; 		 (neg '()))
; 	(cond ((null? numbers) (list nonneg neg))
; 	      ((negative? (car numbers))
; 	       (loop (cdr numbers)
; 		     nonneg
; 		     (cons (car numbers) neg)))
; 	      (else
; 	       (loop (cdr numbers)
; 		     (cons (car numbers) nonneg)
; 		     neg)))))
(SECTION 4 2 6)
(evaltester '(list 3 4) `(list ,(+ 1 2) 4)
	    'quasiquote)
(evaltester '(list a (quote a)) (let ((name 'a)) `(list ,name ',name))
	    'quasiquote)
(evaltester '(a 3 4 5 6 b) `(a ,(+ 1 2) ,@(map abs '(4 -5 6)) b)
	    'quasiquote)
(evaltester '((foo 7) . cons)
	    `((foo ,(- 10 3)) ,@(cdr '(c)) . ,(car '(cons)))
	    'quasiquote)

;;; sqt is defined here because not all implementations are required to
;;; support it.
(define (sqt x) (do ((i 0 (+ i 1))) ((> (* i i) x) (- i 1))))
(test-optimize! sqt)

(evaltester '#(10 5 2 4 3 8) `#(10 5 ,(sqt 4) ,@(map sqt '(16 9)) 8) 'quasiquote)
(evaltester 5 `,(+ 2 3) 'quasiquote)
;; Don't optimize this to avoid breaking the equality test
(evaltest '(a `(b ,(+ 1 2) ,(foo 4 d) e) f)
	    `(a `(b ,(+ 1 2) ,(foo ,(+ 1 3) d) e) f)
	    'quasiquote)
(evaltester '(a `(b ,x ,'y d) e)
	    (let ((name1 'x) (name2 'y)) `(a `(b ,,name1 ,',name2 d) e))
	    'quasiquote)
(evaltester '(list 3 4)
	    (quasiquote (list (unquote (+ 1 2)) 4))
	    'quasiquote)
(evaltester '`(list ,(+ 1 2) 4)
	    '(quasiquote (list (unquote (+ 1 2)) 4))
	    'quasiquote)
(SECTION 5 2 1)
(define add3 (lambda (x) (+ x 3)))
;; We don't optimize add3 because it introduces exactly the error we're avoiding here
;;(test-optimize! add3)
(evaltester 6 (add3 3)
	    'define)
(define 1st car)
(evaltester 1 (1st '(1 2)) 'define)
(define old-+ +)
(define + (lambda (x y) (list y x)))
(applytester '(3 6) add3 6)
(set! + old-+)
(applytester 9 add3 6)
(SECTION 5 2 2)
; (applytester 45 'define
; 	(let ((x 5))
; 		(define foo (lambda (y) (bar x y)))
; 		(define bar (lambda (a b) (+ (* a b) a)))
; 		(foo (+ x 3))))
(define x 34)
; (define (foo) (define x 5) x)
; (applytester 5 foo)
(evaltester 34 x
	    'define)
; (define foo (lambda () (define x 5) x))
; (applytester 5 foo)
(evaltester 34 x
	    'define)
; (define (foo x) ((lambda () (define x 5) x)) x)
; (applytester 88 foo 88)
; (applytester 4 foo 4)
(evaltester 34 x
	    'define)
(SECTION 6 1)
(applytester #f not #t)
(applytester #f not 3)
(applytester #f not (list 3))
(applytester #t not #f)
(applytester #f not '())
(applytester #f not (list))
(applytester #f not 'nil)

(applytester #t boolean? #f)
(applytester #f boolean? 0)
(applytester #f boolean? '())
(SECTION 6 2)
(applytester #t eqv? 'a 'a)
(applytester #f eqv? 'a 'b)
(applytester #t eqv? 2 2)
(applytester #t eqv? '() '())
(applytester #t eqv? '10000 '10000)
(applytester #f eqv? (cons 1 2)(cons 1 2))
(applytester #f eqv? (lambda () 1) (lambda () 2))
(applytester #f eqv? #f 'nil)
;; Break here.
(let ((p (lambda (x) x)))
  (applytest #t eqv? p p))
(define gen-counter
 (lambda ()
   (let ((n 0))
      (lambda () (set! n (+ n 1)) n))))
(let ((g (gen-counter))) (applytest #t eqv? g g))
(applytester #f eqv? (gen-counter) (gen-counter))
; (letrec ((f (lambda () (if (eqv? f g) 'f 'both)))
; 	 (g (lambda () (if (eqv? f g) 'g 'both))))
;   (applytester #f eqv? f g))

(applytester #t eq? 'a 'a)
(applytester #f eq? (list 'a) (list 'a))
(applytester #t eq? '() '())
(applytester #t eq? car car)
(let ((x '(a))) (applytest #t eq? x x))
(let ((x '#())) (applytest #t eq? x x))
(let ((x (lambda (x) x))) (applytest #t eq? x x))

(applytester #t equal? 'a 'a)
(applytester #t equal? '(a) '(a))
(applytester #t equal? '(a (b) c) '(a (b) c))
(applytester #t equal? "abc" "abc")
(applytester #t equal? 2 2)
(applytester #t equal? (make-vector 5 'a) (make-vector 5 'a))
(SECTION 6 3)
(evaltester '(a b c d e) '(a . (b . (c . (d . (e . ())))))
	    'dot)
(define x (list 'a 'b 'c))
(define y x)
(and list? (applytester #t list? y))
; (set-cdr! x 4)
; (applytester '(a . 4) 'set-cdr! x)
; (applytester #t eqv? x y)
(evaltester '(a b c . d) '(a . (b . (c . d)))
	    'dot)
;(and list? (applytester #f list? y))
;(and list? (let ((x (list 'a))) (set-cdr! x x) (applytester #f 'list? (list? x))))

(applytester #t pair? '(a . b))
(applytester #t pair? '(a . 1))
(applytester #t pair? '(a b c))
(applytester #f pair? '())
(applytester #f pair? '#(a b))

(applytester '(a) cons 'a '())
(applytester '((a) b c d) cons '(a) '(b c d))
(applytester '("a" b c) cons "a" '(b c))
(applytester '(a . 3) cons 'a 3)
(applytester '((a b) . c) cons '(a b) 'c)

(applytester 'a car '(a b c))
(applytester '(a) car '((a) b c d))
(applytester 1 car '(1 . 2))

(applytester '(b c d) cdr '((a) b c d))
(applytester 2 cdr '(1 . 2))

(applytester '(a 7 c) list 'a (+ 3 4) 'c)
(applytester '() list)

(applytester 3 length '(a b c))
(applytester 3 length '(a (b) (c d e)))
(applytester 0 length '())

(applytester '(x y) append '(x) '(y))
(applytester '(a b c d) append '(a) '(b c d))
(applytester '(a (b) (c)) append '(a (b)) '((c)))
(applytester '() append)
;(applytester '(a b c . d) append '(a b) '(c . d))
;(applytester 'a append '() 'a)

(applytester '(c b a) reverse '(a b c))
(applytester '((e (f)) d (b c) a) reverse '(a (b c) d (e (f))))
(errtest (reverse '(a b c . d)))

(define list-ref elt)
(applytester 'c list-ref '(a b c d) 2)

(applytester '(a b c) memq 'a '(a b c))
(applytester '(b c) memq 'b '(a b c))
(applytester '#f memq 'a '(b c d))
(applytester '#f memq (list 'a) '(b (a) c))
(applytester '((a) c) member (list 'a) '(b (a) c))
(applytester '(101 102) memv 101 '(100 101 102))

(define e '((a 1) (b 2) (c 3)))
(applytester '(a 1) assq 'a e)
(applytester '(b 2) assq 'b e)
(applytester #f assq 'd e)
(applytester #f assq (list 'a) '(((a)) ((b)) ((c))))
(applytester '((a)) assoc (list 'a) '(((a)) ((b)) ((c))))
(applytester '(5 7) assv 5 '((2 3) (5 7) (11 13)))
(SECTION 6 4)
(applytester #t symbol? 'foo)
(applytester #t symbol? (car '(a b)))
(applytester #f symbol? "bar")
(applytester #t symbol? 'nil)
(applytester #f symbol? '())
(applytester #f symbol? #f)
;;; But first, what case are symbols in?  Determine the standard case:
(define char-standard-case char-upcase)
(if (string=? (symbol->string 'A) "a")
    (set! char-standard-case char-downcase))
(evaltester #t (string=? (symbol->string 'a) (symbol->string 'A)) 'standard-case)
(evaltester #t
      (or (string=? (symbol->string 'a) "A")
	  (string=? (symbol->string 'A) "a"))
      'standard-case)
; (define (str-copy s)
;   (let ((v (make-string (string-length s))))
;     (do ((i (- (string-length v) 1) (- i 1)))
; 	((< i 0) v)
;       (string-set! v i (string-ref s i)))))
; (define (string-standard-case s)
;   (set! s (str-copy s))
;   (do ((i 0 (+ 1 i))
;        (sl (string-length s)))
;       ((>= i sl) s)
;       (string-set! s i (char-standard-case (string-ref s i)))))
; (applytester (string-standard-case "flying-fish") symbol->string 'flying-fish)
; (applytester (string-standard-case "martin") symbol->string 'Martin)
(applytester "Malvina" symbol->string (string->symbol "Malvina"))
(evaltester #t (eq? 'a 'A) 'standard-case)

(define x (string #\a #\b))
(define y (string->symbol x))
; (string-set! x 0 #\c)
; (applytester "cb" 'string-set! x)
(applytester "ab" symbol->string y)
(applytester y string->symbol "ab")

(applytester #t eq? 'mISSISSIppi 'mississippi)
(evaltester #f (eq? 'bitBlt (string->symbol "bitBlt"))
	    'string->symbol)
(applytester 'JollyWog string->symbol (symbol->string 'JollyWog))

(SECTION 6 5 5)
(applytester #t number? 3)
(applytester #t complex? 3)
(applytester #t real? 3)
(applytester #t rational? 3)
(applytester #t integer? 3)

(applytester #t exact? 3)
(applytester #f inexact? 3)

(applytester #t = 22 22 22)
(applytester #t = 22 22)
(applytester #f = 34 34 35)
(applytester #f = 34 35)
(applytester #t > 3 -6246)
(applytester #f > 9 9 -2424)
(applytester #t >= 3 -4 -6246)
(applytester #t >= 9 9)
(applytester #f >= 8 9)
(applytester #t < -1 2 3 4 5 6 7 8)
(applytester #f < -1 2 3 4 4 5 6 7)
(applytester #t <= -1 2 3 4 5 6 7 8)
(applytester #t <= -1 2 3 4 4 5 6 7)
(applytester #f < 1 3 2)
(applytester #f >= 1 3 2)

(applytester #t zero? 0)
(applytester #f zero? 1)
(applytester #f zero? -1)
(applytester #f zero? -100)
(applytester #t positive? 4)
(applytester #f positive? -4)
(applytester #f positive? 0)
(applytester #f negative? 4)
(applytester #t negative? -4)
(applytester #f negative? 0)
(applytester #t odd? 3)
(applytester #f odd? 2)
(applytester #f odd? -4)
(applytester #t odd? -1)
(applytester #f even? 3)
(applytester #t even? 2)
(applytester #t even? -4)
(applytester #f even? -1)

(applytester 38 max 34 5 7 38 6)
(applytester -24 min 3  5 5 330 4 -24)

(applytester 7 + 3 4)
(applytester '3 + 3)
(applytester 0 +)
(applytester 4 * 4)
(applytester 1 *)

(applytester -1 - 3 4)
(applytester -3 - 3)
(applytester 7 abs -7)
(applytester 7 abs 7)
(applytester 0 abs 0)

(applytester 5 quotient 35 7)
(applytester -5 quotient -35 7)
(applytester -5 quotient 35 -7)
(applytester 5 quotient -35 -7)
(applytester 1 modulo 13 4)
(applytester 1 remainder 13 4)
(applytester 3 modulo -13 4)
(applytester -1 remainder -13 4)
(applytester -3 modulo 13 -4)
(applytester 1 remainder 13 -4)
(applytester -1 modulo -13 -4)
(applytester -1 remainder -13 -4)
(define (divtest n1 n2)
  (= n1 (+ (* n2 (quotient n1 n2))
	   (remainder n1 n2))))
(test-optimize! divtest)
(applytester #t divtest 238 9)
(applytester #t divtest -238 9)
(applytester #t divtest 238 -9)
(applytester #t divtest -238 -9)
(applytester 4294967296 * 256 16777216)
(applytester -4294967296 * -256 16777216)

(applytester 4 gcd 0 4)
(applytester 4 gcd -4 0)
(applytester 4 gcd 32 -36)
;(applytester 0 gcd)
(applytester 288 lcm 32 -36)
;(applytester 1 lcm)

;;;;From: fred@sce.carleton.ca (Fred J Kaudel)
;;; Modified by jaffer, and Ken Haase.
(define (test-inexact)
  (let* ((f3.9 (string->number "3.9"))
	 (f4.0 (string->number "4.0"))
	 (f5.0 (string->number "5.0"))
	 (f-3.25 (string->number "-3.25"))
	 (f.25 (string->number "0.25"))
	 (f4.5 (string->number "4.5"))
	 (f3.5 (string->number "3.5"))
	 (f0.0 (string->number "0.0"))
	 (f0.8 (string->number "0.8"))
	 (f1.0 (string->number "1.0"))
	 (tinyfloat (string->number "2.0e-10"))
	 (reallytinyfloat (string->number "2.0e-20"))
	 (bigfloat (string->number "2.0e+10"))
	 (reallybigfloat (string->number "2.0e+20"))
	 (write-test-obj (list f.25 f-3.25))
	 (display-test-obj (list f.25 f-3.25))
	 (load-test-obj (list 'define 'foo (list 'quote write-test-obj))))
    (newline)
    (display ";testing inexact numbers; ")
    (newline)
    (SECTION 6 5 5)
    (applytest #t inexact? f3.9)
    (applytest #t 'inexact? (inexact? (max f3.9 4)))
    (applytest f4.0 'max (max f3.9 4))
    (applytest f4.0 'exact->inexact (exact->inexact 4))
    (applytest (- f5.0) round (- f4.5))
    (applytest (- f4.0) round (- f3.5))
    (applytest (- f4.0) round (- f3.9))
    (applytest f0.0 round f0.0)
    (applytest f0.0 round f.25)
    (applytest f1.0 round f0.8)
    (applytest f4.0 round f3.5)
    (applytest f5.0 round f4.5)
    (applytest 0.0000000002 * 2 0.0000000001)
    (applytest 2.0e-10 * 2 1.0e-10)
    (applytest 0.0000000002 * 2 1.0e-10)
    (applytest tinyfloat * 2 1.0e-10)
    (applytest reallytinyfloat * 2 1.0e-20)
    (applytest bigfloat * 2 1.0e+9 10.0)
    (applytest reallybigfloat * 2 1.0e+19 10)
    (comment
     (applytest #t call-with-output-file
		"tmp3"
		(lambda (applytest-file)
		  (write-char #\; test-file)
		  (display write-test-obj test-file)
		  (newline test-file)
		  (write load-test-obj test-file)
		  (output-port? test-file)))
     (check-test-file "tmp3")
     (set! write-test-obj wto)
     (set! display-test-obj dto)
     (set! load-test-obj lto))
    (let ((x (string->number "4195835.0"))
	  (y (string->number "3145727.0")))
      (applytest #t 'pentium-fdiv-bug (> f1.0 (- x (* (/ x y) y)))))))

(define bigtest
  (lambda (n1 n2)
    (= n1 (+ (* n2 (quotient n1 n2))
	     (remainder n1 n2)))))
(test-optimize! bigtest)
(define (test-bignums)
  (newline)
  (display ";TESTING BIGNUMS; ")
  (newline)
  (SECTION 6 5 5)
  
  (applytest 24691357975308642
	     + 12345678987654321 12345678987654321)
  (applytest 0 - 12345678987654321 12345678987654321)
  (applytest -24691357975308642
	     + -12345678987654321 -12345678987654321)
  (applytest 0 - -12345678987654321 -12345678987654321)
  (applytest 0 + 12345678987654321 -12345678987654321)
  (applytest 0 + -12345678987654321 12345678987654321)
  (applytest 24691357975308642
	     - 12345678987654321 -12345678987654321)
  (applytest -24691357975308642
	     - -12345678987654321 12345678987654321)

  (applytest 0 modulo 3333333333 3)
  (applytest 0 modulo 3333333333 -3)
  (applytest 0 remainder 3333333333 3)
  (applytest 0 remainder 3333333333 -3)
  (applytest 2 modulo 3333333332 3)
  (applytest -1 modulo 3333333332 -3)
  (applytest 2 remainder 3333333332 3)
  (applytest 2 remainder 3333333332 -3)
  (applytest 1 modulo -3333333332 3)
  (applytest -2 modulo -3333333332 -3)
  (applytest -2 remainder -3333333332 3)
  (applytest -2 remainder -3333333332 -3)

  (applytest 3 modulo 3 3333333333)
  (applytest 3333333330 modulo -3 3333333333)
  (applytest 3 remainder 3 3333333333)
  (applytest -3 remainder -3 3333333333)
  (applytest -3333333330 modulo 3 -3333333333)
  (applytest -3 modulo -3 -3333333333)
  (applytest 3 remainder 3 -3333333333)
  (applytest -3 remainder -3 -3333333333)

  (applytest 0 modulo -2177452800 86400)
  (applytest 0 modulo 2177452800 -86400)
  (applytest 0 modulo 2177452800 86400)
  (applytest 0 modulo -2177452800 -86400)
  (applytest #t bigtest 281474976710655 65535)
  (applytest #t bigtest 281474976710654 65535)
  (SECTION 6 5 6)
  (applytest 281474976710655 string->number "281474976710655")
  (applytest "281474976710655" number->string 281474976710655)
  (applytest -281474976710655 string->number "-281474976710655")
  (applytest "-281474976710655" number->string -281474976710655)
  (applytest 281474976710655 string->number "FFFFFFFFFFFF" 16)
  (applytest 4503599627370495 string->number "FFFFFFFFFFFFF" 16)
  (applytest -100000000000000010 'big-minus (- (- 100000000000000000) 10)))

(SECTION 6 5 6)
(applytester "0" number->string 0)
(applytester "100" number->string 100)
(applytester "100" number->string 256 16)
(applytester 100 string->number "100")
(applytester 256 string->number "100" 16)
(applytester #f string->number "")
(applytester #f string->number ".")
(applytester #f string->number "d")
(applytester #f string->number "D")
(applytester #f string->number "i")
(applytester #f string->number "I")
; (applytester #f string->number "3i")
; (applytester #f string->number "3I")
; (applytester #f string->number "33i")
; (applytester #f string->number "33I")
; (applytester #f string->number "3.3i")
; (applytester #f string->number "3.3I")
(applytester #f string->number "-")
(applytester #f string->number "+")

(SECTION 6 6)
(applytester #t eqv? '#\  #\Space)
(applytester #t eqv? #\space '#\Space)
(applytester #t char? #\a)
(applytester #t char? #\()
(applytester #t char? #\ )
(applytester #t char? '#\newline)

(applytester #f char=? #\A #\B)
(applytester #f char=? #\a #\b)
(applytester #f char=? #\9 #\0)
(applytester #t char=? #\A #\A)

(applytester #t char<? #\A #\B)
(applytester #t char<? #\a #\b)
(applytester #f char<? #\9 #\0)
(applytester #f char<? #\A #\A)

(applytester #f char>? #\A #\B)
(applytester #f char>? #\a #\b)
(applytester #t char>? #\9 #\0)
(applytester #f char>? #\A #\A)

(applytester #t char<=? #\A #\B)
(applytester #t char<=? #\a #\b)
(applytester #f char<=? #\9 #\0)
(applytester #t char<=? #\A #\A)

(applytester #f char>=? #\A #\B)
(applytester #f char>=? #\a #\b)
(applytester #t char>=? #\9 #\0)
(applytester #t char>=? #\A #\A)

(applytester #f char-ci=? #\A #\B)
(applytester #f char-ci=? #\a #\B)
(applytester #f char-ci=? #\A #\b)
(applytester #f char-ci=? #\a #\b)
(applytester #f char-ci=? #\9 #\0)
(applytester #t char-ci=? #\A #\A)
(applytester #t char-ci=? #\A #\a)

(applytester #t char-ci<? #\A #\B)
(applytester #t char-ci<? #\a #\B)
(applytester #t char-ci<? #\A #\b)
(applytester #t char-ci<? #\a #\b)
(applytester #f char-ci<? #\9 #\0)
(applytester #f char-ci<? #\A #\A)
(applytester #f char-ci<? #\A #\a)

(applytester #f char-ci>? #\A #\B)
(applytester #f char-ci>? #\a #\B)
(applytester #f char-ci>? #\A #\b)
(applytester #f char-ci>? #\a #\b)
(applytester #t char-ci>? #\9 #\0)
(applytester #f char-ci>? #\A #\A)
(applytester #f char-ci>? #\A #\a)

(applytester #t char-ci<=? #\A #\B)
(applytester #t char-ci<=? #\a #\B)
(applytester #t char-ci<=? #\A #\b)
(applytester #t char-ci<=? #\a #\b)
(applytester #f char-ci<=? #\9 #\0)
(applytester #t char-ci<=? #\A #\A)
(applytester #t char-ci<=? #\A #\a)

(applytester #f char-ci>=? #\A #\B)
(applytester #f char-ci>=? #\a #\B)
(applytester #f char-ci>=? #\A #\b)
(applytester #f char-ci>=? #\a #\b)
(applytester #t char-ci>=? #\9 #\0)
(applytester #t char-ci>=? #\A #\A)
(applytester #t char-ci>=? #\A #\a)

(applytester #t char-alphabetic? #\a)
(applytester #t char-alphabetic? #\A)
(applytester #t char-alphabetic? #\z)
(applytester #t char-alphabetic? #\Z)
(applytester #f char-alphabetic? #\0)
(applytester #f char-alphabetic? #\9)
(applytester #f char-alphabetic? #\space)
(applytester #f char-alphabetic? #\;)

(applytester #f char-numeric? #\a)
(applytester #f char-numeric? #\A)
(applytester #f char-numeric? #\z)
(applytester #f char-numeric? #\Z)
(applytester #t char-numeric? #\0)
(applytester #t char-numeric? #\9)
(applytester #f char-numeric? #\space)
(applytester #f char-numeric? #\;)

(applytester #f char-whitespace? #\a)
(applytester #f char-whitespace? #\A)
(applytester #f char-whitespace? #\z)
(applytester #f char-whitespace? #\Z)
(applytester #f char-whitespace? #\0)
(applytester #f char-whitespace? #\9)
(applytester #t char-whitespace? #\space)
(applytester #f char-whitespace? #\;)

(applytester #f char-upper-case? #\0)
(applytester #f char-upper-case? #\9)
(applytester #f char-upper-case? #\space)
(applytester #f char-upper-case? #\;)

(applytester #f char-lower-case? #\0)
(applytester #f char-lower-case? #\9)
(applytester #f char-lower-case? #\space)
(applytester #f char-lower-case? #\;)

(applytester #\. integer->char (char->integer #\.))
(applytester #\A integer->char (char->integer #\A))
(applytester #\a integer->char (char->integer #\a))
(applytester #\A char-upcase #\A)
(applytester #\A char-upcase #\a)
(applytester #\a char-downcase #\A)
(applytester #\a char-downcase #\a)
(SECTION 6 7)
(applytester #t string? "The word \"recursion\\\" has many meanings.")
(applytester #t string? "")
; (define f (make-string 3 #\*))
; (applytester "?**" 'string-set! (begin (string-set! f 0 #\?) f))
(applytester "abc" string #\a #\b #\c)
(applytester "" string)
(define string-length length)
(define string-ref elt)
(define substring subseq)
(applytester 3 string-length "abc")
(applytester #\a string-ref "abc" 0)
(applytester #\c string-ref "abc" 2)
(applytester 0 string-length "")
(applytester "" substring "ab" 0 0)
(applytester "" substring "ab" 1 1)
(applytester "" substring "ab" 2 2)
(applytester "a" substring "ab" 0 1)
(applytester "b" substring "ab" 1 2)
(applytester "ab" substring "ab" 0 2)
(applytester "foobar" string-append "foo" "bar")
(applytester "foo" string-append "foo")
(applytester "foo" string-append "foo" "")
(applytester "foo" string-append "" "foo")
(applytester "" string-append)
(applytester "" make-string 0)
(applytester #t string=? "" "")
(applytester #f string<? "" "")
(applytester #f string>? "" "")
(applytester #t string<=? "" "")
(applytester #t string>=? "" "")
(applytester #t string-ci=? "" "")
(applytester #f string-ci<? "" "")
(applytester #f string-ci>? "" "")
(applytester #t string-ci<=? "" "")
(applytester #t string-ci>=? "" "")

(applytester #f string=? "A" "B")
(applytester #f string=? "a" "b")
(applytester #f string=? "9" "0")
(applytester #t string=? "A" "A")

(applytester #t string<? "A" "B")
(applytester #t string<? "a" "b")
(applytester #f string<? "9" "0")
(applytester #f string<? "A" "A")

(applytester #f string>? "A" "B")
(applytester #f string>? "a" "b")
(applytester #t string>? "9" "0")
(applytester #f string>? "A" "A")

(applytester #t string<=? "A" "B")
(applytester #t string<=? "a" "b")
(applytester #f string<=? "9" "0")
(applytester #t string<=? "A" "A")

(applytester #f string>=? "A" "B")
(applytester #f string>=? "a" "b")
(applytester #t string>=? "9" "0")
(applytester #t string>=? "A" "A")

(applytester #f string-ci=? "A" "B")
(applytester #f string-ci=? "a" "B")
(applytester #f string-ci=? "A" "b")
(applytester #f string-ci=? "a" "b")
(applytester #f string-ci=? "9" "0")
(applytester #t string-ci=? "A" "A")
(applytester #t string-ci=? "A" "a")

(applytester #t string-ci<? "A" "B")
(applytester #t string-ci<? "a" "B")
(applytester #t string-ci<? "A" "b")
(applytester #t string-ci<? "a" "b")
(applytester #f string-ci<? "9" "0")
(applytester #f string-ci<? "A" "A")
(applytester #f string-ci<? "A" "a")

(applytester #f string-ci>? "A" "B")
(applytester #f string-ci>? "a" "B")
(applytester #f string-ci>? "A" "b")
(applytester #f string-ci>? "a" "b")
(applytester #t string-ci>? "9" "0")
(applytester #f string-ci>? "A" "A")
(applytester #f string-ci>? "A" "a")

(applytester #t string-ci<=? "A" "B")
(applytester #t string-ci<=? "a" "B")
(applytester #t string-ci<=? "A" "b")
(applytester #t string-ci<=? "a" "b")
(applytester #f string-ci<=? "9" "0")
(applytester #t string-ci<=? "A" "A")
(applytester #t string-ci<=? "A" "a")

(applytester #f string-ci>=? "A" "B")
(applytester #f string-ci>=? "a" "B")
(applytester #f string-ci>=? "A" "b")
(applytester #f string-ci>=? "a" "b")
(applytester #t string-ci>=? "9" "0")
(applytester #t string-ci>=? "A" "A")
(applytester #t string-ci>=? "A" "a")
(SECTION 6 8)
(define vector-length length)
(define vector-ref elt)
(applytester #t vector? '#(0 (2 2 2 2) "Anna"))
(applytester #t vector? '#())
(applytester '#(a b c) vector 'a 'b 'c)
(applytester '#() vector)
(applytester 3 vector-length '#(0 (2 2 2 2) "Anna"))
(applytester 0 vector-length '#())
(applytester 8 vector-ref '#(1 1 2 3 5 8 13 21) 5)
; (applytester '#(0 ("Sue" "Sue") "Anna") 'vector-set
; 	(let ((vec (vector 0 '(2 2 2 2) "Anna")))
; 	  (vector-set! vec 1 '("Sue" "Sue"))
; 	  vec))
(applytester '#(hi hi) make-vector 2 'hi)
(applytester '#() make-vector 0)
(applytester '#() make-vector 0 'a)
(SECTION 6 9)
(applytester #t procedure? car)
(applytester #f procedure? 'car)
(applytester #t procedure? (lambda (x) (* x x)))
(applytester #f procedure? '(lambda (x) (* x x)))
;(applytester #t call-with-current-continuation procedure?)
(applytester 7 apply + (list 3 4))
(applytester 7 apply (lambda (a b) (+ a b)) (list 3 4))
(applytester 17 apply + 10 (list 3 4))
(applytester '() apply list '())
(define compose (lambda (f g) (lambda args (f (apply g args))))) ;; ??
(test-optimize! compose)
(applytester 30 (compose sqt *) 12 75) ;; ??

(applytester '(b e h) map cadr '((a b) (d e) (g h)))
(applytester '(5 7 9) map + '(1 2 3) '(4 5 6))
; (applytester '#(0 1 4 9 16) 'for-each
; 	(let ((v (make-vector 5)))
; 		(for-each (lambda (i) (vector-set! v i (* i i)))
; 			'(0 1 2 3 4))
; 		v))
; (applytester -3 call-with-current-continuation
; 		(lambda (exit)
; 		 (for-each (lambda (x) (if (negative? x) (exit x)))
; 		 	'(54 0 37 -3 245 19))
; 		#t))
; (define list-length
;  (lambda (obj)
;   (call-with-current-continuation
;    (lambda (return)
;     (letrec ((r (lambda (obj) (cond ((null? obj) 0)
; 				((pair? obj) (+ (r (cdr obj)) 1))
; 				(else (return #f))))))
; 	(r obj))))))
(define list-length
 (lambda (obj)
   (do ((i 0 (1+ i))
	(l obj (cdr l)))
       ((not (pair? l)) (and (null? l) i)))))
(test-optimize! list-length)
(applytester 4 list-length '(1 2 3 4))
(applytester #f list-length '(a b . c))
(applytester '() map cadr '())

;;; This tests full conformance of call-with-current-continuation.  It
;;; is a separate test because some schemes do not support call/cc
;;; other than escape procedures.  I am indebted to
;;; raja@copper.ucs.indiana.edu (Raja Sooriamurthi) for fixing this
;;; code.  The function leaf-eq? compares the leaves of 2 arbitrary
;;; trees constructed of conses.
(define (next-leaf-generator obj eot)
  (letrec ((return #f)
	   (cont (lambda (x)
		   (recur obj)
		   (set! cont (lambda (x) (return eot)))
		   (cont #f)))
	   (recur (lambda (obj)
		      (if (pair? obj)
			  (for-each recur obj)
			  (call-with-current-continuation
			   (lambda (c)
			     (set! cont c)
			     (return obj)))))))
    (lambda () (call-with-current-continuation
		(lambda (ret) (set! return ret) (cont #f))))))
(define (leaf-eq? x y)
  (let* ((eot (list 'eot))
	 (xf (next-leaf-generator x eot))
	 (yf (next-leaf-generator y eot)))
    (letrec ((loop (lambda (x y)
		     (cond ((not (eq? x y)) #f)
			   ((eq? eot x) #t)
			   (else (loop (xf) (yf)))))))
      (loop (xf) (yf)))))
(define (applytest-cont)
  (newline)
  (display ";testing continuations; ")
  (newline)
  (SECTION 6 9)
  (applytest #t leaf-eq? '(a (b (c))) '((a) b c))
  (applytest #f leaf-eq? '(a (b (c))) '((a) b c d))
  (report-errs))

;;;; Simple continuation testing

(define (test-call/cc)
  (newline)
  (display ";TESTING CALL/CC ")
  (newline)
  (evaltest 6 (call/cc (lambda (quit)
			 (dotimes (i 10) (if (> i 5) (quit i))) #f)))
  (evaltest #f (call/cc (lambda (quit)
			  (dotimes (i 3) (if (> i 5) (quit i))) #f)))
  (evaltest 7 (let ((l '()))
		(call/cc (lambda (quit)
			   (dotimes (i 10)
			     (set! l (cons i l))
			     (if (> i 5) (quit i)))))
		(length l)))
  (evaltest '(5 4 3 2 1 0)
	    (let ((l '()))
	      (call/cc (lambda (quit)
			 (let ((i 0))
			   (while #t ;; forever
			     (set! l (cons i l))
			     (set! i (+ i 1))
			     (if (> i 5) (quit i))))))
	      l)))

;;; Test Optional R4RS DELAY syntax and FORCE procedure
(define (applytest-delay)
  (newline)
  (display ";testing DELAY and FORCE; ")
  (newline)
  (SECTION 6 9)
  (applytest 3 'delay (force (delay (+ 1 2))))
  (applytest '(3 3) 'delay (let ((p (delay (+ 1 2))))
			(list (force p) (force p))))
  (applytest 2 'delay (letrec ((a-stream
			   (letrec ((next (lambda (n)
					    (cons n (delay (next (+ n 1)))))))
			     (next 0)))
			  (head car)
			  (tail (lambda (stream) (force (cdr stream)))))
		   (head (tail (tail a-stream)))))
  (letrec ((count 0)
	   (p (delay (begin (set! count (+ count 1))
			    (if (> count x)
				count
				(force p)))))
	   (x 5))
    (applytest 6 force p)
    (set! x 10)
    (applytester 6 force p))
  (applytest 3 'force
	(letrec ((p (delay (if c 3 (begin (set! c #t) (+ (force p) 1)))))
		 (c #f))
	  (force p)))
  (report-errs))

; (SECTION 6 10 1)
; (applytester #t input-port? (current-input-port))
; (applytester #t output-port? (current-output-port))
; (applytester #t call-with-input-file (get-component "r4rstest.scm") input-port?)
; (define this-file (open-input-file (get-component "r4rstest.scm")))
; (applytester #t input-port? this-file)
; (SECTION 6 10 2)
; (applytester #\; peek-char this-file)
; (applytester #\; read-char this-file)
; (applytester '(define cur-section '()) read this-file)
; (applytester #\( peek-char this-file)
; (applytester '(define errs '()) read this-file)
; (close-input-port this-file)
; (close-input-port this-file)
; (define (check-test-file name)
;   (define test-file (open-input-file name))
;   (applytester #t 'input-port?
; 	(call-with-input-file
; 	    name
; 	  (lambda (applytest-file)
; 	    (applytester load-test-obj read test-file)
; 	    (applytester #t eof-object? (peek-char test-file))
; 	    (applytester #t eof-object? (read-char test-file))
; 	    (input-port? test-file))))
;   (applytester #\; read-char test-file)
;   (applytester display-test-obj read test-file)
;   (applytester load-test-obj read test-file)
;   (close-input-port test-file))
; (SECTION 6 10 3)
; (define write-test-obj
;   '(#t #f #\a () 9739 -3 . #((applytest) "te \" \" st" "" test #() b c)))
; (define display-test-obj
;   '(#t #f a () 9739 -3 . #((applytest) te " " st test #() b c)))
; (define load-test-obj
;   (list 'define 'foo (list 'quote write-test-obj)))
; (applytester #t call-with-output-file
;       "tmp1"
;       (lambda (applytest-file)
; 	(write-char #\; test-file)
; 	(display write-test-obj test-file)
; 	(newline test-file)
; 	(write load-test-obj test-file)
; 	(output-port? test-file)))
; (check-test-file "tmp1")

; (define test-file (open-output-file "tmp2"))
; (write-char #\; test-file)
; (display write-test-obj test-file)
; (newline test-file)
; (write load-test-obj test-file)
; (applytester #t output-port? test-file)
; (close-output-port test-file)
; (check-test-file "tmp2")
; (define (applytest-sc4)
;   (newline)
;   (display ";testing scheme 4 functions; ")
;   (newline)
;   (SECTION 6 7)
;   (applytester '(#\P #\space #\l) string->list "P l")
;   (applytester '() string->list "")
;   (applytester "1\\\"" list->string '(#\1 #\\ #\"))
;   (applytester "" list->string '())
;   (SECTION 6 8)
;   (applytester '(dah dah didah) vector->list '#(dah dah didah))
;   (applytester '() vector->list '#())
;   (applytester '#(dididit dah) list->vector '(dididit dah))
;   (applytester '#() list->vector '())
;   (SECTION 6 10 4)
;   (load "tmp1")
;   (applytester write-test-obj 'load foo)
;   (report-errs))

; (report-errs)

; (if (and (string->number "0.0") (inexact? (string->number "0.0")))
;     (applytest-inexact))

; (let ((n (string->number "281474976710655")))
;   (if (and n (exact? n))
;       (applytest-bignum)))
; (newline)
; (applytest-sc4)
; (newline)
; (applytest-delay)
; (display "To fully test continuations, Scheme 4, and DELAY/FORCE do:")
; (newline)
; (display "(applytest-cont) (applytest-sc4) (applytest-delay)")
; (newline)

(define (fib-iter i cur prev)
  (if (= i 1) cur (fib-iter (-1+ i) (+ cur prev) cur)))
(define (fibi n)
  (if (= n 0) 0 (fib-iter n 1 0)))

(define (test-tail-calls)
  (applytest 6765 fibi 20)
  (applytest 280571172992510140037611932413038677189525 fibi 200)
  (applytest 43466557686937456435688527675040625802564660517371780402481729089536555417949051890403879840079255169295922593080322634775209689623239873322471161642996440906533187938298969649928516003704476137795166849228875
	     fibi 1000))

;; This tests that tail calls in WHEN are evaluated

(define test-flag #f)

(define (set-test-flag! val)
  (set! test-flag val))

(define (bug-test (val #f))
  (when (= 3 3)
    (if (= 2 2)
	(set-test-flag! val))))

(define (optimized-tail-testfn)
  (set! test-flag #f)
  (bug-test #t)
  test-flag)

(test-call/cc)
(test-bignums)
(test-inexact)
(test-tail-calls)

(applytest #t optimized-tail-testfn)

(test-finished "R4RS test")

