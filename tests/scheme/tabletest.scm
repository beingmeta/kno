;;;; Random object generation

(define random-super-pools
  (make-oid (choice (random 200000)
		    (random 200000)
		    (random 200000)
		    (random 200000)
		    (random 200000)
		    (random 200000))
	    (* (random 256) 0x100000)))

(define (random-oid)
  (oid-plus (pick-one random-super-pools)
	    (random 0x100000)))
(define (random-fixnum) (random 1000000))
(define (random-bignum)
  (* (random-fixnum) (random-fixnum) (random-fixnum)))
(define (random-packet)
  (let ((len (random 100)))
    (let ((vector (make-vector len)))
      (dotimes (i len)
	(vector-set! vector i (random 256)))
      (vector->packet vector))))
(define (random-character)
  (integer->char (random 0x1000)))
(define (random-string)
  (let ((len (if (zero? (random 25)) (random 100) (random 15))))
    (stringout
     (dotimes (i len)
       (if (zero? (random 10))
	   (putchar (integer->char (1+ (random 256))))
	 (putchar (integer->char (1+ (random 128)))))))))
(define (random-symbol)
  (pick-one (allsymbols)))

(define (random-primobj)
  (let ((type (random 8)))
    (cond ((= type 0) (random-string))
	  ((= type 1) (random-symbol))
	  ((= type 2) (random-oid))
	  ((= type 3) (random (* 65536 256 64)))
	  ((= type 4) (random 65536))
	  ((= type 5) (random-symbol))
	  ((= type 6) (random-oid))
	  ((= type 7) (random-character))
	  (else (pick-one (allsymbols))))))

(define (randomelts n)
  (if (zero? n) '()
    (cons (random-primobj) (randomelts (1- n)))))

(define (random-list)
  (randomelts (if (zero? (random 10)) (random 25)
		(random 7))))

(define (random-vector)
  (->vector (randomelts (if (zero? (random 10)) (random 25)
			  (random 7)))))

(define (random-object)
  (let ((branch (random 5)))
    (cond ((= branch 0) (random-vector))
	  ((= branch 1) (random-list))
	  ((= branch 2) (random-slotmap))
	  (else (random-primobj)))))

(define (random-slotid)
  (if (zero? (random 2)) (random-oid) (random-symbol)))

(define (random-pair)
  (cons (random-primobj) (random-primobj)))

(define (random-slotvalue)
  (random-primobj))

(define random-slotids
  (let ((slotids {}))
    (dotimes (i 20) (set+! slotids (random-slotid)))
    slotids))

(define (random-slotmap)
  (let ((size (random 16)) (f (frame-create #f)))
    (dotimes (i size)
      (add! f (random-slotid)
	    (if (zero? (random 2)) (random-object)
		(let ((n-values (random 32)) (result {}))
		  (dotimes (i n-values)
		    (set+! result (random-slotvalue)))
		  result))))
    f))

(define (random-slotkey)
  (cons (pick-one random-slotids) (random-slotid)))

;;; Getting components

(define (get-components x)
  (cond ((vector? x) (cachecall get-components (elts x)))
	((pair? x) (choice (cachecall get-components (car x))
			   (cachecall get-components (cdr x))))
	((oid? x) x)
	((table? x)
	 (for-choices (key (getkeys x))
	   (cons key (cachecall get-components (get x key)))))
	(else x)))
(define (get-atomic-components x)
  (cond ((vector? x) (cachecall get-atomic-components (elts x)))
	((string? x) (fail))
	((pair? x)
	 (choice (cachecall get-atomic-components (car x))
		 (cachecall get-atomic-components (cdr x))))
	((oid? x) x)
	((table? x)
	 (for-choices (key (getkeys x))
	   (choice key (cachecall get-atomic-components (get x key)))))
	(else x)))

;;; Generating random tables

(define (fill-table! table size (atomicp #f))
  (let ((items {}) (totalsize 0))
    (until (> totalsize size)
      (let ((item (random-object)))
	(set+! items item)
	(set! totalsize (+ totalsize (count-objects item)))))
    (add! table '%items items)
    (do-choices (item items)
      (let ((components (if atomicp
			    (get-atomic-components item)
			    (get-components item))))
	(add! table components item)))))

(define bad-maps {})
(define missed-maps {})

(define (check-table table (atomicp #f))
  (let ((ok #t))
    (do-choices (key (difference (getkeys table) '%items))
      (do-choices (value (get table key))
	(let ((components (if atomicp
			      (get-atomic-components value)
			      (get-components value))))
	  (unless (overlaps? key components)
	    (set! ok #f)
	    (message "Bad map for " key)
	    (set+! bad-maps (cons key value))))))
    (do-choices (item (get table '%items))
      (do-choices (component (if atomicp
				 (get-atomic-components item)
				 (get-components item)))
	(unless (test table component item)
	  (set! ok #f)
	  (message "Missed map for " component)
	  (set+! missed-maps (cons component item)))))
    ok))

;;; Top level

(define (table-for file)
  (cond ((has-suffix file ".slotmap") (frame-create #f))
	((has-suffix file ".table") (make-hashtable))
	((has-suffix file ".index")
	 (make-file-index file 1000000)
	 (open-index file))
	;; ((has-suffix file ".zindex") (make-zindex file))
	(else (make-hashtable))))
(define (table-from file)
  (if (or (has-suffix file ".index") (has-suffix file ".zindex"))
      (open-index file)
    (file->dtype file)))

(define (save-table table file)
  (if (or (has-suffix file ".index") (has-suffix file ".zindex"))
      (begin (commit table) (swapout table) table)
    (begin (dtype->file table file)
	   (file->dtype file))))

(define intable #f)
(define outtable #f)

(define (count-objects x)
  (cond ((ambiguous? x)
	 (let ((size 1))
	   (do-choices (elt x) (set! size (count-objects elt)))
	   size))
	((null? x) 0)
	((pair? x)
	 (+ 1 (count-objects (qc (car x))) (count-objects (qc (cdr x)))))
	((vector? x)
	 (let ((size 1))
	   (doseq (elt x) (set! size (+ size (count-objects (qc elt)))))
	   size))
	((or (oid? x) (symbol? x) (string? x) (number? x)) 1)
	((table? x)
	 (let ((size 1) (keys (getkeys x)))
	   (do-choices (key keys)
	     (set! size (+ size (count-objects key))))
	   (do-choices (key keys)
	     (set! size (+ size (count-objects (qc (get x key))))))
	   size))
	(else 0)))

(define (table-report table (name "Table"))
  (message name " covers "
	   (choice-size (get table '%items)) " items, "
	   (table-size table) " keys, and "
	   (count-objects table) " objects"))

(define (main filename (size #f))
  (if size
      (let ((table (table-for filename))
	    (atomicp (has-suffix filename ".slotmap")))
	(set! intable table)
	(message "Generating table for " size " items")
	(fill-table! table (* 64 8) atomicp)
	(table-report table)
	(message "Checking consistency....")
	(unless (check-table table atomicp)
	  (message "Table is inconsistent")
	  (exit 1))
	(message "Table is consistent, saving...")
	(save-table table filename)
	(message "Table saved, reloaded...")
 	(set! table (table-from filename))
	(set! outtable table)
	(table-report table "Reloaded table ")
	(message "Checking consistency of reloaded table...")
 	(unless (check-table table atomicp)
 	  (message "Reloaded table is inconsistent")
 	  (exit 1))
	(message "Reloaded table is consistent."))
      (let* ((table (table-from filename))
	     (atomicp (has-suffix filename ".slotmap"))
	     (objectcount (count-objects table)))
	(table-report table "Restored table")
	(message "Checking restored table for consistency...")
	(if (check-table table atomicp)
	    (message "Table is consistent")
	    (begin (message "Table is inconsistent")
		   (exit 1)))
	(message "Restored table is consistent"))))





