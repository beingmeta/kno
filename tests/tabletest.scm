(load-component "common.scm")

(use-module 'randobj)

(define aggindex #f)
(varconfig! aggindex aggindex config:boolean)
(define-init aggindex-cache (make-hashtable))

;;; Generating random tables

(define bad-maps {})
(define missed-maps {})

(defambda (atomic-contains? structure atom)
  (or (eq? structure atom)
      (if (ambiguous? structure)
	  (or (overlaps? atom structure)
	      (try-choices (s (reject structure {pair? vector? slotmap}))
		(tryif (atomic-contains? s atom) #t)))
	  (or (and (or (vector? structure) (pair? structure))
		   (or (position atom structure)
		       (atomic-contains? 
			(pick (elts structure) {pair? vector? slotmap}) 
			atom)))
	      (and (slotmap? structure) 
		   (let* ((keys (getkeys structure))
			  (all-elts (choice keys (get structure keys)))
			  (atomic-elts (reject all-elts {pair? vector? slotmap}))
			  (other-elts (difference all-elts atomic-elts)))
		     (or (overlaps? atom atomic-elts)
			 (atomic-contains? other-elts atom))))))))

(define (check-table table (atomicp #f))
  (let ((ok #t))
    (clearcaches)
    (do-choices (key (difference (getkeys table) '{%items %xitems}))
      (do-choices (value (get table key))
	(let ((components (if atomicp
			      (cachecall get-atomic-components value)
			      (cachecall get-components value))))
	  (unless (overlaps? key components)
	    (set! ok #f)
	    (message "Bad map for " key)
	    (set+! bad-maps (cons key value))))))
    (do-choices (item (get table '%items))
      (do-choices (component (if atomicp
				 (cachecall get-atomic-components item)
				 (cachecall get-components item)))
	(unless (test table component item)
	  (set! ok #f)
	  (message "Missed map for " component " in " item)
	  (set+! missed-maps (cons component item)))))
    ok))

;;; Top level

(define (table-for file (consed (config 'consindex)) (indextype indextype))
  (cond ((has-suffix file ".slotmap") (frame-create #f))
	((has-suffix file ".table") (make-hashtable))
	((has-suffix file ".index")
	 (make-index file (frame-create #f 
			    'type indextype
			    'module (or (config 'indexmod #f #t) {})
			    'register (not consed)
			    'size 1000000
			    'offtype (config 'offtype 'b40)
			    'oidcodes (config 'oidcodes #f)
			    'slotcodes (config 'slotcodes #f))))
	((has-suffix file ".aggindex")
	 (make-aggindex file consed indextype))
	(else (make-hashtable))))
(define (table-from file (consed (config 'consindex)) (indextype indextype))
  (if (has-suffix file ".index")
      (open-index file (frame-create #f 
			 'type indextype
			 'register (not consed)
			 'module (or (config 'indexmod #f #t) {})))
      (if (has-suffix file ".aggindex")
	  (open-aggindex file consed indextype)
	  (file->dtype file))))

(define (make-aggindex file consed indextype)
  (let* ((part-opts (frame-create #f 
		      'type indextype
		      'register (not consed)
		      'module (or (config 'indexmod #f #t) {})
		      'size 1000000
		      'offtype (config 'offtype 'b40)
		      'oidcodes (config 'oidcodes #f)
		      'slotcodes (config 'slotcodes #f)))
	 (base (strip-suffix file ".aggindex"))
	 (aindex (make-index (glom base "-a") part-opts))
	 (bindex (make-index (glom base "-b") part-opts))
	 (agg (make-aggregate-index {aindex bindex}
				    (frame-create #f 
				      'type indextype
				      'module (or (config 'indexmod #f #t) {})
				      'size 1000000
				      'offtype (config 'offtype 'b40)
				      'oidcodes (config 'oidcodes #f)
				      'slotcodes (config 'slotcodes #f)))))
    (indexctl agg 'props 'front aindex)
    (store! aggindex-cache (sorted {aindex bindex}) agg)
    (set! aggindex #t)
    agg))

(define (open-aggindex file consed indextype)
  (let* ((part-opts (frame-create #f 
		      'type indextype
		      'register (not consed)
		      'module (or (config 'indexmod #f #t) {})
		      'size 1000000
		      'offtype (config 'offtype 'b40)
		      'oidcodes (config 'oidcodes #f)
		      'slotcodes (config 'slotcodes #f)))
	 (base (strip-suffix file ".aggindex"))
	 (aindex (make-index (glom base "-a") part-opts))
	 (bindex (make-index (glom base "-b") part-opts)))
    (try (get aggindex-cache (sorted {aindex bindex}))
	 (let ((agg (make-aggregate-index {aindex bindex} #[])))
	   (indexctl agg 'props 'front aindex)
	   (store! aggindex-cache (sorted {aindex bindex}) agg)
	   (set! aggindex #t)
	   agg))))

(define (save-table table file)
  (if (has-suffix file {".index" ".aggindex"})
      (begin (commit table) (swapout table) table)
      (begin (dtype->file table file)
	(file->dtype file))))

(define intable #f)
(define outtable #f)

(define (edit-tests filename arg (editfile) (op #f))
  (cond ((not (and (string? arg) (> (length arg) 2)))
	 (irritant arg "Bad test filename"))
	((has-prefix arg "+")
	 (set! op 'picktest)
	 (set! editfile (slice arg 1)))
	((has-prefix arg "?")
	 (set! op 'runtest)
	 (set! editfile (slice arg 1)))
	((file-exists? arg)
	 (set! editfile arg)
	 (set! op 'runtest))
	(else
	 (set! editfile arg)
	 (set! op 'picktest)))
  (if (eq? op 'runtest)
      (let ((table (table-from filename (CONFIG 'consindex)))
	    (in (file->dtype editfile))
	    (worked #t))
	(message "Testing edits with " in)
	(when (test table '%items in)
	  (message "Drop didn't work")
	  (set! worked #f))
	(unless (identical? (get table '%xitems) in)
	  (message "Store didn't work")
	  (set! worked #f))
	(if worked
	    (message "Drop and store worked")
	    (exit 1)))
      (let* ((table (table-from filename (CONFIG 'consindex)))
	     (items (get table '%items))
	     (drop (try (pick-one (pick items {vector? slotmap? pair?}))
			(pick-one items))))
	(store! table '%xitems drop)
	(message "Dropping item " (write drop))
	(drop! table '%items drop)
	(dtype->file drop editfile)
	(commit table))))

(define (tablecheckfn table atomicp)
  (unless (check-table table atomicp)
    (message "Table is inconsistent"))
  #t)

(define (get-rthreads)
  (config 'RTHREADS 
	  (and (CONFIG 'NTHREADS) 
	       (* 3 (CONFIG 'NTHREADS #f)))))
(define (get-wthreads) (config 'WTHREADS (CONFIG 'NTHREADS #f)))

(define (main filename (size #f) 
	      (rthreads (get-rthreads)) (wthreads (get-wthreads)))
  (when (and (config 'reset) (string? filename) (file-exists? filename))
    (remove-file filename))
  (message "■■ TABLETEST " (write filename) 
    (when size (printout " BUILD=" size))
    " cache=" (config 'cachelevel) 
    (when (config 'indextype) (printout " type=" (config 'indextype)))
    (when (config 'offtype) (printout " offtype=" (config 'offtype))))
  (if (and size (number? size))
      (let ((table (table-for filename (config 'CONSINDEX #f)))
	    (atomicp (has-suffix filename ".slotmap")))
	(when (file-exists? (glom filename ".edit.dtype")) 
	  (remove-file (glom filename ".edit.dtype")))
	(when wthreads (set! size (1+ (quotient size wthreads))))
	(set! intable table)
	(message "Generating table for " size " items")
	(if wthreads
	    (let ((use-size (1+ (quotient size wthreads)))
		  (threads {}))
	      (dotimes (i wthreads)
		(set+! threads (thread/call random-table table use-size atomicp)))
	      (thread/join threads))
	    (random-table table size atomicp))
	(unless (config 'noreport) (table-report table))
	(message "Checking consistency....")
	(if rthreads
	    (let ((threads {}))
	      (dotimes (i rthreads)
		(set+! threads (thread/call tablecheckfn table atomicp)))
	      (thread/join threads))
	    (tablecheckfn table atomicp))
	(message "Table is consistent, saving...")
	(save-table table filename)
	(message "Table saved, reopening...")
 	(set! table (table-from filename (config 'consindex)))
	(set! outtable table)
	(unless (config 'noreport) (table-report table "Reloaded table"))
	(message "Checking consistency of reopened table...")
	(if rthreads
	    (let ((threads {}))
	      (dotimes (i rthreads)
		(set+! threads (thread/call tablecheckfn table atomicp)))
	      (thread/join threads))
	    (tablecheckfn table atomicp))
	(clearcaches)
	(message "Reopened table is consistent."))
      (if size
	  (begin (edit-tests filename size)
		 (clearcaches))
	  (let* ((table (table-from filename (config 'consindex)))
		 (atomicp (has-suffix filename ".slotmap"))
		 (objectcount (count-objects table)))
	    (message "Opened table with " (table-size table) " keys")
	    (unless (config 'noreport) (table-report table "Restored table"))
	    (message "Checking reopened table for consistency...")
	    (if rthreads
		(let ((threads {}))
		  (dotimes (i rthreads)
		    (set+! threads (thread/call tablecheckfn table atomicp)))
		  (thread/join threads))
		(tablecheckfn table atomicp))
	    (message "Reopened table is consistent")
	    (clearcaches))))
  (evaltest {} bad-maps)
  (evaltest {} missed-maps)
  (test-finished "TABLETEST"))
